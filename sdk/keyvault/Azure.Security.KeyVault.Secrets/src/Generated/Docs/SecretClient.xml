<?xml version="1.0" encoding="utf-8"?>
<doc>
  <members>
    <member name="SetSecretAsync(String,RequestContent,RequestContext)">
<example>
This sample shows how to call SetSecretAsync with required parameters and request content, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {
    value = "<value>",
};

Response response = await client.SetSecretAsync("<secretName>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call SetSecretAsync with all parameters and request content, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {
    value = "<value>",
    tags = new {
        key = "<String>",
    },
    contentType = "<contentType>",
    attributes = new {
        enabled = true,
        nbf = "1652209051",
        exp = "1652209051",
    },
};

Response response = await client.SetSecretAsync("<secretName>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
 The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault creates a new version of that secret. This operation requires the secrets/set permission.

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>SecretSetParameters</c>:
<code>{
  value: string, # Required. The value of the secret.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  contentType: string, # Optional. Type of the secret value such as a password.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
}
</code>

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="SetSecret(String,RequestContent,RequestContext)">
<example>
This sample shows how to call SetSecret with required parameters and request content, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {
    value = "<value>",
};

Response response = client.SetSecret("<secretName>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call SetSecret with all parameters and request content, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {
    value = "<value>",
    tags = new {
        key = "<String>",
    },
    contentType = "<contentType>",
    attributes = new {
        enabled = true,
        nbf = "1652209051",
        exp = "1652209051",
    },
};

Response response = client.SetSecret("<secretName>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
 The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault creates a new version of that secret. This operation requires the secrets/set permission.

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>SecretSetParameters</c>:
<code>{
  value: string, # Required. The value of the secret.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  contentType: string, # Optional. Type of the secret value such as a password.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
}
</code>

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="DeleteSecretAsync(String,RequestContext)">
<example>
This sample shows how to call DeleteSecretAsync with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = await client.DeleteSecretAsync("<secretName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("recoveryId").ToString());
Console.WriteLine(result.GetProperty("scheduledPurgeDate").ToString());
Console.WriteLine(result.GetProperty("deletedDate").ToString());
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual version of a secret. This operation requires the secrets/delete permission.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="DeleteSecret(String,RequestContext)">
<example>
This sample shows how to call DeleteSecret with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = client.DeleteSecret("<secretName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("recoveryId").ToString());
Console.WriteLine(result.GetProperty("scheduledPurgeDate").ToString());
Console.WriteLine(result.GetProperty("deletedDate").ToString());
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual version of a secret. This operation requires the secrets/delete permission.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="UpdateSecretAsync(String,String,RequestContent,RequestContext)">
<example>
This sample shows how to call UpdateSecretAsync with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {};

Response response = await client.UpdateSecretAsync("<secretName>", "<secretVersion>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateSecretAsync with all parameters and request content, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {
    contentType = "<contentType>",
    attributes = new {
        enabled = true,
        nbf = "1652209051",
        exp = "1652209051",
    },
    tags = new {
        key = "<String>",
    },
};

Response response = await client.UpdateSecretAsync("<secretName>", "<secretVersion>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not specified in the request are left unchanged. The value of a secret itself cannot be changed. This operation requires the secrets/set permission.

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>SecretUpdateParameters</c>:
<code>{
  contentType: string, # Optional. Type of the secret value such as a password.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
}
</code>

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="UpdateSecret(String,String,RequestContent,RequestContext)">
<example>
This sample shows how to call UpdateSecret with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {};

Response response = client.UpdateSecret("<secretName>", "<secretVersion>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateSecret with all parameters and request content, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {
    contentType = "<contentType>",
    attributes = new {
        enabled = true,
        nbf = "1652209051",
        exp = "1652209051",
    },
    tags = new {
        key = "<String>",
    },
};

Response response = client.UpdateSecret("<secretName>", "<secretVersion>", RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not specified in the request are left unchanged. The value of a secret itself cannot be changed. This operation requires the secrets/set permission.

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>SecretUpdateParameters</c>:
<code>{
  contentType: string, # Optional. Type of the secret value such as a password.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
}
</code>

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="GetSecretAsync(String,String,RequestContext)">
<example>
This sample shows how to call GetSecretAsync with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = await client.GetSecretAsync("<secretName>", "<secretVersion>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get permission.

Below is the JSON schema for the response payload.

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="GetSecret(String,String,RequestContext)">
<example>
This sample shows how to call GetSecret with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = client.GetSecret("<secretName>", "<secretVersion>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get permission.

Below is the JSON schema for the response payload.

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="GetDeletedSecretAsync(String,RequestContext)">
<example>
This sample shows how to call GetDeletedSecretAsync with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = await client.GetDeletedSecretAsync("<secretName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("recoveryId").ToString());
Console.WriteLine(result.GetProperty("scheduledPurgeDate").ToString());
Console.WriteLine(result.GetProperty("deletedDate").ToString());
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This operation requires the secrets/get permission.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="GetDeletedSecret(String,RequestContext)">
<example>
This sample shows how to call GetDeletedSecret with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = client.GetDeletedSecret("<secretName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("recoveryId").ToString());
Console.WriteLine(result.GetProperty("scheduledPurgeDate").ToString());
Console.WriteLine(result.GetProperty("deletedDate").ToString());
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This operation requires the secrets/get permission.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="PurgeDeletedSecretAsync(String,RequestContext)">
<example>
This sample shows how to call PurgeDeletedSecretAsync with required parameters.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = await client.PurgeDeletedSecretAsync("<secretName>");
Console.WriteLine(response.Status);
]]></code>
</example>
<remarks>
The purge deleted secret operation removes the secret permanently, without the possibility of recovery. This operation can only be enabled on a soft-delete enabled vault. This operation requires the secrets/purge permission.
</remarks>
    </member>
    <member name="PurgeDeletedSecret(String,RequestContext)">
<example>
This sample shows how to call PurgeDeletedSecret with required parameters.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = client.PurgeDeletedSecret("<secretName>");
Console.WriteLine(response.Status);
]]></code>
</example>
<remarks>
The purge deleted secret operation removes the secret permanently, without the possibility of recovery. This operation can only be enabled on a soft-delete enabled vault. This operation requires the secrets/purge permission.
</remarks>
    </member>
    <member name="RecoverDeletedSecretAsync(String,RequestContext)">
<example>
This sample shows how to call RecoverDeletedSecretAsync with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = await client.RecoverDeletedSecretAsync("<secretName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete enabled vault. This operation requires the secrets/recover permission.

Below is the JSON schema for the response payload.

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="RecoverDeletedSecret(String,RequestContext)">
<example>
This sample shows how to call RecoverDeletedSecret with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = client.RecoverDeletedSecret("<secretName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete enabled vault. This operation requires the secrets/recover permission.

Below is the JSON schema for the response payload.

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="BackupSecretAsync(String,RequestContext)">
<example>
This sample shows how to call BackupSecretAsync with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = await client.BackupSecretAsync("<secretName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
]]></code>
</example>
<remarks>
Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will be downloaded. This operation requires the secrets/backup permission.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>BackupSecretResult</c>:
<code>{
  value: BytesBase64Url, # Optional. The backup blob containing the backed up secret.
}
</code>

</remarks>
    </member>
    <member name="BackupSecret(String,RequestContext)">
<example>
This sample shows how to call BackupSecret with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

Response response = client.BackupSecret("<secretName>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
]]></code>
</example>
<remarks>
Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will be downloaded. This operation requires the secrets/backup permission.

Below is the JSON schema for the response payload.

Response Body:

Schema for <c>BackupSecretResult</c>:
<code>{
  value: BytesBase64Url, # Optional. The backup blob containing the backed up secret.
}
</code>

</remarks>
    </member>
    <member name="RestoreSecretAsync(RequestContent,RequestContext)">
<example>
This sample shows how to call RestoreSecretAsync with required request content and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {
    value = new {},
};

Response response = await client.RestoreSecretAsync(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore permission.

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>SecretRestoreParameters</c>:
<code>{
  value: BytesBase64Url, # Required. The backup blob associated with a secret bundle.
}
</code>

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="RestoreSecret(RequestContent,RequestContext)">
<example>
This sample shows how to call RestoreSecret with required request content and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

var data = new {
    value = new {},
};

Response response = client.RestoreSecret(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("contentType").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("kid").ToString());
Console.WriteLine(result.GetProperty("managed").ToString());
]]></code>
</example>
<remarks>
Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore permission.

Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>SecretRestoreParameters</c>:
<code>{
  value: BytesBase64Url, # Required. The backup blob associated with a secret bundle.
}
</code>

Response Body:

<details><summary>DeletedSecretBundle</summary>Schema for <c>DeletedSecretBundle</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  value: string, # Optional. The secret value.
  id: string, # Optional. The secret id.
  contentType: string, # Optional. The content type of the secret.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  kid: string, # Optional. If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV certificate.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a secret backing a certificate, then managed will be true.
}
</code>
</details>

</remarks>
    </member>
    <member name="GetSecretsAsync(Int32,RequestContext)">
<example>
This sample shows how to call GetSecretsAsync and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

await foreach (var data in client.GetSecretsAsync())
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetSecretsAsync with all parameters, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

await foreach (var data in client.GetSecretsAsync(1234))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
    Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
    Console.WriteLine(result.GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("managed").ToString());
}
]]></code>
</example>
<remarks>
The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its attributes are provided in the response. Individual secret versions are not listed in the response. This operation requires the secrets/list permission.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>SecretListResultValue</c>:
<code>{
  id: string, # Optional. Secret identifier.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  contentType: string, # Optional. Type of the secret value such as a password.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="GetSecrets(Int32,RequestContext)">
<example>
This sample shows how to call GetSecrets and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

foreach (var data in client.GetSecrets())
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetSecrets with all parameters, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

foreach (var data in client.GetSecrets(1234))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
    Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
    Console.WriteLine(result.GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("managed").ToString());
}
]]></code>
</example>
<remarks>
The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its attributes are provided in the response. Individual secret versions are not listed in the response. This operation requires the secrets/list permission.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>SecretListResultValue</c>:
<code>{
  id: string, # Optional. Secret identifier.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  contentType: string, # Optional. Type of the secret value such as a password.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="GetSecretVersionsAsync(String,Int32,RequestContext)">
<example>
This sample shows how to call GetSecretVersionsAsync with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

await foreach (var data in client.GetSecretVersionsAsync("<secretName>"))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetSecretVersionsAsync with all parameters, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

await foreach (var data in client.GetSecretVersionsAsync("<secretName>", 1234))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
    Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
    Console.WriteLine(result.GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("managed").ToString());
}
]]></code>
</example>
<remarks>
The full secret identifier and attributes are provided in the response. No values are returned for the secrets. This operations requires the secrets/list permission.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>SecretListResultValue</c>:
<code>{
  id: string, # Optional. Secret identifier.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  contentType: string, # Optional. Type of the secret value such as a password.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="GetSecretVersions(String,Int32,RequestContext)">
<example>
This sample shows how to call GetSecretVersions with required parameters and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

foreach (var data in client.GetSecretVersions("<secretName>"))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetSecretVersions with all parameters, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

foreach (var data in client.GetSecretVersions("<secretName>", 1234))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
    Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
    Console.WriteLine(result.GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("managed").ToString());
}
]]></code>
</example>
<remarks>
The full secret identifier and attributes are provided in the response. No values are returned for the secrets. This operations requires the secrets/list permission.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>SecretListResultValue</c>:
<code>{
  id: string, # Optional. Secret identifier.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  contentType: string, # Optional. Type of the secret value such as a password.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="GetDeletedSecretsAsync(Int32,RequestContext)">
<example>
This sample shows how to call GetDeletedSecretsAsync and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

await foreach (var data in client.GetDeletedSecretsAsync())
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetDeletedSecretsAsync with all parameters, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

await foreach (var data in client.GetDeletedSecretsAsync(1234))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("recoveryId").ToString());
    Console.WriteLine(result.GetProperty("scheduledPurgeDate").ToString());
    Console.WriteLine(result.GetProperty("deletedDate").ToString());
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
    Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
    Console.WriteLine(result.GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("managed").ToString());
}
]]></code>
</example>
<remarks>
The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete. This operation requires the secrets/list permission.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>DeletedSecretListResultValue</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  id: string, # Optional. Secret identifier.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  contentType: string, # Optional. Type of the secret value such as a password.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
    <member name="GetDeletedSecrets(Int32,RequestContext)">
<example>
This sample shows how to call GetDeletedSecrets and parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

foreach (var data in client.GetDeletedSecrets())
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.ToString());
}
]]></code>
This sample shows how to call GetDeletedSecrets with all parameters, and how to parse the result.
<code><![CDATA[
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new SecretClient(endpoint);

foreach (var data in client.GetDeletedSecrets(1234))
{
    JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
    Console.WriteLine(result.GetProperty("recoveryId").ToString());
    Console.WriteLine(result.GetProperty("scheduledPurgeDate").ToString());
    Console.WriteLine(result.GetProperty("deletedDate").ToString());
    Console.WriteLine(result.GetProperty("id").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoverableDays").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("recoveryLevel").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("enabled").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("nbf").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("exp").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("created").ToString());
    Console.WriteLine(result.GetProperty("attributes").GetProperty("updated").ToString());
    Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
    Console.WriteLine(result.GetProperty("contentType").ToString());
    Console.WriteLine(result.GetProperty("managed").ToString());
}
]]></code>
</example>
<remarks>
The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete. This operation requires the secrets/list permission.

Below is the JSON schema for one item in the pageable response.

Response Body:

Schema for <c>DeletedSecretListResultValue</c>:
<code>{
  recoveryId: string, # Optional. The url of the recovery object, used to identify and recover the deleted secret.
  scheduledPurgeDate: string (Unix Format), # Optional. The time when the secret is scheduled to be purged, in UTC
  deletedDate: string (Unix Format), # Optional. The time when the secret was deleted, in UTC
  id: string, # Optional. Secret identifier.
  attributes: {
    recoverableDays: number, # Optional. softDelete data retention days. Value should be &gt;=7 and &lt;=90 when softDelete enabled, otherwise 0.
    recoveryLevel: &quot;Purgeable&quot; | &quot;Recoverable+Purgeable&quot; | &quot;Recoverable&quot; | &quot;Recoverable+ProtectedSubscription&quot; | &quot;CustomizedRecoverable+Purgeable&quot; | &quot;CustomizedRecoverable&quot; | &quot;CustomizedRecoverable+ProtectedSubscription&quot;, # Optional. Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains &apos;Purgeable&apos;, the secret can be permanently deleted by a privileged user; otherwise, only the system can purge the secret, at the end of the retention interval.
    enabled: boolean, # Optional. Determines whether the object is enabled.
    nbf: string (Unix Format), # Optional. Not before date in UTC.
    exp: string (Unix Format), # Optional. Expiry date in UTC.
    created: string (Unix Format), # Optional. Creation time in UTC.
    updated: string (Unix Format), # Optional. Last updated time in UTC.
  }, # Optional. The secret management attributes.
  tags: Dictionary&lt;string, string&gt;, # Optional. Application specific metadata in the form of key-value pairs.
  contentType: string, # Optional. Type of the secret value such as a password.
  managed: boolean, # Optional. True if the secret&apos;s lifetime is managed by key vault. If this is a key backing a certificate, then managed will be true.
}
</code>

</remarks>
    </member>
  </members>
</doc>