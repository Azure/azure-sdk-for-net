// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure;
using Azure.Core;
using Azure.ResourceManager.KeyVault;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.KeyVault.Models
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class ArmKeyVaultModelFactory
    {
        /// <summary> Resource information with extended details. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> Properties of the vault. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <returns> A new <see cref="KeyVault.KeyVaultData"/> instance for mocking. </returns>
        public static KeyVaultData KeyVaultData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, KeyVaultProperties properties = default, IDictionary<string, string> tags = default, AzureLocation? location = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new KeyVaultData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties,
                tags,
                location);
        }

        /// <summary> Properties of the vault. </summary>
        /// <param name="tenantId"> The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault. </param>
        /// <param name="sku"> SKU details. </param>
        /// <param name="accessPolicies"> An array of 0 to 1024 identities that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID. When `createMode` is set to `recover`, access policies are not required. Otherwise, access policies are required. </param>
        /// <param name="vaultUri"> The URI of the vault for performing operations on keys and secrets. </param>
        /// <param name="hsmPoolResourceId"> The resource id of HSM Pool. </param>
        /// <param name="enabledForDeployment"> Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key vault. </param>
        /// <param name="enabledForDiskEncryption"> Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys. </param>
        /// <param name="enabledForTemplateDeployment"> Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault. </param>
        /// <param name="enableSoftDelete"> Property to specify whether the 'soft delete' functionality is enabled for this key vault. If it's not set to any value(true or false) when creating new key vault, it will be set to true by default. Once set to true, it cannot be reverted to false. </param>
        /// <param name="softDeleteRetentionInDays"> softDelete data retention days. It accepts &gt;=7 and &lt;=90. </param>
        /// <param name="enableRbacAuthorization"> Property that controls how data actions are authorized. When true, the key vault will use Role Based Access Control (RBAC) for authorization of data actions, and the access policies specified in vault properties will be  ignored. When false, the key vault will use the access policies specified in vault properties, and any policy stored on Azure Resource Manager will be ignored. If null or not specified, the vault is created with the default value of false. Note that management actions are always authorized with RBAC. </param>
        /// <param name="createMode"> The vault's create mode to indicate whether the vault need to be recovered or not. </param>
        /// <param name="enablePurgeProtection"> Property specifying whether protection against purge is enabled for this vault. Setting this property to true activates protection against purge for this vault and its content - only the Key Vault service may initiate a hard, irrecoverable deletion. The setting is effective only if soft delete is also enabled. Enabling this functionality is irreversible - that is, the property does not accept false as its value. </param>
        /// <param name="networkRuleSet"> Rules governing the accessibility of the key vault from specific network locations. </param>
        /// <param name="provisioningState"> Provisioning state of the vault. </param>
        /// <param name="privateEndpointConnections"> List of private endpoint connections associated with the key vault. </param>
        /// <param name="publicNetworkAccess"> Property to specify whether the vault will accept traffic from public internet. If set to 'disabled' all traffic except private endpoint traffic and that that originates from trusted services will be blocked. This will override the set firewall rules, meaning that even if the firewall rules are present we will not honor the rules. </param>
        /// <returns> A new <see cref="Models.KeyVaultProperties"/> instance for mocking. </returns>
        public static KeyVaultProperties KeyVaultProperties(Guid tenantId = default, KeyVaultSku sku = default, IEnumerable<KeyVaultAccessPolicy> accessPolicies = default, Uri vaultUri = default, string hsmPoolResourceId = default, bool? enabledForDeployment = default, bool? enabledForDiskEncryption = default, bool? enabledForTemplateDeployment = default, bool? enableSoftDelete = default, int? softDeleteRetentionInDays = default, bool? enableRbacAuthorization = default, KeyVaultCreateMode? createMode = default, bool? enablePurgeProtection = default, KeyVaultNetworkRuleSet networkRuleSet = default, KeyVaultProvisioningState? provisioningState = default, IEnumerable<KeyVaultPrivateEndpointConnectionItemData> privateEndpointConnections = default, string publicNetworkAccess = default)
        {
            accessPolicies ??= new ChangeTrackingList<KeyVaultAccessPolicy>();
            privateEndpointConnections ??= new ChangeTrackingList<KeyVaultPrivateEndpointConnectionItemData>();

            return new KeyVaultProperties(
                tenantId,
                sku,
                accessPolicies.ToList(),
                vaultUri,
                hsmPoolResourceId,
                enabledForDeployment,
                enabledForDiskEncryption,
                enabledForTemplateDeployment,
                enableSoftDelete,
                softDeleteRetentionInDays,
                enableRbacAuthorization,
                createMode,
                enablePurgeProtection,
                networkRuleSet,
                provisioningState,
                privateEndpointConnections.ToList(),
                publicNetworkAccess,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Permissions the identity has for keys, secrets, certificates and storage. </summary>
        /// <param name="keys"> Permissions to keys. </param>
        /// <param name="secrets"> Permissions to secrets. </param>
        /// <param name="certificates"> Permissions to certificates. </param>
        /// <param name="storage"> Permissions to storage accounts. </param>
        /// <returns> A new <see cref="Models.IdentityAccessPermissions"/> instance for mocking. </returns>
        public static IdentityAccessPermissions IdentityAccessPermissions(IEnumerable<IdentityAccessKeyPermission> keys = default, IEnumerable<IdentityAccessSecretPermission> secrets = default, IEnumerable<IdentityAccessCertificatePermission> certificates = default, IEnumerable<IdentityAccessStoragePermission> storage = default)
        {
            keys ??= new ChangeTrackingList<IdentityAccessKeyPermission>();
            secrets ??= new ChangeTrackingList<IdentityAccessSecretPermission>();
            certificates ??= new ChangeTrackingList<IdentityAccessCertificatePermission>();
            storage ??= new ChangeTrackingList<IdentityAccessStoragePermission>();

            return new IdentityAccessPermissions(keys.ToList(), secrets.ToList(), certificates.ToList(), storage.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> A set of rules governing the network accessibility of a vault. </summary>
        /// <param name="bypass"> Tells what traffic can bypass network rules. This can be 'AzureServices' or 'None'.  If not specified the default is 'AzureServices'. </param>
        /// <param name="defaultAction"> The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property has been evaluated. </param>
        /// <param name="ipRules"> The list of IP address rules. </param>
        /// <param name="virtualNetworkRules"> The list of virtual network rules. </param>
        /// <returns> A new <see cref="Models.KeyVaultNetworkRuleSet"/> instance for mocking. </returns>
        public static KeyVaultNetworkRuleSet KeyVaultNetworkRuleSet(KeyVaultNetworkRuleBypassOption? bypass = default, KeyVaultNetworkRuleAction? defaultAction = default, IEnumerable<KeyVaultIPRule> ipRules = default, IEnumerable<KeyVaultVirtualNetworkRule> virtualNetworkRules = default)
        {
            ipRules ??= new ChangeTrackingList<KeyVaultIPRule>();
            virtualNetworkRules ??= new ChangeTrackingList<KeyVaultVirtualNetworkRule>();

            return new KeyVaultNetworkRuleSet(bypass, defaultAction, ipRules.ToList(), virtualNetworkRules.ToList(), additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Id of private endpoint connection. </param>
        /// <param name="eTag"> Modified whenever there is a change in the state of private endpoint connection. </param>
        /// <param name="connectionState"> Approval state of the private link connection. </param>
        /// <param name="provisioningState"> Provisioning state of the private endpoint connection. </param>
        /// <param name="privateEndpointId"> Full identifier of the private endpoint resource. </param>
        /// <returns> A new <see cref="Models.KeyVaultPrivateEndpointConnectionItemData"/> instance for mocking. </returns>
        public static KeyVaultPrivateEndpointConnectionItemData KeyVaultPrivateEndpointConnectionItemData(string id = default, ETag? eTag = default, KeyVaultPrivateLinkServiceConnectionState connectionState = default, KeyVaultPrivateEndpointConnectionProvisioningState? provisioningState = default, string privateEndpointId = default)
        {
            return new KeyVaultPrivateEndpointConnectionItemData(id, eTag, connectionState is null || provisioningState is null || privateEndpointId is null ? default : new PrivateEndpointConnectionProperties(new PrivateEndpoint(privateEndpointId, new Dictionary<string, BinaryData>()), connectionState, provisioningState, new Dictionary<string, BinaryData>()), additionalBinaryDataProperties: null);
        }

        /// <summary> Parameters for creating or updating a vault. </summary>
        /// <param name="location"> The supported Azure location where the key vault should be created. </param>
        /// <param name="tags"> The tags that will be assigned to the key vault. </param>
        /// <param name="properties"> Properties of the vault. </param>
        /// <returns> A new <see cref="Models.VaultCreateOrUpdateParameters"/> instance for mocking. </returns>
        public static VaultCreateOrUpdateParameters VaultCreateOrUpdateParameters(AzureLocation location = default, IDictionary<string, string> tags = default, KeyVaultProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new VaultCreateOrUpdateParameters(location, tags, properties, additionalBinaryDataProperties: null);
        }

        /// <summary> Parameters for creating or updating a vault. </summary>
        /// <param name="tags"> The tags that will be assigned to the key vault. </param>
        /// <param name="properties"> Properties of the vault. </param>
        /// <returns> A new <see cref="Models.KeyVaultPatch"/> instance for mocking. </returns>
        public static KeyVaultPatch KeyVaultPatch(IDictionary<string, string> tags = default, KeyVaultPatchProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new KeyVaultPatch(tags, properties, additionalBinaryDataProperties: null);
        }

        /// <summary> Properties of the vault. </summary>
        /// <param name="tenantId"> The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault. </param>
        /// <param name="sku"> SKU details. </param>
        /// <param name="accessPolicies"> An array of 0 to 16 identities that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID. </param>
        /// <param name="enabledForDeployment"> Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key vault. </param>
        /// <param name="enabledForDiskEncryption"> Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys. </param>
        /// <param name="enabledForTemplateDeployment"> Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault. </param>
        /// <param name="enableSoftDelete"> Property to specify whether the 'soft delete' functionality is enabled for this key vault. Once set to true, it cannot be reverted to false. </param>
        /// <param name="enableRbacAuthorization"> Property that controls how data actions are authorized. When true, the key vault will use Role Based Access Control (RBAC) for authorization of data actions, and the access policies specified in vault properties will be  ignored. When false, the key vault will use the access policies specified in vault properties, and any policy stored on Azure Resource Manager will be ignored. If null or not specified, the value of this property will not change. </param>
        /// <param name="softDeleteRetentionInDays"> softDelete data retention days. It accepts &gt;=7 and &lt;=90. </param>
        /// <param name="createMode"> The vault's create mode to indicate whether the vault need to be recovered or not. </param>
        /// <param name="enablePurgeProtection"> Property specifying whether protection against purge is enabled for this vault. Setting this property to true activates protection against purge for this vault and its content - only the Key Vault service may initiate a hard, irrecoverable deletion. The setting is effective only if soft delete is also enabled. Enabling this functionality is irreversible - that is, the property does not accept false as its value. </param>
        /// <param name="networkRuleSet"> A collection of rules governing the accessibility of the vault from specific network locations. </param>
        /// <param name="publicNetworkAccess"> Property to specify whether the vault will accept traffic from public internet. If set to 'disabled' all traffic except private endpoint traffic and that that originates from trusted services will be blocked. This will override the set firewall rules, meaning that even if the firewall rules are present we will not honor the rules. </param>
        /// <returns> A new <see cref="Models.KeyVaultPatchProperties"/> instance for mocking. </returns>
        public static KeyVaultPatchProperties KeyVaultPatchProperties(Guid? tenantId = default, KeyVaultSku sku = default, IEnumerable<KeyVaultAccessPolicy> accessPolicies = default, bool? enabledForDeployment = default, bool? enabledForDiskEncryption = default, bool? enabledForTemplateDeployment = default, bool? enableSoftDelete = default, bool? enableRbacAuthorization = default, int? softDeleteRetentionInDays = default, KeyVaultPatchMode? createMode = default, bool? enablePurgeProtection = default, KeyVaultNetworkRuleSet networkRuleSet = default, string publicNetworkAccess = default)
        {
            accessPolicies ??= new ChangeTrackingList<KeyVaultAccessPolicy>();

            return new KeyVaultPatchProperties(
                tenantId,
                sku,
                accessPolicies.ToList(),
                enabledForDeployment,
                enabledForDiskEncryption,
                enabledForTemplateDeployment,
                enableSoftDelete,
                enableRbacAuthorization,
                softDeleteRetentionInDays,
                createMode,
                enablePurgeProtection,
                networkRuleSet,
                publicNetworkAccess,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> The resource id of the access policy. </param>
        /// <param name="name"> The resource name of the access policy. </param>
        /// <param name="type"> The resource name of the access policy. </param>
        /// <param name="location"> The resource type of the access policy. </param>
        /// <param name="accessPolicies"> An array of 0 to 16 identities that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID. </param>
        /// <returns> A new <see cref="Models.KeyVaultAccessPolicyParameters"/> instance for mocking. </returns>
        public static KeyVaultAccessPolicyParameters KeyVaultAccessPolicyParameters(string id = default, string name = default, string @type = default, AzureLocation? location = default, IList<KeyVaultAccessPolicy> accessPolicies = default)
        {
            return new KeyVaultAccessPolicyParameters(
                id,
                name,
                @type,
                location,
                accessPolicies is null ? default : new KeyVaultAccessPolicyProperties(accessPolicies, new Dictionary<string, BinaryData>()),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Properties of the vault access policy. </summary>
        /// <param name="accessPolicies"> An array of 0 to 16 identities that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID. </param>
        /// <returns> A new <see cref="Models.KeyVaultAccessPolicyProperties"/> instance for mocking. </returns>
        public static KeyVaultAccessPolicyProperties KeyVaultAccessPolicyProperties(IEnumerable<KeyVaultAccessPolicy> accessPolicies = default)
        {
            accessPolicies ??= new ChangeTrackingList<KeyVaultAccessPolicy>();

            return new KeyVaultAccessPolicyProperties(accessPolicies.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> A list of private link resources. </summary>
        /// <param name="value"> Array of private link resources. </param>
        /// <returns> A new <see cref="Models.KeyVaultPrivateLinkResourceListResult"/> instance for mocking. </returns>
        public static KeyVaultPrivateLinkResourceListResult KeyVaultPrivateLinkResourceListResult(IEnumerable<KeyVaultPrivateLinkResourceData> value = default)
        {
            value ??= new ChangeTrackingList<KeyVaultPrivateLinkResourceData>();

            return new KeyVaultPrivateLinkResourceListResult(value.ToList(), additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="groupId"> Group identifier of private link resource. </param>
        /// <param name="requiredMembers"> Required member names of private link resource. </param>
        /// <param name="requiredZoneNames"> Required DNS zone names of the the private link resource. </param>
        /// <param name="location"> Azure location of the key vault resource. </param>
        /// <param name="tags"> Tags assigned to the key vault resource. </param>
        /// <returns> A new <see cref="Models.KeyVaultPrivateLinkResourceData"/> instance for mocking. </returns>
        public static KeyVaultPrivateLinkResourceData KeyVaultPrivateLinkResourceData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string groupId = default, IReadOnlyList<string> requiredMembers = default, IList<string> requiredZoneNames = default, AzureLocation? location = default, IReadOnlyDictionary<string, string> tags = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new KeyVaultPrivateLinkResourceData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                groupId is null || requiredMembers is null || requiredZoneNames is null ? default : new KeyVaultPrivateLinkResourceProperties(groupId, requiredMembers, requiredZoneNames, new Dictionary<string, BinaryData>()),
                location,
                tags);
        }

        /// <summary> Deleted vault information with extended details. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> Properties of the vault. </param>
        /// <returns> A new <see cref="KeyVault.DeletedKeyVaultData"/> instance for mocking. </returns>
        public static DeletedKeyVaultData DeletedKeyVaultData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, DeletedKeyVaultProperties properties = default)
        {
            return new DeletedKeyVaultData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> Properties of the deleted vault. </summary>
        /// <param name="vaultId"> The resource id of the original vault. </param>
        /// <param name="location"> The location of the original vault. </param>
        /// <param name="deletedOn"> The deleted date. </param>
        /// <param name="scheduledPurgeOn"> The scheduled purged date. </param>
        /// <param name="tags"> Tags of the original vault. </param>
        /// <param name="purgeProtectionEnabled"> Purge protection status of the original vault. </param>
        /// <returns> A new <see cref="Models.DeletedKeyVaultProperties"/> instance for mocking. </returns>
        public static DeletedKeyVaultProperties DeletedKeyVaultProperties(ResourceIdentifier vaultId = default, AzureLocation? location = default, DateTimeOffset? deletedOn = default, DateTimeOffset? scheduledPurgeOn = default, IReadOnlyDictionary<string, string> tags = default, bool? purgeProtectionEnabled = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new DeletedKeyVaultProperties(
                vaultId,
                location,
                deletedOn,
                scheduledPurgeOn,
                tags,
                purgeProtectionEnabled,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="connectionState"> Approval state of the private link connection. </param>
        /// <param name="provisioningState"> Provisioning state of the private endpoint connection. </param>
        /// <param name="privateEndpointId"> Full identifier of the private endpoint resource. </param>
        /// <param name="location"> Azure location of the key vault resource. </param>
        /// <param name="tags"> Tags assigned to the key vault resource. </param>
        /// <param name="eTag"> Modified whenever there is a change in the state of private endpoint connection. </param>
        /// <returns> A new <see cref="KeyVault.KeyVaultPrivateEndpointConnectionData"/> instance for mocking. </returns>
        public static KeyVaultPrivateEndpointConnectionData KeyVaultPrivateEndpointConnectionData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, KeyVaultPrivateLinkServiceConnectionState connectionState = default, KeyVaultPrivateEndpointConnectionProvisioningState? provisioningState = default, string privateEndpointId = default, AzureLocation? location = default, IReadOnlyDictionary<string, string> tags = default, ETag? eTag = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new KeyVaultPrivateEndpointConnectionData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                connectionState is null || provisioningState is null || privateEndpointId is null ? default : new PrivateEndpointConnectionProperties(new PrivateEndpoint(privateEndpointId, new Dictionary<string, BinaryData>()), connectionState, provisioningState, new Dictionary<string, BinaryData>()),
                location,
                tags,
                eTag);
        }

        /// <summary> Resource information with extended details. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> Properties of the managed HSM. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="sku"> SKU details. </param>
        /// <param name="identity"> Managed service identity. </param>
        /// <returns> A new <see cref="KeyVault.ManagedHsmData"/> instance for mocking. </returns>
        public static ManagedHsmData ManagedHsmData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ManagedHsmProperties properties = default, IDictionary<string, string> tags = default, AzureLocation? location = default, ManagedHsmSku sku = default, ManagedServiceIdentity identity = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ManagedHsmData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties,
                tags,
                location,
                sku,
                identity);
        }

        /// <summary> Properties of the managed HSM Pool. </summary>
        /// <param name="tenantId"> The Azure Active Directory tenant ID that should be used for authenticating requests to the managed HSM pool. </param>
        /// <param name="initialAdminObjectIds"> Array of initial administrators object ids for this managed hsm pool. </param>
        /// <param name="hsmUri"> The URI of the managed hsm pool for performing operations on keys. </param>
        /// <param name="enableSoftDelete"> Property to specify whether the 'soft delete' functionality is enabled for this managed HSM pool. Soft delete is enabled by default for all managed HSMs and is immutable. </param>
        /// <param name="softDeleteRetentionInDays"> Soft deleted data retention days. When you delete an HSM or a key, it will remain recoverable for the configured retention period or for a default period of 90 days. It accepts values between 7 and 90. </param>
        /// <param name="enablePurgeProtection"> Property specifying whether protection against purge is enabled for this managed HSM pool. Setting this property to true activates protection against purge for this managed HSM pool and its content - only the Managed HSM service may initiate a hard, irrecoverable deletion. Enabling this functionality is irreversible. </param>
        /// <param name="createMode"> The create mode to indicate whether the resource is being created or is being recovered from a deleted resource. </param>
        /// <param name="statusMessage"> Resource Status Message. </param>
        /// <param name="provisioningState"> Provisioning state. </param>
        /// <param name="networkRuleSet"> Rules governing the accessibility of the key vault from specific network locations. </param>
        /// <param name="regions"> List of all regions associated with the managed hsm pool. </param>
        /// <param name="privateEndpointConnections"> List of private endpoint connections associated with the managed hsm pool. </param>
        /// <param name="publicNetworkAccess"> Control permission to the managed HSM from public networks. </param>
        /// <param name="scheduledPurgeOn"> The scheduled purge date in UTC. </param>
        /// <param name="securityDomainProperties"> Managed HSM security domain properties. </param>
        /// <returns> A new <see cref="Models.ManagedHsmProperties"/> instance for mocking. </returns>
        public static ManagedHsmProperties ManagedHsmProperties(Guid? tenantId = default, IEnumerable<string> initialAdminObjectIds = default, Uri hsmUri = default, bool? enableSoftDelete = default, int? softDeleteRetentionInDays = default, bool? enablePurgeProtection = default, ManagedHsmCreateMode? createMode = default, string statusMessage = default, ManagedHsmProvisioningState? provisioningState = default, ManagedHsmNetworkRuleSet networkRuleSet = default, IEnumerable<ManagedHsmGeoReplicatedRegion> regions = default, IEnumerable<ManagedHsmPrivateEndpointConnectionItemData> privateEndpointConnections = default, ManagedHsmPublicNetworkAccess? publicNetworkAccess = default, DateTimeOffset? scheduledPurgeOn = default, ManagedHSMSecurityDomainProperties securityDomainProperties = default)
        {
            initialAdminObjectIds ??= new ChangeTrackingList<string>();
            regions ??= new ChangeTrackingList<ManagedHsmGeoReplicatedRegion>();
            privateEndpointConnections ??= new ChangeTrackingList<ManagedHsmPrivateEndpointConnectionItemData>();

            return new ManagedHsmProperties(
                tenantId,
                initialAdminObjectIds.ToList(),
                hsmUri,
                enableSoftDelete,
                softDeleteRetentionInDays,
                enablePurgeProtection,
                createMode,
                statusMessage,
                provisioningState,
                networkRuleSet,
                regions.ToList(),
                privateEndpointConnections.ToList(),
                publicNetworkAccess,
                scheduledPurgeOn,
                securityDomainProperties,
                additionalBinaryDataProperties: null);
        }

        /// <summary> A set of rules governing the network accessibility of a managed hsm pool. </summary>
        /// <param name="bypass"> Tells what traffic can bypass network rules. This can be 'AzureServices' or 'None'.  If not specified the default is 'AzureServices'. </param>
        /// <param name="defaultAction"> The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property has been evaluated. </param>
        /// <param name="ipRules"> The list of IP address rules. </param>
        /// <param name="serviceTags"> The list of service tags. </param>
        /// <param name="virtualNetworkRules"> The list of virtual network rules. </param>
        /// <returns> A new <see cref="Models.ManagedHsmNetworkRuleSet"/> instance for mocking. </returns>
        public static ManagedHsmNetworkRuleSet ManagedHsmNetworkRuleSet(ManagedHsmNetworkRuleBypassOption? bypass = default, ManagedHsmNetworkRuleAction? defaultAction = default, IEnumerable<ManagedHsmIPRule> ipRules = default, IEnumerable<ManagedHsmServiceTagRule> serviceTags = default, IEnumerable<ManagedHsmVirtualNetworkRule> virtualNetworkRules = default)
        {
            ipRules ??= new ChangeTrackingList<ManagedHsmIPRule>();
            serviceTags ??= new ChangeTrackingList<ManagedHsmServiceTagRule>();
            virtualNetworkRules ??= new ChangeTrackingList<ManagedHsmVirtualNetworkRule>();

            return new ManagedHsmNetworkRuleSet(
                bypass,
                defaultAction,
                ipRules.ToList(),
                serviceTags.ToList(),
                virtualNetworkRules.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> A region that this managed HSM Pool has been extended to. </summary>
        /// <param name="name"> Name of the geo replicated region. </param>
        /// <param name="provisioningState"> Provisioning state of the geo replicated region. </param>
        /// <param name="isPrimary"> A boolean value that indicates whether the region is the primary region or a secondary region. </param>
        /// <returns> A new <see cref="Models.ManagedHsmGeoReplicatedRegion"/> instance for mocking. </returns>
        public static ManagedHsmGeoReplicatedRegion ManagedHsmGeoReplicatedRegion(string name = default, ManagedHsmGeoReplicatedRegionProvisioningState? provisioningState = default, bool? isPrimary = default)
        {
            return new ManagedHsmGeoReplicatedRegion(name, provisioningState, isPrimary, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Id of private endpoint connection. </param>
        /// <param name="eTag"> Modified whenever there is a change in the state of private endpoint connection. </param>
        /// <param name="privateLinkServiceConnectionState"> Approval state of the private link connection. </param>
        /// <param name="provisioningState"> Provisioning state of the private endpoint connection. </param>
        /// <param name="privateEndpointId"> Full identifier of the private endpoint resource. </param>
        /// <returns> A new <see cref="Models.ManagedHsmPrivateEndpointConnectionItemData"/> instance for mocking. </returns>
        public static ManagedHsmPrivateEndpointConnectionItemData ManagedHsmPrivateEndpointConnectionItemData(ResourceIdentifier id = default, ETag? eTag = default, ManagedHsmPrivateLinkServiceConnectionState privateLinkServiceConnectionState = default, ManagedHsmPrivateEndpointConnectionProvisioningState? provisioningState = default, string privateEndpointId = default)
        {
            return new ManagedHsmPrivateEndpointConnectionItemData(id, eTag, privateLinkServiceConnectionState is null || provisioningState is null || privateEndpointId is null ? default : new ManagedHsmPrivateEndpointConnectionProperties(new ManagedHsmPrivateEndpoint(privateEndpointId, new Dictionary<string, BinaryData>()), privateLinkServiceConnectionState, provisioningState, new Dictionary<string, BinaryData>()), additionalBinaryDataProperties: null);
        }

        /// <summary> The security domain properties of the managed hsm. </summary>
        /// <param name="activationStatus"> Activation Status. </param>
        /// <param name="activationStatusMessage"> Activation Status Message. </param>
        /// <returns> A new <see cref="Models.ManagedHSMSecurityDomainProperties"/> instance for mocking. </returns>
        public static ManagedHSMSecurityDomainProperties ManagedHSMSecurityDomainProperties(ManagedHSMSecurityDomainActivationStatus? activationStatus = default, string activationStatusMessage = default)
        {
            return new ManagedHSMSecurityDomainProperties(activationStatus, activationStatusMessage, additionalBinaryDataProperties: null);
        }

        /// <summary> A list of private link resources. </summary>
        /// <param name="value"> Array of private link resources. </param>
        /// <returns> A new <see cref="Models.ManagedHsmPrivateLinkResourceListResult"/> instance for mocking. </returns>
        public static ManagedHsmPrivateLinkResourceListResult ManagedHsmPrivateLinkResourceListResult(IEnumerable<ManagedHsmPrivateLinkResourceData> value = default)
        {
            value ??= new ChangeTrackingList<ManagedHsmPrivateLinkResourceData>();

            return new ManagedHsmPrivateLinkResourceListResult(value.ToList(), additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="provisioningState"> The provisioned state of the resource. </param>
        /// <param name="groupId"> Group identifier of private link resource. </param>
        /// <param name="requiredMembers"> Required member names of private link resource. </param>
        /// <param name="requiredZoneNames"> Required DNS zone names of the the private link resource. </param>
        /// <param name="sku"> SKU details. </param>
        /// <param name="identity"> Managed service identity (system assigned and/or user assigned identities). </param>
        /// <returns> A new <see cref="Models.ManagedHsmPrivateLinkResourceData"/> instance for mocking. </returns>
        public static ManagedHsmPrivateLinkResourceData ManagedHsmPrivateLinkResourceData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ManagedHsmProvisioningState? provisioningState = default, string groupId = default, IReadOnlyList<string> requiredMembers = default, IList<string> requiredZoneNames = default, ManagedHsmSku sku = default, ManagedServiceIdentity identity = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ManagedHsmPrivateLinkResourceData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                provisioningState is null || groupId is null || requiredMembers is null || requiredZoneNames is null ? default : new MhsmPrivateLinkResourceProperties(provisioningState, groupId, requiredMembers, requiredZoneNames, new Dictionary<string, BinaryData>()),
                sku,
                identity);
        }

        /// <summary> Concrete proxy resource types can be created by aliasing this type using a specific property type. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> Properties of the deleted managed HSM. </param>
        /// <returns> A new <see cref="KeyVault.DeletedManagedHsmData"/> instance for mocking. </returns>
        public static DeletedManagedHsmData DeletedManagedHsmData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, DeletedManagedHsmProperties properties = default)
        {
            return new DeletedManagedHsmData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> Properties of the deleted managed HSM. </summary>
        /// <param name="managedHsmId"> The resource id of the original managed HSM. </param>
        /// <param name="location"> The location of the original managed HSM. </param>
        /// <param name="deletedOn"> The deleted date. </param>
        /// <param name="scheduledPurgeOn"> The scheduled purged date. </param>
        /// <param name="purgeProtectionEnabled"> Purge protection status of the original managed HSM. </param>
        /// <param name="tags"> Tags of the original managed HSM. </param>
        /// <returns> A new <see cref="Models.DeletedManagedHsmProperties"/> instance for mocking. </returns>
        public static DeletedManagedHsmProperties DeletedManagedHsmProperties(ResourceIdentifier managedHsmId = default, AzureLocation? location = default, DateTimeOffset? deletedOn = default, DateTimeOffset? scheduledPurgeOn = default, bool? purgeProtectionEnabled = default, IReadOnlyDictionary<string, string> tags = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new DeletedManagedHsmProperties(
                managedHsmId,
                location,
                deletedOn,
                scheduledPurgeOn,
                purgeProtectionEnabled,
                tags,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="privateLinkServiceConnectionState"> Approval state of the private link connection. </param>
        /// <param name="provisioningState"> Provisioning state of the private endpoint connection. </param>
        /// <param name="privateEndpointId"> Full identifier of the private endpoint resource. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="sku"> SKU details. </param>
        /// <param name="identity"> Managed service identity. </param>
        /// <param name="eTag"> Modified whenever there is a change in the state of private endpoint connection. </param>
        /// <returns> A new <see cref="KeyVault.ManagedHsmPrivateEndpointConnectionData"/> instance for mocking. </returns>
        public static ManagedHsmPrivateEndpointConnectionData ManagedHsmPrivateEndpointConnectionData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ManagedHsmPrivateLinkServiceConnectionState privateLinkServiceConnectionState = default, ManagedHsmPrivateEndpointConnectionProvisioningState? provisioningState = default, string privateEndpointId = default, IDictionary<string, string> tags = default, AzureLocation? location = default, ManagedHsmSku sku = default, ManagedServiceIdentity identity = default, ETag? eTag = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ManagedHsmPrivateEndpointConnectionData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                privateLinkServiceConnectionState is null || provisioningState is null || privateEndpointId is null ? default : new ManagedHsmPrivateEndpointConnectionProperties(new ManagedHsmPrivateEndpoint(privateEndpointId, new Dictionary<string, BinaryData>()), privateLinkServiceConnectionState, provisioningState, new Dictionary<string, BinaryData>()),
                tags,
                location,
                sku,
                identity,
                eTag);
        }

        /// <summary> Resource information with extended details. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> Properties of the secret. </param>
        /// <param name="location"> Azure location of the key vault resource. </param>
        /// <param name="tags"> Tags assigned to the key vault resource. </param>
        /// <returns> A new <see cref="KeyVault.KeyVaultSecretData"/> instance for mocking. </returns>
        public static KeyVaultSecretData KeyVaultSecretData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, SecretProperties properties = default, AzureLocation? location = default, IReadOnlyDictionary<string, string> tags = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new KeyVaultSecretData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties,
                location,
                tags);
        }

        /// <summary> Properties of the secret. </summary>
        /// <param name="value"> The value of the secret. NOTE: 'value' will never be returned from the service, as APIs using this model are is intended for internal use in ARM deployments. Users should use the data-plane REST service for interaction with vault secrets. </param>
        /// <param name="contentType"> The content type of the secret. </param>
        /// <param name="attributes"> The attributes of the secret. </param>
        /// <param name="secretUri"> The URI to retrieve the current version of the secret. </param>
        /// <param name="secretUriWithVersion"> The URI to retrieve the specific version of the secret. </param>
        /// <returns> A new <see cref="Models.SecretProperties"/> instance for mocking. </returns>
        public static SecretProperties SecretProperties(string value = default, string contentType = default, SecretAttributes attributes = default, Uri secretUri = default, string secretUriWithVersion = default)
        {
            return new SecretProperties(
                value,
                contentType,
                attributes,
                secretUri,
                secretUriWithVersion,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The secret management attributes. </summary>
        /// <param name="enabled"> Determines whether the object is enabled. </param>
        /// <param name="notBefore"> Not before date in seconds since 1970-01-01T00:00:00Z. </param>
        /// <param name="expires"> Expiry date in seconds since 1970-01-01T00:00:00Z. </param>
        /// <param name="created"> Creation time in seconds since 1970-01-01T00:00:00Z. </param>
        /// <param name="updated"> Last updated time in seconds since 1970-01-01T00:00:00Z. </param>
        /// <returns> A new <see cref="Models.SecretAttributes"/> instance for mocking. </returns>
        public static SecretAttributes SecretAttributes(bool? enabled = default, DateTimeOffset? notBefore = default, DateTimeOffset? expires = default, DateTimeOffset? created = default, DateTimeOffset? updated = default)
        {
            return new SecretAttributes(
                enabled,
                notBefore,
                expires,
                created,
                updated,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The object attributes managed by the KeyVault service. </summary>
        /// <param name="enabled"> Determines whether the object is enabled. </param>
        /// <param name="notBefore"> Not before date in seconds since 1970-01-01T00:00:00Z. </param>
        /// <param name="expires"> Expiry date in seconds since 1970-01-01T00:00:00Z. </param>
        /// <param name="created"> Creation time in seconds since 1970-01-01T00:00:00Z. </param>
        /// <param name="updated"> Last updated time in seconds since 1970-01-01T00:00:00Z. </param>
        /// <returns> A new <see cref="Models.SecretBaseAttributes"/> instance for mocking. </returns>
        public static SecretBaseAttributes SecretBaseAttributes(bool? enabled = default, DateTimeOffset? notBefore = default, DateTimeOffset? expires = default, DateTimeOffset? created = default, DateTimeOffset? updated = default)
        {
            return new SecretBaseAttributes(
                enabled,
                notBefore,
                expires,
                created,
                updated,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Parameters for creating or updating a secret. </summary>
        /// <param name="tags"> The tags that will be assigned to the secret. </param>
        /// <param name="properties"> Properties of the secret. </param>
        /// <returns> A new <see cref="Models.SecretCreateOrUpdateParameters"/> instance for mocking. </returns>
        public static SecretCreateOrUpdateParameters SecretCreateOrUpdateParameters(IDictionary<string, string> tags = default, SecretProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new SecretCreateOrUpdateParameters(tags, properties, additionalBinaryDataProperties: null);
        }

        /// <summary> Parameters for patching a secret. </summary>
        /// <param name="tags"> The tags that will be assigned to the secret. </param>
        /// <param name="properties"> Properties of the secret. </param>
        /// <returns> A new <see cref="Models.KeyVaultSecretPatch"/> instance for mocking. </returns>
        public static KeyVaultSecretPatch KeyVaultSecretPatch(IDictionary<string, string> tags = default, SecretPatchProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new KeyVaultSecretPatch(tags, properties, additionalBinaryDataProperties: null);
        }

        /// <summary> The parameters used to check the availability of the vault name. </summary>
        /// <param name="name"> The vault name. </param>
        /// <param name="resourceType"> The type of resource, Microsoft.KeyVault/vaults. </param>
        /// <returns> A new <see cref="Models.KeyVaultNameAvailabilityContent"/> instance for mocking. </returns>
        public static KeyVaultNameAvailabilityContent KeyVaultNameAvailabilityContent(string name = default, ResourceType resourceType = default)
        {
            return new KeyVaultNameAvailabilityContent(name, resourceType, additionalBinaryDataProperties: null);
        }

        /// <summary> The CheckNameAvailability operation response. </summary>
        /// <param name="nameAvailable"> A boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already been taken or is invalid and cannot be used. </param>
        /// <param name="reason"> The reason that a vault name could not be used. The Reason element is only returned if NameAvailable is false. </param>
        /// <param name="message"> An error message explaining the Reason value in more detail. </param>
        /// <returns> A new <see cref="Models.KeyVaultNameAvailabilityResult"/> instance for mocking. </returns>
        public static KeyVaultNameAvailabilityResult KeyVaultNameAvailabilityResult(bool? nameAvailable = default, KeyVaultNameUnavailableReason? reason = default, string message = default)
        {
            return new KeyVaultNameAvailabilityResult(nameAvailable, reason, message, additionalBinaryDataProperties: null);
        }

        /// <summary> The parameters used to check the availability of the managed hsm name. </summary>
        /// <param name="name"> The managed hsm name. </param>
        /// <returns> A new <see cref="Models.ManagedHsmNameAvailabilityParameters"/> instance for mocking. </returns>
        public static ManagedHsmNameAvailabilityParameters ManagedHsmNameAvailabilityParameters(string name = default)
        {
            return new ManagedHsmNameAvailabilityParameters(name, additionalBinaryDataProperties: null);
        }

        /// <summary> The CheckMhsmNameAvailability operation response. </summary>
        /// <param name="isNameAvailable"> A boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already been taken or is invalid and cannot be used. </param>
        /// <param name="reason"> The reason that a managed hsm name could not be used. The reason element is only returned if NameAvailable is false. </param>
        /// <param name="message"> An error message explaining the Reason value in more detail. </param>
        /// <returns> A new <see cref="Models.ManagedHsmNameAvailabilityResult"/> instance for mocking. </returns>
        public static ManagedHsmNameAvailabilityResult ManagedHsmNameAvailabilityResult(bool? isNameAvailable = default, ManagedHsmNameUnavailableReason? reason = default, string message = default)
        {
            return new ManagedHsmNameAvailabilityResult(isNameAvailable, reason, message, additionalBinaryDataProperties: null);
        }
    }
}
