// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Developer.LoadTesting
{
    /// <summary> The Test service client. </summary>
    public partial class TestClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://loadtest.azure-dev.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of TestClient for mocking. </summary>
        protected TestClient()
        {
        }

        /// <summary> Initializes a new instance of TestClient. </summary>
        /// <param name="endpoint"> URL to perform data plane API operations on the resource. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public TestClient(string endpoint, TokenCredential credential) : this(endpoint, credential, new AzureLoadTestingClientOptions())
        {
        }

        /// <summary> Initializes a new instance of TestClient. </summary>
        /// <param name="endpoint"> URL to perform data plane API operations on the resource. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public TestClient(string endpoint, TokenCredential credential, AzureLoadTestingClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new AzureLoadTestingClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Create a new test or Update an existing test. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateTestAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.CreateOrUpdateTestAsync("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateTestAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     description = "<description>",
        ///     displayName = "<displayName>",
        ///     loadTestConfig = new {
        ///         engineInstances = 1234,
        ///         splitAllCSVs = true,
        ///     },
        ///     passFailCriteria = new {
        ///         passFailMetrics = new {
        ///             key = new {
        ///                 clientmetric = "<clientmetric>",
        ///                 aggregate = "<aggregate>",
        ///                 condition = "<condition>",
        ///                 requestName = "<requestName>",
        ///                 value = 123.45d,
        ///                 action = "<action>",
        ///             },
        ///         },
        ///     },
        ///     secrets = new {
        ///         key = new {
        ///             value = "<value>",
        ///             type = "<type>",
        ///         },
        ///     },
        ///     environmentVariables = new {
        ///         key = "<String>",
        ///     },
        ///     subnetId = "<subnetId>",
        ///     keyvaultReferenceIdentityType = "<keyvaultReferenceIdentityType>",
        ///     keyvaultReferenceIdentityId = "<keyvaultReferenceIdentityId>",
        /// };
        /// 
        /// Response response = await client.CreateOrUpdateTestAsync("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateOrUpdateTestAsync(string testId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.CreateOrUpdateTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateTestRequest(testId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new test or Update an existing test. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateTest with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.CreateOrUpdateTest("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateTest with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     description = "<description>",
        ///     displayName = "<displayName>",
        ///     loadTestConfig = new {
        ///         engineInstances = 1234,
        ///         splitAllCSVs = true,
        ///     },
        ///     passFailCriteria = new {
        ///         passFailMetrics = new {
        ///             key = new {
        ///                 clientmetric = "<clientmetric>",
        ///                 aggregate = "<aggregate>",
        ///                 condition = "<condition>",
        ///                 requestName = "<requestName>",
        ///                 value = 123.45d,
        ///                 action = "<action>",
        ///             },
        ///         },
        ///     },
        ///     secrets = new {
        ///         key = new {
        ///             value = "<value>",
        ///             type = "<type>",
        ///         },
        ///     },
        ///     environmentVariables = new {
        ///         key = "<String>",
        ///     },
        ///     subnetId = "<subnetId>",
        ///     keyvaultReferenceIdentityType = "<keyvaultReferenceIdentityType>",
        ///     keyvaultReferenceIdentityId = "<keyvaultReferenceIdentityId>",
        /// };
        /// 
        /// Response response = client.CreateOrUpdateTest("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateOrUpdateTest(string testId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.CreateOrUpdateTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateTestRequest(testId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a test by its name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteLoadTestAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.DeleteLoadTestAsync("<testId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteLoadTestAsync(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.DeleteLoadTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLoadTestRequest(testId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a test by its name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteLoadTest with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.DeleteLoadTest("<testId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteLoadTest(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.DeleteLoadTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLoadTestRequest(testId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get load test details by test name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLoadTestAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetLoadTestAsync("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLoadTestAsync(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetLoadTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLoadTestRequest(testId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get load test details by test name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLoadTest with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetLoadTest("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLoadTest(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetLoadTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLoadTestRequest(testId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all load tests by the fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}. </summary>
        /// <param name="orderBy"> Sort on one of the field - lastModifiedDateTime, displayName, createdBy in (field asc/desc) format. eg: displayName asc. </param>
        /// <param name="search"> Filter search based on searchable fields - testId, createdBy. </param>
        /// <param name="lastUpdatedStartTime"> Start DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="lastUpdatedEndTime"> End DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="maxPageSize"> Number of results in response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLoadTestSearchesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetLoadTestSearchesAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetLoadTestSearchesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetLoadTestSearchesAsync("<orderBy>", "<search>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, "<continuationToken>", 1234);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("keyvaultReferenceIdentityId").ToString());
        /// Console.WriteLine(result.GetProperty("nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModelResourceList</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       testId: string, # Optional. Unique test name as identifier.
        ///       description: string, # Optional. The test description.
        ///       displayName: string, # Optional. Display name of a test.
        ///       resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///       loadTestConfig: {
        ///         engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///         splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///       }, # Optional. The load test configuration.
        ///       passFailCriteria: {
        ///         passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///       }, # Optional. Pass fail criteria for a test.
        ///       createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///       createdBy: string, # Optional. The user that created the test model.
        ///       lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///       lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///       inputArtifacts: {
        ///         configUrl: {
        ///           url: string, # Optional. File URL.
        ///           fileId: string, # Optional. File unique identifier.
        ///           filename: string, # Optional. Name of the file.
        ///           fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///           expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///           validationStatus: string, # Optional. Validation status of the file
        ///         }, # Optional. FileUrl Model.
        ///         testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///         userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///         inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///         additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///       }, # Optional. The input artifacts for the test.
        ///       secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///       environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///       subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///       keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///       keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///     }
        ///   ], # Required. List of Resources
        ///   nextLink: string, # Optional. Link for the next list of resources in case of paginated results, if applicable
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLoadTestSearchesAsync(string orderBy = null, string search = null, DateTimeOffset? lastUpdatedStartTime = null, DateTimeOffset? lastUpdatedEndTime = null, string continuationToken = null, int? maxPageSize = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("TestClient.GetLoadTestSearches");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLoadTestSearchesRequest(orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all load tests by the fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}. </summary>
        /// <param name="orderBy"> Sort on one of the field - lastModifiedDateTime, displayName, createdBy in (field asc/desc) format. eg: displayName asc. </param>
        /// <param name="search"> Filter search based on searchable fields - testId, createdBy. </param>
        /// <param name="lastUpdatedStartTime"> Start DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="lastUpdatedEndTime"> End DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="maxPageSize"> Number of results in response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLoadTestSearches and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetLoadTestSearches();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetLoadTestSearches with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetLoadTestSearches("<orderBy>", "<search>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, "<continuationToken>", 1234);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("keyvaultReferenceIdentityId").ToString());
        /// Console.WriteLine(result.GetProperty("nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModelResourceList</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       testId: string, # Optional. Unique test name as identifier.
        ///       description: string, # Optional. The test description.
        ///       displayName: string, # Optional. Display name of a test.
        ///       resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///       loadTestConfig: {
        ///         engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///         splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///       }, # Optional. The load test configuration.
        ///       passFailCriteria: {
        ///         passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///       }, # Optional. Pass fail criteria for a test.
        ///       createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///       createdBy: string, # Optional. The user that created the test model.
        ///       lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///       lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///       inputArtifacts: {
        ///         configUrl: {
        ///           url: string, # Optional. File URL.
        ///           fileId: string, # Optional. File unique identifier.
        ///           filename: string, # Optional. Name of the file.
        ///           fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///           expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///           validationStatus: string, # Optional. Validation status of the file
        ///         }, # Optional. FileUrl Model.
        ///         testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///         userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///         inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///         additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///       }, # Optional. The input artifacts for the test.
        ///       secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///       environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///       subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///       keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///       keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///     }
        ///   ], # Required. List of Resources
        ///   nextLink: string, # Optional. Link for the next list of resources in case of paginated results, if applicable
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLoadTestSearches(string orderBy = null, string search = null, DateTimeOffset? lastUpdatedStartTime = null, DateTimeOffset? lastUpdatedEndTime = null, string continuationToken = null, int? maxPageSize = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("TestClient.GetLoadTestSearches");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLoadTestSearchesRequest(orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upload input file for a given test name. File size can&apos;t be more than 50 MB. Existing file with same name for the given test will be overwritten. File should be provided in the request body as multipart/form-data. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="fileType"> Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/>, <paramref name="fileId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UploadTestFileAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = await client.UploadTestFileAsync("<testId>", "<fileId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UploadTestFileAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = await client.UploadTestFileAsync("<testId>", "<fileId>", RequestContent.Create(data), 1234);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: string, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UploadTestFileAsync(string testId, string fileId, RequestContent content, int? fileType = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.UploadTestFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadTestFileRequest(testId, fileId, content, fileType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upload input file for a given test name. File size can&apos;t be more than 50 MB. Existing file with same name for the given test will be overwritten. File should be provided in the request body as multipart/form-data. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="fileType"> Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/>, <paramref name="fileId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UploadTestFile with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = client.UploadTestFile("<testId>", "<fileId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UploadTestFile with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = client.UploadTestFile("<testId>", "<fileId>", RequestContent.Create(data), 1234);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: string, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UploadTestFile(string testId, string fileId, RequestContent content, int? fileType = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.UploadTestFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadTestFileRequest(testId, fileId, content, fileType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test file by the file name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestFileAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetTestFileAsync("<testId>", "<fileId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: string, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTestFileAsync(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetTestFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTestFileRequest(testId, fileId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test file by the file name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestFile with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetTestFile("<testId>", "<fileId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: string, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTestFile(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetTestFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTestFileRequest(testId, fileId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete file by the file name for a test. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTestFileAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.DeleteTestFileAsync("<testId>", "<fileId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteTestFileAsync(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.DeleteTestFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTestFileRequest(testId, fileId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete file by the file name for a test. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTestFile with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.DeleteTestFile("<testId>", "<fileId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteTestFile(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.DeleteTestFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTestFileRequest(testId, fileId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all test files. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetAllTestFilesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetAllTestFilesAsync("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetAllTestFilesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetAllTestFilesAsync("<testId>", "<continuationToken>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrlList</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }
        ///   ], # Required. List of file URLs.
        ///   nextLink: string, # Optional. Link for the next list of file URLs, if applicable
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetAllTestFilesAsync(string testId, string continuationToken = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetAllTestFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllTestFilesRequest(testId, continuationToken, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all test files. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetAllTestFiles with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetAllTestFiles("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetAllTestFiles with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetAllTestFiles("<testId>", "<continuationToken>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrlList</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }
        ///   ], # Required. List of file URLs.
        ///   nextLink: string, # Optional. Link for the next list of file URLs, if applicable
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetAllTestFiles(string testId, string continuationToken = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetAllTestFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllTestFilesRequest(testId, continuationToken, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateOrUpdateTestRequest(string testId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLoadTestRequest(string testId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLoadTestRequest(string testId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLoadTestSearchesRequest(string orderBy, string search, DateTimeOffset? lastUpdatedStartTime, DateTimeOffset? lastUpdatedEndTime, string continuationToken, int? maxPageSize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/sortAndFilter", false);
            if (orderBy != null)
            {
                uri.AppendQuery("orderBy", orderBy, true);
            }
            if (search != null)
            {
                uri.AppendQuery("search", search, true);
            }
            if (lastUpdatedStartTime != null)
            {
                uri.AppendQuery("lastUpdatedStartTime", lastUpdatedStartTime.Value, "O", true);
            }
            if (lastUpdatedEndTime != null)
            {
                uri.AppendQuery("lastUpdatedEndTime", lastUpdatedEndTime.Value, "O", true);
            }
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            if (maxPageSize != null)
            {
                uri.AppendQuery("maxPageSize", maxPageSize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUploadTestFileRequest(string testId, string fileId, RequestContent content, int? fileType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            if (fileType != null)
            {
                uri.AppendQuery("fileType", fileType.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTestFileRequest(string testId, string fileId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteTestFileRequest(string testId, string fileId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllTestFilesRequest(string testId, string continuationToken, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
    }
}
