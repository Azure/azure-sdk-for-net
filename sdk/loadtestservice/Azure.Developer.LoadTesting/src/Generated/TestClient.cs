// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Developer.LoadTesting
{
    // Data plane generated client. The Test service client.
    /// <summary> The Test service client. </summary>
    public partial class TestClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://loadtest.azure-dev.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of TestClient for mocking. </summary>
        protected TestClient()
        {
        }

        /// <summary> Create a new test or Update an existing test. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.CreateOrUpdateAsync("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     description = "<description>",
        ///     displayName = "<displayName>",
        ///     loadTestConfig = new {
        ///         engineInstances = 1234,
        ///         splitAllCSVs = true,
        ///     },
        ///     passFailCriteria = new {
        ///         passFailMetrics = new {
        ///             key = new {
        ///                 clientmetric = "<clientmetric>",
        ///                 aggregate = "<aggregate>",
        ///                 condition = "<condition>",
        ///                 requestName = "<requestName>",
        ///                 value = 123.45d,
        ///                 action = "<action>",
        ///             },
        ///         },
        ///     },
        ///     secrets = new {
        ///         key = new {
        ///             value = "<value>",
        ///             type = "<type>",
        ///         },
        ///     },
        ///     environmentVariables = new {
        ///         key = "<String>",
        ///     },
        ///     subnetId = "<subnetId>",
        ///     keyvaultReferenceIdentityType = "<keyvaultReferenceIdentityType>",
        ///     keyvaultReferenceIdentityId = "<keyvaultReferenceIdentityId>",
        /// };
        /// 
        /// Response response = await client.CreateOrUpdateAsync("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateOrUpdateAsync(string testId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(testId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new test or Update an existing test. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdate with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.CreateOrUpdate("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdate with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = new {
        ///     description = "<description>",
        ///     displayName = "<displayName>",
        ///     loadTestConfig = new {
        ///         engineInstances = 1234,
        ///         splitAllCSVs = true,
        ///     },
        ///     passFailCriteria = new {
        ///         passFailMetrics = new {
        ///             key = new {
        ///                 clientmetric = "<clientmetric>",
        ///                 aggregate = "<aggregate>",
        ///                 condition = "<condition>",
        ///                 requestName = "<requestName>",
        ///                 value = 123.45d,
        ///                 action = "<action>",
        ///             },
        ///         },
        ///     },
        ///     secrets = new {
        ///         key = new {
        ///             value = "<value>",
        ///             type = "<type>",
        ///         },
        ///     },
        ///     environmentVariables = new {
        ///         key = "<String>",
        ///     },
        ///     subnetId = "<subnetId>",
        ///     keyvaultReferenceIdentityType = "<keyvaultReferenceIdentityType>",
        ///     keyvaultReferenceIdentityId = "<keyvaultReferenceIdentityId>",
        /// };
        /// 
        /// Response response = client.CreateOrUpdate("<testId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateOrUpdate(string testId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(testId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a test by its name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.DeleteAsync("<testId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteAsync(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(testId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a test by its name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call Delete with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.Delete("<testId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response Delete(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(testId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get load test details by test name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTestAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetTestAsync("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTestAsync(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTestRequest(testId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get load test details by test name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTest with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetTest("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("keyvaultReferenceIdentityId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModel</c>:
        /// <code>{
        ///   testId: string, # Optional. Unique test name as identifier.
        ///   description: string, # Optional. The test description.
        ///   displayName: string, # Optional. Display name of a test.
        ///   resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///   loadTestConfig: {
        ///     engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///     splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///   }, # Optional. The load test configuration.
        ///   passFailCriteria: {
        ///     passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///   }, # Optional. Pass fail criteria for a test.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///   createdBy: string, # Optional. The user that created the test model.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///   lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///   inputArtifacts: {
        ///     configUrl: {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }, # Optional. FileUrl Model.
        ///     testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///     userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///     inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///     additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///   }, # Optional. The input artifacts for the test.
        ///   secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///   environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///   subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///   keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///   keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTest(string testId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetTest");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTestRequest(testId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all load tests by the fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}. </summary>
        /// <param name="orderBy"> Sort on one of the field - lastModifiedDateTime, displayName, createdBy in (field asc/desc) format. eg: displayName asc. </param>
        /// <param name="search"> Filter search based on searchable fields - testId, createdBy. </param>
        /// <param name="lastUpdatedStartTime"> Start DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="lastUpdatedEndTime"> End DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="maxPageSize"> Number of results in response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call SearchAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.SearchAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// This sample shows how to call SearchAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.SearchAsync("<orderBy>", "<search>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, "<continuationToken>", 1234);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("keyvaultReferenceIdentityId").ToString());
        /// Console.WriteLine(result.GetProperty("nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModelResourceList</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       testId: string, # Optional. Unique test name as identifier.
        ///       description: string, # Optional. The test description.
        ///       displayName: string, # Optional. Display name of a test.
        ///       resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///       loadTestConfig: {
        ///         engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///         splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///       }, # Optional. The load test configuration.
        ///       passFailCriteria: {
        ///         passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///       }, # Optional. Pass fail criteria for a test.
        ///       createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///       createdBy: string, # Optional. The user that created the test model.
        ///       lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///       lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///       inputArtifacts: {
        ///         configUrl: {
        ///           url: string, # Optional. File URL.
        ///           fileId: string, # Optional. File unique identifier.
        ///           filename: string, # Optional. Name of the file.
        ///           fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///           expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///           validationStatus: string, # Optional. Validation status of the file
        ///         }, # Optional. FileUrl Model.
        ///         testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///         userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///         inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///         additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///       }, # Optional. The input artifacts for the test.
        ///       secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///       environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///       subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///       keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///       keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///     }
        ///   ], # Required. List of Resources
        ///   nextLink: string, # Optional. Link for the next list of resources in case of paginated results, if applicable
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> SearchAsync(string orderBy = null, string search = null, DateTimeOffset? lastUpdatedStartTime = null, DateTimeOffset? lastUpdatedEndTime = null, string continuationToken = null, int? maxPageSize = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("TestClient.Search");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSearchRequest(orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all load tests by the fully qualified resource Id e.g subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}. </summary>
        /// <param name="orderBy"> Sort on one of the field - lastModifiedDateTime, displayName, createdBy in (field asc/desc) format. eg: displayName asc. </param>
        /// <param name="search"> Filter search based on searchable fields - testId, createdBy. </param>
        /// <param name="lastUpdatedStartTime"> Start DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="lastUpdatedEndTime"> End DateTime(ISO 8601 literal format) of the last updated time range to filter tests. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="maxPageSize"> Number of results in response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call Search and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.Search();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// This sample shows how to call Search with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.Search("<orderBy>", "<search>", DateTimeOffset.UtcNow, DateTimeOffset.UtcNow, "<continuationToken>", 1234);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("testId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("resourceId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("loadTestConfig").GetProperty("engineInstances").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("loadTestConfig").GetProperty("splitAllCSVs").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("clientmetric").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("aggregate").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("condition").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("requestName").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("action").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("actualValue").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("passFailCriteria").GetProperty("passFailMetrics").GetProperty("<test>").GetProperty("result").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("lastModifiedBy").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("configUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("testScriptUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("userPropUrl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("inputArtifactsZipFileurl").GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("inputArtifacts").GetProperty("additionalUrls")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("secrets").GetProperty("<test>").GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("secrets").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("environmentVariables").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("subnetId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("keyvaultReferenceIdentityType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("keyvaultReferenceIdentityId").ToString());
        /// Console.WriteLine(result.GetProperty("nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TestModelResourceList</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       testId: string, # Optional. Unique test name as identifier.
        ///       description: string, # Optional. The test description.
        ///       displayName: string, # Optional. Display name of a test.
        ///       resourceId: string, # Optional. Fully qualified resource Id e.g /subscriptions/{subId}/resourceGroups/{rg}/providers/Microsoft.LoadTestService/loadtests/{resName}.
        ///       loadTestConfig: {
        ///         engineInstances: number, # Optional. The number of engine instances to execute load test. Supported values are in range of 1-45. Required for creating a new test.
        ///         splitAllCSVs: boolean, # Optional. Whether all the input CSV files should be split evenly across all engines.
        ///       }, # Optional. The load test configuration.
        ///       passFailCriteria: {
        ///         passFailMetrics: Dictionary&lt;string, PassFailMetric&gt;, # Optional. Map of id and pass fail metrics { id  : pass fail metrics }.
        ///       }, # Optional. Pass fail criteria for a test.
        ///       createdDateTime: string (ISO 8601 Format), # Optional. The created DateTime(ISO 8601 literal format) of the test model.
        ///       createdBy: string, # Optional. The user that created the test model.
        ///       lastModifiedDateTime: string (ISO 8601 Format), # Optional. The last Modified DateTime(ISO 8601 literal format) of the test model.
        ///       lastModifiedBy: string, # Optional. The user that last modified the test model.
        ///       inputArtifacts: {
        ///         configUrl: {
        ///           url: string, # Optional. File URL.
        ///           fileId: string, # Optional. File unique identifier.
        ///           filename: string, # Optional. Name of the file.
        ///           fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///           expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///           validationStatus: string, # Optional. Validation status of the file
        ///         }, # Optional. FileUrl Model.
        ///         testScriptUrl: FileUrl, # Optional. FileUrl Model.
        ///         userPropUrl: FileUrl, # Optional. FileUrl Model.
        ///         inputArtifactsZipFileurl: FileUrl, # Optional. FileUrl Model.
        ///         additionalUrls: [FileUrl], # Optional. The input artifacts file { name : url } map for the test run.
        ///       }, # Optional. The input artifacts for the test.
        ///       secrets: Dictionary&lt;string, SecretMetadata&gt;, # Optional. Secrets can be stored in an Azure Key Vault or any other secret store. If the secret is stored in an Azure Key Vault, the value should be the secret identifier and the type should be AKV_SECRET_URI. If the secret is stored elsewhere, the secret value should be provided directly and the type should be SECRET_VALUE.
        ///       environmentVariables: Dictionary&lt;string, string&gt;, # Optional. Environment variables which are defined as a set of &lt;name,value&gt; pairs.
        ///       subnetId: string, # Optional. Subnet ID on which the load test instances should run.
        ///       keyvaultReferenceIdentityType: string, # Optional. Type of the managed identity referencing the Key vault.
        ///       keyvaultReferenceIdentityId: string, # Optional. Resource Id of the managed identity referencing the Key vault.
        ///     }
        ///   ], # Required. List of Resources
        ///   nextLink: string, # Optional. Link for the next list of resources in case of paginated results, if applicable
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Search(string orderBy = null, string search = null, DateTimeOffset? lastUpdatedStartTime = null, DateTimeOffset? lastUpdatedEndTime = null, string continuationToken = null, int? maxPageSize = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("TestClient.Search");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSearchRequest(orderBy, search, lastUpdatedStartTime, lastUpdatedEndTime, continuationToken, maxPageSize, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upload input file for a given test name. File size can&apos;t be more than 50 MB. Existing file with same name for the given test will be overwritten. File should be provided in the request body as multipart/form-data. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="fileType"> Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/>, <paramref name="fileId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UploadFileAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = await client.UploadFileAsync("<testId>", "<fileId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UploadFileAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = await client.UploadFileAsync("<testId>", "<fileId>", RequestContent.Create(data), 1234);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: string, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UploadFileAsync(string testId, string fileId, RequestContent content, int? fileType = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.UploadFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadFileRequest(testId, fileId, content, fileType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upload input file for a given test name. File size can&apos;t be more than 50 MB. Existing file with same name for the given test will be overwritten. File should be provided in the request body as multipart/form-data. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="fileType"> Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/>, <paramref name="fileId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UploadFile with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = client.UploadFile("<testId>", "<fileId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UploadFile with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// var data = File.OpenRead("<filePath>");
        /// 
        /// Response response = client.UploadFile("<testId>", "<fileId>", RequestContent.Create(data), 1234);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: string, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UploadFile(string testId, string fileId, RequestContent content, int? fileType = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TestClient.UploadFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadFileRequest(testId, fileId, content, fileType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test file by the file name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetFileAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetFileAsync("<testId>", "<fileId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: string, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetFileAsync(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFileRequest(testId, fileId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get test file by the file name. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetFile with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetFile("<testId>", "<fileId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("validationStatus").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrl</c>:
        /// <code>{
        ///   url: string, # Optional. File URL.
        ///   fileId: string, # Optional. File unique identifier.
        ///   filename: string, # Optional. Name of the file.
        ///   fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///   expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///   validationStatus: string, # Optional. Validation status of the file
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetFile(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFileRequest(testId, fileId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete file by the file name for a test. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteFileAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.DeleteFileAsync("<testId>", "<fileId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteFileAsync(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.DeleteFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFileRequest(testId, fileId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete file by the file name for a test. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="fileId"> Unique identifier for test file, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteFile with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.DeleteFile("<testId>", "<fileId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteFile(string testId, string fileId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.DeleteFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFileRequest(testId, fileId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all test files. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetAllFilesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetAllFilesAsync("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetAllFilesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = await client.GetAllFilesAsync("<testId>", "<continuationToken>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrlList</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }
        ///   ], # Required. List of file URLs.
        ///   nextLink: string, # Optional. Link for the next list of file URLs, if applicable
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetAllFilesAsync(string testId, string continuationToken = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetAllFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllFilesRequest(testId, continuationToken, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all test files. </summary>
        /// <param name="testId"> Unique name for load test, must be a valid URL character ^[a-z0-9_-]*$. </param>
        /// <param name="continuationToken"> Continuation token to get the next page of response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="testId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="testId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetAllFiles with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetAllFiles("<testId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetAllFiles with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new TestClient("<https://my-service.azure.com>", credential);
        /// 
        /// Response response = client.GetAllFiles("<testId>", "<continuationToken>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileId").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("filename").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("fileType").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("expireTime").ToString());
        /// Console.WriteLine(result.GetProperty("value")[0].GetProperty("validationStatus").ToString());
        /// Console.WriteLine(result.GetProperty("nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>FileUrlList</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       url: string, # Optional. File URL.
        ///       fileId: string, # Optional. File unique identifier.
        ///       filename: string, # Optional. Name of the file.
        ///       fileType: &quot;0&quot; | &quot;1&quot; | &quot;2&quot;, # Optional. Integer representation of the file type (0 = JMX_FILE, 1 = USER_PROPERTIES, 2 = ADDITIONAL_ARTIFACTS)
        ///       expireTime: string (ISO 8601 Format), # Optional. Expiry time of the file
        ///       validationStatus: string, # Optional. Validation status of the file
        ///     }
        ///   ], # Required. List of file URLs.
        ///   nextLink: string, # Optional. Link for the next list of file URLs, if applicable
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetAllFiles(string testId, string continuationToken = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(testId, nameof(testId));

            using var scope = ClientDiagnostics.CreateScope("TestClient.GetAllFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllFilesRequest(testId, continuationToken, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string testId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string testId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTestRequest(string testId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSearchRequest(string orderBy, string search, DateTimeOffset? lastUpdatedStartTime, DateTimeOffset? lastUpdatedEndTime, string continuationToken, int? maxPageSize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/sortAndFilter", false);
            if (orderBy != null)
            {
                uri.AppendQuery("orderBy", orderBy, true);
            }
            if (search != null)
            {
                uri.AppendQuery("search", search, true);
            }
            if (lastUpdatedStartTime != null)
            {
                uri.AppendQuery("lastUpdatedStartTime", lastUpdatedStartTime.Value, "O", true);
            }
            if (lastUpdatedEndTime != null)
            {
                uri.AppendQuery("lastUpdatedEndTime", lastUpdatedEndTime.Value, "O", true);
            }
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            if (maxPageSize != null)
            {
                uri.AppendQuery("maxPageSize", maxPageSize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUploadFileRequest(string testId, string fileId, RequestContent content, int? fileType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            if (fileType != null)
            {
                uri.AppendQuery("fileType", fileType.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetFileRequest(string testId, string fileId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteFileRequest(string testId, string fileId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllFilesRequest(string testId, string continuationToken, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/loadtests/", false);
            uri.AppendPath(testId, true);
            uri.AppendPath("/files", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (continuationToken != null)
            {
                uri.AppendQuery("continuationToken", continuationToken, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
    }
}
