// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.AutonomousDevelopmentPlatform.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.AutonomousDevelopmentPlatform
{
    // Data plane generated client. The DataManagement service client.
    /// <summary> The DataManagement service client. </summary>
    public partial class DataManagementClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://adp.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of DataManagementClient for mocking. </summary>
        protected DataManagementClient()
        {
        }

        /// <summary> Initializes a new instance of DataManagementClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="credential"/> is null. </exception>
        public DataManagementClient(TokenCredential credential) : this(credential, new DataManagementClientOptions())
        {
        }

        /// <summary> Initializes a new instance of DataManagementClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="credential"/> is null. </exception>
        public DataManagementClient(TokenCredential credential, DataManagementClientOptions options)
        {
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new DataManagementClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _apiVersion = options.Version;
        }

        /// <summary>
        /// List special files details for the discovery resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        public virtual AsyncPageable<DiscoverySpecialFile> GetDiscoverySpecialFileUploadLocationValuesAsync(string discoveryId, CancellationToken cancellationToken = default)
        {
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            async Task<Page<DiscoverySpecialFile>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDiscoverySpecialFileUploadLocationValues");
                scope.Start();
                try
                {
                    var response = await GetDiscoverySpecialFileUploadLocationsFirstPageAsync(discoveryId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DiscoverySpecialFile>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDiscoverySpecialFileUploadLocationValues");
                scope.Start();
                try
                {
                    var response = await GetDiscoverySpecialFileUploadLocationsNextPageAsync(nextLink, discoveryId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary>
        /// List special files details for the discovery resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        public virtual Pageable<DiscoverySpecialFile> GetDiscoverySpecialFileUploadLocationValues(string discoveryId, CancellationToken cancellationToken = default)
        {
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            Page<DiscoverySpecialFile> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDiscoverySpecialFileUploadLocationValues");
                scope.Start();
                try
                {
                    var response = GetDiscoverySpecialFileUploadLocationsFirstPage(discoveryId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DiscoverySpecialFile> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDiscoverySpecialFileUploadLocationValues");
                scope.Start();
                try
                {
                    var response = GetDiscoverySpecialFileUploadLocationsNextPage(nextLink, discoveryId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary>
        /// List special files details for the discovery resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        private async Task<Response<PagedDiscoverySpecialFile>> GetDiscoverySpecialFileUploadLocationsFirstPageAsync(string discoveryId, CancellationToken cancellationToken = default)
        {
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDiscoverySpecialFileUploadLocationsRequest(discoveryId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDiscoverySpecialFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the discovery resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        private Response<PagedDiscoverySpecialFile> GetDiscoverySpecialFileUploadLocationsFirstPage(string discoveryId, CancellationToken cancellationToken = default)
        {
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDiscoverySpecialFileUploadLocationsRequest(discoveryId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDiscoverySpecialFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the discovery resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="discoveryId"/> is null. </exception>
        private async Task<Response<PagedDiscoverySpecialFile>> GetDiscoverySpecialFileUploadLocationsNextPageAsync(string nextLink, string discoveryId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDiscoverySpecialFileUploadLocationsNextPageRequest(nextLink, discoveryId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDiscoverySpecialFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the discovery resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="discoveryId"/> is null. </exception>
        private Response<PagedDiscoverySpecialFile> GetDiscoverySpecialFileUploadLocationsNextPage(string nextLink, string discoveryId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDiscoverySpecialFileUploadLocationsNextPageRequest(nextLink, discoveryId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDiscoverySpecialFile.FromResponse(response), response);
        }

        /// <summary> List upload detail for the discovery resource. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        public virtual AsyncPageable<DiscoveryUpload> GetAllDiscoveryUploadValuesAsync(string discoveryId, CancellationToken cancellationToken = default)
        {
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            async Task<Page<DiscoveryUpload>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetAllDiscoveryUploadValues");
                scope.Start();
                try
                {
                    var response = await GetAllDiscoveryUploadsFirstPageAsync(discoveryId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DiscoveryUpload>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetAllDiscoveryUploadValues");
                scope.Start();
                try
                {
                    var response = await GetAllDiscoveryUploadsNextPageAsync(nextLink, discoveryId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List upload detail for the discovery resource. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        public virtual Pageable<DiscoveryUpload> GetAllDiscoveryUploadValues(string discoveryId, CancellationToken cancellationToken = default)
        {
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            Page<DiscoveryUpload> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetAllDiscoveryUploadValues");
                scope.Start();
                try
                {
                    var response = GetAllDiscoveryUploadsFirstPage(discoveryId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DiscoveryUpload> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetAllDiscoveryUploadValues");
                scope.Start();
                try
                {
                    var response = GetAllDiscoveryUploadsNextPage(nextLink, discoveryId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List upload detail for the discovery resource. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        private async Task<Response<PagedDiscoveryUpload>> GetAllDiscoveryUploadsFirstPageAsync(string discoveryId, CancellationToken cancellationToken = default)
        {
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetAllDiscoveryUploadsRequest(discoveryId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDiscoveryUpload.FromResponse(response), response);
        }

        /// <summary> List upload detail for the discovery resource. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        private Response<PagedDiscoveryUpload> GetAllDiscoveryUploadsFirstPage(string discoveryId, CancellationToken cancellationToken = default)
        {
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetAllDiscoveryUploadsRequest(discoveryId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDiscoveryUpload.FromResponse(response), response);
        }

        /// <summary> List upload detail for the discovery resource. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="discoveryId"/> is null. </exception>
        private async Task<Response<PagedDiscoveryUpload>> GetAllDiscoveryUploadsNextPageAsync(string nextLink, string discoveryId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetAllDiscoveryUploadsNextPageRequest(nextLink, discoveryId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDiscoveryUpload.FromResponse(response), response);
        }

        /// <summary> List upload detail for the discovery resource. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="discoveryId"/> is null. </exception>
        private Response<PagedDiscoveryUpload> GetAllDiscoveryUploadsNextPage(string nextLink, string discoveryId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (discoveryId == null)
            {
                throw new ArgumentNullException(nameof(discoveryId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetAllDiscoveryUploadsNextPageRequest(nextLink, discoveryId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDiscoveryUpload.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        public virtual AsyncPageable<UploadSpecialFile> GetUploadSpecialFileValuesAsync(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            async Task<Page<UploadSpecialFile>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadSpecialFileValues");
                scope.Start();
                try
                {
                    var response = await GetUploadSpecialFilesFirstPageAsync(uploadId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<UploadSpecialFile>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadSpecialFileValues");
                scope.Start();
                try
                {
                    var response = await GetUploadSpecialFilesNextPageAsync(nextLink, uploadId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        public virtual Pageable<UploadSpecialFile> GetUploadSpecialFileValues(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            Page<UploadSpecialFile> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadSpecialFileValues");
                scope.Start();
                try
                {
                    var response = GetUploadSpecialFilesFirstPage(uploadId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<UploadSpecialFile> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadSpecialFileValues");
                scope.Start();
                try
                {
                    var response = GetUploadSpecialFilesNextPage(nextLink, uploadId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        private async Task<Response<PagedUploadSpecialFile>> GetUploadSpecialFilesFirstPageAsync(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetUploadSpecialFilesRequest(uploadId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedUploadSpecialFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        private Response<PagedUploadSpecialFile> GetUploadSpecialFilesFirstPage(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetUploadSpecialFilesRequest(uploadId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedUploadSpecialFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="uploadId"/> is null. </exception>
        private async Task<Response<PagedUploadSpecialFile>> GetUploadSpecialFilesNextPageAsync(string nextLink, string uploadId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetUploadSpecialFilesNextPageRequest(nextLink, uploadId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedUploadSpecialFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="uploadId"/> is null. </exception>
        private Response<PagedUploadSpecialFile> GetUploadSpecialFilesNextPage(string nextLink, string uploadId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetUploadSpecialFilesNextPageRequest(nextLink, uploadId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedUploadSpecialFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading data files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        public virtual AsyncPageable<UploadDataFile> GetUploadDataFileValuesAsync(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            async Task<Page<UploadDataFile>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadDataFileValues");
                scope.Start();
                try
                {
                    var response = await GetUploadDataFilesFirstPageAsync(uploadId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<UploadDataFile>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadDataFileValues");
                scope.Start();
                try
                {
                    var response = await GetUploadDataFilesNextPageAsync(nextLink, uploadId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading data files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        public virtual Pageable<UploadDataFile> GetUploadDataFileValues(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            Page<UploadDataFile> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadDataFileValues");
                scope.Start();
                try
                {
                    var response = GetUploadDataFilesFirstPage(uploadId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<UploadDataFile> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadDataFileValues");
                scope.Start();
                try
                {
                    var response = GetUploadDataFilesNextPage(nextLink, uploadId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading data files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        private async Task<Response<PagedUploadDataFile>> GetUploadDataFilesFirstPageAsync(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetUploadDataFilesRequest(uploadId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedUploadDataFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading data files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        private Response<PagedUploadDataFile> GetUploadDataFilesFirstPage(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetUploadDataFilesRequest(uploadId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedUploadDataFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading data files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="uploadId"/> is null. </exception>
        private async Task<Response<PagedUploadDataFile>> GetUploadDataFilesNextPageAsync(string nextLink, string uploadId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetUploadDataFilesNextPageRequest(nextLink, uploadId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedUploadDataFile.FromResponse(response), response);
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading data files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="uploadId"/> is null. </exception>
        private Response<PagedUploadDataFile> GetUploadDataFilesNextPage(string nextLink, string uploadId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetUploadDataFilesNextPageRequest(nextLink, uploadId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedUploadDataFile.FromResponse(response), response);
        }

        /// <summary> List of the measurement identifiers that have been created by the upload. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        public virtual AsyncPageable<UploadResultMeasurement> GetMeasurementValuesAsync(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            async Task<Page<UploadResultMeasurement>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValues");
                scope.Start();
                try
                {
                    var response = await GetMeasurementsFirstPageAsync(uploadId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<UploadResultMeasurement>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValues");
                scope.Start();
                try
                {
                    var response = await GetMeasurementsNextPageAsync(nextLink, uploadId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List of the measurement identifiers that have been created by the upload. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        public virtual Pageable<UploadResultMeasurement> GetMeasurementValues(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            Page<UploadResultMeasurement> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValues");
                scope.Start();
                try
                {
                    var response = GetMeasurementsFirstPage(uploadId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<UploadResultMeasurement> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValues");
                scope.Start();
                try
                {
                    var response = GetMeasurementsNextPage(nextLink, uploadId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List of the measurement identifiers that have been created by the upload. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        private async Task<Response<PagedUploadResultMeasurement>> GetMeasurementsFirstPageAsync(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsRequest(uploadId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedUploadResultMeasurement.FromResponse(response), response);
        }

        /// <summary> List of the measurement identifiers that have been created by the upload. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        private Response<PagedUploadResultMeasurement> GetMeasurementsFirstPage(string uploadId, CancellationToken cancellationToken = default)
        {
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsRequest(uploadId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedUploadResultMeasurement.FromResponse(response), response);
        }

        /// <summary> List of the measurement identifiers that have been created by the upload. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="uploadId"/> is null. </exception>
        private async Task<Response<PagedUploadResultMeasurement>> GetMeasurementsNextPageAsync(string nextLink, string uploadId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsNextPageRequest(nextLink, uploadId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedUploadResultMeasurement.FromResponse(response), response);
        }

        /// <summary> List of the measurement identifiers that have been created by the upload. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="uploadId"/> is null. </exception>
        private Response<PagedUploadResultMeasurement> GetMeasurementsNextPage(string nextLink, string uploadId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (uploadId == null)
            {
                throw new ArgumentNullException(nameof(uploadId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsNextPageRequest(nextLink, uploadId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedUploadResultMeasurement.FromResponse(response), response);
        }

        /// <summary> List all classification schemas. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<ClassificationSchema> GetClassificationSchemaValuesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ClassificationSchema>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetClassificationSchemaValues");
                scope.Start();
                try
                {
                    var response = await GetClassificationSchemasFirstPageAsync(cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ClassificationSchema>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetClassificationSchemaValues");
                scope.Start();
                try
                {
                    var response = await GetClassificationSchemasNextPageAsync(nextLink, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List all classification schemas. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<ClassificationSchema> GetClassificationSchemaValues(CancellationToken cancellationToken = default)
        {
            Page<ClassificationSchema> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetClassificationSchemaValues");
                scope.Start();
                try
                {
                    var response = GetClassificationSchemasFirstPage(cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ClassificationSchema> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetClassificationSchemaValues");
                scope.Start();
                try
                {
                    var response = GetClassificationSchemasNextPage(nextLink, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List all classification schemas. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        private async Task<Response<PagedClassificationSchema>> GetClassificationSchemasFirstPageAsync(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetClassificationSchemasRequest(context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedClassificationSchema.FromResponse(response), response);
        }

        /// <summary> List all classification schemas. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        private Response<PagedClassificationSchema> GetClassificationSchemasFirstPage(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetClassificationSchemasRequest(context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedClassificationSchema.FromResponse(response), response);
        }

        /// <summary> List all classification schemas. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        private async Task<Response<PagedClassificationSchema>> GetClassificationSchemasNextPageAsync(string nextLink, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetClassificationSchemasNextPageRequest(nextLink, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedClassificationSchema.FromResponse(response), response);
        }

        /// <summary> List all classification schemas. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        private Response<PagedClassificationSchema> GetClassificationSchemasNextPage(string nextLink, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetClassificationSchemasNextPageRequest(nextLink, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedClassificationSchema.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<Measurement> GetMeasurementValuesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<Measurement>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValues");
                scope.Start();
                try
                {
                    var response = await GetMeasurementsFirstPageAsync(cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<Measurement>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValues");
                scope.Start();
                try
                {
                    var response = await GetMeasurementsNextPageAsync(nextLink, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the measurements in a workspace. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<Measurement> GetMeasurementValues(CancellationToken cancellationToken = default)
        {
            Page<Measurement> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValues");
                scope.Start();
                try
                {
                    var response = GetMeasurementsFirstPage(cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<Measurement> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValues");
                scope.Start();
                try
                {
                    var response = GetMeasurementsNextPage(nextLink, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the measurements in a workspace. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        private async Task<Response<PagedMeasurement>> GetMeasurementsFirstPageAsync(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsRequest(context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedMeasurement.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        private Response<PagedMeasurement> GetMeasurementsFirstPage(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsRequest(context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedMeasurement.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        private async Task<Response<PagedMeasurement>> GetMeasurementsNextPageAsync(string nextLink, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsNextPageRequest(nextLink, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedMeasurement.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        private Response<PagedMeasurement> GetMeasurementsNextPage(string nextLink, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsNextPageRequest(nextLink, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedMeasurement.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace with extended metadata. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<MeasurementWithMetadata> GetMeasurementsWithMetadataValueAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<MeasurementWithMetadata>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementsWithMetadataValue");
                scope.Start();
                try
                {
                    var response = await GetMeasurementsWithMetadataFirstPageAsync(cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<MeasurementWithMetadata>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementsWithMetadataValue");
                scope.Start();
                try
                {
                    var response = await GetMeasurementsWithMetadataNextPageAsync(nextLink, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the measurements in a workspace with extended metadata. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<MeasurementWithMetadata> GetMeasurementsWithMetadataValue(CancellationToken cancellationToken = default)
        {
            Page<MeasurementWithMetadata> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementsWithMetadataValue");
                scope.Start();
                try
                {
                    var response = GetMeasurementsWithMetadataFirstPage(cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<MeasurementWithMetadata> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementsWithMetadataValue");
                scope.Start();
                try
                {
                    var response = GetMeasurementsWithMetadataNextPage(nextLink, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the measurements in a workspace with extended metadata. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        private async Task<Response<PagedMeasurementWithMetadata>> GetMeasurementsWithMetadataFirstPageAsync(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsWithMetadataRequest(context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedMeasurementWithMetadata.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace with extended metadata. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        private Response<PagedMeasurementWithMetadata> GetMeasurementsWithMetadataFirstPage(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsWithMetadataRequest(context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedMeasurementWithMetadata.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace with extended metadata. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        private async Task<Response<PagedMeasurementWithMetadata>> GetMeasurementsWithMetadataNextPageAsync(string nextLink, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsWithMetadataNextPageRequest(nextLink, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedMeasurementWithMetadata.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace with extended metadata. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        private Response<PagedMeasurementWithMetadata> GetMeasurementsWithMetadataNextPage(string nextLink, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsWithMetadataNextPageRequest(nextLink, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedMeasurementWithMetadata.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace that are in the given measurement IDs list. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<Measurement> GetMeasurementsByIdsAsync(RequestContent content, CancellationToken cancellationToken = default)
        {
            async Task<Page<Measurement>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementsByIds");
                scope.Start();
                try
                {
                    var response = await GetMeasurementsByIdsFirstPageAsync(content, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<Measurement>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementsByIds");
                scope.Start();
                try
                {
                    var response = await GetMeasurementsByIdsNextPageAsync(nextLink, content, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the measurements in a workspace that are in the given measurement IDs list. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<Measurement> GetMeasurementsByIds(RequestContent content, CancellationToken cancellationToken = default)
        {
            Page<Measurement> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementsByIds");
                scope.Start();
                try
                {
                    var response = GetMeasurementsByIdsFirstPage(content, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<Measurement> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementsByIds");
                scope.Start();
                try
                {
                    var response = GetMeasurementsByIdsNextPage(nextLink, content, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the measurements in a workspace that are in the given measurement IDs list. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        private async Task<Response<PagedMeasurement>> GetMeasurementsByIdsFirstPageAsync(RequestContent content, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsByIdsRequest(content, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedMeasurement.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace that are in the given measurement IDs list. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        private Response<PagedMeasurement> GetMeasurementsByIdsFirstPage(RequestContent content, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsByIdsRequest(content, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedMeasurement.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace that are in the given measurement IDs list. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        private async Task<Response<PagedMeasurement>> GetMeasurementsByIdsNextPageAsync(string nextLink, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsByIdsNextPageRequest(nextLink, content, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedMeasurement.FromResponse(response), response);
        }

        /// <summary> Lists the measurements in a workspace that are in the given measurement IDs list. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        private Response<PagedMeasurement> GetMeasurementsByIdsNextPage(string nextLink, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementsByIdsNextPageRequest(nextLink, content, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedMeasurement.FromResponse(response), response);
        }

        /// <summary> List state machines instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual AsyncPageable<StateMachine> GetMeasurementStateMachineValuesAsync(string measurementId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            async Task<Page<StateMachine>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementStateMachineValues");
                scope.Start();
                try
                {
                    var response = await GetMeasurementStateMachinesFirstPageAsync(measurementId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<StateMachine>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementStateMachineValues");
                scope.Start();
                try
                {
                    var response = await GetMeasurementStateMachinesNextPageAsync(nextLink, measurementId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List state machines instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual Pageable<StateMachine> GetMeasurementStateMachineValues(string measurementId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            Page<StateMachine> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementStateMachineValues");
                scope.Start();
                try
                {
                    var response = GetMeasurementStateMachinesFirstPage(measurementId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<StateMachine> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementStateMachineValues");
                scope.Start();
                try
                {
                    var response = GetMeasurementStateMachinesNextPage(nextLink, measurementId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List state machines instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedStateMachine>> GetMeasurementStateMachinesFirstPageAsync(string measurementId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementStateMachinesRequest(measurementId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedStateMachine.FromResponse(response), response);
        }

        /// <summary> List state machines instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private Response<PagedStateMachine> GetMeasurementStateMachinesFirstPage(string measurementId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementStateMachinesRequest(measurementId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedStateMachine.FromResponse(response), response);
        }

        /// <summary> List state machines instance for the measurement. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedStateMachine>> GetMeasurementStateMachinesNextPageAsync(string nextLink, string measurementId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementStateMachinesNextPageRequest(nextLink, measurementId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedStateMachine.FromResponse(response), response);
        }

        /// <summary> List state machines instance for the measurement. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private Response<PagedStateMachine> GetMeasurementStateMachinesNextPage(string nextLink, string measurementId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementStateMachinesNextPageRequest(nextLink, measurementId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedStateMachine.FromResponse(response), response);
        }

        /// <summary> Lists the classifications assigned to the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual AsyncPageable<MeasurementClassification> GetMeasurementClassificationValuesAsync(string measurementId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            async Task<Page<MeasurementClassification>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementClassificationValues");
                scope.Start();
                try
                {
                    var response = await GetMeasurementClassificationsFirstPageAsync(measurementId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<MeasurementClassification>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementClassificationValues");
                scope.Start();
                try
                {
                    var response = await GetMeasurementClassificationsNextPageAsync(nextLink, measurementId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the classifications assigned to the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual Pageable<MeasurementClassification> GetMeasurementClassificationValues(string measurementId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            Page<MeasurementClassification> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementClassificationValues");
                scope.Start();
                try
                {
                    var response = GetMeasurementClassificationsFirstPage(measurementId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<MeasurementClassification> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementClassificationValues");
                scope.Start();
                try
                {
                    var response = GetMeasurementClassificationsNextPage(nextLink, measurementId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the classifications assigned to the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedMeasurementClassification>> GetMeasurementClassificationsFirstPageAsync(string measurementId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementClassificationsRequest(measurementId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedMeasurementClassification.FromResponse(response), response);
        }

        /// <summary> Lists the classifications assigned to the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private Response<PagedMeasurementClassification> GetMeasurementClassificationsFirstPage(string measurementId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementClassificationsRequest(measurementId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedMeasurementClassification.FromResponse(response), response);
        }

        /// <summary> Lists the classifications assigned to the measurement. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedMeasurementClassification>> GetMeasurementClassificationsNextPageAsync(string nextLink, string measurementId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementClassificationsNextPageRequest(nextLink, measurementId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedMeasurementClassification.FromResponse(response), response);
        }

        /// <summary> Lists the classifications assigned to the measurement. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private Response<PagedMeasurementClassification> GetMeasurementClassificationsNextPage(string nextLink, string measurementId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetMeasurementClassificationsNextPageRequest(nextLink, measurementId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedMeasurementClassification.FromResponse(response), response);
        }

        /// <summary>
        /// Lists the existing data-streams.
        /// Supports the following filter expressions:
        /// - filter=&quot;type=[System | Raw | Derived]&quot;
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="filter"> Filter the result list using the given expression. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual AsyncPageable<DataStream> GetAllDataStreamValueAsync(string measurementId, string filter = null, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            async Task<Page<DataStream>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetAllDataStreamValue");
                scope.Start();
                try
                {
                    var response = await GetAllDataStreamFirstPageAsync(measurementId, filter, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DataStream>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetAllDataStreamValue");
                scope.Start();
                try
                {
                    var response = await GetAllDataStreamNextPageAsync(nextLink, measurementId, filter, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary>
        /// Lists the existing data-streams.
        /// Supports the following filter expressions:
        /// - filter=&quot;type=[System | Raw | Derived]&quot;
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="filter"> Filter the result list using the given expression. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual Pageable<DataStream> GetAllDataStreamValue(string measurementId, string filter = null, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            Page<DataStream> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetAllDataStreamValue");
                scope.Start();
                try
                {
                    var response = GetAllDataStreamFirstPage(measurementId, filter, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DataStream> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetAllDataStreamValue");
                scope.Start();
                try
                {
                    var response = GetAllDataStreamNextPage(nextLink, measurementId, filter, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary>
        /// Lists the existing data-streams.
        /// Supports the following filter expressions:
        /// - filter=&quot;type=[System | Raw | Derived]&quot;
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="filter"> Filter the result list using the given expression. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedDataStream>> GetAllDataStreamFirstPageAsync(string measurementId, string filter = null, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetAllDataStreamRequest(measurementId, filter, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary>
        /// Lists the existing data-streams.
        /// Supports the following filter expressions:
        /// - filter=&quot;type=[System | Raw | Derived]&quot;
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="filter"> Filter the result list using the given expression. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private Response<PagedDataStream> GetAllDataStreamFirstPage(string measurementId, string filter = null, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetAllDataStreamRequest(measurementId, filter, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary>
        /// Lists the existing data-streams.
        /// Supports the following filter expressions:
        /// - filter=&quot;type=[System | Raw | Derived]&quot;
        /// </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="filter"> Filter the result list using the given expression. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedDataStream>> GetAllDataStreamNextPageAsync(string nextLink, string measurementId, string filter = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetAllDataStreamNextPageRequest(nextLink, measurementId, filter, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary>
        /// Lists the existing data-streams.
        /// Supports the following filter expressions:
        /// - filter=&quot;type=[System | Raw | Derived]&quot;
        /// </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="filter"> Filter the result list using the given expression. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private Response<PagedDataStream> GetAllDataStreamNextPage(string nextLink, string measurementId, string filter = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetAllDataStreamNextPageRequest(nextLink, measurementId, filter, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual AsyncPageable<DataStream> GetDataStreamsByTagsAsync(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            async Task<Page<DataStream>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamsByTags");
                scope.Start();
                try
                {
                    var response = await GetDataStreamsByTagsFirstPageAsync(measurementId, content, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DataStream>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamsByTags");
                scope.Start();
                try
                {
                    var response = await GetDataStreamsByTagsNextPageAsync(nextLink, measurementId, content, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the data-streams by tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual Pageable<DataStream> GetDataStreamsByTags(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            Page<DataStream> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamsByTags");
                scope.Start();
                try
                {
                    var response = GetDataStreamsByTagsFirstPage(measurementId, content, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DataStream> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamsByTags");
                scope.Start();
                try
                {
                    var response = GetDataStreamsByTagsNextPage(nextLink, measurementId, content, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the data-streams by tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedDataStream>> GetDataStreamsByTagsFirstPageAsync(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamsByTagsRequest(measurementId, content, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private Response<PagedDataStream> GetDataStreamsByTagsFirstPage(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamsByTagsRequest(measurementId, content, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by tags. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedDataStream>> GetDataStreamsByTagsNextPageAsync(string nextLink, string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamsByTagsNextPageRequest(nextLink, measurementId, content, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by tags. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private Response<PagedDataStream> GetDataStreamsByTagsNextPage(string nextLink, string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamsByTagsNextPageRequest(nextLink, measurementId, content, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by lineage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual AsyncPageable<DataStream> GetDataStreamsByLineageAsync(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            async Task<Page<DataStream>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamsByLineage");
                scope.Start();
                try
                {
                    var response = await GetDataStreamsByLineageFirstPageAsync(measurementId, content, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DataStream>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamsByLineage");
                scope.Start();
                try
                {
                    var response = await GetDataStreamsByLineageNextPageAsync(nextLink, measurementId, content, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the data-streams by lineage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual Pageable<DataStream> GetDataStreamsByLineage(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            Page<DataStream> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamsByLineage");
                scope.Start();
                try
                {
                    var response = GetDataStreamsByLineageFirstPage(measurementId, content, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DataStream> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamsByLineage");
                scope.Start();
                try
                {
                    var response = GetDataStreamsByLineageNextPage(nextLink, measurementId, content, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the data-streams by lineage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedDataStream>> GetDataStreamsByLineageFirstPageAsync(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamsByLineageRequest(measurementId, content, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by lineage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private Response<PagedDataStream> GetDataStreamsByLineageFirstPage(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamsByLineageRequest(measurementId, content, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by lineage. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedDataStream>> GetDataStreamsByLineageNextPageAsync(string nextLink, string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamsByLineageNextPageRequest(nextLink, measurementId, content, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by lineage. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private Response<PagedDataStream> GetDataStreamsByLineageNextPage(string nextLink, string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamsByLineageNextPageRequest(nextLink, measurementId, content, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStream.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by lineage graph. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual AsyncPageable<DataStreamsGraphListResponse> GetDataStreamLineageGraphsByLineageAsync(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            async Task<Page<DataStreamsGraphListResponse>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamLineageGraphsByLineage");
                scope.Start();
                try
                {
                    var response = await GetDataStreamLineageGraphsByLineageFirstPageAsync(measurementId, content, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DataStreamsGraphListResponse>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamLineageGraphsByLineage");
                scope.Start();
                try
                {
                    var response = await GetDataStreamLineageGraphsByLineageNextPageAsync(nextLink, measurementId, content, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the data-streams by lineage graph. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        public virtual Pageable<DataStreamsGraphListResponse> GetDataStreamLineageGraphsByLineage(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            Page<DataStreamsGraphListResponse> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamLineageGraphsByLineage");
                scope.Start();
                try
                {
                    var response = GetDataStreamLineageGraphsByLineageFirstPage(measurementId, content, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DataStreamsGraphListResponse> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamLineageGraphsByLineage");
                scope.Start();
                try
                {
                    var response = GetDataStreamLineageGraphsByLineageNextPage(nextLink, measurementId, content, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists the data-streams by lineage graph. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedDataStreamsGraphListResponse>> GetDataStreamLineageGraphsByLineageFirstPageAsync(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamLineageGraphsByLineageRequest(measurementId, content, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStreamsGraphListResponse.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by lineage graph. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        private Response<PagedDataStreamsGraphListResponse> GetDataStreamLineageGraphsByLineageFirstPage(string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamLineageGraphsByLineageRequest(measurementId, content, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStreamsGraphListResponse.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by lineage graph. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private async Task<Response<PagedDataStreamsGraphListResponse>> GetDataStreamLineageGraphsByLineageNextPageAsync(string nextLink, string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamLineageGraphsByLineageNextPageRequest(nextLink, measurementId, content, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStreamsGraphListResponse.FromResponse(response), response);
        }

        /// <summary> Lists the data-streams by lineage graph. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="measurementId"/> is null. </exception>
        private Response<PagedDataStreamsGraphListResponse> GetDataStreamLineageGraphsByLineageNextPage(string nextLink, string measurementId, RequestContent content, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamLineageGraphsByLineageNextPageRequest(nextLink, measurementId, content, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStreamsGraphListResponse.FromResponse(response), response);
        }

        /// <summary> Returns SAS signed URIs for reading special files from Azure Storage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        public virtual AsyncPageable<DataStreamFile> GetDataStreamFileValuesAsync(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }
            if (dataStreamId == null)
            {
                throw new ArgumentNullException(nameof(dataStreamId));
            }

            async Task<Page<DataStreamFile>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamFileValues");
                scope.Start();
                try
                {
                    var response = await GetDataStreamFilesFirstPageAsync(measurementId, dataStreamId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DataStreamFile>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamFileValues");
                scope.Start();
                try
                {
                    var response = await GetDataStreamFilesNextPageAsync(nextLink, measurementId, dataStreamId, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Returns SAS signed URIs for reading special files from Azure Storage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        public virtual Pageable<DataStreamFile> GetDataStreamFileValues(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }
            if (dataStreamId == null)
            {
                throw new ArgumentNullException(nameof(dataStreamId));
            }

            Page<DataStreamFile> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamFileValues");
                scope.Start();
                try
                {
                    var response = GetDataStreamFilesFirstPage(measurementId, dataStreamId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DataStreamFile> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamFileValues");
                scope.Start();
                try
                {
                    var response = GetDataStreamFilesNextPage(nextLink, measurementId, dataStreamId, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Returns SAS signed URIs for reading special files from Azure Storage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        private async Task<Response<PagedDataStreamFile>> GetDataStreamFilesFirstPageAsync(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }
            if (dataStreamId == null)
            {
                throw new ArgumentNullException(nameof(dataStreamId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamFilesRequest(measurementId, dataStreamId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStreamFile.FromResponse(response), response);
        }

        /// <summary> Returns SAS signed URIs for reading special files from Azure Storage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        private Response<PagedDataStreamFile> GetDataStreamFilesFirstPage(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }
            if (dataStreamId == null)
            {
                throw new ArgumentNullException(nameof(dataStreamId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamFilesRequest(measurementId, dataStreamId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStreamFile.FromResponse(response), response);
        }

        /// <summary> Returns SAS signed URIs for reading special files from Azure Storage. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        private async Task<Response<PagedDataStreamFile>> GetDataStreamFilesNextPageAsync(string nextLink, string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }
            if (dataStreamId == null)
            {
                throw new ArgumentNullException(nameof(dataStreamId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamFilesNextPageRequest(nextLink, measurementId, dataStreamId, context);
            Response response = await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            return Response.FromValue(PagedDataStreamFile.FromResponse(response), response);
        }

        /// <summary> Returns SAS signed URIs for reading special files from Azure Storage. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        private Response<PagedDataStreamFile> GetDataStreamFilesNextPage(string nextLink, string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (measurementId == null)
            {
                throw new ArgumentNullException(nameof(measurementId));
            }
            if (dataStreamId == null)
            {
                throw new ArgumentNullException(nameof(dataStreamId));
            }

            RequestContext context = FromCancellationToken(cancellationToken);
            using var message = CreateGetDataStreamFilesNextPageRequest(nextLink, measurementId, dataStreamId, context);
            Response response = _pipeline.ProcessMessage(message, context);
            return Response.FromValue(PagedDataStreamFile.FromResponse(response), response);
        }

        /// <summary> Get the details of an LRO. </summary>
        /// <param name="operationId"> The unique ID of the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<LongRunningOperationWithResponseHeaders>> GetLongRunningValueAsync(string operationId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetLongRunningValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetLongRunningAsync(operationId, context).ConfigureAwait(false);
                return Response.FromValue(LongRunningOperationWithResponseHeaders.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the details of an LRO. </summary>
        /// <param name="operationId"> The unique ID of the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<LongRunningOperationWithResponseHeaders> GetLongRunningValue(string operationId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetLongRunningValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetLongRunning(operationId, context);
                return Response.FromValue(LongRunningOperationWithResponseHeaders.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the details of an LRO. </summary>
        /// <param name="operationId"> The unique ID of the operation. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetLongRunningAsync(String,RequestContext)']/*" />
        public virtual async Task<Response> GetLongRunningAsync(string operationId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetLongRunning");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLongRunningRequest(operationId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the details of an LRO. </summary>
        /// <param name="operationId"> The unique ID of the operation. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetLongRunning(String,RequestContext)']/*" />
        public virtual Response GetLongRunning(string operationId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetLongRunning");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLongRunningRequest(operationId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new ingestion discovery instance. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="body"> Parameter of type &apos;DiscoveryCreationParameters&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<Discovery>> CreateOrReplaceDiscoveryAsync(string discoveryId, DiscoveryCreationParameters body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateOrReplaceDiscoveryAsync(discoveryId, body?.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(Discovery.FromResponse(response), response);
        }

        /// <summary> Creates a new ingestion discovery instance. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="body"> Parameter of type &apos;DiscoveryCreationParameters&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<Discovery> CreateOrReplaceDiscovery(string discoveryId, DiscoveryCreationParameters body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateOrReplaceDiscovery(discoveryId, body?.ToRequestContent(), context);
            return Response.FromValue(Discovery.FromResponse(response), response);
        }

        /// <summary> Creates a new ingestion discovery instance. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateOrReplaceDiscoveryAsync(String,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateOrReplaceDiscoveryAsync(string discoveryId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateOrReplaceDiscovery");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceDiscoveryRequest(discoveryId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new ingestion discovery instance. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateOrReplaceDiscovery(String,RequestContent,RequestContext)']/*" />
        public virtual Response CreateOrReplaceDiscovery(string discoveryId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateOrReplaceDiscovery");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceDiscoveryRequest(discoveryId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get discovery by ID. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<Discovery>> GetDiscoveryValueAsync(string discoveryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDiscoveryValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetDiscoveryAsync(discoveryId, context).ConfigureAwait(false);
                return Response.FromValue(Discovery.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get discovery by ID. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<Discovery> GetDiscoveryValue(string discoveryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDiscoveryValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetDiscovery(discoveryId, context);
                return Response.FromValue(Discovery.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get discovery by ID. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDiscoveryAsync(String,RequestContext)']/*" />
        public virtual async Task<Response> GetDiscoveryAsync(string discoveryId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDiscovery");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDiscoveryRequest(discoveryId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get discovery by ID. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDiscovery(String,RequestContext)']/*" />
        public virtual Response GetDiscovery(string discoveryId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDiscovery");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDiscoveryRequest(discoveryId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new ingestion upload instance. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="body"> Parameter of type &apos;UploadCreationParameters&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<Upload>> CreateOrReplaceUploadAsync(string uploadId, UploadCreationParameters body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateOrReplaceUploadAsync(uploadId, body?.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(Upload.FromResponse(response), response);
        }

        /// <summary> Creates a new ingestion upload instance. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="body"> Parameter of type &apos;UploadCreationParameters&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<Upload> CreateOrReplaceUpload(string uploadId, UploadCreationParameters body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateOrReplaceUpload(uploadId, body?.ToRequestContent(), context);
            return Response.FromValue(Upload.FromResponse(response), response);
        }

        /// <summary> Creates a new ingestion upload instance. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateOrReplaceUploadAsync(String,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateOrReplaceUploadAsync(string uploadId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateOrReplaceUpload");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceUploadRequest(uploadId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new ingestion upload instance. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateOrReplaceUpload(String,RequestContent,RequestContext)']/*" />
        public virtual Response CreateOrReplaceUpload(string uploadId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateOrReplaceUpload");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceUploadRequest(uploadId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get discovery by ID. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<Upload>> GetUploadValueAsync(string uploadId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetUploadAsync(uploadId, context).ConfigureAwait(false);
                return Response.FromValue(Upload.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get discovery by ID. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<Upload> GetUploadValue(string uploadId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUploadValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetUpload(uploadId, context);
                return Response.FromValue(Upload.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get discovery by ID. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetUploadAsync(String,RequestContext)']/*" />
        public virtual async Task<Response> GetUploadAsync(string uploadId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUpload");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUploadRequest(uploadId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get discovery by ID. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetUpload(String,RequestContext)']/*" />
        public virtual Response GetUpload(string uploadId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetUpload");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUploadRequest(uploadId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get classification schema by name. </summary>
        /// <param name="name"> Classification schema identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<ClassificationSchema>> GetClassificationSchemaValueAsync(string name, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetClassificationSchemaValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetClassificationSchemaAsync(name, context).ConfigureAwait(false);
                return Response.FromValue(ClassificationSchema.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get classification schema by name. </summary>
        /// <param name="name"> Classification schema identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<ClassificationSchema> GetClassificationSchemaValue(string name, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetClassificationSchemaValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetClassificationSchema(name, context);
                return Response.FromValue(ClassificationSchema.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get classification schema by name. </summary>
        /// <param name="name"> Classification schema identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetClassificationSchemaAsync(String,RequestContext)']/*" />
        public virtual async Task<Response> GetClassificationSchemaAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetClassificationSchema");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationSchemaRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get classification schema by name. </summary>
        /// <param name="name"> Classification schema identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetClassificationSchema(String,RequestContext)']/*" />
        public virtual Response GetClassificationSchema(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetClassificationSchema");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationSchemaRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get measurement by ID. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<Measurement>> GetMeasurementValueAsync(string measurementId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetMeasurementAsync(measurementId, context).ConfigureAwait(false);
                return Response.FromValue(Measurement.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get measurement by ID. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<Measurement> GetMeasurementValue(string measurementId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetMeasurement(measurementId, context);
                return Response.FromValue(Measurement.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get measurement by ID. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementAsync(String,RequestContext)']/*" />
        public virtual async Task<Response> GetMeasurementAsync(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurement");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementRequest(measurementId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get measurement by ID. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurement(String,RequestContext)']/*" />
        public virtual Response GetMeasurement(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurement");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementRequest(measurementId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement metadata. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<MeasurementMetadataBase>> GetMeasurementMetadataValueAsync(string measurementId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementMetadataValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetMeasurementMetadataAsync(measurementId, context).ConfigureAwait(false);
                return Response.FromValue(MeasurementMetadataBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement metadata. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<MeasurementMetadataBase> GetMeasurementMetadataValue(string measurementId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementMetadataValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetMeasurementMetadata(measurementId, context);
                return Response.FromValue(MeasurementMetadataBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement metadata. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementMetadataAsync(String,RequestContext)']/*" />
        public virtual async Task<Response> GetMeasurementMetadataAsync(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementMetadataRequest(measurementId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement metadata. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementMetadata(String,RequestContext)']/*" />
        public virtual Response GetMeasurementMetadata(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementMetadataRequest(measurementId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement processing result. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<MeasurementProcessingResultsBase>> GetMeasurementProcessingResultValuesAsync(string measurementId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementProcessingResultValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetMeasurementProcessingResultsAsync(measurementId, context).ConfigureAwait(false);
                return Response.FromValue(MeasurementProcessingResultsBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement processing result. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<MeasurementProcessingResultsBase> GetMeasurementProcessingResultValues(string measurementId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementProcessingResultValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetMeasurementProcessingResults(measurementId, context);
                return Response.FromValue(MeasurementProcessingResultsBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement processing result. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementProcessingResultsAsync(String,RequestContext)']/*" />
        public virtual async Task<Response> GetMeasurementProcessingResultsAsync(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementProcessingResults");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementProcessingResultsRequest(measurementId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement processing result. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementProcessingResults(String,RequestContext)']/*" />
        public virtual Response GetMeasurementProcessingResults(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementProcessingResults");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementProcessingResultsRequest(measurementId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the state machine instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="id"> The state machine identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="id"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="id"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<StateMachine>> GetMeasurementStateMachineValueAsync(string measurementId, string id, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(id, nameof(id));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementStateMachineValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetMeasurementStateMachineAsync(measurementId, id, context).ConfigureAwait(false);
                return Response.FromValue(StateMachine.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the state machine instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="id"> The state machine identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="id"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="id"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<StateMachine> GetMeasurementStateMachineValue(string measurementId, string id, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(id, nameof(id));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementStateMachineValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetMeasurementStateMachine(measurementId, id, context);
                return Response.FromValue(StateMachine.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the state machine instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="id"> The state machine identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="id"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="id"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementStateMachineAsync(String,String,RequestContext)']/*" />
        public virtual async Task<Response> GetMeasurementStateMachineAsync(string measurementId, string id, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(id, nameof(id));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementStateMachine");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementStateMachineRequest(measurementId, id, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the state machine instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="id"> The state machine identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="id"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="id"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementStateMachine(String,String,RequestContext)']/*" />
        public virtual Response GetMeasurementStateMachine(string measurementId, string id, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(id, nameof(id));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementStateMachine");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementStateMachineRequest(measurementId, id, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement metadata schema file information. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<MeasurementMetadataSchemaFileInfoBase>> GetMeasurementMetadataSchemaFileInfoValueAsync(string measurementId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementMetadataSchemaFileInfoValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetMeasurementMetadataSchemaFileInfoAsync(measurementId, context).ConfigureAwait(false);
                return Response.FromValue(MeasurementMetadataSchemaFileInfoBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement metadata schema file information. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<MeasurementMetadataSchemaFileInfoBase> GetMeasurementMetadataSchemaFileInfoValue(string measurementId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementMetadataSchemaFileInfoValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetMeasurementMetadataSchemaFileInfo(measurementId, context);
                return Response.FromValue(MeasurementMetadataSchemaFileInfoBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement metadata schema file information. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementMetadataSchemaFileInfoAsync(String,RequestContext)']/*" />
        public virtual async Task<Response> GetMeasurementMetadataSchemaFileInfoAsync(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementMetadataSchemaFileInfo");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementMetadataSchemaFileInfoRequest(measurementId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the measurement metadata schema file information. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementMetadataSchemaFileInfo(String,RequestContext)']/*" />
        public virtual Response GetMeasurementMetadataSchemaFileInfo(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementMetadataSchemaFileInfo");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementMetadataSchemaFileInfoRequest(measurementId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get measurement classification by schema name. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="schemaName"> Classification schema name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<MeasurementClassification>> GetMeasurementClassificationValueAsync(string measurementId, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementClassificationValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetMeasurementClassificationAsync(measurementId, schemaName, context).ConfigureAwait(false);
                return Response.FromValue(MeasurementClassification.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get measurement classification by schema name. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="schemaName"> Classification schema name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<MeasurementClassification> GetMeasurementClassificationValue(string measurementId, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementClassificationValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetMeasurementClassification(measurementId, schemaName, context);
                return Response.FromValue(MeasurementClassification.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get measurement classification by schema name. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="schemaName"> Classification schema name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementClassificationAsync(String,String,RequestContext)']/*" />
        public virtual async Task<Response> GetMeasurementClassificationAsync(string measurementId, string schemaName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementClassificationRequest(measurementId, schemaName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get measurement classification by schema name. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="schemaName"> Classification schema name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementClassification(String,String,RequestContext)']/*" />
        public virtual Response GetMeasurementClassification(string measurementId, string schemaName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetMeasurementClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMeasurementClassificationRequest(measurementId, schemaName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get data-stream by identifier. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<DataStream>> GetDataStreamValueAsync(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetDataStreamAsync(measurementId, dataStreamId, context).ConfigureAwait(false);
                return Response.FromValue(DataStream.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get data-stream by identifier. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<DataStream> GetDataStreamValue(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetDataStream(measurementId, dataStreamId, context);
                return Response.FromValue(DataStream.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get data-stream by identifier. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamAsync(String,String,RequestContext)']/*" />
        public virtual async Task<Response> GetDataStreamAsync(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDataStreamRequest(measurementId, dataStreamId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get data-stream by identifier. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStream(String,String,RequestContext)']/*" />
        public virtual Response GetDataStream(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDataStreamRequest(measurementId, dataStreamId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns SAS-signed upload URIs for files that need to be uploaded to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="body"> Parameter of type &apos;UploadDerivedDataStreamFilesRequest&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<UploadDerivedDataStreamFilesResponse>> StageFilesForDataStreamAsync(string measurementId, string dataStreamId, UploadDerivedDataStreamFilesRequest body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await StageFilesForDataStreamAsync(measurementId, dataStreamId, body?.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(UploadDerivedDataStreamFilesResponse.FromResponse(response), response);
        }

        /// <summary>
        /// Returns SAS-signed upload URIs for files that need to be uploaded to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="body"> Parameter of type &apos;UploadDerivedDataStreamFilesRequest&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<UploadDerivedDataStreamFilesResponse> StageFilesForDataStream(string measurementId, string dataStreamId, UploadDerivedDataStreamFilesRequest body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = StageFilesForDataStream(measurementId, dataStreamId, body?.ToRequestContent(), context);
            return Response.FromValue(UploadDerivedDataStreamFilesResponse.FromResponse(response), response);
        }

        /// <summary>
        /// Returns SAS-signed upload URIs for files that need to be uploaded to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='StageFilesForDataStreamAsync(String,String,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> StageFilesForDataStreamAsync(string measurementId, string dataStreamId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.StageFilesForDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStageFilesForDataStreamRequest(measurementId, dataStreamId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns SAS-signed upload URIs for files that need to be uploaded to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='StageFilesForDataStream(String,String,RequestContent,RequestContext)']/*" />
        public virtual Response StageFilesForDataStream(string measurementId, string dataStreamId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.StageFilesForDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStageFilesForDataStreamRequest(measurementId, dataStreamId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or replace storage information of the data-stream.
        /// Returns the data-stream storage resource with SAS signed URIs that allow uploading to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="body"> Parameter of type &apos;StorageCreationParameters&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<object>> CreateOrReplaceDataStreamStorageAsync(string measurementId, string dataStreamId, StorageCreationParameters body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateOrReplaceDataStreamStorageAsync(measurementId, dataStreamId, body?.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(object.FromResponse(response), response);
        }

        /// <summary>
        /// Create or replace storage information of the data-stream.
        /// Returns the data-stream storage resource with SAS signed URIs that allow uploading to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="body"> Parameter of type &apos;StorageCreationParameters&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<object> CreateOrReplaceDataStreamStorage(string measurementId, string dataStreamId, StorageCreationParameters body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateOrReplaceDataStreamStorage(measurementId, dataStreamId, body?.ToRequestContent(), context);
            return Response.FromValue(object.FromResponse(response), response);
        }

        /// <summary>
        /// Create or replace storage information of the data-stream.
        /// Returns the data-stream storage resource with SAS signed URIs that allow uploading to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateOrReplaceDataStreamStorageAsync(String,String,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateOrReplaceDataStreamStorageAsync(string measurementId, string dataStreamId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateOrReplaceDataStreamStorage");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceDataStreamStorageRequest(measurementId, dataStreamId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or replace storage information of the data-stream.
        /// Returns the data-stream storage resource with SAS signed URIs that allow uploading to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateOrReplaceDataStreamStorage(String,String,RequestContent,RequestContext)']/*" />
        public virtual Response CreateOrReplaceDataStreamStorage(string measurementId, string dataStreamId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateOrReplaceDataStreamStorage");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceDataStreamStorageRequest(measurementId, dataStreamId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns the data-stream storage resource with SAS signed URIs that allow uploading to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<StorageBase>> GetDataStreamStorageValueAsync(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamStorageValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetDataStreamStorageAsync(measurementId, dataStreamId, context).ConfigureAwait(false);
                return Response.FromValue(StorageBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns the data-stream storage resource with SAS signed URIs that allow uploading to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<StorageBase> GetDataStreamStorageValue(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamStorageValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetDataStreamStorage(measurementId, dataStreamId, context);
                return Response.FromValue(StorageBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns the data-stream storage resource with SAS signed URIs that allow uploading to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamStorageAsync(String,String,RequestContext)']/*" />
        public virtual async Task<Response> GetDataStreamStorageAsync(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamStorage");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDataStreamStorageRequest(measurementId, dataStreamId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns the data-stream storage resource with SAS signed URIs that allow uploading to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamStorage(String,String,RequestContext)']/*" />
        public virtual Response GetDataStreamStorage(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamStorage");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDataStreamStorageRequest(measurementId, dataStreamId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or replace all tags at once. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="body"> Parameter of type &apos;TagSetCreationParameters&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<TagSet>> CreateOrReplaceDataStreamTagsAsync(string measurementId, string dataStreamId, TagSetCreationParameters body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateOrReplaceDataStreamTagsAsync(measurementId, dataStreamId, body?.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(TagSet.FromResponse(response), response);
        }

        /// <summary> Create or replace all tags at once. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="body"> Parameter of type &apos;TagSetCreationParameters&apos; in the body. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<TagSet> CreateOrReplaceDataStreamTags(string measurementId, string dataStreamId, TagSetCreationParameters body = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateOrReplaceDataStreamTags(measurementId, dataStreamId, body?.ToRequestContent(), context);
            return Response.FromValue(TagSet.FromResponse(response), response);
        }

        /// <summary> Create or replace all tags at once. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateOrReplaceDataStreamTagsAsync(String,String,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateOrReplaceDataStreamTagsAsync(string measurementId, string dataStreamId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateOrReplaceDataStreamTags");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceDataStreamTagsRequest(measurementId, dataStreamId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or replace all tags at once. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateOrReplaceDataStreamTags(String,String,RequestContent,RequestContext)']/*" />
        public virtual Response CreateOrReplaceDataStreamTags(string measurementId, string dataStreamId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateOrReplaceDataStreamTags");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceDataStreamTagsRequest(measurementId, dataStreamId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns set of the data-stream tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<TagSet>> GetDataStreamTagValuesAsync(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamTagValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetDataStreamTagsAsync(measurementId, dataStreamId, context).ConfigureAwait(false);
                return Response.FromValue(TagSet.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns set of the data-stream tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<TagSet> GetDataStreamTagValues(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamTagValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetDataStreamTags(measurementId, dataStreamId, context);
                return Response.FromValue(TagSet.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns set of the data-stream tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamTagsAsync(String,String,RequestContext)']/*" />
        public virtual async Task<Response> GetDataStreamTagsAsync(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamTags");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDataStreamTagsRequest(measurementId, dataStreamId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns set of the data-stream tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamTags(String,String,RequestContext)']/*" />
        public virtual Response GetDataStreamTags(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamTags");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDataStreamTagsRequest(measurementId, dataStreamId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns SAS signed URI of the data-stream logs folder that allow uploading log files to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<DataStreamLogsContainerBase>> GetDataStreamLogsContainerLocationValueAsync(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamLogsContainerLocationValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetDataStreamLogsContainerLocationAsync(measurementId, dataStreamId, context).ConfigureAwait(false);
                return Response.FromValue(DataStreamLogsContainerBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns SAS signed URI of the data-stream logs folder that allow uploading log files to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<DataStreamLogsContainerBase> GetDataStreamLogsContainerLocationValue(string measurementId, string dataStreamId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamLogsContainerLocationValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetDataStreamLogsContainerLocation(measurementId, dataStreamId, context);
                return Response.FromValue(DataStreamLogsContainerBase.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns SAS signed URI of the data-stream logs folder that allow uploading log files to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamLogsContainerLocationAsync(String,String,RequestContext)']/*" />
        public virtual async Task<Response> GetDataStreamLogsContainerLocationAsync(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamLogsContainerLocation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDataStreamLogsContainerLocationRequest(measurementId, dataStreamId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns SAS signed URI of the data-stream logs folder that allow uploading log files to Azure Storage.
        /// The SAS token expires in 24 hours.
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamLogsContainerLocation(String,String,RequestContext)']/*" />
        public virtual Response GetDataStreamLogsContainerLocation(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GetDataStreamLogsContainerLocation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDataStreamLogsContainerLocationRequest(measurementId, dataStreamId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List special files details for the discovery resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDiscoverySpecialFileUploadLocationsAsync(String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDiscoverySpecialFileUploadLocationsAsync(string discoveryId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            return GetDiscoverySpecialFileUploadLocationsImplementationAsync("DataManagementClient.GetDiscoverySpecialFileUploadLocations", discoveryId, context);
        }

        private AsyncPageable<BinaryData> GetDiscoverySpecialFileUploadLocationsImplementationAsync(string diagnosticsScopeName, string discoveryId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDiscoverySpecialFileUploadLocationsRequest(discoveryId, context)
                        : CreateGetDiscoverySpecialFileUploadLocationsNextPageRequest(nextLink, discoveryId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary>
        /// List special files details for the discovery resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDiscoverySpecialFileUploadLocations(String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDiscoverySpecialFileUploadLocations(string discoveryId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            return GetDiscoverySpecialFileUploadLocationsImplementation("DataManagementClient.GetDiscoverySpecialFileUploadLocations", discoveryId, context);
        }

        private Pageable<BinaryData> GetDiscoverySpecialFileUploadLocationsImplementation(string diagnosticsScopeName, string discoveryId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDiscoverySpecialFileUploadLocationsRequest(discoveryId, context)
                        : CreateGetDiscoverySpecialFileUploadLocationsNextPageRequest(nextLink, discoveryId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List upload detail for the discovery resource. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetAllDiscoveryUploadsAsync(String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetAllDiscoveryUploadsAsync(string discoveryId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            return GetAllDiscoveryUploadsImplementationAsync("DataManagementClient.GetAllDiscoveryUploads", discoveryId, context);
        }

        private AsyncPageable<BinaryData> GetAllDiscoveryUploadsImplementationAsync(string diagnosticsScopeName, string discoveryId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAllDiscoveryUploadsRequest(discoveryId, context)
                        : CreateGetAllDiscoveryUploadsNextPageRequest(nextLink, discoveryId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List upload detail for the discovery resource. </summary>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetAllDiscoveryUploads(String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetAllDiscoveryUploads(string discoveryId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            return GetAllDiscoveryUploadsImplementation("DataManagementClient.GetAllDiscoveryUploads", discoveryId, context);
        }

        private Pageable<BinaryData> GetAllDiscoveryUploadsImplementation(string diagnosticsScopeName, string discoveryId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAllDiscoveryUploadsRequest(discoveryId, context)
                        : CreateGetAllDiscoveryUploadsNextPageRequest(nextLink, discoveryId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetUploadSpecialFilesAsync(String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetUploadSpecialFilesAsync(string uploadId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            return GetUploadSpecialFilesImplementationAsync("DataManagementClient.GetUploadSpecialFiles", uploadId, context);
        }

        private AsyncPageable<BinaryData> GetUploadSpecialFilesImplementationAsync(string diagnosticsScopeName, string uploadId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetUploadSpecialFilesRequest(uploadId, context)
                        : CreateGetUploadSpecialFilesNextPageRequest(nextLink, uploadId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading special files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetUploadSpecialFiles(String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetUploadSpecialFiles(string uploadId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            return GetUploadSpecialFilesImplementation("DataManagementClient.GetUploadSpecialFiles", uploadId, context);
        }

        private Pageable<BinaryData> GetUploadSpecialFilesImplementation(string diagnosticsScopeName, string uploadId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetUploadSpecialFilesRequest(uploadId, context)
                        : CreateGetUploadSpecialFilesNextPageRequest(nextLink, uploadId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading data files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetUploadDataFilesAsync(String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetUploadDataFilesAsync(string uploadId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            return GetUploadDataFilesImplementationAsync("DataManagementClient.GetUploadDataFiles", uploadId, context);
        }

        private AsyncPageable<BinaryData> GetUploadDataFilesImplementationAsync(string diagnosticsScopeName, string uploadId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetUploadDataFilesRequest(uploadId, context)
                        : CreateGetUploadDataFilesNextPageRequest(nextLink, uploadId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary>
        /// List special files details for the upload resource.
        /// Returns SAS signed URI that allows uploading data files to Azure Storage.
        /// This URI expires in 24 hours.
        /// </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetUploadDataFiles(String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetUploadDataFiles(string uploadId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            return GetUploadDataFilesImplementation("DataManagementClient.GetUploadDataFiles", uploadId, context);
        }

        private Pageable<BinaryData> GetUploadDataFilesImplementation(string diagnosticsScopeName, string uploadId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetUploadDataFilesRequest(uploadId, context)
                        : CreateGetUploadDataFilesNextPageRequest(nextLink, uploadId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List of the measurement identifiers that have been created by the upload. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementsAsync(String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetMeasurementsAsync(string uploadId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            return GetMeasurementsImplementationAsync("DataManagementClient.GetMeasurements", uploadId, context);
        }

        private AsyncPageable<BinaryData> GetMeasurementsImplementationAsync(string diagnosticsScopeName, string uploadId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementsRequest(uploadId, context)
                        : CreateGetMeasurementsNextPageRequest(nextLink, uploadId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List of the measurement identifiers that have been created by the upload. </summary>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurements(String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetMeasurements(string uploadId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            return GetMeasurementsImplementation("DataManagementClient.GetMeasurements", uploadId, context);
        }

        private Pageable<BinaryData> GetMeasurementsImplementation(string diagnosticsScopeName, string uploadId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementsRequest(uploadId, context)
                        : CreateGetMeasurementsNextPageRequest(nextLink, uploadId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List all classification schemas. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetClassificationSchemasAsync(RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetClassificationSchemasAsync(RequestContext context = null)
        {
            return GetClassificationSchemasImplementationAsync("DataManagementClient.GetClassificationSchemas", context);
        }

        private AsyncPageable<BinaryData> GetClassificationSchemasImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetClassificationSchemasRequest(context)
                        : CreateGetClassificationSchemasNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List all classification schemas. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetClassificationSchemas(RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetClassificationSchemas(RequestContext context = null)
        {
            return GetClassificationSchemasImplementation("DataManagementClient.GetClassificationSchemas", context);
        }

        private Pageable<BinaryData> GetClassificationSchemasImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetClassificationSchemasRequest(context)
                        : CreateGetClassificationSchemasNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the measurements in a workspace. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementsAsync(RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetMeasurementsAsync(RequestContext context = null)
        {
            return GetMeasurementsImplementationAsync("DataManagementClient.GetMeasurements", context);
        }

        private AsyncPageable<BinaryData> GetMeasurementsImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementsRequest(context)
                        : CreateGetMeasurementsNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the measurements in a workspace. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurements(RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetMeasurements(RequestContext context = null)
        {
            return GetMeasurementsImplementation("DataManagementClient.GetMeasurements", context);
        }

        private Pageable<BinaryData> GetMeasurementsImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementsRequest(context)
                        : CreateGetMeasurementsNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the measurements in a workspace with extended metadata. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementsWithMetadataAsync(RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetMeasurementsWithMetadataAsync(RequestContext context = null)
        {
            return GetMeasurementsWithMetadataImplementationAsync("DataManagementClient.GetMeasurementsWithMetadata", context);
        }

        private AsyncPageable<BinaryData> GetMeasurementsWithMetadataImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementsWithMetadataRequest(context)
                        : CreateGetMeasurementsWithMetadataNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the measurements in a workspace with extended metadata. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementsWithMetadata(RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetMeasurementsWithMetadata(RequestContext context = null)
        {
            return GetMeasurementsWithMetadataImplementation("DataManagementClient.GetMeasurementsWithMetadata", context);
        }

        private Pageable<BinaryData> GetMeasurementsWithMetadataImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementsWithMetadataRequest(context)
                        : CreateGetMeasurementsWithMetadataNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the measurements in a workspace that are in the given measurement IDs list. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementsByIdsAsync(RequestContent,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetMeasurementsByIdsAsync(RequestContent content, RequestContext context = null)
        {
            return GetMeasurementsByIdsImplementationAsync("DataManagementClient.GetMeasurementsByIds", content, context);
        }

        private AsyncPageable<BinaryData> GetMeasurementsByIdsImplementationAsync(string diagnosticsScopeName, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementsByIdsRequest(content, context)
                        : CreateGetMeasurementsByIdsNextPageRequest(nextLink, content, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the measurements in a workspace that are in the given measurement IDs list. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementsByIds(RequestContent,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetMeasurementsByIds(RequestContent content, RequestContext context = null)
        {
            return GetMeasurementsByIdsImplementation("DataManagementClient.GetMeasurementsByIds", content, context);
        }

        private Pageable<BinaryData> GetMeasurementsByIdsImplementation(string diagnosticsScopeName, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementsByIdsRequest(content, context)
                        : CreateGetMeasurementsByIdsNextPageRequest(nextLink, content, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List state machines instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementStateMachinesAsync(String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetMeasurementStateMachinesAsync(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetMeasurementStateMachinesImplementationAsync("DataManagementClient.GetMeasurementStateMachines", measurementId, context);
        }

        private AsyncPageable<BinaryData> GetMeasurementStateMachinesImplementationAsync(string diagnosticsScopeName, string measurementId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementStateMachinesRequest(measurementId, context)
                        : CreateGetMeasurementStateMachinesNextPageRequest(nextLink, measurementId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List state machines instance for the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementStateMachines(String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetMeasurementStateMachines(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetMeasurementStateMachinesImplementation("DataManagementClient.GetMeasurementStateMachines", measurementId, context);
        }

        private Pageable<BinaryData> GetMeasurementStateMachinesImplementation(string diagnosticsScopeName, string measurementId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementStateMachinesRequest(measurementId, context)
                        : CreateGetMeasurementStateMachinesNextPageRequest(nextLink, measurementId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the classifications assigned to the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementClassificationsAsync(String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetMeasurementClassificationsAsync(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetMeasurementClassificationsImplementationAsync("DataManagementClient.GetMeasurementClassifications", measurementId, context);
        }

        private AsyncPageable<BinaryData> GetMeasurementClassificationsImplementationAsync(string diagnosticsScopeName, string measurementId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementClassificationsRequest(measurementId, context)
                        : CreateGetMeasurementClassificationsNextPageRequest(nextLink, measurementId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the classifications assigned to the measurement. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetMeasurementClassifications(String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetMeasurementClassifications(string measurementId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetMeasurementClassificationsImplementation("DataManagementClient.GetMeasurementClassifications", measurementId, context);
        }

        private Pageable<BinaryData> GetMeasurementClassificationsImplementation(string diagnosticsScopeName, string measurementId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMeasurementClassificationsRequest(measurementId, context)
                        : CreateGetMeasurementClassificationsNextPageRequest(nextLink, measurementId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary>
        /// Lists the existing data-streams.
        /// Supports the following filter expressions:
        /// - filter=&quot;type=[System | Raw | Derived]&quot;
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="filter"> Filter the result list using the given expression. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetAllDataStreamAsync(String,String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetAllDataStreamAsync(string measurementId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetAllDataStreamImplementationAsync("DataManagementClient.GetAllDataStream", measurementId, filter, context);
        }

        private AsyncPageable<BinaryData> GetAllDataStreamImplementationAsync(string diagnosticsScopeName, string measurementId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAllDataStreamRequest(measurementId, filter, context)
                        : CreateGetAllDataStreamNextPageRequest(nextLink, measurementId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary>
        /// Lists the existing data-streams.
        /// Supports the following filter expressions:
        /// - filter=&quot;type=[System | Raw | Derived]&quot;
        /// </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="filter"> Filter the result list using the given expression. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetAllDataStream(String,String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetAllDataStream(string measurementId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetAllDataStreamImplementation("DataManagementClient.GetAllDataStream", measurementId, filter, context);
        }

        private Pageable<BinaryData> GetAllDataStreamImplementation(string diagnosticsScopeName, string measurementId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAllDataStreamRequest(measurementId, filter, context)
                        : CreateGetAllDataStreamNextPageRequest(nextLink, measurementId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the data-streams by tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamsByTagsAsync(String,RequestContent,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDataStreamsByTagsAsync(string measurementId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetDataStreamsByTagsImplementationAsync("DataManagementClient.GetDataStreamsByTags", measurementId, content, context);
        }

        private AsyncPageable<BinaryData> GetDataStreamsByTagsImplementationAsync(string diagnosticsScopeName, string measurementId, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDataStreamsByTagsRequest(measurementId, content, context)
                        : CreateGetDataStreamsByTagsNextPageRequest(nextLink, measurementId, content, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the data-streams by tags. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamsByTags(String,RequestContent,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDataStreamsByTags(string measurementId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetDataStreamsByTagsImplementation("DataManagementClient.GetDataStreamsByTags", measurementId, content, context);
        }

        private Pageable<BinaryData> GetDataStreamsByTagsImplementation(string diagnosticsScopeName, string measurementId, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDataStreamsByTagsRequest(measurementId, content, context)
                        : CreateGetDataStreamsByTagsNextPageRequest(nextLink, measurementId, content, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the data-streams by lineage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamsByLineageAsync(String,RequestContent,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDataStreamsByLineageAsync(string measurementId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetDataStreamsByLineageImplementationAsync("DataManagementClient.GetDataStreamsByLineage", measurementId, content, context);
        }

        private AsyncPageable<BinaryData> GetDataStreamsByLineageImplementationAsync(string diagnosticsScopeName, string measurementId, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDataStreamsByLineageRequest(measurementId, content, context)
                        : CreateGetDataStreamsByLineageNextPageRequest(nextLink, measurementId, content, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the data-streams by lineage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamsByLineage(String,RequestContent,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDataStreamsByLineage(string measurementId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetDataStreamsByLineageImplementation("DataManagementClient.GetDataStreamsByLineage", measurementId, content, context);
        }

        private Pageable<BinaryData> GetDataStreamsByLineageImplementation(string diagnosticsScopeName, string measurementId, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDataStreamsByLineageRequest(measurementId, content, context)
                        : CreateGetDataStreamsByLineageNextPageRequest(nextLink, measurementId, content, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the data-streams by lineage graph. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamLineageGraphsByLineageAsync(String,RequestContent,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDataStreamLineageGraphsByLineageAsync(string measurementId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetDataStreamLineageGraphsByLineageImplementationAsync("DataManagementClient.GetDataStreamLineageGraphsByLineage", measurementId, content, context);
        }

        private AsyncPageable<BinaryData> GetDataStreamLineageGraphsByLineageImplementationAsync(string diagnosticsScopeName, string measurementId, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDataStreamLineageGraphsByLineageRequest(measurementId, content, context)
                        : CreateGetDataStreamLineageGraphsByLineageNextPageRequest(nextLink, measurementId, content, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the data-streams by lineage graph. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamLineageGraphsByLineage(String,RequestContent,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDataStreamLineageGraphsByLineage(string measurementId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            return GetDataStreamLineageGraphsByLineageImplementation("DataManagementClient.GetDataStreamLineageGraphsByLineage", measurementId, content, context);
        }

        private Pageable<BinaryData> GetDataStreamLineageGraphsByLineageImplementation(string diagnosticsScopeName, string measurementId, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDataStreamLineageGraphsByLineageRequest(measurementId, content, context)
                        : CreateGetDataStreamLineageGraphsByLineageNextPageRequest(nextLink, measurementId, content, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Returns SAS signed URIs for reading special files from Azure Storage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamFilesAsync(String,String,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetDataStreamFilesAsync(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            return GetDataStreamFilesImplementationAsync("DataManagementClient.GetDataStreamFiles", measurementId, dataStreamId, context);
        }

        private AsyncPageable<BinaryData> GetDataStreamFilesImplementationAsync(string diagnosticsScopeName, string measurementId, string dataStreamId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDataStreamFilesRequest(measurementId, dataStreamId, context)
                        : CreateGetDataStreamFilesNextPageRequest(nextLink, measurementId, dataStreamId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Returns SAS signed URIs for reading special files from Azure Storage. </summary>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GetDataStreamFiles(String,String,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetDataStreamFiles(string measurementId, string dataStreamId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            return GetDataStreamFilesImplementation("DataManagementClient.GetDataStreamFiles", measurementId, dataStreamId, context);
        }

        private Pageable<BinaryData> GetDataStreamFilesImplementation(string diagnosticsScopeName, string measurementId, string dataStreamId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDataStreamFilesRequest(measurementId, dataStreamId, context)
                        : CreateGetDataStreamFilesNextPageRequest(nextLink, measurementId, dataStreamId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Initiates the process of completing the discovery and creating the upload file grouping manifest files. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CompleteDiscoveryAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CompleteDiscoveryAsync(WaitUntil waitUntil, string discoveryId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CompleteDiscovery");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCompleteDiscoveryRequest(discoveryId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.CompleteDiscovery", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of completing the discovery and creating the upload file grouping manifest files. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CompleteDiscovery(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> CompleteDiscovery(WaitUntil waitUntil, string discoveryId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CompleteDiscovery");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCompleteDiscoveryRequest(discoveryId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.CompleteDiscovery", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of cancelling the discovery. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CancelDiscoveryAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CancelDiscoveryAsync(WaitUntil waitUntil, string discoveryId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CancelDiscovery");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelDiscoveryRequest(discoveryId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.CancelDiscovery", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of cancelling the discovery. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CancelDiscovery(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> CancelDiscovery(WaitUntil waitUntil, string discoveryId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CancelDiscovery");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelDiscoveryRequest(discoveryId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.CancelDiscovery", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of generating SAS signed URIs for uploading special files for the discovery. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GenerateDiscoverySpecialFileUploadLocationsAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> GenerateDiscoverySpecialFileUploadLocationsAsync(WaitUntil waitUntil, string discoveryId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GenerateDiscoverySpecialFileUploadLocations");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGenerateDiscoverySpecialFileUploadLocationsRequest(discoveryId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.GenerateDiscoverySpecialFileUploadLocations", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of generating SAS signed URIs for uploading special files for the discovery. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="discoveryId"> The discovery identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="discoveryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="discoveryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GenerateDiscoverySpecialFileUploadLocations(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> GenerateDiscoverySpecialFileUploadLocations(WaitUntil waitUntil, string discoveryId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(discoveryId, nameof(discoveryId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GenerateDiscoverySpecialFileUploadLocations");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGenerateDiscoverySpecialFileUploadLocationsRequest(discoveryId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.GenerateDiscoverySpecialFileUploadLocations", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of completing the upload and creating the measurements. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CompleteUploadAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CompleteUploadAsync(WaitUntil waitUntil, string uploadId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CompleteUpload");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCompleteUploadRequest(uploadId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.CompleteUpload", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of completing the upload and creating the measurements. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CompleteUpload(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> CompleteUpload(WaitUntil waitUntil, string uploadId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CompleteUpload");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCompleteUploadRequest(uploadId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.CompleteUpload", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of cancelling the upload. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CancelUploadAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CancelUploadAsync(WaitUntil waitUntil, string uploadId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CancelUpload");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelUploadRequest(uploadId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.CancelUpload", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of cancelling the upload. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CancelUpload(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> CancelUpload(WaitUntil waitUntil, string uploadId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CancelUpload");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelUploadRequest(uploadId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.CancelUpload", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of generating SAS signed URIs for uploading special files for the upload. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GenerateUploadSpecialFilesAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> GenerateUploadSpecialFilesAsync(WaitUntil waitUntil, string uploadId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GenerateUploadSpecialFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGenerateUploadSpecialFilesRequest(uploadId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.GenerateUploadSpecialFiles", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of generating SAS signed URIs for uploading special files for the upload. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GenerateUploadSpecialFiles(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> GenerateUploadSpecialFiles(WaitUntil waitUntil, string uploadId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GenerateUploadSpecialFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGenerateUploadSpecialFilesRequest(uploadId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.GenerateUploadSpecialFiles", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of allocating the data files. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GenerateUploadDataFilesAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> GenerateUploadDataFilesAsync(WaitUntil waitUntil, string uploadId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GenerateUploadDataFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGenerateUploadDataFilesRequest(uploadId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.GenerateUploadDataFiles", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of allocating the data files. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="uploadId"> The upload resource identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="uploadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GenerateUploadDataFiles(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> GenerateUploadDataFiles(WaitUntil waitUntil, string uploadId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(uploadId, nameof(uploadId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GenerateUploadDataFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGenerateUploadDataFilesRequest(uploadId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.GenerateUploadDataFiles", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates new classification schema. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateClassificationSchemaAsync(WaitUntil,RequestContent,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreateClassificationSchemaAsync(WaitUntil waitUntil, RequestContent content, string operationId = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateClassificationSchema");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateClassificationSchemaRequest(content, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.CreateClassificationSchema", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates new classification schema. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateClassificationSchema(WaitUntil,RequestContent,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreateClassificationSchema(WaitUntil waitUntil, RequestContent content, string operationId = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateClassificationSchema");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateClassificationSchemaRequest(content, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.CreateClassificationSchema", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the classification schema and all related classification assignments (instances). </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="name"> Classification schema identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='DeleteClassificationSchemaAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> DeleteClassificationSchemaAsync(WaitUntil waitUntil, string name, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.DeleteClassificationSchema");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteClassificationSchemaRequest(name, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.DeleteClassificationSchema", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the classification schema and all related classification assignments (instances). </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="name"> Classification schema identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='DeleteClassificationSchema(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> DeleteClassificationSchema(WaitUntil waitUntil, string name, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.DeleteClassificationSchema");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteClassificationSchemaRequest(name, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.DeleteClassificationSchema", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the measurement. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='DeleteMeasurementAsync(WaitUntil,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> DeleteMeasurementAsync(WaitUntil waitUntil, string measurementId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.DeleteMeasurement");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteMeasurementRequest(measurementId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.DeleteMeasurement", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the measurement. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='DeleteMeasurement(WaitUntil,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> DeleteMeasurement(WaitUntil waitUntil, string measurementId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.DeleteMeasurement");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteMeasurementRequest(measurementId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.DeleteMeasurement", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates process of applying an action on the measurement. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="id"> The state machine identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="id"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="id"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='ActMeasurementStateMachineAsync(WaitUntil,String,String,RequestContent,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> ActMeasurementStateMachineAsync(WaitUntil waitUntil, string measurementId, string id, RequestContent content, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(id, nameof(id));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.ActMeasurementStateMachine");
            scope.Start();
            try
            {
                using HttpMessage message = CreateActMeasurementStateMachineRequest(measurementId, id, content, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.ActMeasurementStateMachine", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates process of applying an action on the measurement. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="id"> The state machine identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="id"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="id"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='ActMeasurementStateMachine(WaitUntil,String,String,RequestContent,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> ActMeasurementStateMachine(WaitUntil waitUntil, string measurementId, string id, RequestContent content, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(id, nameof(id));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.ActMeasurementStateMachine");
            scope.Start();
            try
            {
                using HttpMessage message = CreateActMeasurementStateMachineRequest(measurementId, id, content, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.ActMeasurementStateMachine", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Unassign the classification from the measurement. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="schemaName"> Classification schema name. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='DeleteMeasurementClassificationAsync(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> DeleteMeasurementClassificationAsync(WaitUntil waitUntil, string measurementId, string schemaName, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.DeleteMeasurementClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteMeasurementClassificationRequest(measurementId, schemaName, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.DeleteMeasurementClassification", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Unassign the classification from the measurement. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="schemaName"> Classification schema name. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='DeleteMeasurementClassification(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> DeleteMeasurementClassification(WaitUntil waitUntil, string measurementId, string schemaName, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.DeleteMeasurementClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteMeasurementClassificationRequest(measurementId, schemaName, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.DeleteMeasurementClassification", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Assigns classification to the measurement. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateMeasurementClassificationAsync(WaitUntil,String,RequestContent,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreateMeasurementClassificationAsync(WaitUntil waitUntil, string measurementId, RequestContent content, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateMeasurementClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateMeasurementClassificationRequest(measurementId, content, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.CreateMeasurementClassification", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Assigns classification to the measurement. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateMeasurementClassification(WaitUntil,String,RequestContent,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreateMeasurementClassification(WaitUntil waitUntil, string measurementId, RequestContent content, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateMeasurementClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateMeasurementClassificationRequest(measurementId, content, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.CreateMeasurementClassification", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates new data-stream resource. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateDataStreamAsync(WaitUntil,String,RequestContent,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreateDataStreamAsync(WaitUntil waitUntil, string measurementId, RequestContent content, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDataStreamRequest(measurementId, content, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.CreateDataStream", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates new data-stream resource. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CreateDataStream(WaitUntil,String,RequestContent,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreateDataStream(WaitUntil waitUntil, string measurementId, RequestContent content, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CreateDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDataStreamRequest(measurementId, content, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.CreateDataStream", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Clear the data-stream content. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='ClearContentOfDataStreamAsync(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> ClearContentOfDataStreamAsync(WaitUntil waitUntil, string measurementId, string dataStreamId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.ClearContentOfDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateClearContentOfDataStreamRequest(measurementId, dataStreamId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.ClearContentOfDataStream", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Clear the data-stream content. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='ClearContentOfDataStream(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> ClearContentOfDataStream(WaitUntil waitUntil, string measurementId, string dataStreamId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.ClearContentOfDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateClearContentOfDataStreamRequest(measurementId, dataStreamId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.ClearContentOfDataStream", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Marks a data stream as completed. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CompleteDataStreamAsync(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CompleteDataStreamAsync(WaitUntil waitUntil, string measurementId, string dataStreamId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CompleteDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCompleteDataStreamRequest(measurementId, dataStreamId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.CompleteDataStream", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Marks a data stream as completed. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='CompleteDataStream(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> CompleteDataStream(WaitUntil waitUntil, string measurementId, string dataStreamId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.CompleteDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCompleteDataStreamRequest(measurementId, dataStreamId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.CompleteDataStream", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Marks a data stream as failed. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='FailDataStreamAsync(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> FailDataStreamAsync(WaitUntil waitUntil, string measurementId, string dataStreamId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.FailDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateFailDataStreamRequest(measurementId, dataStreamId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.FailDataStream", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Marks a data stream as failed. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='FailDataStream(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> FailDataStream(WaitUntil waitUntil, string measurementId, string dataStreamId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.FailDataStream");
            scope.Start();
            try
            {
                using HttpMessage message = CreateFailDataStreamRequest(measurementId, dataStreamId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.FailDataStream", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of generating SAS signed URIs for accessing the data-stream files. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GenerateDataStreamFilesAsync(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> GenerateDataStreamFilesAsync(WaitUntil waitUntil, string measurementId, string dataStreamId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GenerateDataStreamFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGenerateDataStreamFilesRequest(measurementId, dataStreamId, operationId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DataManagementClient.GenerateDataStreamFiles", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Initiates the process of generating SAS signed URIs for accessing the data-stream files. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="measurementId"> The measurement identifier. </param>
        /// <param name="dataStreamId"> The data stream identifier. </param>
        /// <param name="operationId"> The long running operation identifier. Operation-Id should be valid UUID string. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="measurementId"/> or <paramref name="dataStreamId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <include file="Docs/DataManagementClient.xml" path="doc/members/member[@name='GenerateDataStreamFiles(WaitUntil,String,String,String,RequestContext)']/*" />
        public virtual Operation<BinaryData> GenerateDataStreamFiles(WaitUntil waitUntil, string measurementId, string dataStreamId, string operationId = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(measurementId, nameof(measurementId));
            Argument.AssertNotNullOrEmpty(dataStreamId, nameof(dataStreamId));

            using var scope = ClientDiagnostics.CreateScope("DataManagementClient.GenerateDataStreamFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGenerateDataStreamFilesRequest(measurementId, dataStreamId, operationId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DataManagementClient.GenerateDataStreamFiles", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetLongRunningRequest(string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/operations/", false);
            uri.AppendPath(operationId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrReplaceDiscoveryRequest(string discoveryId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/discoveries/", false);
            uri.AppendPath(discoveryId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDiscoveryRequest(string discoveryId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/discoveries/", false);
            uri.AppendPath(discoveryId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCompleteDiscoveryRequest(string discoveryId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/discoveries/", false);
            uri.AppendPath(discoveryId, true);
            uri.AppendPath(":completeDiscovery", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCancelDiscoveryRequest(string discoveryId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/discoveries/", false);
            uri.AppendPath(discoveryId, true);
            uri.AppendPath(":cancelDiscovery", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDiscoverySpecialFileUploadLocationsRequest(string discoveryId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/discoveries/", false);
            uri.AppendPath(discoveryId, true);
            uri.AppendPath("/specialFilesUploadInfo:getDiscoverySpecialFileUploadLocations", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGenerateDiscoverySpecialFileUploadLocationsRequest(string discoveryId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/discoveries/", false);
            uri.AppendPath(discoveryId, true);
            uri.AppendPath("/specialFilesUploadInfo:generateDiscoverySpecialFileUploadLocations", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllDiscoveryUploadsRequest(string discoveryId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/discoveries/", false);
            uri.AppendPath(discoveryId, true);
            uri.AppendPath("/uploads", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrReplaceUploadRequest(string uploadId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetUploadRequest(string uploadId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCompleteUploadRequest(string uploadId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendPath(":completeUpload", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCancelUploadRequest(string uploadId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendPath(":cancelUpload", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGenerateUploadSpecialFilesRequest(string uploadId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendPath("/specialFilesUploadInfo:generateUploadSpecialFiles", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUploadSpecialFilesRequest(string uploadId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendPath("/specialFilesUploadInfo:getUploadSpecialFiles", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGenerateUploadDataFilesRequest(string uploadId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendPath("/dataFilesUploadInfo:generateUploadDataFiles", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUploadDataFilesRequest(string uploadId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendPath("/dataFilesUploadInfo:getUploadDataFiles", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementsRequest(string uploadId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/uploads/", false);
            uri.AppendPath(uploadId, true);
            uri.AppendPath("/measurements", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationSchemaRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/classificationSchemas/", false);
            uri.AppendPath(name, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateClassificationSchemaRequest(RequestContent content, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/classificationSchemas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteClassificationSchemaRequest(string name, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/classificationSchemas/", false);
            uri.AppendPath(name, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationSchemasRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/classificationSchemas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementRequest(string measurementId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteMeasurementRequest(string measurementId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementsWithMetadataRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements:getMeasurementsWithMetadata", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementsByIdsRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements:getMeasurementsByIds", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMeasurementMetadataRequest(string measurementId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/metadata", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementProcessingResultsRequest(string measurementId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/processingResults", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementStateMachineRequest(string measurementId, string id, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/stateMachines/", false);
            uri.AppendPath(id, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementStateMachinesRequest(string measurementId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/stateMachines", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateActMeasurementStateMachineRequest(string measurementId, string id, RequestContent content, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/stateMachines/", false);
            uri.AppendPath(id, true);
            uri.AppendPath(":actMeasurementStateMachine", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMeasurementMetadataSchemaFileInfoRequest(string measurementId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/metadataSchemaFileInfo", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementClassificationRequest(string measurementId, string schemaName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/classifications/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementClassificationsRequest(string measurementId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/classifications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteMeasurementClassificationRequest(string measurementId, string schemaName, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/classifications/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateMeasurementClassificationRequest(string measurementId, RequestContent content, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/classifications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateDataStreamRequest(string measurementId, RequestContent content, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDataStreamRequest(string measurementId, string dataStreamId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllDataStreamRequest(string measurementId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateClearContentOfDataStreamRequest(string measurementId, string dataStreamId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath(":clearContentOfDataStream", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStageFilesForDataStreamRequest(string measurementId, string dataStreamId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath(":stageFilesForDataStream", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCompleteDataStreamRequest(string measurementId, string dataStreamId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath(":completeDataStream", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateFailDataStreamRequest(string measurementId, string dataStreamId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath(":failDataStream", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDataStreamsByTagsRequest(string measurementId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams:getDataStreamsByTags", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDataStreamsByLineageRequest(string measurementId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams:getDataStreamsByLineage", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDataStreamLineageGraphsByLineageRequest(string measurementId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams:getDataStreamLineageGraphsByLineage", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateOrReplaceDataStreamStorageRequest(string measurementId, string dataStreamId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath("/storage", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDataStreamStorageRequest(string measurementId, string dataStreamId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath("/storage:getDataStreamStorage", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrReplaceDataStreamTagsRequest(string measurementId, string dataStreamId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath("/tags", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDataStreamTagsRequest(string measurementId, string dataStreamId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath("/tags", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGenerateDataStreamFilesRequest(string measurementId, string dataStreamId, string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath("/files:generateDataStreamFiles", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (operationId != null)
            {
                request.Headers.Add("operation-id", operationId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDataStreamFilesRequest(string measurementId, string dataStreamId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath("/files", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDataStreamLogsContainerLocationRequest(string measurementId, string dataStreamId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendPath("/measurements/", false);
            uri.AppendPath(measurementId, true);
            uri.AppendPath("/dataStreams/", false);
            uri.AppendPath(dataStreamId, true);
            uri.AppendPath("/logs:getDataStreamLogsContainerLocation", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDiscoverySpecialFileUploadLocationsNextPageRequest(string nextLink, string discoveryId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllDiscoveryUploadsNextPageRequest(string nextLink, string discoveryId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUploadSpecialFilesNextPageRequest(string nextLink, string uploadId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUploadDataFilesNextPageRequest(string nextLink, string uploadId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementsNextPageRequest(string nextLink, string uploadId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationSchemasNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementsNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementsWithMetadataNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementsByIdsNextPageRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementStateMachinesNextPageRequest(string nextLink, string measurementId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMeasurementClassificationsNextPageRequest(string nextLink, string measurementId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllDataStreamNextPageRequest(string nextLink, string measurementId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDataStreamsByTagsNextPageRequest(string nextLink, string measurementId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDataStreamsByLineageNextPageRequest(string nextLink, string measurementId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDataStreamLineageGraphsByLineageNextPageRequest(string nextLink, string measurementId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDataStreamFilesNextPageRequest(string nextLink, string measurementId, string dataStreamId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
        private static ResponseClassifier _responseClassifier202204;
        private static ResponseClassifier ResponseClassifier202204 => _responseClassifier202204 ??= new StatusCodeClassifier(stackalloc ushort[] { 202, 204 });
    }
}
