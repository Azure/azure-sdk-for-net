// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Analytics.Synapse.Artifacts.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.Synapse.Artifacts
{
    /// <summary> The Library service client. </summary>
    internal partial class LibraryClient
    {
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly HttpPipeline _pipeline;
        internal LibraryRestClient RestClient { get; }

        /// <summary> Initializes a new instance of LibraryClient for mocking. </summary>
        protected LibraryClient()
        {
        }

        /// <summary> Initializes a new instance of LibraryClient. </summary>
        /// <param name="endpoint"> The workspace development endpoint, for example https://myworkspace.dev.azuresynapse.net. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        public LibraryClient(string endpoint, TokenCredential credential, ArtifactsClientOptions options = null)
        {
            if (endpoint == null)
            {
                throw new ArgumentNullException(nameof(endpoint));
            }
            if (credential == null)
            {
                throw new ArgumentNullException(nameof(credential));
            }

            options ??= new ArtifactsClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            string[] scopes = { "https://dev.azuresynapse.net/.default" };
            _pipeline = HttpPipelineBuilder.Build(options, new BearerTokenAuthenticationPolicy(credential, scopes));
            RestClient = new LibraryRestClient(_clientDiagnostics, _pipeline, endpoint, options.Version);
        }

        /// <summary> Initializes a new instance of LibraryClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> The workspace development endpoint, for example https://myworkspace.dev.azuresynapse.net. </param>
        /// <param name="apiVersion"> Api Version. </param>
        internal LibraryClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string endpoint, string apiVersion = "2019-06-01-preview")
        {
            RestClient = new LibraryRestClient(clientDiagnostics, pipeline, endpoint, apiVersion);
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        /// <summary> Get Operation result for Library. </summary>
        /// <param name="operationId"> operation id for which status is requested. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<object>> GetOperationResultAsync(string operationId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("LibraryClient.GetOperationResult");
            scope.Start();
            try
            {
                return await RestClient.GetOperationResultAsync(operationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get Operation result for Library. </summary>
        /// <param name="operationId"> operation id for which status is requested. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<object> GetOperationResult(string operationId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("LibraryClient.GetOperationResult");
            scope.Start();
            try
            {
                return RestClient.GetOperationResult(operationId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get Library. </summary>
        /// <param name="libraryName"> file name to upload. Minimum length of the filename should be 1 excluding the extension length. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<LibraryResource>> GetAsync(string libraryName, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("LibraryClient.Get");
            scope.Start();
            try
            {
                return await RestClient.GetAsync(libraryName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get Library. </summary>
        /// <param name="libraryName"> file name to upload. Minimum length of the filename should be 1 excluding the extension length. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<LibraryResource> Get(string libraryName, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("LibraryClient.Get");
            scope.Start();
            try
            {
                return RestClient.Get(libraryName, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists Library. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<LibraryResource> ListAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<LibraryResource>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("LibraryClient.List");
                scope.Start();
                try
                {
                    var response = await RestClient.ListAsync(cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<LibraryResource>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("LibraryClient.List");
                scope.Start();
                try
                {
                    var response = await RestClient.ListNextPageAsync(nextLink, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists Library. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<LibraryResource> List(CancellationToken cancellationToken = default)
        {
            Page<LibraryResource> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("LibraryClient.List");
                scope.Start();
                try
                {
                    var response = RestClient.List(cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<LibraryResource> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("LibraryClient.List");
                scope.Start();
                try
                {
                    var response = RestClient.ListNextPage(nextLink, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Flush Library. </summary>
        /// <param name="libraryName"> file name to upload. Minimum length of the filename should be 1 excluding the extension length. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="libraryName"/> is null. </exception>
        public virtual async Task<LibraryFlushOperation> StartFlushAsync(string libraryName, CancellationToken cancellationToken = default)
        {
            if (libraryName == null)
            {
                throw new ArgumentNullException(nameof(libraryName));
            }

            using var scope = _clientDiagnostics.CreateScope("LibraryClient.StartFlush");
            scope.Start();
            try
            {
                var originalResponse = await RestClient.FlushAsync(libraryName, cancellationToken).ConfigureAwait(false);
                return new LibraryFlushOperation(_clientDiagnostics, _pipeline, RestClient.CreateFlushRequest(libraryName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Flush Library. </summary>
        /// <param name="libraryName"> file name to upload. Minimum length of the filename should be 1 excluding the extension length. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="libraryName"/> is null. </exception>
        public virtual LibraryFlushOperation StartFlush(string libraryName, CancellationToken cancellationToken = default)
        {
            if (libraryName == null)
            {
                throw new ArgumentNullException(nameof(libraryName));
            }

            using var scope = _clientDiagnostics.CreateScope("LibraryClient.StartFlush");
            scope.Start();
            try
            {
                var originalResponse = RestClient.Flush(libraryName, cancellationToken);
                return new LibraryFlushOperation(_clientDiagnostics, _pipeline, RestClient.CreateFlushRequest(libraryName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete Library. </summary>
        /// <param name="libraryName"> file name to upload. Minimum length of the filename should be 1 excluding the extension length. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="libraryName"/> is null. </exception>
        public virtual async Task<LibraryDeleteOperation> StartDeleteAsync(string libraryName, CancellationToken cancellationToken = default)
        {
            if (libraryName == null)
            {
                throw new ArgumentNullException(nameof(libraryName));
            }

            using var scope = _clientDiagnostics.CreateScope("LibraryClient.StartDelete");
            scope.Start();
            try
            {
                var originalResponse = await RestClient.DeleteAsync(libraryName, cancellationToken).ConfigureAwait(false);
                return new LibraryDeleteOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteRequest(libraryName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete Library. </summary>
        /// <param name="libraryName"> file name to upload. Minimum length of the filename should be 1 excluding the extension length. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="libraryName"/> is null. </exception>
        public virtual LibraryDeleteOperation StartDelete(string libraryName, CancellationToken cancellationToken = default)
        {
            if (libraryName == null)
            {
                throw new ArgumentNullException(nameof(libraryName));
            }

            using var scope = _clientDiagnostics.CreateScope("LibraryClient.StartDelete");
            scope.Start();
            try
            {
                var originalResponse = RestClient.Delete(libraryName, cancellationToken);
                return new LibraryDeleteOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteRequest(libraryName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a library with the library name. Use query param &apos;comp=appendblock&apos; to append the data to the library resource created using the create operation. </summary>
        /// <param name="libraryName"> file name to upload. Minimum length of the filename should be 1 excluding the extension length. </param>
        /// <param name="comp"> If this param is specified with value appendblock, the api will append the data chunk provided in body to the library created. </param>
        /// <param name="xMsBlobConditionAppendpos"> Set this header to a byte offset at which the block is expected to be appended. The request succeeds only if the current offset matches this value. Otherwise, the request fails with the AppendPositionConditionNotMet error (HTTP status code 412 – Precondition Failed). </param>
        /// <param name="content"> Library file chunk. Use this content in with append operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="libraryName"/> is null. </exception>
        public virtual async Task<LibraryCreateOrAppendOperation> StartCreateOrAppendAsync(string libraryName, string comp = null, long? xMsBlobConditionAppendpos = null, Stream content = null, CancellationToken cancellationToken = default)
        {
            if (libraryName == null)
            {
                throw new ArgumentNullException(nameof(libraryName));
            }

            using var scope = _clientDiagnostics.CreateScope("LibraryClient.StartCreateOrAppend");
            scope.Start();
            try
            {
                var originalResponse = await RestClient.CreateOrAppendAsync(libraryName, comp, xMsBlobConditionAppendpos, content, cancellationToken).ConfigureAwait(false);
                return new LibraryCreateOrAppendOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrAppendRequest(libraryName, comp, xMsBlobConditionAppendpos, content).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a library with the library name. Use query param &apos;comp=appendblock&apos; to append the data to the library resource created using the create operation. </summary>
        /// <param name="libraryName"> file name to upload. Minimum length of the filename should be 1 excluding the extension length. </param>
        /// <param name="comp"> If this param is specified with value appendblock, the api will append the data chunk provided in body to the library created. </param>
        /// <param name="xMsBlobConditionAppendpos"> Set this header to a byte offset at which the block is expected to be appended. The request succeeds only if the current offset matches this value. Otherwise, the request fails with the AppendPositionConditionNotMet error (HTTP status code 412 – Precondition Failed). </param>
        /// <param name="content"> Library file chunk. Use this content in with append operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="libraryName"/> is null. </exception>
        public virtual LibraryCreateOrAppendOperation StartCreateOrAppend(string libraryName, string comp = null, long? xMsBlobConditionAppendpos = null, Stream content = null, CancellationToken cancellationToken = default)
        {
            if (libraryName == null)
            {
                throw new ArgumentNullException(nameof(libraryName));
            }

            using var scope = _clientDiagnostics.CreateScope("LibraryClient.StartCreateOrAppend");
            scope.Start();
            try
            {
                var originalResponse = RestClient.CreateOrAppend(libraryName, comp, xMsBlobConditionAppendpos, content, cancellationToken);
                return new LibraryCreateOrAppendOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrAppendRequest(libraryName, comp, xMsBlobConditionAppendpos, content).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
