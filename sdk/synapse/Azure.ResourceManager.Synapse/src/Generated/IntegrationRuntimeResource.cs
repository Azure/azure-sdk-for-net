// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.Synapse.Models;

namespace Azure.ResourceManager.Synapse
{
    /// <summary>
    /// A Class representing an IntegrationRuntimeResource along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier" /> you can construct an <see cref="IntegrationRuntimeResource" />
    /// from an instance of <see cref="ArmClient" /> using the GetIntegrationRuntimeResource method.
    /// Otherwise you can get one from its parent resource <see cref="WorkspaceResource" /> using the GetIntegrationRuntimeResource method.
    /// </summary>
    public partial class IntegrationRuntimeResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="IntegrationRuntimeResource"/> instance. </summary>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string workspaceName, string integrationRuntimeName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics;
        private readonly IntegrationRuntimesRestOperations _integrationRuntimeResourceIntegrationRuntimesRestClient;
        private readonly ClientDiagnostics _integrationRuntimeNodeIPAddressClientDiagnostics;
        private readonly IntegrationRuntimeNodeIpAddressRestOperations _integrationRuntimeNodeIPAddressRestClient;
        private readonly ClientDiagnostics _integrationRuntimeObjectMetadataClientDiagnostics;
        private readonly IntegrationRuntimeObjectMetadataRestOperations _integrationRuntimeObjectMetadataRestClient;
        private readonly ClientDiagnostics _integrationRuntimeNodesClientDiagnostics;
        private readonly IntegrationRuntimeNodesRestOperations _integrationRuntimeNodesRestClient;
        private readonly ClientDiagnostics _integrationRuntimeCredentialsClientDiagnostics;
        private readonly IntegrationRuntimeCredentialsRestOperations _integrationRuntimeCredentialsRestClient;
        private readonly ClientDiagnostics _integrationRuntimeConnectionInfosClientDiagnostics;
        private readonly IntegrationRuntimeConnectionInfosRestOperations _integrationRuntimeConnectionInfosRestClient;
        private readonly ClientDiagnostics _integrationRuntimeAuthKeysClientDiagnostics;
        private readonly IntegrationRuntimeAuthKeysRestOperations _integrationRuntimeAuthKeysRestClient;
        private readonly ClientDiagnostics _integrationRuntimeMonitoringDataClientDiagnostics;
        private readonly IntegrationRuntimeMonitoringDataRestOperations _integrationRuntimeMonitoringDataRestClient;
        private readonly ClientDiagnostics _integrationRuntimeStatusClientDiagnostics;
        private readonly IntegrationRuntimeStatusRestOperations _integrationRuntimeStatusRestClient;
        private readonly IntegrationRuntimeResourceData _data;

        /// <summary> Initializes a new instance of the <see cref="IntegrationRuntimeResource"/> class for mocking. </summary>
        protected IntegrationRuntimeResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref = "IntegrationRuntimeResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal IntegrationRuntimeResource(ArmClient client, IntegrationRuntimeResourceData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="IntegrationRuntimeResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal IntegrationRuntimeResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string integrationRuntimeResourceIntegrationRuntimesApiVersion);
            _integrationRuntimeResourceIntegrationRuntimesRestClient = new IntegrationRuntimesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, integrationRuntimeResourceIntegrationRuntimesApiVersion);
            _integrationRuntimeNodeIPAddressClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ProviderConstants.DefaultProviderNamespace, Diagnostics);
            _integrationRuntimeNodeIPAddressRestClient = new IntegrationRuntimeNodeIpAddressRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
            _integrationRuntimeObjectMetadataClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ProviderConstants.DefaultProviderNamespace, Diagnostics);
            _integrationRuntimeObjectMetadataRestClient = new IntegrationRuntimeObjectMetadataRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
            _integrationRuntimeNodesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ProviderConstants.DefaultProviderNamespace, Diagnostics);
            _integrationRuntimeNodesRestClient = new IntegrationRuntimeNodesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
            _integrationRuntimeCredentialsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ProviderConstants.DefaultProviderNamespace, Diagnostics);
            _integrationRuntimeCredentialsRestClient = new IntegrationRuntimeCredentialsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
            _integrationRuntimeConnectionInfosClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ProviderConstants.DefaultProviderNamespace, Diagnostics);
            _integrationRuntimeConnectionInfosRestClient = new IntegrationRuntimeConnectionInfosRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
            _integrationRuntimeAuthKeysClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ProviderConstants.DefaultProviderNamespace, Diagnostics);
            _integrationRuntimeAuthKeysRestClient = new IntegrationRuntimeAuthKeysRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
            _integrationRuntimeMonitoringDataClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ProviderConstants.DefaultProviderNamespace, Diagnostics);
            _integrationRuntimeMonitoringDataRestClient = new IntegrationRuntimeMonitoringDataRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
            _integrationRuntimeStatusClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.Synapse", ProviderConstants.DefaultProviderNamespace, Diagnostics);
            _integrationRuntimeStatusRestClient = new IntegrationRuntimeStatusRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Synapse/workspaces/integrationRuntimes";

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual IntegrationRuntimeResourceData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}
        /// Operation Id: IntegrationRuntimes_Get
        /// </summary>
        /// <param name="ifNoneMatch"> ETag of the integration runtime entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will be returned. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IntegrationRuntimeResource>> GetAsync(string ifNoneMatch = null, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Get");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, ifNoneMatch, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new IntegrationRuntimeResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}
        /// Operation Id: IntegrationRuntimes_Get
        /// </summary>
        /// <param name="ifNoneMatch"> ETag of the integration runtime entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will be returned. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeResource> Get(string ifNoneMatch = null, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Get");
            scope.Start();
            try
            {
                var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, ifNoneMatch, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new IntegrationRuntimeResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}
        /// Operation Id: IntegrationRuntimes_Delete
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Delete");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new SynapseArmOperation(_integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}
        /// Operation Id: IntegrationRuntimes_Delete
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Delete");
            scope.Start();
            try
            {
                var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new SynapseArmOperation(_integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}
        /// Operation Id: IntegrationRuntimes_Update
        /// </summary>
        /// <param name="patch"> The parameters for updating an integration runtime. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<Response<IntegrationRuntimeResource>> UpdateAsync(IntegrationRuntimeResourcePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Update");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new IntegrationRuntimeResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}
        /// Operation Id: IntegrationRuntimes_Update
        /// </summary>
        /// <param name="patch"> The parameters for updating an integration runtime. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual Response<IntegrationRuntimeResource> Update(IntegrationRuntimeResourcePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Update");
            scope.Start();
            try
            {
                var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken);
                return Response.FromValue(new IntegrationRuntimeResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Upgrade an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/upgrade
        /// Operation Id: IntegrationRuntimes_Upgrade
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> UpgradeAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Upgrade");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.UpgradeAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Upgrade an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/upgrade
        /// Operation Id: IntegrationRuntimes_Upgrade
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response Upgrade(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Upgrade");
            scope.Start();
            try
            {
                var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.Upgrade(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Start an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/start
        /// Operation Id: IntegrationRuntimes_Start
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<IntegrationRuntimeStatusResponse>> StartAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Start");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.StartAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new SynapseArmOperation<IntegrationRuntimeStatusResponse>(new IntegrationRuntimeStatusResponseOperationSource(), _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateStartRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Start an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/start
        /// Operation Id: IntegrationRuntimes_Start
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<IntegrationRuntimeStatusResponse> Start(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Start");
            scope.Start();
            try
            {
                var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.Start(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new SynapseArmOperation<IntegrationRuntimeStatusResponse>(new IntegrationRuntimeStatusResponseOperationSource(), _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateStartRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Stop an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/stop
        /// Operation Id: IntegrationRuntimes_Stop
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> StopAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Stop");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.StopAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new SynapseArmOperation(_integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateStopRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Stop an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/stop
        /// Operation Id: IntegrationRuntimes_Stop
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Stop(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.Stop");
            scope.Start();
            try
            {
                var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.Stop(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new SynapseArmOperation(_integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateStopRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the list of outbound network dependencies for a given Azure-SSIS integration runtime.
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/outboundNetworkDependenciesEndpoints
        /// Operation Id: IntegrationRuntimes_ListOutboundNetworkDependenciesEndpoints
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint> GetOutboundNetworkDependenciesEndpointsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetOutboundNetworkDependenciesEndpoints");
                scope.Start();
                try
                {
                    var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.ListOutboundNetworkDependenciesEndpointsAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary>
        /// Gets the list of outbound network dependencies for a given Azure-SSIS integration runtime.
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/outboundNetworkDependenciesEndpoints
        /// Operation Id: IntegrationRuntimes_ListOutboundNetworkDependenciesEndpoints
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint> GetOutboundNetworkDependenciesEndpoints(CancellationToken cancellationToken = default)
        {
            Page<IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetOutboundNetworkDependenciesEndpoints");
                scope.Start();
                try
                {
                    var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.ListOutboundNetworkDependenciesEndpoints(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary>
        /// Enable interactive query in integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/enableInteractiveQuery
        /// Operation Id: IntegrationRuntimes_EnableInteractiveQuery
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> EnableInteractiveQueryAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.EnableInteractiveQuery");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.EnableInteractiveQueryAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new SynapseArmOperation(_integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateEnableInteractiveQueryRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Enable interactive query in integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/enableInteractiveQuery
        /// Operation Id: IntegrationRuntimes_EnableInteractiveQuery
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation EnableInteractiveQuery(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.EnableInteractiveQuery");
            scope.Start();
            try
            {
                var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.EnableInteractiveQuery(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new SynapseArmOperation(_integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateEnableInteractiveQueryRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Disable interactive query in integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/disableInteractiveQuery
        /// Operation Id: IntegrationRuntimes_DisableInteractiveQuery
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DisableInteractiveQueryAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.DisableInteractiveQuery");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeResourceIntegrationRuntimesRestClient.DisableInteractiveQueryAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new SynapseArmOperation(_integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateDisableInteractiveQueryRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Disable interactive query in integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/disableInteractiveQuery
        /// Operation Id: IntegrationRuntimes_DisableInteractiveQuery
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DisableInteractiveQuery(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeResourceIntegrationRuntimesClientDiagnostics.CreateScope("IntegrationRuntimeResource.DisableInteractiveQuery");
            scope.Start();
            try
            {
                var response = _integrationRuntimeResourceIntegrationRuntimesRestClient.DisableInteractiveQuery(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new SynapseArmOperation(_integrationRuntimeResourceIntegrationRuntimesClientDiagnostics, Pipeline, _integrationRuntimeResourceIntegrationRuntimesRestClient.CreateDisableInteractiveQueryRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the IP address of an integration runtime node
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}/ipAddress
        /// Operation Id: IntegrationRuntimeNodeIpAddress_Get
        /// </summary>
        /// <param name="nodeName"> Integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="nodeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual async Task<Response<IntegrationRuntimeNodeIPAddress>> GetIntegrationRuntimeNodeIpAddresAsync(string nodeName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(nodeName, nameof(nodeName));

            using var scope = _integrationRuntimeNodeIPAddressClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeNodeIpAddres");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeNodeIPAddressRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the IP address of an integration runtime node
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}/ipAddress
        /// Operation Id: IntegrationRuntimeNodeIpAddress_Get
        /// </summary>
        /// <param name="nodeName"> Integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="nodeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual Response<IntegrationRuntimeNodeIPAddress> GetIntegrationRuntimeNodeIpAddres(string nodeName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(nodeName, nameof(nodeName));

            using var scope = _integrationRuntimeNodeIPAddressClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeNodeIpAddres");
            scope.Start();
            try
            {
                var response = _integrationRuntimeNodeIPAddressRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get object metadata from an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getObjectMetadata
        /// Operation Id: IntegrationRuntimeObjectMetadata_List
        /// </summary>
        /// <param name="content"> The parameters for getting a SSIS object metadata. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SsisObjectMetadata" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SsisObjectMetadata> GetAllIntegrationRuntimeObjectMetadataAsync(GetSsisObjectMetadataContent content = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<SsisObjectMetadata>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _integrationRuntimeObjectMetadataClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetAllIntegrationRuntimeObjectMetadata");
                scope.Start();
                try
                {
                    var response = await _integrationRuntimeObjectMetadataRestClient.ListAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary>
        /// Get object metadata from an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getObjectMetadata
        /// Operation Id: IntegrationRuntimeObjectMetadata_List
        /// </summary>
        /// <param name="content"> The parameters for getting a SSIS object metadata. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SsisObjectMetadata" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SsisObjectMetadata> GetAllIntegrationRuntimeObjectMetadata(GetSsisObjectMetadataContent content = null, CancellationToken cancellationToken = default)
        {
            Page<SsisObjectMetadata> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _integrationRuntimeObjectMetadataClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetAllIntegrationRuntimeObjectMetadata");
                scope.Start();
                try
                {
                    var response = _integrationRuntimeObjectMetadataRestClient.List(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary>
        /// Refresh the object metadata in an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/refreshObjectMetadata
        /// Operation Id: IntegrationRuntimeObjectMetadata_Refresh
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<SsisObjectMetadataStatusResponse>> RefreshIntegrationRuntimeObjectMetadataAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeObjectMetadataClientDiagnostics.CreateScope("IntegrationRuntimeResource.RefreshIntegrationRuntimeObjectMetadata");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeObjectMetadataRestClient.RefreshAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new SynapseArmOperation<SsisObjectMetadataStatusResponse>(new SsisObjectMetadataStatusResponseOperationSource(), _integrationRuntimeObjectMetadataClientDiagnostics, Pipeline, _integrationRuntimeObjectMetadataRestClient.CreateRefreshRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Refresh the object metadata in an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/refreshObjectMetadata
        /// Operation Id: IntegrationRuntimeObjectMetadata_Refresh
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<SsisObjectMetadataStatusResponse> RefreshIntegrationRuntimeObjectMetadata(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeObjectMetadataClientDiagnostics.CreateScope("IntegrationRuntimeResource.RefreshIntegrationRuntimeObjectMetadata");
            scope.Start();
            try
            {
                var response = _integrationRuntimeObjectMetadataRestClient.Refresh(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new SynapseArmOperation<SsisObjectMetadataStatusResponse>(new SsisObjectMetadataStatusResponseOperationSource(), _integrationRuntimeObjectMetadataClientDiagnostics, Pipeline, _integrationRuntimeObjectMetadataRestClient.CreateRefreshRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get an integration runtime node
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}
        /// Operation Id: IntegrationRuntimeNodes_Get
        /// </summary>
        /// <param name="nodeName"> Integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="nodeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual async Task<Response<SelfHostedIntegrationRuntimeNode>> GetIntegrationRuntimeNodeAsync(string nodeName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(nodeName, nameof(nodeName));

            using var scope = _integrationRuntimeNodesClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeNodesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get an integration runtime node
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}
        /// Operation Id: IntegrationRuntimeNodes_Get
        /// </summary>
        /// <param name="nodeName"> Integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="nodeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual Response<SelfHostedIntegrationRuntimeNode> GetIntegrationRuntimeNode(string nodeName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(nodeName, nameof(nodeName));

            using var scope = _integrationRuntimeNodesClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = _integrationRuntimeNodesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create an integration runtime node
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}
        /// Operation Id: IntegrationRuntimeNodes_Update
        /// </summary>
        /// <param name="nodeName"> Integration runtime node name. </param>
        /// <param name="content"> The parameters for updating an integration runtime node. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="nodeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> or <paramref name="content"/> is null. </exception>
        public virtual async Task<Response<SelfHostedIntegrationRuntimeNode>> UpdateIntegrationRuntimeNodeAsync(string nodeName, UpdateIntegrationRuntimeNodeContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(nodeName, nameof(nodeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _integrationRuntimeNodesClientDiagnostics.CreateScope("IntegrationRuntimeResource.UpdateIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeNodesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, content, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create an integration runtime node
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}
        /// Operation Id: IntegrationRuntimeNodes_Update
        /// </summary>
        /// <param name="nodeName"> Integration runtime node name. </param>
        /// <param name="content"> The parameters for updating an integration runtime node. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="nodeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> or <paramref name="content"/> is null. </exception>
        public virtual Response<SelfHostedIntegrationRuntimeNode> UpdateIntegrationRuntimeNode(string nodeName, UpdateIntegrationRuntimeNodeContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(nodeName, nameof(nodeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _integrationRuntimeNodesClientDiagnostics.CreateScope("IntegrationRuntimeResource.UpdateIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = _integrationRuntimeNodesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, content, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete an integration runtime node
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}
        /// Operation Id: IntegrationRuntimeNodes_Delete
        /// </summary>
        /// <param name="nodeName"> Integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="nodeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual async Task<Response> DeleteIntegrationRuntimeNodeAsync(string nodeName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(nodeName, nameof(nodeName));

            using var scope = _integrationRuntimeNodesClientDiagnostics.CreateScope("IntegrationRuntimeResource.DeleteIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeNodesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete an integration runtime node
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}
        /// Operation Id: IntegrationRuntimeNodes_Delete
        /// </summary>
        /// <param name="nodeName"> Integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="nodeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual Response DeleteIntegrationRuntimeNode(string nodeName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(nodeName, nameof(nodeName));

            using var scope = _integrationRuntimeNodesClientDiagnostics.CreateScope("IntegrationRuntimeResource.DeleteIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = _integrationRuntimeNodesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across all worker nodes with those available on the dispatcher node. If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using this API directly.
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/syncCredentials
        /// Operation Id: IntegrationRuntimeCredentials_Sync
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> SyncIntegrationRuntimeCredentialAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeCredentialsClientDiagnostics.CreateScope("IntegrationRuntimeResource.SyncIntegrationRuntimeCredential");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeCredentialsRestClient.SyncAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across all worker nodes with those available on the dispatcher node. If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using this API directly.
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/syncCredentials
        /// Operation Id: IntegrationRuntimeCredentials_Sync
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response SyncIntegrationRuntimeCredential(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeCredentialsClientDiagnostics.CreateScope("IntegrationRuntimeResource.SyncIntegrationRuntimeCredential");
            scope.Start();
            try
            {
                var response = _integrationRuntimeCredentialsRestClient.Sync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get connection info for an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getConnectionInfo
        /// Operation Id: IntegrationRuntimeConnectionInfos_Get
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IntegrationRuntimeConnectionInfo>> GetIntegrationRuntimeConnectionInfoAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeConnectionInfosClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeConnectionInfo");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeConnectionInfosRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get connection info for an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getConnectionInfo
        /// Operation Id: IntegrationRuntimeConnectionInfos_Get
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeConnectionInfo> GetIntegrationRuntimeConnectionInfo(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeConnectionInfosClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeConnectionInfo");
            scope.Start();
            try
            {
                var response = _integrationRuntimeConnectionInfosRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Regenerate the authentication key for an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/regenerateAuthKey
        /// Operation Id: IntegrationRuntimeAuthKeys_Regenerate
        /// </summary>
        /// <param name="content"> The parameters for regenerating integration runtime authentication key. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<Response<IntegrationRuntimeAuthKeys>> RegenerateIntegrationRuntimeAuthKeyAsync(IntegrationRuntimeRegenerateKeyContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _integrationRuntimeAuthKeysClientDiagnostics.CreateScope("IntegrationRuntimeResource.RegenerateIntegrationRuntimeAuthKey");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeAuthKeysRestClient.RegenerateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Regenerate the authentication key for an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/regenerateAuthKey
        /// Operation Id: IntegrationRuntimeAuthKeys_Regenerate
        /// </summary>
        /// <param name="content"> The parameters for regenerating integration runtime authentication key. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual Response<IntegrationRuntimeAuthKeys> RegenerateIntegrationRuntimeAuthKey(IntegrationRuntimeRegenerateKeyContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _integrationRuntimeAuthKeysClientDiagnostics.CreateScope("IntegrationRuntimeResource.RegenerateIntegrationRuntimeAuthKey");
            scope.Start();
            try
            {
                var response = _integrationRuntimeAuthKeysRestClient.Regenerate(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List authentication keys in an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/listAuthKeys
        /// Operation Id: IntegrationRuntimeAuthKeys_List
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IntegrationRuntimeAuthKeys>> GetIntegrationRuntimeAuthKeyAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeAuthKeysClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeAuthKey");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeAuthKeysRestClient.ListAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List authentication keys in an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/listAuthKeys
        /// Operation Id: IntegrationRuntimeAuthKeys_List
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeAuthKeys> GetIntegrationRuntimeAuthKey(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeAuthKeysClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeAuthKey");
            scope.Start();
            try
            {
                var response = _integrationRuntimeAuthKeysRestClient.List(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get monitoring data for an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/monitoringData
        /// Operation Id: IntegrationRuntimeMonitoringData_List
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IntegrationRuntimeMonitoringData>> GetIntegrationRuntimeMonitoringDataAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeMonitoringDataClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeMonitoringData");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeMonitoringDataRestClient.ListAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get monitoring data for an integration runtime
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/monitoringData
        /// Operation Id: IntegrationRuntimeMonitoringData_List
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeMonitoringData> GetIntegrationRuntimeMonitoringData(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeMonitoringDataClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeMonitoringData");
            scope.Start();
            try
            {
                var response = _integrationRuntimeMonitoringDataRestClient.List(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the integration runtime status
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getStatus
        /// Operation Id: IntegrationRuntimeStatus_Get
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IntegrationRuntimeStatusResponse>> GetIntegrationRuntimeStatusAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeStatusClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeStatus");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeStatusRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the integration runtime status
        /// Request Path: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getStatus
        /// Operation Id: IntegrationRuntimeStatus_Get
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeStatusResponse> GetIntegrationRuntimeStatus(CancellationToken cancellationToken = default)
        {
            using var scope = _integrationRuntimeStatusClientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeStatus");
            scope.Start();
            try
            {
                var response = _integrationRuntimeStatusRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
