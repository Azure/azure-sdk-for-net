// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Microsoft.Azure.Management.VideoAnalyzer.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Pipeline topology describes the processing steps to be applied when
    /// processing content for a particular outcome. The topology should be
    /// defined according to the scenario to be achieved and can be reused
    /// across many pipeline instances which share the same processing
    /// characteristics. For instance, a pipeline topology which captures
    /// content from a RTSP camera and archives the content can be reused
    /// across many different cameras, as long as the same processing is to be
    /// applied across all the cameras. Individual instance properties can be
    /// defined through the use of user-defined parameters, which allow for a
    /// topology to be parameterized. This allows  individual pipelines refer
    /// to different values, such as individual cameras' RTSP endpoints and
    /// credentials. Overall a topology is composed of the following:
    ///
    /// - Parameters: list of user defined parameters that can be references
    /// across the topology nodes.
    /// - Sources: list of one or more data sources nodes such as an RTSP
    /// source which allows for content to be ingested from cameras.
    /// - Processors: list of nodes which perform data analysis or
    /// transformations.
    /// - Sinks: list of one or more data sinks which allow for data to be
    /// stored or exported to other destinations.
    /// </summary>
    [Rest.Serialization.JsonTransformation]
    public partial class PipelineTopologyUpdate : ProxyResource
    {
        /// <summary>
        /// Initializes a new instance of the PipelineTopologyUpdate class.
        /// </summary>
        public PipelineTopologyUpdate()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the PipelineTopologyUpdate class.
        /// </summary>
        /// <param name="id">Fully qualified resource ID for the resource. Ex -
        /// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}</param>
        /// <param name="name">The name of the resource</param>
        /// <param name="type">The type of the resource. E.g.
        /// "Microsoft.Compute/virtualMachines" or
        /// "Microsoft.Storage/storageAccounts"</param>
        /// <param name="systemData">Azure Resource Manager metadata containing
        /// createdBy and modifiedBy information.</param>
        /// <param name="description">An optional description of the pipeline
        /// topology. It is recommended that the expected use of the topology
        /// to be described here.</param>
        /// <param name="parameters">List of the topology parameter
        /// declarations. Parameters declared here can be referenced throughout
        /// the topology nodes through the use of "${PARAMETER_NAME}" string
        /// pattern. Parameters can have optional default values and can later
        /// be defined in individual instances of the pipeline.</param>
        /// <param name="sources">List of the topology source nodes. Source
        /// nodes enable external data to be ingested by the pipeline.</param>
        /// <param name="processors">List of the topology processor nodes.
        /// Processor nodes enable pipeline data to be analyzed, processed or
        /// transformed.</param>
        /// <param name="sinks">List of the topology sink nodes. Sink nodes
        /// allow pipeline data to be stored or exported.</param>
        /// <param name="kind">Topology kind. Possible values include: 'Live',
        /// 'Batch'</param>
        /// <param name="sku">Describes the properties of a SKU.</param>
        public PipelineTopologyUpdate(string id = default(string), string name = default(string), string type = default(string), SystemData systemData = default(SystemData), string description = default(string), IList<ParameterDeclaration> parameters = default(IList<ParameterDeclaration>), IList<SourceNodeBase> sources = default(IList<SourceNodeBase>), IList<ProcessorNodeBase> processors = default(IList<ProcessorNodeBase>), IList<SinkNodeBase> sinks = default(IList<SinkNodeBase>), Kind? kind = default(Kind?), Sku sku = default(Sku))
            : base(id, name, type, systemData)
        {
            Description = description;
            Parameters = parameters;
            Sources = sources;
            Processors = processors;
            Sinks = sinks;
            Kind = kind;
            Sku = sku;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets an optional description of the pipeline topology. It
        /// is recommended that the expected use of the topology to be
        /// described here.
        /// </summary>
        [JsonProperty(PropertyName = "properties.description")]
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets list of the topology parameter declarations.
        /// Parameters declared here can be referenced throughout the topology
        /// nodes through the use of "${PARAMETER_NAME}" string pattern.
        /// Parameters can have optional default values and can later be
        /// defined in individual instances of the pipeline.
        /// </summary>
        [JsonProperty(PropertyName = "properties.parameters")]
        public IList<ParameterDeclaration> Parameters { get; set; }

        /// <summary>
        /// Gets or sets list of the topology source nodes. Source nodes enable
        /// external data to be ingested by the pipeline.
        /// </summary>
        [JsonProperty(PropertyName = "properties.sources")]
        public IList<SourceNodeBase> Sources { get; set; }

        /// <summary>
        /// Gets or sets list of the topology processor nodes. Processor nodes
        /// enable pipeline data to be analyzed, processed or transformed.
        /// </summary>
        [JsonProperty(PropertyName = "properties.processors")]
        public IList<ProcessorNodeBase> Processors { get; set; }

        /// <summary>
        /// Gets or sets list of the topology sink nodes. Sink nodes allow
        /// pipeline data to be stored or exported.
        /// </summary>
        [JsonProperty(PropertyName = "properties.sinks")]
        public IList<SinkNodeBase> Sinks { get; set; }

        /// <summary>
        /// Gets or sets topology kind. Possible values include: 'Live',
        /// 'Batch'
        /// </summary>
        [JsonProperty(PropertyName = "kind")]
        public Kind? Kind { get; set; }

        /// <summary>
        /// Gets or sets describes the properties of a SKU.
        /// </summary>
        [JsonProperty(PropertyName = "sku")]
        public Sku Sku { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Parameters != null)
            {
                foreach (var element in Parameters)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
            if (Sources != null)
            {
                foreach (var element1 in Sources)
                {
                    if (element1 != null)
                    {
                        element1.Validate();
                    }
                }
            }
            if (Processors != null)
            {
                foreach (var element2 in Processors)
                {
                    if (element2 != null)
                    {
                        element2.Validate();
                    }
                }
            }
            if (Sinks != null)
            {
                foreach (var element3 in Sinks)
                {
                    if (element3 != null)
                    {
                        element3.Validate();
                    }
                }
            }
            if (Sku != null)
            {
                Sku.Validate();
            }
        }
    }
}
