// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.AI.DocumentIntelligence
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class DocumentIntelligenceModelFactory
    {

        /// <summary> The error object. </summary>
        /// <param name="code"> One of a server-defined set of error codes. </param>
        /// <param name="message"> A human-readable representation of the error. </param>
        /// <param name="target"> The target of the error. </param>
        /// <param name="details"> An array of details about specific errors that led to this reported error. </param>
        /// <param name="innerError"> An object containing more specific information than the current object about the error. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentIntelligenceError"/> instance for mocking. </returns>
        public static DocumentIntelligenceError DocumentIntelligenceError(string code = default, string message = default, string target = default, IEnumerable<DocumentIntelligenceError> details = default, DocumentIntelligenceInnerError innerError = default)
        {
            details ??= new ChangeTrackingList<DocumentIntelligenceError>();

            return new DocumentIntelligenceError(
                code,
                message,
                target,
                details.ToList(),
                innerError,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object containing more specific information about the error. </summary>
        /// <param name="code"> One of a server-defined set of error codes. </param>
        /// <param name="message"> A human-readable representation of the error. </param>
        /// <param name="innerError"> Inner error. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentIntelligenceInnerError"/> instance for mocking. </returns>
        public static DocumentIntelligenceInnerError DocumentIntelligenceInnerError(string code = default, string message = default, DocumentIntelligenceInnerError innerError = default)
        {
            return new DocumentIntelligenceInnerError(code, message, innerError, additionalBinaryDataProperties: null);
        }

        /// <summary> Content and layout elements extracted from a page from the input. </summary>
        /// <param name="pageNumber"> 1-based page number in the input document. </param>
        /// <param name="angle">
        /// The general orientation of the content in clockwise direction, measured in
        /// degrees between (-180, 180].
        /// </param>
        /// <param name="width"> The width of the image/PDF in pixels/inches, respectively. </param>
        /// <param name="height"> The height of the image/PDF in pixels/inches, respectively. </param>
        /// <param name="unit">
        /// The unit used by the width, height, and polygon properties. For images, the
        /// unit is "pixel". For PDF, the unit is "inch".
        /// </param>
        /// <param name="spans"> Location of the page in the reading order concatenated content. </param>
        /// <param name="words"> Extracted words from the page. </param>
        /// <param name="selectionMarks"> Extracted selection marks from the page. </param>
        /// <param name="lines">
        /// Extracted lines from the page, potentially containing both textual and visual
        /// elements.
        /// </param>
        /// <param name="barcodes"> Extracted barcodes from the page. </param>
        /// <param name="formulas"> Extracted formulas from the page. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentPage"/> instance for mocking. </returns>
        public static DocumentPage DocumentPage(int pageNumber = default, float? angle = default, float? width = default, float? height = default, LengthUnit? unit = default, IEnumerable<DocumentSpan> spans = default, IEnumerable<DocumentWord> words = default, IEnumerable<DocumentSelectionMark> selectionMarks = default, IEnumerable<DocumentLine> lines = default, IEnumerable<DocumentBarcode> barcodes = default, IEnumerable<DocumentFormula> formulas = default)
        {
            spans ??= new ChangeTrackingList<DocumentSpan>();
            words ??= new ChangeTrackingList<DocumentWord>();
            selectionMarks ??= new ChangeTrackingList<DocumentSelectionMark>();
            lines ??= new ChangeTrackingList<DocumentLine>();
            barcodes ??= new ChangeTrackingList<DocumentBarcode>();
            formulas ??= new ChangeTrackingList<DocumentFormula>();

            return new DocumentPage(
                pageNumber,
                angle,
                width,
                height,
                unit,
                spans.ToList(),
                words.ToList(),
                selectionMarks.ToList(),
                lines.ToList(),
                barcodes.ToList(),
                formulas.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Contiguous region of the concatenated content property, specified as an offset
        /// and length.
        /// </summary>
        /// <param name="offset"> Zero-based index of the content represented by the span. </param>
        /// <param name="length"> Number of characters in the content represented by the span. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentSpan"/> instance for mocking. </returns>
        public static DocumentSpan DocumentSpan(int offset = default, int length = default)
        {
            return new DocumentSpan(offset, length, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// A word object consisting of a contiguous sequence of characters.  For non-space
        /// delimited languages, such as Chinese, Japanese, and Korean, each character is
        /// represented as its own word.
        /// </summary>
        /// <param name="content"> Text content of the word. </param>
        /// <param name="polygon">
        /// Bounding polygon of the word, with coordinates specified relative to the
        /// top-left of the page. The numbers represent the x, y values of the polygon
        /// vertices, clockwise from the left (-180 degrees inclusive) relative to the
        /// element orientation.
        /// </param>
        /// <param name="span"> Location of the word in the reading order concatenated content. </param>
        /// <param name="confidence"> Confidence of correctly extracting the word. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentWord"/> instance for mocking. </returns>
        public static DocumentWord DocumentWord(string content = default, IEnumerable<float> polygon = default, DocumentSpan span = default, float confidence = default)
        {
            polygon ??= new ChangeTrackingList<float>();

            return new DocumentWord(content, polygon.ToList(), span, confidence, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// A selection mark object representing check boxes, radio buttons, and other
        /// elements indicating a selection.
        /// </summary>
        /// <param name="state"> State of the selection mark. </param>
        /// <param name="polygon">
        /// Bounding polygon of the selection mark, with coordinates specified relative
        /// to the top-left of the page. The numbers represent the x, y values of the
        /// polygon vertices, clockwise from the left (-180 degrees inclusive) relative
        /// to the element orientation.
        /// </param>
        /// <param name="span"> Location of the selection mark in the reading order concatenated content. </param>
        /// <param name="confidence"> Confidence of correctly extracting the selection mark. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentSelectionMark"/> instance for mocking. </returns>
        public static DocumentSelectionMark DocumentSelectionMark(DocumentSelectionMarkState state = default, IEnumerable<float> polygon = default, DocumentSpan span = default, float confidence = default)
        {
            polygon ??= new ChangeTrackingList<float>();

            return new DocumentSelectionMark(state, polygon.ToList(), span, confidence, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// A content line object consisting of an adjacent sequence of content elements,
        /// such as words and selection marks.
        /// </summary>
        /// <param name="content"> Concatenated content of the contained elements in reading order. </param>
        /// <param name="polygon">
        /// Bounding polygon of the line, with coordinates specified relative to the
        /// top-left of the page. The numbers represent the x, y values of the polygon
        /// vertices, clockwise from the left (-180 degrees inclusive) relative to the
        /// element orientation.
        /// </param>
        /// <param name="spans"> Location of the line in the reading order concatenated content. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentLine"/> instance for mocking. </returns>
        public static DocumentLine DocumentLine(string content = default, IEnumerable<float> polygon = default, IEnumerable<DocumentSpan> spans = default)
        {
            polygon ??= new ChangeTrackingList<float>();
            spans ??= new ChangeTrackingList<DocumentSpan>();

            return new DocumentLine(content, polygon.ToList(), spans.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> A barcode object. </summary>
        /// <param name="kind"> Barcode kind. </param>
        /// <param name="value"> Barcode value. </param>
        /// <param name="polygon">
        /// Bounding polygon of the barcode, with coordinates specified relative to the
        /// top-left of the page. The numbers represent the x, y values of the polygon
        /// vertices, clockwise from the left (-180 degrees inclusive) relative to the
        /// element orientation.
        /// </param>
        /// <param name="span"> Location of the barcode in the reading order concatenated content. </param>
        /// <param name="confidence"> Confidence of correctly extracting the barcode. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentBarcode"/> instance for mocking. </returns>
        public static DocumentBarcode DocumentBarcode(DocumentBarcodeKind kind = default, string value = default, IEnumerable<float> polygon = default, DocumentSpan span = default, float confidence = default)
        {
            polygon ??= new ChangeTrackingList<float>();

            return new DocumentBarcode(
                kind,
                value,
                polygon.ToList(),
                span,
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary> A formula object. </summary>
        /// <param name="kind"> Formula kind. </param>
        /// <param name="value"> LaTex expression describing the formula. </param>
        /// <param name="polygon">
        /// Bounding polygon of the formula, with coordinates specified relative to the
        /// top-left of the page. The numbers represent the x, y values of the polygon
        /// vertices, clockwise from the left (-180 degrees inclusive) relative to the
        /// element orientation.
        /// </param>
        /// <param name="span"> Location of the formula in the reading order concatenated content. </param>
        /// <param name="confidence"> Confidence of correctly extracting the formula. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentFormula"/> instance for mocking. </returns>
        public static DocumentFormula DocumentFormula(DocumentFormulaKind kind = default, string value = default, IEnumerable<float> polygon = default, DocumentSpan span = default, float confidence = default)
        {
            polygon ??= new ChangeTrackingList<float>();

            return new DocumentFormula(
                kind,
                value,
                polygon.ToList(),
                span,
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// A paragraph object consisting with contiguous lines generally with common
        /// alignment and spacing.
        /// </summary>
        /// <param name="role"> Semantic role of the paragraph. </param>
        /// <param name="content"> Concatenated content of the paragraph in reading order. </param>
        /// <param name="boundingRegions"> Bounding regions covering the paragraph. </param>
        /// <param name="spans"> Location of the paragraph in the reading order concatenated content. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentParagraph"/> instance for mocking. </returns>
        public static DocumentParagraph DocumentParagraph(ParagraphRole? role = default, string content = default, IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default)
        {
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();

            return new DocumentParagraph(role, content, boundingRegions.ToList(), spans.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Bounding polygon on a specific page of the input. </summary>
        /// <param name="pageNumber"> 1-based page number of page containing the bounding region. </param>
        /// <param name="polygon">
        /// Bounding polygon on the page, or the entire page if not specified.
        /// Coordinates specified relative to the top-left of the page. The numbers
        /// represent the x, y values of the polygon vertices, clockwise from the left
        /// (-180 degrees inclusive) relative to the element orientation.
        /// </param>
        /// <returns> A new <see cref="DocumentIntelligence.BoundingRegion"/> instance for mocking. </returns>
        public static BoundingRegion BoundingRegion(int pageNumber = default, IEnumerable<float> polygon = default)
        {
            polygon ??= new ChangeTrackingList<float>();

            return new BoundingRegion(pageNumber, polygon.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> A table object consisting table cells arranged in a rectangular layout. </summary>
        /// <param name="rowCount"> Number of rows in the table. </param>
        /// <param name="columnCount"> Number of columns in the table. </param>
        /// <param name="cells"> Cells contained within the table. </param>
        /// <param name="boundingRegions"> Bounding regions covering the table. </param>
        /// <param name="spans"> Location of the table in the reading order concatenated content. </param>
        /// <param name="caption"> Caption associated with the table. </param>
        /// <param name="footnotes"> List of footnotes associated with the table. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentTable"/> instance for mocking. </returns>
        public static DocumentTable DocumentTable(int rowCount = default, int columnCount = default, IEnumerable<DocumentTableCell> cells = default, IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default, DocumentCaption caption = default, IEnumerable<DocumentFootnote> footnotes = default)
        {
            cells ??= new ChangeTrackingList<DocumentTableCell>();
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();
            footnotes ??= new ChangeTrackingList<DocumentFootnote>();

            return new DocumentTable(
                rowCount,
                columnCount,
                cells.ToList(),
                boundingRegions.ToList(),
                spans.ToList(),
                caption,
                footnotes.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing the location and content of a table cell. </summary>
        /// <param name="kind"> Table cell kind. </param>
        /// <param name="rowIndex"> Row index of the cell. </param>
        /// <param name="columnIndex"> Column index of the cell. </param>
        /// <param name="rowSpan"> Number of rows spanned by this cell. </param>
        /// <param name="columnSpan"> Number of columns spanned by this cell. </param>
        /// <param name="content"> Concatenated content of the table cell in reading order. </param>
        /// <param name="boundingRegions"> Bounding regions covering the table cell. </param>
        /// <param name="spans"> Location of the table cell in the reading order concatenated content. </param>
        /// <param name="elements"> Child elements of the table cell. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentTableCell"/> instance for mocking. </returns>
        public static DocumentTableCell DocumentTableCell(DocumentTableCellKind? kind = default, int rowIndex = default, int columnIndex = default, int? rowSpan = default, int? columnSpan = default, string content = default, IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default, IEnumerable<string> elements = default)
        {
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();
            elements ??= new ChangeTrackingList<string>();

            return new DocumentTableCell(
                kind,
                rowIndex,
                columnIndex,
                rowSpan,
                columnSpan,
                content,
                boundingRegions.ToList(),
                spans.ToList(),
                elements.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> A caption object describing a table or figure. </summary>
        /// <param name="content"> Content of the caption. </param>
        /// <param name="boundingRegions"> Bounding regions covering the caption. </param>
        /// <param name="spans"> Location of the caption in the reading order concatenated content. </param>
        /// <param name="elements"> Child elements of the caption. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentCaption"/> instance for mocking. </returns>
        public static DocumentCaption DocumentCaption(string content = default, IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default, IEnumerable<string> elements = default)
        {
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();
            elements ??= new ChangeTrackingList<string>();

            return new DocumentCaption(content, boundingRegions.ToList(), spans.ToList(), elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> A footnote object describing a table or figure. </summary>
        /// <param name="content"> Content of the footnote. </param>
        /// <param name="boundingRegions"> Bounding regions covering the footnote. </param>
        /// <param name="spans"> Location of the footnote in the reading order concatenated content. </param>
        /// <param name="elements"> Child elements of the footnote. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentFootnote"/> instance for mocking. </returns>
        public static DocumentFootnote DocumentFootnote(string content = default, IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default, IEnumerable<string> elements = default)
        {
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();
            elements ??= new ChangeTrackingList<string>();

            return new DocumentFootnote(content, boundingRegions.ToList(), spans.ToList(), elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing a figure in the document. </summary>
        /// <param name="boundingRegions"> Bounding regions covering the figure. </param>
        /// <param name="spans"> Location of the figure in the reading order concatenated content. </param>
        /// <param name="elements"> Child elements of the figure, excluding any caption or footnotes. </param>
        /// <param name="caption"> Caption associated with the figure. </param>
        /// <param name="footnotes"> List of footnotes associated with the figure. </param>
        /// <param name="id"> Figure ID. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentFigure"/> instance for mocking. </returns>
        public static DocumentFigure DocumentFigure(IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default, IEnumerable<string> elements = default, DocumentCaption caption = default, IEnumerable<DocumentFootnote> footnotes = default, string id = default)
        {
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();
            elements ??= new ChangeTrackingList<string>();
            footnotes ??= new ChangeTrackingList<DocumentFootnote>();

            return new DocumentFigure(
                boundingRegions.ToList(),
                spans.ToList(),
                elements.ToList(),
                caption,
                footnotes.ToList(),
                id,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing a section in the document. </summary>
        /// <param name="spans"> Location of the section in the reading order concatenated content. </param>
        /// <param name="elements"> Child elements of the section. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentSection"/> instance for mocking. </returns>
        public static DocumentSection DocumentSection(IEnumerable<DocumentSpan> spans = default, IEnumerable<string> elements = default)
        {
            spans ??= new ChangeTrackingList<DocumentSpan>();
            elements ??= new ChangeTrackingList<string>();

            return new DocumentSection(spans.ToList(), elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// An object representing a form field with distinct field label (key) and field
        /// value (may be empty).
        /// </summary>
        /// <param name="key"> Field label of the key-value pair. </param>
        /// <param name="value"> Field value of the key-value pair. </param>
        /// <param name="confidence"> Confidence of correctly extracting the key-value pair. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentKeyValuePair"/> instance for mocking. </returns>
        public static DocumentKeyValuePair DocumentKeyValuePair(DocumentKeyValueElement key = default, DocumentKeyValueElement value = default, float confidence = default)
        {
            return new DocumentKeyValuePair(key, value, confidence, additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing the field key or value in a key-value pair. </summary>
        /// <param name="content"> Concatenated content of the key-value element in reading order. </param>
        /// <param name="boundingRegions"> Bounding regions covering the key-value element. </param>
        /// <param name="spans"> Location of the key-value element in the reading order concatenated content. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentKeyValueElement"/> instance for mocking. </returns>
        public static DocumentKeyValueElement DocumentKeyValueElement(string content = default, IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default)
        {
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();

            return new DocumentKeyValueElement(content, boundingRegions.ToList(), spans.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing observed text styles. </summary>
        /// <param name="isHandwritten"> Is content handwritten?. </param>
        /// <param name="similarFontFamily">
        /// Visually most similar font from among the set of supported font families, with
        /// fallback fonts following CSS convention (ex. 'Arial, sans-serif').
        /// </param>
        /// <param name="fontStyle"> Font style. </param>
        /// <param name="fontWeight"> Font weight. </param>
        /// <param name="color"> Foreground color in #rrggbb hexadecimal format. </param>
        /// <param name="backgroundColor"> Background color in #rrggbb hexadecimal format.. </param>
        /// <param name="spans"> Location of the text elements in the concatenated content the style applies to. </param>
        /// <param name="confidence"> Confidence of correctly identifying the style. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentStyle"/> instance for mocking. </returns>
        public static DocumentStyle DocumentStyle(bool? isHandwritten = default, string similarFontFamily = default, DocumentFontStyle? fontStyle = default, DocumentFontWeight? fontWeight = default, string color = default, string backgroundColor = default, IEnumerable<DocumentSpan> spans = default, float confidence = default)
        {
            spans ??= new ChangeTrackingList<DocumentSpan>();

            return new DocumentStyle(
                isHandwritten,
                similarFontFamily,
                fontStyle,
                fontWeight,
                color,
                backgroundColor,
                spans.ToList(),
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing the detected language for a given text span. </summary>
        /// <param name="locale">
        /// Detected language.  Value may an ISO 639-1 language code (ex. "en", "fr")
        /// or BCP 47 language tag (ex. "zh-Hans").
        /// </param>
        /// <param name="spans">
        /// Location of the text elements in the concatenated content the language applies
        /// to.
        /// </param>
        /// <param name="confidence"> Confidence of correctly identifying the language. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentLanguage"/> instance for mocking. </returns>
        public static DocumentLanguage DocumentLanguage(string locale = default, IEnumerable<DocumentSpan> spans = default, float confidence = default)
        {
            spans ??= new ChangeTrackingList<DocumentSpan>();

            return new DocumentLanguage(locale, spans.ToList(), confidence, additionalBinaryDataProperties: null);
        }

        /// <summary> An object describing the location and semantic content of a document. </summary>
        /// <param name="documentType"> Document type. </param>
        /// <param name="boundingRegions"> Bounding regions covering the document. </param>
        /// <param name="spans"> Location of the document in the reading order concatenated content. </param>
        /// <param name="fieldsPrivate"> Dictionary of named field values. </param>
        /// <param name="confidence"> Confidence of correctly extracting the document. </param>
        /// <returns> A new <see cref="DocumentIntelligence.AnalyzedDocument"/> instance for mocking. </returns>
        public static AnalyzedDocument AnalyzedDocument(string documentType = default, IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default, IReadOnlyDictionary<string, DocumentField> fieldsPrivate = default, float confidence = default)
        {
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();
            fieldsPrivate ??= new ChangeTrackingDictionary<string, DocumentField>();

            return new AnalyzedDocument(
                documentType,
                boundingRegions.ToList(),
                spans.ToList(),
                fieldsPrivate,
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object representing the content and location of a field value. </summary>
        /// <param name="fieldType"> Data type of the field value. </param>
        /// <param name="valueString"> String value. </param>
        /// <param name="valueDate"> Date value in YYYY-MM-DD format (ISO 8601). </param>
        /// <param name="valueTime"> Time value in hh:mm:ss format (ISO 8601). </param>
        /// <param name="valuePhoneNumber"> Phone number value in E.164 format (ex. +19876543210). </param>
        /// <param name="valueDouble"> Floating point value. </param>
        /// <param name="valueInt64"> Integer value. </param>
        /// <param name="valueSelectionMark"> Selection mark value. </param>
        /// <param name="valueSignature"> Presence of signature. </param>
        /// <param name="valueCountryRegion"> 3-letter country code value (ISO 3166-1 alpha-3). </param>
        /// <param name="valueList"> Array of field values. </param>
        /// <param name="valueObject"> Dictionary of named field values. </param>
        /// <param name="valueCurrency"> Currency value. </param>
        /// <param name="valueAddress"> Address value. </param>
        /// <param name="valueBoolean"> Boolean value. </param>
        /// <param name="valueSelectionGroup"> Selection group value. </param>
        /// <param name="content"> Field content. </param>
        /// <param name="boundingRegions"> Bounding regions covering the field. </param>
        /// <param name="spans"> Location of the field in the reading order concatenated content. </param>
        /// <param name="confidence"> Confidence of correctly extracting the field. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentField"/> instance for mocking. </returns>
        public static DocumentField DocumentField(DocumentFieldType fieldType = default, string valueString = default, DateTimeOffset? valueDate = default, TimeSpan? valueTime = default, string valuePhoneNumber = default, double? valueDouble = default, long? valueInt64 = default, DocumentSelectionMarkState? valueSelectionMark = default, DocumentSignatureType? valueSignature = default, string valueCountryRegion = default, IEnumerable<DocumentField> valueList = default, IReadOnlyDictionary<string, DocumentField> valueObject = default, CurrencyValue valueCurrency = default, AddressValue valueAddress = default, bool? valueBoolean = default, IEnumerable<string> valueSelectionGroup = default, string content = default, IEnumerable<BoundingRegion> boundingRegions = default, IEnumerable<DocumentSpan> spans = default, float? confidence = default)
        {
            valueList ??= new ChangeTrackingList<DocumentField>();
            valueObject ??= new ChangeTrackingDictionary<string, DocumentField>();
            valueSelectionGroup ??= new ChangeTrackingList<string>();
            boundingRegions ??= new ChangeTrackingList<BoundingRegion>();
            spans ??= new ChangeTrackingList<DocumentSpan>();

            return new DocumentField(
                fieldType,
                valueString,
                valueDate,
                valueTime,
                valuePhoneNumber,
                valueDouble,
                valueInt64,
                valueSelectionMark,
                valueSignature,
                valueCountryRegion,
                valueList.ToList(),
                valueObject,
                valueCurrency,
                valueAddress,
                valueBoolean,
                valueSelectionGroup.ToList(),
                content,
                boundingRegions.ToList(),
                spans.ToList(),
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Currency field value. </summary>
        /// <param name="amount"> Currency amount. </param>
        /// <param name="currencySymbol"> Currency symbol label, if any. </param>
        /// <param name="currencyCode"> Resolved currency code (ISO 4217), if any. </param>
        /// <returns> A new <see cref="DocumentIntelligence.CurrencyValue"/> instance for mocking. </returns>
        public static CurrencyValue CurrencyValue(double amount = default, string currencySymbol = default, string currencyCode = default)
        {
            return new CurrencyValue(amount, currencySymbol, currencyCode, additionalBinaryDataProperties: null);
        }

        /// <summary> Address field value. </summary>
        /// <param name="houseNumber"> House or building number. </param>
        /// <param name="poBox"> Post office box number. </param>
        /// <param name="road"> Street name. </param>
        /// <param name="city"> Name of city, town, village, etc. </param>
        /// <param name="state"> First-level administrative division. </param>
        /// <param name="postalCode"> Postal code used for mail sorting. </param>
        /// <param name="countryRegion"> Country/region. </param>
        /// <param name="streetAddress"> Street-level address, excluding city, state, countryRegion, and postalCode. </param>
        /// <param name="unit"> Apartment or office number. </param>
        /// <param name="cityDistrict">
        /// Districts or boroughs within a city, such as Brooklyn in New York City or City
        /// of Westminster in London.
        /// </param>
        /// <param name="stateDistrict"> Second-level administrative division used in certain locales. </param>
        /// <param name="suburb"> Unofficial neighborhood name, like Chinatown. </param>
        /// <param name="house"> Build name, such as World Trade Center. </param>
        /// <param name="level"> Floor number, such as 3F. </param>
        /// <returns> A new <see cref="DocumentIntelligence.AddressValue"/> instance for mocking. </returns>
        public static AddressValue AddressValue(string houseNumber = default, string poBox = default, string road = default, string city = default, string state = default, string postalCode = default, string countryRegion = default, string streetAddress = default, string unit = default, string cityDistrict = default, string stateDistrict = default, string suburb = default, string house = default, string level = default)
        {
            return new AddressValue(
                houseNumber,
                poBox,
                road,
                city,
                state,
                postalCode,
                countryRegion,
                streetAddress,
                unit,
                cityDistrict,
                stateDistrict,
                suburb,
                house,
                level,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The error object. </summary>
        /// <param name="code"> One of a server-defined set of warning codes. </param>
        /// <param name="message"> A human-readable representation of the warning. </param>
        /// <param name="target"> The target of the error. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentIntelligenceWarning"/> instance for mocking. </returns>
        public static DocumentIntelligenceWarning DocumentIntelligenceWarning(string code = default, string message = default, string target = default)
        {
            return new DocumentIntelligenceWarning(code, message, target, additionalBinaryDataProperties: null);
        }

        /// <summary> Batch document analysis parameters. </summary>
        /// <param name="blobSource">
        /// Azure Blob Storage location containing the batch documents.  Either
        /// azureBlobSource or azureBlobFileListSource must be specified.
        /// </param>
        /// <param name="blobFileListSource">
        /// Azure Blob Storage file list specifying the batch documents.  Either
        /// azureBlobSource or azureBlobFileListSource must be specified.
        /// </param>
        /// <param name="resultContainerUri"> Azure Blob Storage container URL where analyze result files will be stored. </param>
        /// <param name="resultPrefix"> Blob name prefix of result files. </param>
        /// <param name="overwriteExisting"> Overwrite existing analyze result files?. </param>
        /// <returns> A new <see cref="DocumentIntelligence.AnalyzeBatchDocumentsOptions"/> instance for mocking. </returns>
        public static AnalyzeBatchDocumentsOptions AnalyzeBatchDocumentsOptions(BlobContentSource blobSource = default, BlobFileListContentSource blobFileListSource = default, Uri resultContainerUri = default, string resultPrefix = default, bool? overwriteExisting = default)
        {
            return new AnalyzeBatchDocumentsOptions(
                blobSource,
                blobFileListSource,
                resultContainerUri,
                resultPrefix,
                overwriteExisting,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Azure Blob Storage content. </summary>
        /// <param name="containerUri"> Azure Blob Storage container URL. </param>
        /// <param name="prefix"> Blob name prefix. </param>
        /// <returns> A new <see cref="DocumentIntelligence.BlobContentSource"/> instance for mocking. </returns>
        public static BlobContentSource BlobContentSource(Uri containerUri = default, string prefix = default)
        {
            return new BlobContentSource(containerUri, prefix, additionalBinaryDataProperties: null);
        }

        /// <summary> File list in Azure Blob Storage. </summary>
        /// <param name="containerUri"> Azure Blob Storage container URL. </param>
        /// <param name="fileList"> Path to a JSONL file within the container specifying a subset of documents. </param>
        /// <returns> A new <see cref="DocumentIntelligence.BlobFileListContentSource"/> instance for mocking. </returns>
        public static BlobFileListContentSource BlobFileListContentSource(Uri containerUri = default, string fileList = default)
        {
            return new BlobFileListContentSource(containerUri, fileList, additionalBinaryDataProperties: null);
        }

        /// <summary> Batch document analysis result. </summary>
        /// <param name="succeededCount"> Number of documents that completed with status succeeded. </param>
        /// <param name="failedCount"> Number of documents that completed with status failed. </param>
        /// <param name="skippedCount"> Number of documents that completed with status skipped. </param>
        /// <param name="details"> Operation detail for each document in the batch. </param>
        /// <returns> A new <see cref="DocumentIntelligence.AnalyzeBatchResult"/> instance for mocking. </returns>
        public static AnalyzeBatchResult AnalyzeBatchResult(int succeededCount = default, int failedCount = default, int skippedCount = default, IEnumerable<AnalyzeBatchResultDetails> details = default)
        {
            details ??= new ChangeTrackingList<AnalyzeBatchResultDetails>();

            return new AnalyzeBatchResult(succeededCount, failedCount, skippedCount, details.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Operation detail for a document in a batch analysis. </summary>
        /// <param name="status"> Analyze status.  succeeded, failed, or skipped. </param>
        /// <param name="sourceUri"> URL of the source document. </param>
        /// <param name="resultUri"> URL of the analyze result JSON. </param>
        /// <param name="error"> Encountered error. </param>
        /// <returns> A new <see cref="DocumentIntelligence.AnalyzeBatchResultDetails"/> instance for mocking. </returns>
        public static AnalyzeBatchResultDetails AnalyzeBatchResultDetails(DocumentIntelligenceOperationStatus status = default, Uri sourceUri = default, Uri resultUri = default, DocumentIntelligenceError error = default)
        {
            return new AnalyzeBatchResultDetails(status, sourceUri, resultUri, error, additionalBinaryDataProperties: null);
        }

        /// <summary> Status and result of the analyze batch operation. </summary>
        /// <param name="resultId"> Analyze batch operation result ID. </param>
        /// <param name="status"> Operation status.  notStarted, running, succeeded, or failed. </param>
        /// <param name="createdOn"> Date and time (UTC) when the operation was submitted. </param>
        /// <param name="lastUpdatedOn"> Date and time (UTC) when the status was last updated. </param>
        /// <param name="percentCompleted"> Operation progress (0-100). </param>
        /// <param name="error"> Encountered error during batch document analysis. </param>
        /// <param name="result"> Batch document analysis result. </param>
        /// <returns> A new <see cref="DocumentIntelligence.AnalyzeBatchOperationDetails"/> instance for mocking. </returns>
        public static AnalyzeBatchOperationDetails AnalyzeBatchOperationDetails(string resultId = default, DocumentIntelligenceOperationStatus status = default, DateTimeOffset createdOn = default, DateTimeOffset lastUpdatedOn = default, int? percentCompleted = default, DocumentIntelligenceError error = default, AnalyzeBatchResult result = default)
        {
            return new AnalyzeBatchOperationDetails(
                resultId,
                status,
                createdOn,
                lastUpdatedOn,
                percentCompleted,
                error,
                result,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Request body to build a new custom document model. </summary>
        /// <param name="modelId"> Unique document model name. </param>
        /// <param name="description"> Document model description. </param>
        /// <param name="buildMode"> Custom document model build mode. </param>
        /// <param name="blobSource">
        /// Azure Blob Storage location containing the training data.  Either
        /// azureBlobSource or azureBlobFileListSource must be specified.
        /// </param>
        /// <param name="blobFileListSource">
        /// Azure Blob Storage file list specifying the training data.  Either
        /// azureBlobSource or azureBlobFileListSource must be specified.
        /// </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <param name="maxTrainingHours"> Max number of V100-equivalent GPU hours to use for model training.  Default=0.5. </param>
        /// <param name="allowOverwrite"> Allow overwriting an existing model with the same name. </param>
        /// <returns> A new <see cref="DocumentIntelligence.BuildDocumentModelOptions"/> instance for mocking. </returns>
        public static BuildDocumentModelOptions BuildDocumentModelOptions(string modelId = default, string description = default, DocumentBuildMode buildMode = default, BlobContentSource blobSource = default, BlobFileListContentSource blobFileListSource = default, IDictionary<string, string> tags = default, float? maxTrainingHours = default, bool? allowOverwrite = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new BuildDocumentModelOptions(
                modelId,
                description,
                buildMode,
                blobSource,
                blobFileListSource,
                tags,
                maxTrainingHours,
                allowOverwrite,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Document model info. </summary>
        /// <param name="modelId"> Unique document model name. </param>
        /// <param name="description"> Document model description. </param>
        /// <param name="createdOn"> Date and time (UTC) when the document model was created. </param>
        /// <param name="expiresOn"> Date and time (UTC) when the document model will expire. </param>
        /// <param name="modifiedOn"> Date and time (UTC) when the document model was last modified. </param>
        /// <param name="apiVersion"> API version used to create this document model. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <param name="buildMode"> Custom document model build mode. </param>
        /// <param name="blobSource">
        /// Azure Blob Storage location containing the training data.  Either
        /// azureBlobSource or azureBlobFileListSource must be specified.
        /// </param>
        /// <param name="blobFileListSource">
        /// Azure Blob Storage file list specifying the training data.  Either
        /// azureBlobSource or azureBlobFileListSource must be specified.
        /// </param>
        /// <param name="classifierId"> For composed models, the custom classifier to split and classify the input file. </param>
        /// <param name="split"> For composed models, the file splitting behavior. </param>
        /// <param name="documentTypes"> Supported document types. </param>
        /// <param name="warnings"> List of warnings encountered while building the model. </param>
        /// <param name="trainingHours"> Number of V100-equivalent GPU hours consumed for model training. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentModelDetails"/> instance for mocking. </returns>
        public static DocumentModelDetails DocumentModelDetails(string modelId = default, string description = default, DateTimeOffset createdOn = default, DateTimeOffset? expiresOn = default, DateTimeOffset? modifiedOn = default, string apiVersion = default, IReadOnlyDictionary<string, string> tags = default, DocumentBuildMode? buildMode = default, BlobContentSource blobSource = default, BlobFileListContentSource blobFileListSource = default, string classifierId = default, SplitMode? split = default, IReadOnlyDictionary<string, DocumentTypeDetails> documentTypes = default, IEnumerable<DocumentIntelligenceWarning> warnings = default, float? trainingHours = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            documentTypes ??= new ChangeTrackingDictionary<string, DocumentTypeDetails>();
            warnings ??= new ChangeTrackingList<DocumentIntelligenceWarning>();

            return new DocumentModelDetails(
                modelId,
                description,
                createdOn,
                expiresOn,
                modifiedOn,
                apiVersion,
                tags,
                buildMode,
                blobSource,
                blobFileListSource,
                classifierId,
                split,
                documentTypes,
                warnings.ToList(),
                trainingHours,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Document type info. </summary>
        /// <param name="description"> Document model description. </param>
        /// <param name="buildMode"> Custom document model build mode. </param>
        /// <param name="fieldSchema"> Description of the document semantic schema using a JSON Schema style syntax. </param>
        /// <param name="fieldConfidence"> Estimated confidence for each field. </param>
        /// <param name="modelId"> Document model to use for analyzing documents with specified type. </param>
        /// <param name="confidenceThreshold"> Only perform analysis if docType confidence is above threshold. </param>
        /// <param name="features"> List of optional analysis features. </param>
        /// <param name="queryFields"> List of additional fields to extract.  Ex. "NumberOfGuests,StoreNumber". </param>
        /// <param name="maxDocumentsToAnalyze"> Maximum number of documents of specified type to analyze.  Default=all. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentTypeDetails"/> instance for mocking. </returns>
        public static DocumentTypeDetails DocumentTypeDetails(string description = default, DocumentBuildMode? buildMode = default, IDictionary<string, DocumentFieldSchema> fieldSchema = default, IDictionary<string, float> fieldConfidence = default, string modelId = default, float? confidenceThreshold = default, IEnumerable<DocumentAnalysisFeature> features = default, IEnumerable<string> queryFields = default, int? maxDocumentsToAnalyze = default)
        {
            fieldSchema ??= new ChangeTrackingDictionary<string, DocumentFieldSchema>();
            fieldConfidence ??= new ChangeTrackingDictionary<string, float>();
            features ??= new ChangeTrackingList<DocumentAnalysisFeature>();
            queryFields ??= new ChangeTrackingList<string>();

            return new DocumentTypeDetails(
                description,
                buildMode,
                fieldSchema,
                fieldConfidence,
                modelId,
                confidenceThreshold,
                features.ToList(),
                queryFields.ToList(),
                maxDocumentsToAnalyze,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Description of the field semantic schema using a JSON Schema style syntax. </summary>
        /// <param name="fieldType"> Semantic data type of the field value. </param>
        /// <param name="description"> Field description. </param>
        /// <param name="example"> Example field content. </param>
        /// <param name="items"> Field type schema of each array element. </param>
        /// <param name="properties"> Named sub-fields of the object field. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentFieldSchema"/> instance for mocking. </returns>
        public static DocumentFieldSchema DocumentFieldSchema(DocumentFieldType fieldType = default, string description = default, string example = default, DocumentFieldSchema items = default, IDictionary<string, DocumentFieldSchema> properties = default)
        {
            properties ??= new ChangeTrackingDictionary<string, DocumentFieldSchema>();

            return new DocumentFieldSchema(
                fieldType,
                description,
                example,
                items,
                properties,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Get Operation response object. </summary>
        /// <param name="operationId"> Operation ID. </param>
        /// <param name="status"> Operation status.  notStarted, running, completed, or failed. </param>
        /// <param name="percentCompleted"> Operation progress (0-100). </param>
        /// <param name="createdOn"> Date and time (UTC) when the operation was created. </param>
        /// <param name="lastUpdatedOn"> Date and time (UTC) when the status was last updated. </param>
        /// <param name="resourceLocation"> URL of the resource targeted by this operation. </param>
        /// <param name="apiVersion"> API version used to create this operation. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <param name="error"> Encountered error. </param>
        /// <param name="result"> Operation result upon success. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentModelBuildOperationDetails"/> instance for mocking. </returns>
        public static DocumentModelBuildOperationDetails DocumentModelBuildOperationDetails(string operationId = default, DocumentIntelligenceOperationStatus status = default, int? percentCompleted = default, DateTimeOffset createdOn = default, DateTimeOffset lastUpdatedOn = default, Uri resourceLocation = default, string apiVersion = default, IReadOnlyDictionary<string, string> tags = default, DocumentIntelligenceError error = default, DocumentModelDetails result = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new DocumentModelBuildOperationDetails(
                operationId,
                status,
                percentCompleted,
                createdOn,
                lastUpdatedOn,
                OperationKind.DocumentModelBuild,
                resourceLocation,
                apiVersion,
                tags,
                error,
                additionalBinaryDataProperties: null,
                result);
        }

        /// <summary>
        /// Operation info.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="DocumentIntelligence.DocumentModelBuildOperationDetails"/>, <see cref="DocumentIntelligence.DocumentModelComposeOperationDetails"/>, <see cref="DocumentIntelligence.DocumentModelCopyToOperationDetails"/>, <see cref="DocumentIntelligence.DocumentClassifierCopyToOperationDetails"/>, and <see cref="DocumentIntelligence.DocumentClassifierBuildOperationDetails"/>.
        /// </summary>
        /// <param name="operationId"> Operation ID. </param>
        /// <param name="status"> Operation status.  notStarted, running, completed, or failed. </param>
        /// <param name="percentCompleted"> Operation progress (0-100). </param>
        /// <param name="createdOn"> Date and time (UTC) when the operation was created. </param>
        /// <param name="lastUpdatedOn"> Date and time (UTC) when the status was last updated. </param>
        /// <param name="kind"> Type of operation. </param>
        /// <param name="resourceLocation"> URL of the resource targeted by this operation. </param>
        /// <param name="apiVersion"> API version used to create this operation. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <param name="error"> Encountered error. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentIntelligenceOperationDetails"/> instance for mocking. </returns>
        public static DocumentIntelligenceOperationDetails DocumentIntelligenceOperationDetails(string operationId = default, DocumentIntelligenceOperationStatus status = default, int? percentCompleted = default, DateTimeOffset createdOn = default, DateTimeOffset lastUpdatedOn = default, string kind = default, Uri resourceLocation = default, string apiVersion = default, IReadOnlyDictionary<string, string> tags = default, DocumentIntelligenceError error = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new UnknownDocumentIntelligenceOperationDetails(
                operationId,
                status,
                percentCompleted,
                createdOn,
                lastUpdatedOn,
                new OperationKind(kind),
                resourceLocation,
                apiVersion,
                tags,
                error,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Get Operation response object. </summary>
        /// <param name="operationId"> Operation ID. </param>
        /// <param name="status"> Operation status.  notStarted, running, completed, or failed. </param>
        /// <param name="percentCompleted"> Operation progress (0-100). </param>
        /// <param name="createdOn"> Date and time (UTC) when the operation was created. </param>
        /// <param name="lastUpdatedOn"> Date and time (UTC) when the status was last updated. </param>
        /// <param name="resourceLocation"> URL of the resource targeted by this operation. </param>
        /// <param name="apiVersion"> API version used to create this operation. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <param name="error"> Encountered error. </param>
        /// <param name="result"> Operation result upon success. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentModelComposeOperationDetails"/> instance for mocking. </returns>
        public static DocumentModelComposeOperationDetails DocumentModelComposeOperationDetails(string operationId = default, DocumentIntelligenceOperationStatus status = default, int? percentCompleted = default, DateTimeOffset createdOn = default, DateTimeOffset lastUpdatedOn = default, Uri resourceLocation = default, string apiVersion = default, IReadOnlyDictionary<string, string> tags = default, DocumentIntelligenceError error = default, DocumentModelDetails result = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new DocumentModelComposeOperationDetails(
                operationId,
                status,
                percentCompleted,
                createdOn,
                lastUpdatedOn,
                OperationKind.DocumentModelCompose,
                resourceLocation,
                apiVersion,
                tags,
                error,
                additionalBinaryDataProperties: null,
                result);
        }

        /// <summary> Get Operation response object. </summary>
        /// <param name="operationId"> Operation ID. </param>
        /// <param name="status"> Operation status.  notStarted, running, completed, or failed. </param>
        /// <param name="percentCompleted"> Operation progress (0-100). </param>
        /// <param name="createdOn"> Date and time (UTC) when the operation was created. </param>
        /// <param name="lastUpdatedOn"> Date and time (UTC) when the status was last updated. </param>
        /// <param name="resourceLocation"> URL of the resource targeted by this operation. </param>
        /// <param name="apiVersion"> API version used to create this operation. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <param name="error"> Encountered error. </param>
        /// <param name="result"> Operation result upon success. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentModelCopyToOperationDetails"/> instance for mocking. </returns>
        public static DocumentModelCopyToOperationDetails DocumentModelCopyToOperationDetails(string operationId = default, DocumentIntelligenceOperationStatus status = default, int? percentCompleted = default, DateTimeOffset createdOn = default, DateTimeOffset lastUpdatedOn = default, Uri resourceLocation = default, string apiVersion = default, IReadOnlyDictionary<string, string> tags = default, DocumentIntelligenceError error = default, DocumentModelDetails result = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new DocumentModelCopyToOperationDetails(
                operationId,
                status,
                percentCompleted,
                createdOn,
                lastUpdatedOn,
                OperationKind.DocumentModelCopyTo,
                resourceLocation,
                apiVersion,
                tags,
                error,
                additionalBinaryDataProperties: null,
                result);
        }

        /// <summary> Get Operation response object. </summary>
        /// <param name="operationId"> Operation ID. </param>
        /// <param name="status"> Operation status.  notStarted, running, completed, or failed. </param>
        /// <param name="percentCompleted"> Operation progress (0-100). </param>
        /// <param name="createdOn"> Date and time (UTC) when the operation was created. </param>
        /// <param name="lastUpdatedOn"> Date and time (UTC) when the status was last updated. </param>
        /// <param name="resourceLocation"> URL of the resource targeted by this operation. </param>
        /// <param name="apiVersion"> API version used to create this operation. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <param name="error"> Encountered error. </param>
        /// <param name="result"> Operation result upon success. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentClassifierCopyToOperationDetails"/> instance for mocking. </returns>
        public static DocumentClassifierCopyToOperationDetails DocumentClassifierCopyToOperationDetails(string operationId = default, DocumentIntelligenceOperationStatus status = default, int? percentCompleted = default, DateTimeOffset createdOn = default, DateTimeOffset lastUpdatedOn = default, Uri resourceLocation = default, string apiVersion = default, IReadOnlyDictionary<string, string> tags = default, DocumentIntelligenceError error = default, DocumentClassifierDetails result = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new DocumentClassifierCopyToOperationDetails(
                operationId,
                status,
                percentCompleted,
                createdOn,
                lastUpdatedOn,
                OperationKind.DocumentClassifierCopyTo,
                resourceLocation,
                apiVersion,
                tags,
                error,
                additionalBinaryDataProperties: null,
                result);
        }

        /// <summary> Document classifier info. </summary>
        /// <param name="classifierId"> Unique document classifier name. </param>
        /// <param name="description"> Document classifier description. </param>
        /// <param name="createdOn"> Date and time (UTC) when the document classifier was created. </param>
        /// <param name="expiresOn"> Date and time (UTC) when the document classifier will expire. </param>
        /// <param name="modifiedOn"> Date and time (UTC) when the document model was last modified. </param>
        /// <param name="apiVersion"> API version used to create this document classifier. </param>
        /// <param name="baseClassifierId"> Base classifierId on top of which the classifier was trained. </param>
        /// <param name="documentTypes"> List of document types to classify against. </param>
        /// <param name="warnings"> List of warnings encountered while building the classifier. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentClassifierDetails"/> instance for mocking. </returns>
        public static DocumentClassifierDetails DocumentClassifierDetails(string classifierId = default, string description = default, DateTimeOffset createdOn = default, DateTimeOffset? expiresOn = default, DateTimeOffset? modifiedOn = default, string apiVersion = default, string baseClassifierId = default, IReadOnlyDictionary<string, ClassifierDocumentTypeDetails> documentTypes = default, IEnumerable<DocumentIntelligenceWarning> warnings = default)
        {
            documentTypes ??= new ChangeTrackingDictionary<string, ClassifierDocumentTypeDetails>();
            warnings ??= new ChangeTrackingList<DocumentIntelligenceWarning>();

            return new DocumentClassifierDetails(
                classifierId,
                description,
                createdOn,
                expiresOn,
                modifiedOn,
                apiVersion,
                baseClassifierId,
                documentTypes,
                warnings.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Get Operation response object. </summary>
        /// <param name="operationId"> Operation ID. </param>
        /// <param name="status"> Operation status.  notStarted, running, completed, or failed. </param>
        /// <param name="percentCompleted"> Operation progress (0-100). </param>
        /// <param name="createdOn"> Date and time (UTC) when the operation was created. </param>
        /// <param name="lastUpdatedOn"> Date and time (UTC) when the status was last updated. </param>
        /// <param name="resourceLocation"> URL of the resource targeted by this operation. </param>
        /// <param name="apiVersion"> API version used to create this operation. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <param name="error"> Encountered error. </param>
        /// <param name="result"> Operation result upon success. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentClassifierBuildOperationDetails"/> instance for mocking. </returns>
        public static DocumentClassifierBuildOperationDetails DocumentClassifierBuildOperationDetails(string operationId = default, DocumentIntelligenceOperationStatus status = default, int? percentCompleted = default, DateTimeOffset createdOn = default, DateTimeOffset lastUpdatedOn = default, Uri resourceLocation = default, string apiVersion = default, IReadOnlyDictionary<string, string> tags = default, DocumentIntelligenceError error = default, DocumentClassifierDetails result = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new DocumentClassifierBuildOperationDetails(
                operationId,
                status,
                percentCompleted,
                createdOn,
                lastUpdatedOn,
                OperationKind.DocumentClassifierBuild,
                resourceLocation,
                apiVersion,
                tags,
                error,
                additionalBinaryDataProperties: null,
                result);
        }

        /// <summary> Request body to create a composed document model from component document models. </summary>
        /// <param name="modelId"> Unique document model name. </param>
        /// <param name="description"> Document model description. </param>
        /// <param name="classifierId"> Custom classifier to split and classify the input file. </param>
        /// <param name="split"> File splitting behavior. </param>
        /// <param name="documentTypes"> Dictionary mapping supported docTypes to the corresponding document models. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <returns> A new <see cref="DocumentIntelligence.ComposeModelOptions"/> instance for mocking. </returns>
        public static ComposeModelOptions ComposeModelOptions(string modelId = default, string description = default, string classifierId = default, SplitMode? split = default, IDictionary<string, DocumentTypeDetails> documentTypes = default, IDictionary<string, string> tags = default)
        {
            documentTypes ??= new ChangeTrackingDictionary<string, DocumentTypeDetails>();
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ComposeModelOptions(
                modelId,
                description,
                classifierId,
                split,
                documentTypes,
                tags,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Request body to authorize document model copy. </summary>
        /// <param name="modelId"> Unique document model name. </param>
        /// <param name="description"> Document model description. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document model. </param>
        /// <returns> A new <see cref="DocumentIntelligence.AuthorizeModelCopyOptions"/> instance for mocking. </returns>
        public static AuthorizeModelCopyOptions AuthorizeModelCopyOptions(string modelId = default, string description = default, IDictionary<string, string> tags = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new AuthorizeModelCopyOptions(modelId, description, tags, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Authorization to copy a document model to the specified target resource and
        /// modelId.
        /// </summary>
        /// <param name="targetResourceId"> ID of the target Azure resource where the document model should be copied to. </param>
        /// <param name="targetResourceRegion">
        /// Location of the target Azure resource where the document model should be copied
        /// to.
        /// </param>
        /// <param name="targetModelId"> Identifier of the target document model. </param>
        /// <param name="targetModelLocation"> URL of the copied document model in the target account. </param>
        /// <param name="accessToken"> Token used to authorize the request. </param>
        /// <param name="expiresOn"> Date/time when the access token expires. </param>
        /// <returns> A new <see cref="DocumentIntelligence.ModelCopyAuthorization"/> instance for mocking. </returns>
        public static ModelCopyAuthorization ModelCopyAuthorization(string targetResourceId = default, string targetResourceRegion = default, string targetModelId = default, Uri targetModelLocation = default, string accessToken = default, DateTimeOffset expiresOn = default)
        {
            return new ModelCopyAuthorization(
                targetResourceId,
                targetResourceRegion,
                targetModelId,
                targetModelLocation,
                accessToken,
                expiresOn,
                additionalBinaryDataProperties: null);
        }

        /// <summary> General information regarding the current resource. </summary>
        /// <param name="customDocumentModels"> Details regarding custom document models. </param>
        /// <returns> A new <see cref="DocumentIntelligence.DocumentIntelligenceResourceDetails"/> instance for mocking. </returns>
        public static DocumentIntelligenceResourceDetails DocumentIntelligenceResourceDetails(CustomDocumentModelsDetails customDocumentModels = default)
        {
            return new DocumentIntelligenceResourceDetails(customDocumentModels, additionalBinaryDataProperties: null);
        }

        /// <summary> Details regarding custom document models. </summary>
        /// <param name="count"> Number of custom document models in the current resource. </param>
        /// <param name="limit"> Maximum number of custom document models supported in the current resource. </param>
        /// <returns> A new <see cref="DocumentIntelligence.CustomDocumentModelsDetails"/> instance for mocking. </returns>
        public static CustomDocumentModelsDetails CustomDocumentModelsDetails(int count = default, int limit = default)
        {
            return new CustomDocumentModelsDetails(count, limit, additionalBinaryDataProperties: null);
        }

        /// <summary> Request body to build a new custom document classifier. </summary>
        /// <param name="classifierId"> Unique document classifier name. </param>
        /// <param name="description"> Document classifier description. </param>
        /// <param name="baseClassifierId"> Base classifierId on top of which to train the classifier. </param>
        /// <param name="documentTypes"> List of document types to classify against. </param>
        /// <param name="allowOverwrite"> Allow overwriting an existing classifier with the same name. </param>
        /// <returns> A new <see cref="DocumentIntelligence.BuildClassifierOptions"/> instance for mocking. </returns>
        public static BuildClassifierOptions BuildClassifierOptions(string classifierId = default, string description = default, string baseClassifierId = default, IDictionary<string, ClassifierDocumentTypeDetails> documentTypes = default, bool? allowOverwrite = default)
        {
            documentTypes ??= new ChangeTrackingDictionary<string, ClassifierDocumentTypeDetails>();

            return new BuildClassifierOptions(
                classifierId,
                description,
                baseClassifierId,
                documentTypes,
                allowOverwrite,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Request body to authorize document classifier copy. </summary>
        /// <param name="classifierId"> Unique document classifier name. </param>
        /// <param name="description"> Document classifier description. </param>
        /// <param name="tags"> List of key-value tag attributes associated with the document classifier. </param>
        /// <returns> A new <see cref="DocumentIntelligence.AuthorizeClassifierCopyOptions"/> instance for mocking. </returns>
        public static AuthorizeClassifierCopyOptions AuthorizeClassifierCopyOptions(string classifierId = default, string description = default, IDictionary<string, string> tags = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new AuthorizeClassifierCopyOptions(classifierId, description, tags, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Authorization to copy a document classifier to the specified target resource and
        /// classifierId.
        /// </summary>
        /// <param name="targetResourceId"> ID of the target Azure resource where the document classifier should be copied to. </param>
        /// <param name="targetResourceRegion">
        /// Location of the target Azure resource where the document classifier should be copied
        /// to.
        /// </param>
        /// <param name="targetClassifierId"> Identifier of the target document classifier. </param>
        /// <param name="targetClassifierLocation"> URL of the copied document classifier in the target account. </param>
        /// <param name="accessToken"> Token used to authorize the request. </param>
        /// <param name="expiresOn"> Date/time when the access token expires. </param>
        /// <returns> A new <see cref="DocumentIntelligence.ClassifierCopyAuthorization"/> instance for mocking. </returns>
        public static ClassifierCopyAuthorization ClassifierCopyAuthorization(string targetResourceId = default, string targetResourceRegion = default, string targetClassifierId = default, Uri targetClassifierLocation = default, string accessToken = default, DateTimeOffset expiresOn = default)
        {
            return new ClassifierCopyAuthorization(
                targetResourceId,
                targetResourceRegion,
                targetClassifierId,
                targetClassifierLocation,
                accessToken,
                expiresOn,
                additionalBinaryDataProperties: null);
        }
    }
}
