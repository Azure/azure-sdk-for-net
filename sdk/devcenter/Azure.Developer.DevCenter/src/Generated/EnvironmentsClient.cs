// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Developer.DevCenter
{
    // Data plane generated client. The Environments service client.
    /// <summary> The Environments service client. </summary>
    public partial class EnvironmentsClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://devcenter.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _tenantId;
        private readonly string _devCenter;
        private readonly string _projectName;
        private readonly string _devCenterDnsSuffix;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of EnvironmentsClient for mocking. </summary>
        protected EnvironmentsClient()
        {
        }

        /// <summary> Initializes a new instance of EnvironmentsClient. </summary>
        /// <param name="tenantId"> The tenant to operate on. </param>
        /// <param name="devCenter"> The DevCenter to operate on. </param>
        /// <param name="projectName"> The DevCenter Project upon which to execute operations. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tenantId"/>, <paramref name="devCenter"/>, <paramref name="projectName"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        public EnvironmentsClient(string tenantId, string devCenter, string projectName, TokenCredential credential) : this(tenantId, devCenter, projectName, credential, "devcenter.azure.com", new DevCenterClientOptions())
        {
        }

        /// <summary> Initializes a new instance of EnvironmentsClient. </summary>
        /// <param name="tenantId"> The tenant to operate on. </param>
        /// <param name="devCenter"> The DevCenter to operate on. </param>
        /// <param name="projectName"> The DevCenter Project upon which to execute operations. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="devCenterDnsSuffix"> The DNS suffix used as the base for all devcenter requests. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tenantId"/>, <paramref name="devCenter"/>, <paramref name="projectName"/>, <paramref name="credential"/> or <paramref name="devCenterDnsSuffix"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        public EnvironmentsClient(string tenantId, string devCenter, string projectName, TokenCredential credential, string devCenterDnsSuffix, DevCenterClientOptions options)
        {
            Argument.AssertNotNull(tenantId, nameof(tenantId));
            Argument.AssertNotNull(devCenter, nameof(devCenter));
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(devCenterDnsSuffix, nameof(devCenterDnsSuffix));
            options ??= new DevCenterClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _tenantId = tenantId;
            _devCenter = devCenter;
            _projectName = projectName;
            _devCenterDnsSuffix = devCenterDnsSuffix;
            _apiVersion = options.Version;
        }

        /// <summary> Gets an environment. </summary>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnvironmentByUserAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// Response response = await client.GetEnvironmentByUserAsync("<environmentName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetEnvironmentByUserAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// Response response = await client.GetEnvironmentByUserAsync("<environmentName>", <me>);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.GetProperty("owner").ToString());
        /// Console.WriteLine(result.GetProperty("provisioningState").ToString());
        /// Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        /// Console.WriteLine(result.GetProperty("parameters").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEnvironmentByUserAsync(string environmentName, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.GetEnvironmentByUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnvironmentByUserRequest(userId, environmentName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets an environment. </summary>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnvironmentByUser with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// Response response = client.GetEnvironmentByUser("<environmentName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetEnvironmentByUser with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// Response response = client.GetEnvironmentByUser("<environmentName>", <me>);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.GetProperty("owner").ToString());
        /// Console.WriteLine(result.GetProperty("provisioningState").ToString());
        /// Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        /// Console.WriteLine(result.GetProperty("parameters").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEnvironmentByUser(string environmentName, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.GetEnvironmentByUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnvironmentByUserRequest(userId, environmentName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Partially updates an environment. </summary>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateEnvironmentAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     environmentType = "<environmentType>",
        /// };
        /// 
        /// Response response = await client.UpdateEnvironmentAsync("<environmentName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UpdateEnvironmentAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     environmentType = "<environmentType>",
        ///     owner = "<owner>",
        ///     description = "<description>",
        ///     catalogName = "<catalogName>",
        ///     catalogItemName = "<catalogItemName>",
        ///     parameters = new {},
        ///     scheduledTasks = new {
        ///         key = new {
        ///             type = "AutoExpire",
        ///             enabled = "Enabled",
        ///             startTime = "2022-05-10T18:57:31.2311892Z",
        ///         },
        ///     },
        ///     tags = new {
        ///         key = "<String>",
        ///     },
        /// };
        /// 
        /// Response response = await client.UpdateEnvironmentAsync("<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.GetProperty("owner").ToString());
        /// Console.WriteLine(result.GetProperty("provisioningState").ToString());
        /// Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        /// Console.WriteLine(result.GetProperty("parameters").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// <details><summary>Environment</summary>Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// </details>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateEnvironmentAsync(string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.UpdateEnvironment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateEnvironmentRequest(userId, environmentName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Partially updates an environment. </summary>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateEnvironment with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     environmentType = "<environmentType>",
        /// };
        /// 
        /// Response response = client.UpdateEnvironment("<environmentName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UpdateEnvironment with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     environmentType = "<environmentType>",
        ///     owner = "<owner>",
        ///     description = "<description>",
        ///     catalogName = "<catalogName>",
        ///     catalogItemName = "<catalogItemName>",
        ///     parameters = new {},
        ///     scheduledTasks = new {
        ///         key = new {
        ///             type = "AutoExpire",
        ///             enabled = "Enabled",
        ///             startTime = "2022-05-10T18:57:31.2311892Z",
        ///         },
        ///     },
        ///     tags = new {
        ///         key = "<String>",
        ///     },
        /// };
        /// 
        /// Response response = client.UpdateEnvironment("<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.GetProperty("owner").ToString());
        /// Console.WriteLine(result.GetProperty("provisioningState").ToString());
        /// Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        /// Console.WriteLine(result.GetProperty("parameters").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// <details><summary>Environment</summary>Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// </details>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateEnvironment(string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.UpdateEnvironment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateEnvironmentRequest(userId, environmentName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a catalog item from a project. </summary>
        /// <param name="catalogItemId"> The unique id of the catalog item. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="catalogItemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="catalogItemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCatalogItemAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// Response response = await client.GetCatalogItemAsync("<catalogItemId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CatalogItem</c>:
        /// <code>{
        ///   id: string, # Optional. Unique identifier of the catalog item.
        ///   name: string, # Optional. Name of the catalog item.
        ///   catalogName: string, # Optional. Name of the catalog.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetCatalogItemAsync(string catalogItemId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(catalogItemId, nameof(catalogItemId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.GetCatalogItem");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCatalogItemRequest(catalogItemId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a catalog item from a project. </summary>
        /// <param name="catalogItemId"> The unique id of the catalog item. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="catalogItemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="catalogItemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCatalogItem with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// Response response = client.GetCatalogItem("<catalogItemId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CatalogItem</c>:
        /// <code>{
        ///   id: string, # Optional. Unique identifier of the catalog item.
        ///   name: string, # Optional. Name of the catalog item.
        ///   catalogName: string, # Optional. Name of the catalog.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetCatalogItem(string catalogItemId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(catalogItemId, nameof(catalogItemId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.GetCatalogItem");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCatalogItemRequest(catalogItemId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a specific catalog item version from a project. </summary>
        /// <param name="catalogItemId"> The unique id of the catalog item. </param>
        /// <param name="version"> The version of the catalog item. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="catalogItemId"/> or <paramref name="version"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="catalogItemId"/> or <paramref name="version"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCatalogItemVersionAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// Response response = await client.GetCatalogItemVersionAsync("<catalogItemId>", "<version>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("catalogItemId").ToString());
        /// Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("summary").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("templatePath").ToString());
        /// Console.WriteLine(result.GetProperty("parametersSchema").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("default").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("readOnly").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("required").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("allowed")[0].ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parametersSchema").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("default").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("readOnly").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("required").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("allowed")[0].ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("runner").ToString());
        /// Console.WriteLine(result.GetProperty("runner").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("eligibleForLatestVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CatalogItemVersion</c>:
        /// <code>{
        ///   catalogItemId: string, # Optional. Unique identifier of the catalog item.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   version: string, # Optional. The version of the catalog item.
        ///   summary: string, # Optional. A short summary of the catalog item.
        ///   description: string, # Optional. A long description of the catalog item.
        ///   templatePath: string, # Optional. Path to the catalog item entrypoint file.
        ///   parametersSchema: string, # Optional. JSON schema defining the parameters object passed to actions
        ///   parameters: [
        ///     {
        ///       id: string, # Optional. Unique ID of the parameter
        ///       name: string, # Optional. Display name of the parameter
        ///       description: string, # Optional. Description of the parameter
        ///       default: AnyObject, # Optional. Default value of the parameter
        ///       type: &quot;array&quot; | &quot;boolean&quot; | &quot;integer&quot; | &quot;null&quot; | &quot;number&quot; | &quot;object&quot; | &quot;string&quot;, # Optional. A string of one of the basic JSON types (number, integer, null, array, object, boolean, string)
        ///       readOnly: boolean, # Optional. Whether or not this parameter is read-only.  If true, default should have a value.
        ///       required: boolean, # Optional. Whether or not this parameter is required
        ///       allowed: [AnyObject], # Optional. An array of allowed values
        ///     }
        ///   ], # Optional. Input parameters passed to actions
        ///   actions: [
        ///     {
        ///       id: string, # Optional. Unique identifier of the action
        ///       name: string, # Optional. Display name of the action
        ///       description: string, # Optional. Description of the action
        ///       parametersSchema: string, # Optional. JSON schema defining the parameters specific to the custom action
        ///       parameters: [CatalogItemParameter], # Optional. Input parameters passed to the action
        ///       type: &quot;Custom&quot; | &quot;Deploy&quot; | &quot;Delete&quot;, # Optional. The action type.
        ///       typeName: string, # Optional. Name of the custom action type
        ///       runner: string, # Optional. The container image to use to execute the action
        ///     }
        ///   ], # Optional. Custom actions for the catalog item.
        ///   runner: string, # Optional. The default container image to use to execute actions
        ///   status: &quot;Enabled&quot; | &quot;Disabled&quot;, # Optional. Defines whether the specific catalog item version can be used.
        ///   eligibleForLatestVersion: boolean, # Optional. Whether the version is eligible to be the latest version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetCatalogItemVersionAsync(string catalogItemId, string version, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(catalogItemId, nameof(catalogItemId));
            Argument.AssertNotNullOrEmpty(version, nameof(version));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.GetCatalogItemVersion");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCatalogItemVersionRequest(catalogItemId, version, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a specific catalog item version from a project. </summary>
        /// <param name="catalogItemId"> The unique id of the catalog item. </param>
        /// <param name="version"> The version of the catalog item. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="catalogItemId"/> or <paramref name="version"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="catalogItemId"/> or <paramref name="version"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCatalogItemVersion with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// Response response = client.GetCatalogItemVersion("<catalogItemId>", "<version>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("catalogItemId").ToString());
        /// Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("summary").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("templatePath").ToString());
        /// Console.WriteLine(result.GetProperty("parametersSchema").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("default").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("readOnly").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("required").ToString());
        /// Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("allowed")[0].ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parametersSchema").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("default").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("readOnly").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("required").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("allowed")[0].ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("actions")[0].GetProperty("runner").ToString());
        /// Console.WriteLine(result.GetProperty("runner").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("eligibleForLatestVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CatalogItemVersion</c>:
        /// <code>{
        ///   catalogItemId: string, # Optional. Unique identifier of the catalog item.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   version: string, # Optional. The version of the catalog item.
        ///   summary: string, # Optional. A short summary of the catalog item.
        ///   description: string, # Optional. A long description of the catalog item.
        ///   templatePath: string, # Optional. Path to the catalog item entrypoint file.
        ///   parametersSchema: string, # Optional. JSON schema defining the parameters object passed to actions
        ///   parameters: [
        ///     {
        ///       id: string, # Optional. Unique ID of the parameter
        ///       name: string, # Optional. Display name of the parameter
        ///       description: string, # Optional. Description of the parameter
        ///       default: AnyObject, # Optional. Default value of the parameter
        ///       type: &quot;array&quot; | &quot;boolean&quot; | &quot;integer&quot; | &quot;null&quot; | &quot;number&quot; | &quot;object&quot; | &quot;string&quot;, # Optional. A string of one of the basic JSON types (number, integer, null, array, object, boolean, string)
        ///       readOnly: boolean, # Optional. Whether or not this parameter is read-only.  If true, default should have a value.
        ///       required: boolean, # Optional. Whether or not this parameter is required
        ///       allowed: [AnyObject], # Optional. An array of allowed values
        ///     }
        ///   ], # Optional. Input parameters passed to actions
        ///   actions: [
        ///     {
        ///       id: string, # Optional. Unique identifier of the action
        ///       name: string, # Optional. Display name of the action
        ///       description: string, # Optional. Description of the action
        ///       parametersSchema: string, # Optional. JSON schema defining the parameters specific to the custom action
        ///       parameters: [CatalogItemParameter], # Optional. Input parameters passed to the action
        ///       type: &quot;Custom&quot; | &quot;Deploy&quot; | &quot;Delete&quot;, # Optional. The action type.
        ///       typeName: string, # Optional. Name of the custom action type
        ///       runner: string, # Optional. The container image to use to execute the action
        ///     }
        ///   ], # Optional. Custom actions for the catalog item.
        ///   runner: string, # Optional. The default container image to use to execute actions
        ///   status: &quot;Enabled&quot; | &quot;Disabled&quot;, # Optional. Defines whether the specific catalog item version can be used.
        ///   eligibleForLatestVersion: boolean, # Optional. Whether the version is eligible to be the latest version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetCatalogItemVersion(string catalogItemId, string version, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(catalogItemId, nameof(catalogItemId));
            Argument.AssertNotNullOrEmpty(version, nameof(version));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.GetCatalogItemVersion");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCatalogItemVersionRequest(catalogItemId, version, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the environments for a project. </summary>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnvironmentsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetEnvironmentsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("environmentType").ToString());
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetEnvironmentsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetEnvironmentsAsync(1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("environmentType").ToString());
        ///     Console.WriteLine(result.GetProperty("owner").ToString());
        ///     Console.WriteLine(result.GetProperty("provisioningState").ToString());
        ///     Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogName").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        ///     Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EnvironmentListResultValue</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetEnvironmentsAsync(int? maxCount = null, RequestContext context = null)
        {
            return GetEnvironmentsImplementationAsync("EnvironmentsClient.GetEnvironments", maxCount, context);
        }

        private AsyncPageable<BinaryData> GetEnvironmentsImplementationAsync(string diagnosticsScopeName, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetEnvironmentsRequest(maxCount, context)
                        : CreateGetEnvironmentsNextPageRequest(nextLink, maxCount, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the environments for a project. </summary>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnvironments and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetEnvironments())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("environmentType").ToString());
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetEnvironments with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetEnvironments(1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("environmentType").ToString());
        ///     Console.WriteLine(result.GetProperty("owner").ToString());
        ///     Console.WriteLine(result.GetProperty("provisioningState").ToString());
        ///     Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogName").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        ///     Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EnvironmentListResultValue</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetEnvironments(int? maxCount = null, RequestContext context = null)
        {
            return GetEnvironmentsImplementation("EnvironmentsClient.GetEnvironments", maxCount, context);
        }

        private Pageable<BinaryData> GetEnvironmentsImplementation(string diagnosticsScopeName, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetEnvironmentsRequest(maxCount, context)
                        : CreateGetEnvironmentsNextPageRequest(nextLink, maxCount, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the environments for a project and user. </summary>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnvironmentsByUserAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetEnvironmentsByUserAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("environmentType").ToString());
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetEnvironmentsByUserAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetEnvironmentsByUserAsync(<me>, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("environmentType").ToString());
        ///     Console.WriteLine(result.GetProperty("owner").ToString());
        ///     Console.WriteLine(result.GetProperty("provisioningState").ToString());
        ///     Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogName").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        ///     Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EnvironmentListResultValue</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetEnvironmentsByUserAsync(string userId = "me", int? maxCount = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            return GetEnvironmentsByUserImplementationAsync("EnvironmentsClient.GetEnvironmentsByUser", userId, maxCount, context);
        }

        private AsyncPageable<BinaryData> GetEnvironmentsByUserImplementationAsync(string diagnosticsScopeName, string userId, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetEnvironmentsByUserRequest(userId, maxCount, context)
                        : CreateGetEnvironmentsByUserNextPageRequest(nextLink, userId, maxCount, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the environments for a project and user. </summary>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnvironmentsByUser and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetEnvironmentsByUser())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("environmentType").ToString());
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetEnvironmentsByUser with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetEnvironmentsByUser(<me>, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("environmentType").ToString());
        ///     Console.WriteLine(result.GetProperty("owner").ToString());
        ///     Console.WriteLine(result.GetProperty("provisioningState").ToString());
        ///     Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogName").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        ///     Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        ///     Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EnvironmentListResultValue</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetEnvironmentsByUser(string userId = "me", int? maxCount = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            return GetEnvironmentsByUserImplementation("EnvironmentsClient.GetEnvironmentsByUser", userId, maxCount, context);
        }

        private Pageable<BinaryData> GetEnvironmentsByUserImplementation(string diagnosticsScopeName, string userId, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetEnvironmentsByUserRequest(userId, maxCount, context)
                        : CreateGetEnvironmentsByUserNextPageRequest(nextLink, userId, maxCount, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the artifacts for an environment. </summary>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetArtifactsByEnvironmentAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetArtifactsByEnvironmentAsync("<environmentName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetArtifactsByEnvironmentAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetArtifactsByEnvironmentAsync("<environmentName>", <me>))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("isDirectory").ToString());
        ///     Console.WriteLine(result.GetProperty("downloadUri").ToString());
        ///     Console.WriteLine(result.GetProperty("fileSize").ToString());
        ///     Console.WriteLine(result.GetProperty("createdTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedTime").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArtifactListResultValue</c>:
        /// <code>{
        ///   id: string, # Optional. Artifact identifier
        ///   name: string, # Optional. Artifact name
        ///   isDirectory: boolean, # Optional. Whether artifact is a directory
        ///   downloadUri: string, # Optional. Uri where the file contents can be downloaded
        ///   fileSize: number, # Optional. Size of file in bytes, if the artifact is a file
        ///   createdTime: string (ISO 8601 Format), # Optional. Time the artifact was created
        ///   lastModifiedTime: string (ISO 8601 Format), # Optional. Time the artifact was last modified
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetArtifactsByEnvironmentAsync(string environmentName, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            return GetArtifactsByEnvironmentImplementationAsync("EnvironmentsClient.GetArtifactsByEnvironment", environmentName, userId, context);
        }

        private AsyncPageable<BinaryData> GetArtifactsByEnvironmentImplementationAsync(string diagnosticsScopeName, string environmentName, string userId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetArtifactsByEnvironmentRequest(userId, environmentName, context)
                        : CreateGetArtifactsByEnvironmentNextPageRequest(nextLink, userId, environmentName, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the artifacts for an environment. </summary>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetArtifactsByEnvironment with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetArtifactsByEnvironment("<environmentName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetArtifactsByEnvironment with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetArtifactsByEnvironment("<environmentName>", <me>))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("isDirectory").ToString());
        ///     Console.WriteLine(result.GetProperty("downloadUri").ToString());
        ///     Console.WriteLine(result.GetProperty("fileSize").ToString());
        ///     Console.WriteLine(result.GetProperty("createdTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedTime").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArtifactListResultValue</c>:
        /// <code>{
        ///   id: string, # Optional. Artifact identifier
        ///   name: string, # Optional. Artifact name
        ///   isDirectory: boolean, # Optional. Whether artifact is a directory
        ///   downloadUri: string, # Optional. Uri where the file contents can be downloaded
        ///   fileSize: number, # Optional. Size of file in bytes, if the artifact is a file
        ///   createdTime: string (ISO 8601 Format), # Optional. Time the artifact was created
        ///   lastModifiedTime: string (ISO 8601 Format), # Optional. Time the artifact was last modified
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetArtifactsByEnvironment(string environmentName, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            return GetArtifactsByEnvironmentImplementation("EnvironmentsClient.GetArtifactsByEnvironment", environmentName, userId, context);
        }

        private Pageable<BinaryData> GetArtifactsByEnvironmentImplementation(string diagnosticsScopeName, string environmentName, string userId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetArtifactsByEnvironmentRequest(userId, environmentName, context)
                        : CreateGetArtifactsByEnvironmentNextPageRequest(nextLink, userId, environmentName, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the artifacts for an environment at a specified path, or returns the file at the path. </summary>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="artifactPath"> The path of the artifact. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="artifactPath"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/>, <paramref name="artifactPath"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetArtifactsByEnvironmentAndPathAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetArtifactsByEnvironmentAndPathAsync("<environmentName>", "<artifactPath>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetArtifactsByEnvironmentAndPathAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetArtifactsByEnvironmentAndPathAsync("<environmentName>", "<artifactPath>", <me>))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("isDirectory").ToString());
        ///     Console.WriteLine(result.GetProperty("downloadUri").ToString());
        ///     Console.WriteLine(result.GetProperty("fileSize").ToString());
        ///     Console.WriteLine(result.GetProperty("createdTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedTime").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArtifactListResultValue</c>:
        /// <code>{
        ///   id: string, # Optional. Artifact identifier
        ///   name: string, # Optional. Artifact name
        ///   isDirectory: boolean, # Optional. Whether artifact is a directory
        ///   downloadUri: string, # Optional. Uri where the file contents can be downloaded
        ///   fileSize: number, # Optional. Size of file in bytes, if the artifact is a file
        ///   createdTime: string (ISO 8601 Format), # Optional. Time the artifact was created
        ///   lastModifiedTime: string (ISO 8601 Format), # Optional. Time the artifact was last modified
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetArtifactsByEnvironmentAndPathAsync(string environmentName, string artifactPath, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNullOrEmpty(artifactPath, nameof(artifactPath));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            return GetArtifactsByEnvironmentAndPathImplementationAsync("EnvironmentsClient.GetArtifactsByEnvironmentAndPath", environmentName, artifactPath, userId, context);
        }

        private AsyncPageable<BinaryData> GetArtifactsByEnvironmentAndPathImplementationAsync(string diagnosticsScopeName, string environmentName, string artifactPath, string userId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetArtifactsByEnvironmentAndPathRequest(userId, environmentName, artifactPath, context)
                        : CreateGetArtifactsByEnvironmentAndPathNextPageRequest(nextLink, userId, environmentName, artifactPath, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the artifacts for an environment at a specified path, or returns the file at the path. </summary>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="artifactPath"> The path of the artifact. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="artifactPath"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/>, <paramref name="artifactPath"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetArtifactsByEnvironmentAndPath with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetArtifactsByEnvironmentAndPath("<environmentName>", "<artifactPath>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetArtifactsByEnvironmentAndPath with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetArtifactsByEnvironmentAndPath("<environmentName>", "<artifactPath>", <me>))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("isDirectory").ToString());
        ///     Console.WriteLine(result.GetProperty("downloadUri").ToString());
        ///     Console.WriteLine(result.GetProperty("fileSize").ToString());
        ///     Console.WriteLine(result.GetProperty("createdTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedTime").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArtifactListResultValue</c>:
        /// <code>{
        ///   id: string, # Optional. Artifact identifier
        ///   name: string, # Optional. Artifact name
        ///   isDirectory: boolean, # Optional. Whether artifact is a directory
        ///   downloadUri: string, # Optional. Uri where the file contents can be downloaded
        ///   fileSize: number, # Optional. Size of file in bytes, if the artifact is a file
        ///   createdTime: string (ISO 8601 Format), # Optional. Time the artifact was created
        ///   lastModifiedTime: string (ISO 8601 Format), # Optional. Time the artifact was last modified
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetArtifactsByEnvironmentAndPath(string environmentName, string artifactPath, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNullOrEmpty(artifactPath, nameof(artifactPath));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            return GetArtifactsByEnvironmentAndPathImplementation("EnvironmentsClient.GetArtifactsByEnvironmentAndPath", environmentName, artifactPath, userId, context);
        }

        private Pageable<BinaryData> GetArtifactsByEnvironmentAndPathImplementation(string diagnosticsScopeName, string environmentName, string artifactPath, string userId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetArtifactsByEnvironmentAndPathRequest(userId, environmentName, artifactPath, context)
                        : CreateGetArtifactsByEnvironmentAndPathNextPageRequest(nextLink, userId, environmentName, artifactPath, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists latest version of all catalog items available for a project. </summary>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCatalogItemsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetCatalogItemsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetCatalogItemsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetCatalogItemsAsync(1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CatalogItemListResultValue</c>:
        /// <code>{
        ///   id: string, # Optional. Unique identifier of the catalog item.
        ///   name: string, # Optional. Name of the catalog item.
        ///   catalogName: string, # Optional. Name of the catalog.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetCatalogItemsAsync(int? maxCount = null, RequestContext context = null)
        {
            return GetCatalogItemsImplementationAsync("EnvironmentsClient.GetCatalogItems", maxCount, context);
        }

        private AsyncPageable<BinaryData> GetCatalogItemsImplementationAsync(string diagnosticsScopeName, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetCatalogItemsRequest(maxCount, context)
                        : CreateGetCatalogItemsNextPageRequest(nextLink, maxCount, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists latest version of all catalog items available for a project. </summary>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCatalogItems and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetCatalogItems())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetCatalogItems with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetCatalogItems(1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CatalogItemListResultValue</c>:
        /// <code>{
        ///   id: string, # Optional. Unique identifier of the catalog item.
        ///   name: string, # Optional. Name of the catalog item.
        ///   catalogName: string, # Optional. Name of the catalog.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetCatalogItems(int? maxCount = null, RequestContext context = null)
        {
            return GetCatalogItemsImplementation("EnvironmentsClient.GetCatalogItems", maxCount, context);
        }

        private Pageable<BinaryData> GetCatalogItemsImplementation(string diagnosticsScopeName, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetCatalogItemsRequest(maxCount, context)
                        : CreateGetCatalogItemsNextPageRequest(nextLink, maxCount, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List all versions of a catalog item from a project. </summary>
        /// <param name="catalogItemId"> The unique id of the catalog item. </param>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="catalogItemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="catalogItemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCatalogItemVersionsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetCatalogItemVersionsAsync("<catalogItemId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetCatalogItemVersionsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetCatalogItemVersionsAsync("<catalogItemId>", 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("catalogItemId").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogName").ToString());
        ///     Console.WriteLine(result.GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("templatePath").ToString());
        ///     Console.WriteLine(result.GetProperty("parametersSchema").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("default").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("readOnly").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("required").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("allowed")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parametersSchema").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("default").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("readOnly").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("required").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("allowed")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("typeName").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("runner").ToString());
        ///     Console.WriteLine(result.GetProperty("runner").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("eligibleForLatestVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CatalogItemVersionListResultValue</c>:
        /// <code>{
        ///   catalogItemId: string, # Optional. Unique identifier of the catalog item.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   version: string, # Optional. The version of the catalog item.
        ///   summary: string, # Optional. A short summary of the catalog item.
        ///   description: string, # Optional. A long description of the catalog item.
        ///   templatePath: string, # Optional. Path to the catalog item entrypoint file.
        ///   parametersSchema: string, # Optional. JSON schema defining the parameters object passed to actions
        ///   parameters: [
        ///     {
        ///       id: string, # Optional. Unique ID of the parameter
        ///       name: string, # Optional. Display name of the parameter
        ///       description: string, # Optional. Description of the parameter
        ///       default: AnyObject, # Optional. Default value of the parameter
        ///       type: &quot;array&quot; | &quot;boolean&quot; | &quot;integer&quot; | &quot;null&quot; | &quot;number&quot; | &quot;object&quot; | &quot;string&quot;, # Optional. A string of one of the basic JSON types (number, integer, null, array, object, boolean, string)
        ///       readOnly: boolean, # Optional. Whether or not this parameter is read-only.  If true, default should have a value.
        ///       required: boolean, # Optional. Whether or not this parameter is required
        ///       allowed: [AnyObject], # Optional. An array of allowed values
        ///     }
        ///   ], # Optional. Input parameters passed to actions
        ///   actions: [
        ///     {
        ///       id: string, # Optional. Unique identifier of the action
        ///       name: string, # Optional. Display name of the action
        ///       description: string, # Optional. Description of the action
        ///       parametersSchema: string, # Optional. JSON schema defining the parameters specific to the custom action
        ///       parameters: [CatalogItemParameter], # Optional. Input parameters passed to the action
        ///       type: &quot;Custom&quot; | &quot;Deploy&quot; | &quot;Delete&quot;, # Optional. The action type.
        ///       typeName: string, # Optional. Name of the custom action type
        ///       runner: string, # Optional. The container image to use to execute the action
        ///     }
        ///   ], # Optional. Custom actions for the catalog item.
        ///   runner: string, # Optional. The default container image to use to execute actions
        ///   status: &quot;Enabled&quot; | &quot;Disabled&quot;, # Optional. Defines whether the specific catalog item version can be used.
        ///   eligibleForLatestVersion: boolean, # Optional. Whether the version is eligible to be the latest version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetCatalogItemVersionsAsync(string catalogItemId, int? maxCount = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(catalogItemId, nameof(catalogItemId));

            return GetCatalogItemVersionsImplementationAsync("EnvironmentsClient.GetCatalogItemVersions", catalogItemId, maxCount, context);
        }

        private AsyncPageable<BinaryData> GetCatalogItemVersionsImplementationAsync(string diagnosticsScopeName, string catalogItemId, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetCatalogItemVersionsRequest(catalogItemId, maxCount, context)
                        : CreateGetCatalogItemVersionsNextPageRequest(nextLink, catalogItemId, maxCount, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List all versions of a catalog item from a project. </summary>
        /// <param name="catalogItemId"> The unique id of the catalog item. </param>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="catalogItemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="catalogItemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCatalogItemVersions with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetCatalogItemVersions("<catalogItemId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetCatalogItemVersions with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetCatalogItemVersions("<catalogItemId>", 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("catalogItemId").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        ///     Console.WriteLine(result.GetProperty("catalogName").ToString());
        ///     Console.WriteLine(result.GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("summary").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("templatePath").ToString());
        ///     Console.WriteLine(result.GetProperty("parametersSchema").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("default").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("readOnly").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("required").ToString());
        ///     Console.WriteLine(result.GetProperty("parameters")[0].GetProperty("allowed")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parametersSchema").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("default").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("readOnly").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("required").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("parameters")[0].GetProperty("allowed")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("typeName").ToString());
        ///     Console.WriteLine(result.GetProperty("actions")[0].GetProperty("runner").ToString());
        ///     Console.WriteLine(result.GetProperty("runner").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("eligibleForLatestVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CatalogItemVersionListResultValue</c>:
        /// <code>{
        ///   catalogItemId: string, # Optional. Unique identifier of the catalog item.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   version: string, # Optional. The version of the catalog item.
        ///   summary: string, # Optional. A short summary of the catalog item.
        ///   description: string, # Optional. A long description of the catalog item.
        ///   templatePath: string, # Optional. Path to the catalog item entrypoint file.
        ///   parametersSchema: string, # Optional. JSON schema defining the parameters object passed to actions
        ///   parameters: [
        ///     {
        ///       id: string, # Optional. Unique ID of the parameter
        ///       name: string, # Optional. Display name of the parameter
        ///       description: string, # Optional. Description of the parameter
        ///       default: AnyObject, # Optional. Default value of the parameter
        ///       type: &quot;array&quot; | &quot;boolean&quot; | &quot;integer&quot; | &quot;null&quot; | &quot;number&quot; | &quot;object&quot; | &quot;string&quot;, # Optional. A string of one of the basic JSON types (number, integer, null, array, object, boolean, string)
        ///       readOnly: boolean, # Optional. Whether or not this parameter is read-only.  If true, default should have a value.
        ///       required: boolean, # Optional. Whether or not this parameter is required
        ///       allowed: [AnyObject], # Optional. An array of allowed values
        ///     }
        ///   ], # Optional. Input parameters passed to actions
        ///   actions: [
        ///     {
        ///       id: string, # Optional. Unique identifier of the action
        ///       name: string, # Optional. Display name of the action
        ///       description: string, # Optional. Description of the action
        ///       parametersSchema: string, # Optional. JSON schema defining the parameters specific to the custom action
        ///       parameters: [CatalogItemParameter], # Optional. Input parameters passed to the action
        ///       type: &quot;Custom&quot; | &quot;Deploy&quot; | &quot;Delete&quot;, # Optional. The action type.
        ///       typeName: string, # Optional. Name of the custom action type
        ///       runner: string, # Optional. The container image to use to execute the action
        ///     }
        ///   ], # Optional. Custom actions for the catalog item.
        ///   runner: string, # Optional. The default container image to use to execute actions
        ///   status: &quot;Enabled&quot; | &quot;Disabled&quot;, # Optional. Defines whether the specific catalog item version can be used.
        ///   eligibleForLatestVersion: boolean, # Optional. Whether the version is eligible to be the latest version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetCatalogItemVersions(string catalogItemId, int? maxCount = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(catalogItemId, nameof(catalogItemId));

            return GetCatalogItemVersionsImplementation("EnvironmentsClient.GetCatalogItemVersions", catalogItemId, maxCount, context);
        }

        private Pageable<BinaryData> GetCatalogItemVersionsImplementation(string diagnosticsScopeName, string catalogItemId, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetCatalogItemVersionsRequest(catalogItemId, maxCount, context)
                        : CreateGetCatalogItemVersionsNextPageRequest(nextLink, catalogItemId, maxCount, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists all environment types configured for a project. </summary>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnvironmentTypesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetEnvironmentTypesAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetEnvironmentTypesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// await foreach (var data in client.GetEnvironmentTypesAsync(1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentTargetId").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EnvironmentTypeListResultValue</c>:
        /// <code>{
        ///   name: string, # Optional. Name of the environment type
        ///   deploymentTargetId: string, # Optional. Id of a subscription or management group that the environment type will be mapped to. The environment&apos;s resources will be deployed into this subscription or management group.
        ///   status: &quot;Enabled&quot; | &quot;Disabled&quot;, # Optional. Defines whether this Environment Type can be used in this Project.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetEnvironmentTypesAsync(int? maxCount = null, RequestContext context = null)
        {
            return GetEnvironmentTypesImplementationAsync("EnvironmentsClient.GetEnvironmentTypes", maxCount, context);
        }

        private AsyncPageable<BinaryData> GetEnvironmentTypesImplementationAsync(string diagnosticsScopeName, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetEnvironmentTypesRequest(maxCount, context)
                        : CreateGetEnvironmentTypesNextPageRequest(nextLink, maxCount, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists all environment types configured for a project. </summary>
        /// <param name="maxCount"> The maximum number of resources to return from the operation. Example: &apos;top=10&apos;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnvironmentTypes and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetEnvironmentTypes())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetEnvironmentTypes with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// foreach (var data in client.GetEnvironmentTypes(1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentTargetId").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EnvironmentTypeListResultValue</c>:
        /// <code>{
        ///   name: string, # Optional. Name of the environment type
        ///   deploymentTargetId: string, # Optional. Id of a subscription or management group that the environment type will be mapped to. The environment&apos;s resources will be deployed into this subscription or management group.
        ///   status: &quot;Enabled&quot; | &quot;Disabled&quot;, # Optional. Defines whether this Environment Type can be used in this Project.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetEnvironmentTypes(int? maxCount = null, RequestContext context = null)
        {
            return GetEnvironmentTypesImplementation("EnvironmentsClient.GetEnvironmentTypes", maxCount, context);
        }

        private Pageable<BinaryData> GetEnvironmentTypesImplementation(string diagnosticsScopeName, int? maxCount, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetEnvironmentTypesRequest(maxCount, context)
                        : CreateGetEnvironmentTypesNextPageRequest(nextLink, maxCount, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Creates or updates an environment. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateEnvironmentAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     environmentType = "<environmentType>",
        /// };
        /// 
        /// var operation = await client.CreateOrUpdateEnvironmentAsync(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateEnvironmentAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     environmentType = "<environmentType>",
        ///     owner = "<owner>",
        ///     description = "<description>",
        ///     catalogName = "<catalogName>",
        ///     catalogItemName = "<catalogItemName>",
        ///     parameters = new {},
        ///     scheduledTasks = new {
        ///         key = new {
        ///             type = "AutoExpire",
        ///             enabled = "Enabled",
        ///             startTime = "2022-05-10T18:57:31.2311892Z",
        ///         },
        ///     },
        ///     tags = new {
        ///         key = "<String>",
        ///     },
        /// };
        /// 
        /// var operation = await client.CreateOrUpdateEnvironmentAsync(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.GetProperty("owner").ToString());
        /// Console.WriteLine(result.GetProperty("provisioningState").ToString());
        /// Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        /// Console.WriteLine(result.GetProperty("parameters").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> CreateOrUpdateEnvironmentAsync(WaitUntil waitUntil, string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.CreateOrUpdateEnvironment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateEnvironmentRequest(userId, environmentName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.CreateOrUpdateEnvironment", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates or updates an environment. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateEnvironment with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     environmentType = "<environmentType>",
        /// };
        /// 
        /// var operation = client.CreateOrUpdateEnvironment(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateEnvironment with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     environmentType = "<environmentType>",
        ///     owner = "<owner>",
        ///     description = "<description>",
        ///     catalogName = "<catalogName>",
        ///     catalogItemName = "<catalogItemName>",
        ///     parameters = new {},
        ///     scheduledTasks = new {
        ///         key = new {
        ///             type = "AutoExpire",
        ///             enabled = "Enabled",
        ///             startTime = "2022-05-10T18:57:31.2311892Z",
        ///         },
        ///     },
        ///     tags = new {
        ///         key = "<String>",
        ///     },
        /// };
        /// 
        /// var operation = client.CreateOrUpdateEnvironment(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("environmentType").ToString());
        /// Console.WriteLine(result.GetProperty("owner").ToString());
        /// Console.WriteLine(result.GetProperty("provisioningState").ToString());
        /// Console.WriteLine(result.GetProperty("resourceGroupId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("catalogName").ToString());
        /// Console.WriteLine(result.GetProperty("catalogItemName").ToString());
        /// Console.WriteLine(result.GetProperty("parameters").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("enabled").ToString());
        /// Console.WriteLine(result.GetProperty("scheduledTasks").GetProperty("<test>").GetProperty("startTime").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Environment</c>:
        /// <code>{
        ///   name: string, # Optional. Environment name.
        ///   environmentType: string, # Required. Environment type.
        ///   owner: string, # Optional. Identifier of the owner of this Environment.
        ///   provisioningState: string, # Optional. The provisioning state of the environment.
        ///   resourceGroupId: string, # Optional. The identifier of the resource group containing the environment&apos;s resources.
        ///   description: string, # Optional. Description of the Environment.
        ///   catalogName: string, # Optional. Name of the catalog.
        ///   catalogItemName: string, # Optional. Name of the catalog item.
        ///   parameters: AnyObject, # Optional. Parameters object for the deploy action
        ///   scheduledTasks: Dictionary&lt;string, ScheduledTask&gt;, # Optional. Set of supported scheduled tasks to help manage cost.
        ///   tags: Dictionary&lt;string, string&gt;, # Optional. Key value pairs that will be applied to resources deployed in this environment as tags.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> CreateOrUpdateEnvironment(WaitUntil waitUntil, string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.CreateOrUpdateEnvironment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateEnvironmentRequest(userId, environmentName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.CreateOrUpdateEnvironment", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an environment and all it&apos;s associated resources. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteEnvironmentAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var operation = await client.DeleteEnvironmentAsync(WaitUntil.Completed, "<environmentName>");
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// This sample shows how to call DeleteEnvironmentAsync with all parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var operation = await client.DeleteEnvironmentAsync(WaitUntil.Completed, "<environmentName>", <me>);
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        public virtual async Task<Operation> DeleteEnvironmentAsync(WaitUntil waitUntil, string environmentName, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.DeleteEnvironment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteEnvironmentRequest(userId, environmentName, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.DeleteEnvironment", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an environment and all it&apos;s associated resources. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteEnvironment with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var operation = client.DeleteEnvironment(WaitUntil.Completed, "<environmentName>");
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// This sample shows how to call DeleteEnvironment with all parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var operation = client.DeleteEnvironment(WaitUntil.Completed, "<environmentName>", <me>);
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        public virtual Operation DeleteEnvironment(WaitUntil waitUntil, string environmentName, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.DeleteEnvironment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteEnvironmentRequest(userId, environmentName, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.DeleteEnvironment", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Executes a deploy action. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call DeployEnvironmentActionAsync with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        /// };
        /// 
        /// var operation = await client.DeployEnvironmentActionAsync(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data));
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// This sample shows how to call DeployEnvironmentActionAsync with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        ///     parameters = new {},
        /// };
        /// 
        /// var operation = await client.DeployEnvironmentActionAsync(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ActionRequest</c>:
        /// <code>{
        ///   actionId: string, # Required. The Catalog Item action id to execute
        ///   parameters: AnyObject, # Optional. Parameters object for the Action
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation> DeployEnvironmentActionAsync(WaitUntil waitUntil, string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.DeployEnvironmentAction");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployEnvironmentActionRequest(userId, environmentName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.DeployEnvironmentAction", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Executes a deploy action. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call DeployEnvironmentAction with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        /// };
        /// 
        /// var operation = client.DeployEnvironmentAction(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data));
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// This sample shows how to call DeployEnvironmentAction with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        ///     parameters = new {},
        /// };
        /// 
        /// var operation = client.DeployEnvironmentAction(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ActionRequest</c>:
        /// <code>{
        ///   actionId: string, # Required. The Catalog Item action id to execute
        ///   parameters: AnyObject, # Optional. Parameters object for the Action
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation DeployEnvironmentAction(WaitUntil waitUntil, string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.DeployEnvironmentAction");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployEnvironmentActionRequest(userId, environmentName, content, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.DeployEnvironmentAction", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Executes a delete action. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteEnvironmentActionAsync with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        /// };
        /// 
        /// var operation = await client.DeleteEnvironmentActionAsync(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data));
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// This sample shows how to call DeleteEnvironmentActionAsync with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        ///     parameters = new {},
        /// };
        /// 
        /// var operation = await client.DeleteEnvironmentActionAsync(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ActionRequest</c>:
        /// <code>{
        ///   actionId: string, # Required. The Catalog Item action id to execute
        ///   parameters: AnyObject, # Optional. Parameters object for the Action
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation> DeleteEnvironmentActionAsync(WaitUntil waitUntil, string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.DeleteEnvironmentAction");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteEnvironmentActionRequest(userId, environmentName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.DeleteEnvironmentAction", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Executes a delete action. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteEnvironmentAction with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        /// };
        /// 
        /// var operation = client.DeleteEnvironmentAction(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data));
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// This sample shows how to call DeleteEnvironmentAction with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        ///     parameters = new {},
        /// };
        /// 
        /// var operation = client.DeleteEnvironmentAction(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ActionRequest</c>:
        /// <code>{
        ///   actionId: string, # Required. The Catalog Item action id to execute
        ///   parameters: AnyObject, # Optional. Parameters object for the Action
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation DeleteEnvironmentAction(WaitUntil waitUntil, string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.DeleteEnvironmentAction");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteEnvironmentActionRequest(userId, environmentName, content, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.DeleteEnvironmentAction", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Executes a custom action. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call CustomEnvironmentActionAsync with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        /// };
        /// 
        /// var operation = await client.CustomEnvironmentActionAsync(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data));
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// This sample shows how to call CustomEnvironmentActionAsync with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        ///     parameters = new {},
        /// };
        /// 
        /// var operation = await client.CustomEnvironmentActionAsync(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ActionRequest</c>:
        /// <code>{
        ///   actionId: string, # Required. The Catalog Item action id to execute
        ///   parameters: AnyObject, # Optional. Parameters object for the Action
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation> CustomEnvironmentActionAsync(WaitUntil waitUntil, string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.CustomEnvironmentAction");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCustomEnvironmentActionRequest(userId, environmentName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.CustomEnvironmentAction", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Executes a custom action. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="environmentName"> The name of the environment. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="userId"> The AAD object id of the user. If value is &apos;me&apos;, the identity is taken from the authentication context. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="environmentName"/>, <paramref name="content"/> or <paramref name="userId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="environmentName"/> or <paramref name="userId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call CustomEnvironmentAction with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        /// };
        /// 
        /// var operation = client.CustomEnvironmentAction(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data));
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// This sample shows how to call CustomEnvironmentAction with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new EnvironmentsClient("<tenantId>", "<devCenter>", "<projectName>", credential);
        /// 
        /// var data = new {
        ///     actionId = "<actionId>",
        ///     parameters = new {},
        /// };
        /// 
        /// var operation = client.CustomEnvironmentAction(WaitUntil.Completed, "<environmentName>", RequestContent.Create(data), <me>);
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ActionRequest</c>:
        /// <code>{
        ///   actionId: string, # Required. The Catalog Item action id to execute
        ///   parameters: AnyObject, # Optional. Parameters object for the Action
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation CustomEnvironmentAction(WaitUntil waitUntil, string environmentName, RequestContent content, string userId = "me", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(environmentName, nameof(environmentName));
            Argument.AssertNotNull(content, nameof(content));
            Argument.AssertNotNullOrEmpty(userId, nameof(userId));

            using var scope = ClientDiagnostics.CreateScope("EnvironmentsClient.CustomEnvironmentAction");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCustomEnvironmentActionRequest(userId, environmentName, content, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "EnvironmentsClient.CustomEnvironmentAction", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetEnvironmentsRequest(int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/environments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxCount != null)
            {
                uri.AppendQuery("top", maxCount.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnvironmentsByUserRequest(string userId, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxCount != null)
            {
                uri.AppendQuery("top", maxCount.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnvironmentByUserRequest(string userId, string environmentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrUpdateEnvironmentRequest(string userId, string environmentName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateEnvironmentRequest(string userId, string environmentName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteEnvironmentRequest(string userId, string environmentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeployEnvironmentActionRequest(string userId, string environmentName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendPath(":deploy", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteEnvironmentActionRequest(string userId, string environmentName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendPath(":delete", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCustomEnvironmentActionRequest(string userId, string environmentName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendPath(":custom", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetArtifactsByEnvironmentRequest(string userId, string environmentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendPath("/artifacts", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetArtifactsByEnvironmentAndPathRequest(string userId, string environmentName, string artifactPath, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendPath("/environments/", false);
            uri.AppendPath(environmentName, true);
            uri.AppendPath("/artifacts/", false);
            uri.AppendPath(artifactPath, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCatalogItemsRequest(int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/catalogItems", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxCount != null)
            {
                uri.AppendQuery("top", maxCount.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCatalogItemRequest(string catalogItemId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/catalogItems/", false);
            uri.AppendPath(catalogItemId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCatalogItemVersionsRequest(string catalogItemId, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/catalogItems/", false);
            uri.AppendPath(catalogItemId, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxCount != null)
            {
                uri.AppendQuery("top", maxCount.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCatalogItemVersionRequest(string catalogItemId, string version, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/catalogItems/", false);
            uri.AppendPath(catalogItemId, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(version, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnvironmentTypesRequest(int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendPath("/projects/", false);
            uri.AppendPath(_projectName, true);
            uri.AppendPath("/environmentTypes", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxCount != null)
            {
                uri.AppendQuery("top", maxCount.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnvironmentsNextPageRequest(string nextLink, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnvironmentsByUserNextPageRequest(string nextLink, string userId, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetArtifactsByEnvironmentNextPageRequest(string nextLink, string userId, string environmentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetArtifactsByEnvironmentAndPathNextPageRequest(string nextLink, string userId, string environmentName, string artifactPath, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCatalogItemsNextPageRequest(string nextLink, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCatalogItemVersionsNextPageRequest(string nextLink, string catalogItemId, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnvironmentTypesNextPageRequest(string nextLink, int? maxCount, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(_tenantId, false);
            uri.AppendRaw("-", false);
            uri.AppendRaw(_devCenter, false);
            uri.AppendRaw(".", false);
            uri.AppendRaw(_devCenterDnsSuffix, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier200202204;
        private static ResponseClassifier ResponseClassifier200202204 => _responseClassifier200202204 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202, 204 });
        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
    }
}
