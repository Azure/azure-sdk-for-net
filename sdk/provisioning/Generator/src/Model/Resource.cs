// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.Provisioning.Generator.Model;

public class Resource(Specification spec, Type armType)
    : TypeModel(
        name: armType.Name.TrimSuffix("Resource")!,
        ns: spec.Namespace,
        // description: specification.DocComments.GetSummary(armType), // These aren't super meaningful doc comments so we'll avoid
        armType: armType,
        spec: spec)
{
    public string? ResourceType { get; set; }
    public string? DefaultResourceVersion { get; set; }
    public IList<string>? ResourceVersions { get; set; }
    public NameRequirements? NameRequirements { get; set; }
    public bool GenerateRoleAssignment { get; set; } = false;
    public Resource? ParentResource { get; set; }
    public SimpleModel? GetKeysType { get; set; }
    public bool GetKeysIsList { get; set; }

    public override string ToString() => $"<Resource {Spec!.Name}::{Name}>";

    public override void Lint()
    {
        base.Lint();
        //if (NameRequirements is null) { Warn($"{GetTypeReference()} has no {nameof(NameRequirements)}."); }
        //if (ResourceVersions is null) { Warn($"{GetTypeReference()} has no {nameof(ResourceVersions)}."); }
        //else if (DefaultResourceVersion is null) { Warn($"{GetTypeReference()} has no {nameof(DefaultResourceVersion)}."); }
    }

    public override void Generate()
    {
        ContextualException.WithContext(
            $"Generating resource {Namespace}.{Name}",
            () =>
            {
                IndentWriter writer = new();
                writer.WriteLine("// Copyright (c) Microsoft Corporation. All rights reserved.");
                writer.WriteLine("// Licensed under the MIT License.");
                writer.WriteLine();
                writer.WriteLine("// <auto-generated/>");
                writer.WriteLine();
                writer.WriteLine("#nullable enable"); // for optional string? resourceVersion
                writer.WriteLine();

                // Add the usings
                HashSet<string> namespaces = CollectNamespaces();
                if (FromExpression || GenerateRoleAssignment || GetKeysType is not null) { namespaces.Add("Azure.Provisioning.Expressions"); }
                if (FromExpression || NameRequirements is not null || GetKeysType is not null) { namespaces.Add("System.ComponentModel"); }
                if (GenerateRoleAssignment) { namespaces.Add("Azure.Provisioning.Authorization"); namespaces.Add("Azure.Provisioning.Roles"); }
                namespaces.Remove(Namespace!);
                foreach (string ns in namespaces.Order())
                {
                    writer.WriteLine($"using {ns};");
                }

                writer.WriteLine();
                writer.WriteLine($"namespace {Namespace};");
                writer.WriteLine();
                writer.WriteLine($"/// <summary>");
                writer.WriteWrapped(Description ?? (Name + "."));
                writer.WriteLine($"/// </summary>");
                writer.WriteLine($"public partial class {Name} : Resource");
                using (writer.Scope("{", "}"))
                {
                    // Write the properties
                    var fence = new IndentWriter.Fenceposter();
                    foreach (Property property in Properties)
                    {
                        if (fence.RequiresSeparator) { writer.WriteLine(); }

                        if (!property.HideAccessors)
                        {
                            writer.WriteLine($"/// <summary>");
                            string orSets = property.IsReadOnly ? "" : " or sets";
                            writer.WriteWrapped(property.Description ?? $"Gets{orSets} the {property.Name}.");
                            writer.WriteLine($"/// </summary>");
                            writer.Write($"public {property.BicepTypeReference} {property.Name} ");
                            writer.Write($"{{ get => {property.FieldName}; ");
                            if (!property.IsReadOnly) { writer.Write($"set => {property.FieldName}.Assign(value); "); }
                            writer.WriteLine("}");
                        }
                        writer.WriteLine($"private readonly {property.BicepTypeReference} {property.FieldName};");
                    }

                    if (ParentResource is not null)
                    {
                        if (fence.RequiresSeparator) { writer.WriteLine(); }
                        writer.WriteLine($"/// <summary>");
                        writer.WriteLine($"/// Gets or sets a reference to the parent {ParentResource.Name}.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"public {ParentResource.Name}? Parent {{ get => _parent!.Value; set => _parent!.Value = value; }}");
                        writer.WriteLine($"private readonly ResourceReference<{ParentResource.Name}> _parent;");
                    }

                    // Write the default value partial methods
                    foreach (Property property in Properties.Where(p => p.GenerateDefaultValue))
                    {
                        if (fence.RequiresSeparator) { writer.WriteLine(); }

                        writer.WriteLine($"/// <summary>");
                        writer.WriteWrapped($"Get the default value for the {property.Name} property.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"private partial {property.BicepTypeReference} Get{property.Name}DefaultValue();");
                    }

                    // Write the .ctor
                    if (fence.RequiresSeparator) { writer.WriteLine(); }
                    writer.WriteLine($"/// <summary>");
                    writer.WriteWrapped($"Creates a new {Name}.");
                    writer.WriteLine($"/// </summary>");
                    writer.WriteLine($"/// <param name=\"resourceName\">Name of the {Name}.</param>");
                    writer.WriteLine($"/// <param name=\"resourceVersion\">Version of the {Name}.</param>");
                    writer.WriteLine($"/// <param name=\"context\">Provisioning context for this resource.</param>");
                    writer.WriteLine($"public {Name}(string resourceName, string? resourceVersion = default, ProvisioningContext? context = default)");
                    writer.Write($"    : base(resourceName, \"{ResourceType}\", resourceVersion");
                    if (DefaultResourceVersion is not null)
                    {
                        writer.Write($" ?? \"{DefaultResourceVersion}\"");
                    }
                    writer.WriteLine(", context)");
                    using (writer.Scope("{", "}"))
                    {
                        foreach (Property property in Properties)
                        {
                            writer.Write($"{property.FieldName} = {property.BicepTypeReference}");
                            writer.Write($".DefineProperty(this, \"{property.Name}\", ");
                            writer.Write($"[{string.Join(", ", (property.Path ?? [property.Name]).Select(s => $"\"{s}\""))}]");
                            if (property.IsRequired) { writer.Write($", isRequired: true"); }
                            if (property.IsReadOnly) { writer.Write($", isOutput: true"); }
                            if (property.IsSecure) { writer.Write($", isSecure: true"); }
                            if (property.GenerateDefaultValue) { writer.Write($", defaultValue: Get{property.Name}DefaultValue()"); }
                            writer.WriteLine($");");
                        }
                        if (ParentResource is not null)
                        {
                            writer.WriteLine($"_parent = ResourceReference<{ParentResource.Name}>.DefineResource(this, \"Parent\", [\"parent\"], isRequired: true);");
                        }
                    }

                    // Add the well known versions
                    if (ResourceVersions is not null)
                    {
                        fence = new IndentWriter.Fenceposter();
                        writer.WriteLine();
                        writer.WriteLine($"/// <summary>");
                        writer.WriteWrapped($"Supported {Name} resource versions.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"public static class ResourceVersions");
                        using (writer.Scope("{", "}"))
                        {
                            foreach (string version in ResourceVersions)
                            {
                                if (fence.RequiresSeparator) { writer.WriteLine(); }

                                string name = $"V{version.Replace("-", "_")}";
                                writer.WriteLine($"/// <summary>");
                                writer.WriteLine($"/// {version}.");
                                writer.WriteLine($"/// </summary>");
                                writer.WriteLine($"public static readonly string {name} = \"{version}\";");
                            }
                        }
                    }

                    // Add the FromExisting method
                    if (Properties.Any(p => p.Name == "Name" && p.PropertyType?.Name == "String"))
                    {
                        if (fence.RequiresSeparator) { writer.WriteLine(); }

                        writer.WriteLine($"/// <summary>");
                        writer.WriteWrapped($"Creates a reference to an existing {Name}.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"/// <param name=\"resourceName\">Name of the {Name}.</param>");
                        writer.WriteLine($"/// <param name=\"resourceVersion\">Version of the {Name}.</param>");
                        writer.WriteLine($"/// <returns>The existing {Name} resource.</returns>");
                        writer.WriteLine($"public static {Name} FromExisting(string resourceName, string? resourceVersion = default) =>");
                        using (writer.Scope())
                        {
                            writer.WriteLine($"new(resourceName, resourceVersion) {{ IsExistingResource = true }};");
                        }
                    }

                    // Add the FromExpression method
                    if (FromExpression)
                    {
                        if (fence.RequiresSeparator) { writer.WriteLine(); }

                        writer.WriteLine($"/// <summary>");
                        writer.WriteWrapped($"Creates a new {Name} resource from a Bicep expression that evaluates to a {Name}.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"/// <param name=\"expression\">");
                        writer.WriteWrapped($"A Bicep expression that evaluates to a {Name} resource.");
                        writer.WriteLine($"/// </param>");
                        writer.WriteLine($"/// <returns>A {Name} resource.</returns>");
                        writer.WriteLine($"[EditorBrowsable(EditorBrowsableState.Never)]");
                        writer.WriteLine($"public static {Name} FromExpression(Expression expression)");
                        using (writer.Scope("{", "}"))
                        {
                            writer.WriteLine($"{Name} resource = new(expression.ToString());");
                            writer.WriteLine($"resource.OverrideWithExpression(expression);");
                            writer.WriteLine($"return resource;");
                        }
                    }

                    // Add the name requirements
                    if (NameRequirements is not null)
                    {
                        if (fence.RequiresSeparator) { writer.WriteLine(); }

                        writer.WriteLine($"/// <summary>");
                        writer.WriteWrapped($"Get the requirements for naming this {Name} resource.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"/// <returns>Naming requirements.</returns>");
                        writer.WriteLine($"[EditorBrowsable(EditorBrowsableState.Never)]");
                        writer.WriteLine($"public override ResourceNameRequirements GetResourceNameRequirements() =>");
                        using (writer.Scope())
                        {
                            writer.Write($"new(minLength: {NameRequirements.Min}, maxLength: {NameRequirements.Max}, validCharacters: ");
                            List<string> cases = [];
                            if (NameRequirements.Lower) { cases.Add("LowercaseLetters"); }
                            if (NameRequirements.Upper) { cases.Add("UppercaseLetters"); }
                            if (NameRequirements.Numbers) { cases.Add("Numbers"); }
                            if (NameRequirements.Hyphen) { cases.Add("Hyphen"); }
                            if (NameRequirements.Underscore) { cases.Add("Underscore"); }
                            if (NameRequirements.Period) { cases.Add("Period"); }
                            if (NameRequirements.Parens) { cases.Add("Parentheses"); }
                            writer.Write(string.Join(" | ", cases.Select(c => $"ResourceNameCharacters.{c}")));
                            writer.WriteLine($");");
                        }
                    }

                    if (GetKeysType is not null)
                    {
                        if (fence.RequiresSeparator) { writer.WriteLine(); }
                        writer.WriteLine($"/// <summary>");
                        writer.WriteWrapped($"Get access keys for this {Name} resource.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"/// <returns>The keys for this {Name} resource.</returns>");
                        string keyType = GetKeysType.Name;
                        if (GetKeysIsList) { keyType = $"BicepList<{keyType}>"; }
                        writer.WriteLine($"public {keyType} GetKeys() =>");
                        using (writer.Scope())
                        {
                            writer.WriteLine($"{keyType}.FromExpression(");
                            using (writer.Scope())
                            {
                                if (GetKeysIsList)
                                {
                                    writer.WriteLine($"{GetKeysType.Name}.FromExpression,");
                                }
                                string expr = $"new FunctionCallExpression(new MemberExpression(new IdentifierExpression(ResourceName), \"listKeys\"))";
                                if (GetKeysIsList)
                                {
                                    expr = $"new MemberExpression({expr}, \"keys\")";
                                }
                                writer.WriteLine($"{expr});");
                            }
                        }
                    }

                    // Add the role assignment
                    if (GenerateRoleAssignment)
                    {
                        if (fence.RequiresSeparator) { writer.WriteLine(); }
                        writer.WriteLine($"/// <summary>");
                        writer.WriteWrapped($"Assign a role to a user-assigned identity that grants access to this {Name}.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"/// <param name=\"role\">The role to grant.</param>");
                        writer.WriteLine($"/// <param name=\"identity\">The <see cref=\"UserAssignedIdentity\"/>.</param>");
                        writer.WriteLine($"/// <returns>The <see cref=\"RoleAssignment\"/>.</returns>");
                        writer.WriteLine($"public RoleAssignment AssignRole({Spec!.Name}BuiltInRole role, UserAssignedIdentity identity) =>");
                        using (writer.Scope())
                        {
                            writer.WriteLine($"new($\"{{identity.ResourceName}}_{{{Spec!.Name}BuiltInRole.GetBuiltInRoleName(role)}}_{{ResourceName}}\")");
                            using (writer.Scope("{", "};"))
                            {
                                writer.WriteLine($"Scope = new IdentifierExpression(ResourceName),");
                                writer.WriteLine($"PrincipalType = RoleManagementPrincipalType.ServicePrincipal,");
                                writer.WriteLine($"RoleDefinitionId = BicepFunction.GetSubscriptionResourceId(\"Microsoft.Authorization/roleDefinitions\", role.ToString()),");
                                writer.WriteLine($"PrincipalId = identity.PrincipalId");
                            }
                        }

                        if (fence.RequiresSeparator) { writer.WriteLine(); }
                        writer.WriteLine($"/// <summary>");
                        writer.WriteWrapped($"Assign a role to an that grants access to this {Name}.");
                        writer.WriteLine($"/// </summary>");
                        writer.WriteLine($"/// <param name=\"role\">The role to grant.</param>");
                        writer.WriteLine($"/// <param name=\"principalType\">The type of the principal to assign to.</param>");
                        writer.WriteLine($"/// <param name=\"principalId\">The principal to assign to.</param>");
                        writer.WriteLine($"/// <returns>The <see cref=\"RoleAssignment\"/>.</returns>");
                        writer.WriteLine($"public RoleAssignment AssignRole({Spec!.Name}BuiltInRole role, BicepValue<RoleManagementPrincipalType> principalType, BicepValue<Guid> principalId) =>");
                        using (writer.Scope())
                        {
                            writer.WriteLine($"new($\"{{principalId.Compile()}}_{{{Spec!.Name}BuiltInRole.GetBuiltInRoleName(role)}}_{{ResourceName}}\")");
                            using (writer.Scope("{", "};"))
                            {
                                writer.WriteLine($"Scope = new IdentifierExpression(ResourceName),");
                                writer.WriteLine($"PrincipalType = principalType,");
                                writer.WriteLine($"RoleDefinitionId = BicepFunction.GetSubscriptionResourceId(\"Microsoft.Authorization/roleDefinitions\", role.ToString()),");
                                writer.WriteLine($"PrincipalId = principalId");
                            }
                        }
                    }
                }

                // Write out the model
                Spec!.SaveFile($"{Name}.cs", writer.ToString());
            });
    }
}
