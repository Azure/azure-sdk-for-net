// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.ScomManagedInstance.Models;

namespace Azure.ResourceManager.ScomManagedInstance
{
    /// <summary> A class to add extension methods to ResourceGroupResource. </summary>
    internal partial class ResourceGroupResourceExtensionClient : ArmResource
    {
        private ClientDiagnostics _instancesClientDiagnostics;
        private InstancesRestOperations _instancesRestClient;
        private ClientDiagnostics _monitoredResourcesClientDiagnostics;
        private MonitoredResourcesRestOperations _monitoredResourcesRestClient;
        private ClientDiagnostics _managedGatewaysClientDiagnostics;
        private ManagedGatewaysRestOperations _managedGatewaysRestClient;

        /// <summary> Initializes a new instance of the <see cref="ResourceGroupResourceExtensionClient"/> class for mocking. </summary>
        protected ResourceGroupResourceExtensionClient()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="ResourceGroupResourceExtensionClient"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal ResourceGroupResourceExtensionClient(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
        }

        private ClientDiagnostics InstancesClientDiagnostics => _instancesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ScomManagedInstance", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private InstancesRestOperations InstancesRestClient => _instancesRestClient ??= new InstancesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics MonitoredResourcesClientDiagnostics => _monitoredResourcesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ScomManagedInstance", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private MonitoredResourcesRestOperations MonitoredResourcesRestClient => _monitoredResourcesRestClient ??= new MonitoredResourcesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics ManagedGatewaysClientDiagnostics => _managedGatewaysClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ScomManagedInstance", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private ManagedGatewaysRestOperations ManagedGatewaysRestClient => _managedGatewaysRestClient ??= new ManagedGatewaysRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);

        private string GetApiVersionOrNull(ResourceType resourceType)
        {
            TryGetApiVersion(resourceType, out string apiVersion);
            return apiVersion;
        }

        /// <summary>
        /// Lists all SCOM managed instances in a resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ManagedInstance" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ManagedInstance> GetInstancesByResourceGroupAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InstancesRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InstancesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, ManagedInstance.DeserializeManagedInstance, InstancesClientDiagnostics, Pipeline, "ResourceGroupResourceExtensionClient.GetInstancesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Lists all SCOM managed instances in a resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ManagedInstance" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ManagedInstance> GetInstancesByResourceGroup(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InstancesRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InstancesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, ManagedInstance.DeserializeManagedInstance, InstancesClientDiagnostics, Pipeline, "ResourceGroupResourceExtensionClient.GetInstancesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Get SCOM managed instance details
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<ManagedInstance>> GetInstanceAsync(string instanceName, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.GetInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get SCOM managed instance details
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<ManagedInstance> GetInstance(string instanceName, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.GetInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, instanceName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update SCOM managed instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_CreateOrUpdate</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="managedInstance"> SCOM Managed Instance. </param>
        /// <param name="validationMode"> Validation mode for the SCOM managed instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ManagedInstance>> CreateOrUpdateInstanceAsync(WaitUntil waitUntil, string instanceName, ManagedInstance managedInstance, bool? validationMode = null, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.CreateOrUpdateInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, managedInstance, validationMode, cancellationToken).ConfigureAwait(false);
                var operation = new ScomManagedInstanceArmOperation<ManagedInstance>(new ManagedInstanceOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, managedInstance, validationMode).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update SCOM managed instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_CreateOrUpdate</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="managedInstance"> SCOM Managed Instance. </param>
        /// <param name="validationMode"> Validation mode for the SCOM managed instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ManagedInstance> CreateOrUpdateInstance(WaitUntil waitUntil, string instanceName, ManagedInstance managedInstance, bool? validationMode = null, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.CreateOrUpdateInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, instanceName, managedInstance, validationMode, cancellationToken);
                var operation = new ScomManagedInstanceArmOperation<ManagedInstance>(new ManagedInstanceOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, managedInstance, validationMode).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Patch SCOM managed instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="patch"> SCOM managed instance properties update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ManagedInstance>> UpdateInstanceAsync(WaitUntil waitUntil, string instanceName, MonitoringInstancePatch patch = null, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.UpdateInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ScomManagedInstanceArmOperation<ManagedInstance>(new ManagedInstanceOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, patch).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Patch SCOM managed instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="patch"> SCOM managed instance properties update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ManagedInstance> UpdateInstance(WaitUntil waitUntil, string instanceName, MonitoringInstancePatch patch = null, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.UpdateInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, instanceName, patch, cancellationToken);
                var operation = new ScomManagedInstanceArmOperation<ManagedInstance>(new ManagedInstanceOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, patch).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a SCOM managed instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteInstanceAsync(WaitUntil waitUntil, string instanceName, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.DeleteInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, cancellationToken).ConfigureAwait(false);
                var operation = new ScomManagedInstanceArmOperation(InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a SCOM managed instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteInstance(WaitUntil waitUntil, string instanceName, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.DeleteInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, instanceName, cancellationToken);
                var operation = new ScomManagedInstanceArmOperation(InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Scaling SCOM managed instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/setServerCount</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Scale</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="body"> The ScalingProperties to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<SetServerCountResponseProperties>> ScaleInstanceAsync(WaitUntil waitUntil, string instanceName, ScalingProperties body, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.ScaleInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.ScaleAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ScomManagedInstanceArmOperation<SetServerCountResponseProperties>(new SetServerCountResponsePropertiesOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateScaleRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Scaling SCOM managed instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/setServerCount</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Scale</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="body"> The ScalingProperties to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<SetServerCountResponseProperties> ScaleInstance(WaitUntil waitUntil, string instanceName, ScalingProperties body, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.ScaleInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.Scale(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body, cancellationToken);
                var operation = new ScomManagedInstanceArmOperation<SetServerCountResponseProperties>(new SetServerCountResponsePropertiesOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateScaleRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update SCOM servers with latest scom software.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/patchServers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_PatchServers</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<PatchServersResponseProperties>> PatchServersInstanceAsync(WaitUntil waitUntil, string instanceName, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.PatchServersInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.PatchServersAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, cancellationToken).ConfigureAwait(false);
                var operation = new ScomManagedInstanceArmOperation<PatchServersResponseProperties>(new PatchServersResponsePropertiesOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreatePatchServersRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update SCOM servers with latest scom software.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/patchServers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_PatchServers</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<PatchServersResponseProperties> PatchServersInstance(WaitUntil waitUntil, string instanceName, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.PatchServersInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.PatchServers(Id.SubscriptionId, Id.ResourceGroupName, instanceName, cancellationToken);
                var operation = new ScomManagedInstanceArmOperation<PatchServersResponseProperties>(new PatchServersResponsePropertiesOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreatePatchServersRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Link Log Analytics workspace for SCOM monitoring instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/linkLogAnalytics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_LinkLogAnalytics</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="body"> The LogAnalyticsConfiguration to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<LogAnalyticsConfiguration>> LinkLogAnalyticsInstanceAsync(WaitUntil waitUntil, string instanceName, LogAnalyticsConfiguration body, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.LinkLogAnalyticsInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.LinkLogAnalyticsAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ScomManagedInstanceArmOperation<LogAnalyticsConfiguration>(new LogAnalyticsConfigurationOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateLinkLogAnalyticsRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Link Log Analytics workspace for SCOM monitoring instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/linkLogAnalytics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_LinkLogAnalytics</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="body"> The LogAnalyticsConfiguration to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<LogAnalyticsConfiguration> LinkLogAnalyticsInstance(WaitUntil waitUntil, string instanceName, LogAnalyticsConfiguration body, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.LinkLogAnalyticsInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.LinkLogAnalytics(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body, cancellationToken);
                var operation = new ScomManagedInstanceArmOperation<LogAnalyticsConfiguration>(new LogAnalyticsConfigurationOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateLinkLogAnalyticsRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Unlink Log Analytics workspace for SCOM monitoring instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/unlinkLogAnalytics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_UnlinkLogAnalytics</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<UnlinkLogAnalyticsResponseProperties>> UnlinkLogAnalyticsInstanceAsync(WaitUntil waitUntil, string instanceName, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.UnlinkLogAnalyticsInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.UnlinkLogAnalyticsAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, cancellationToken).ConfigureAwait(false);
                var operation = new ScomManagedInstanceArmOperation<UnlinkLogAnalyticsResponseProperties>(new UnlinkLogAnalyticsResponsePropertiesOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateUnlinkLogAnalyticsRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Unlink Log Analytics workspace for SCOM monitoring instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/unlinkLogAnalytics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_UnlinkLogAnalytics</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<UnlinkLogAnalyticsResponseProperties> UnlinkLogAnalyticsInstance(WaitUntil waitUntil, string instanceName, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.UnlinkLogAnalyticsInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.UnlinkLogAnalytics(Id.SubscriptionId, Id.ResourceGroupName, instanceName, cancellationToken);
                var operation = new ScomManagedInstanceArmOperation<UnlinkLogAnalyticsResponseProperties>(new UnlinkLogAnalyticsResponsePropertiesOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateUnlinkLogAnalyticsRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update configuration for log analytics linking for SCOM monitoring instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/updateLogAnalytics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_UpdateLogAnalytics</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="body"> The LogAnalyticsUpdateConfiguration to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<LogAnalyticsUpdateConfiguration>> UpdateLogAnalyticsInstanceAsync(WaitUntil waitUntil, string instanceName, LogAnalyticsUpdateConfiguration body, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.UpdateLogAnalyticsInstance");
            scope.Start();
            try
            {
                var response = await InstancesRestClient.UpdateLogAnalyticsAsync(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ScomManagedInstanceArmOperation<LogAnalyticsUpdateConfiguration>(new LogAnalyticsUpdateConfigurationOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateUpdateLogAnalyticsRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update configuration for log analytics linking for SCOM monitoring instance
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/updateLogAnalytics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_UpdateLogAnalytics</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the Azure Monitor Operations Manager Managed Instance (SCOM MI). </param>
        /// <param name="body"> The LogAnalyticsUpdateConfiguration to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<LogAnalyticsUpdateConfiguration> UpdateLogAnalyticsInstance(WaitUntil waitUntil, string instanceName, LogAnalyticsUpdateConfiguration body, CancellationToken cancellationToken = default)
        {
            using var scope = InstancesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.UpdateLogAnalyticsInstance");
            scope.Start();
            try
            {
                var response = InstancesRestClient.UpdateLogAnalytics(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body, cancellationToken);
                var operation = new ScomManagedInstanceArmOperation<LogAnalyticsUpdateConfiguration>(new LogAnalyticsUpdateConfigurationOperationSource(), InstancesClientDiagnostics, Pipeline, InstancesRestClient.CreateUpdateLogAnalyticsRequest(Id.SubscriptionId, Id.ResourceGroupName, instanceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieve the details of the monitored resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/monitoredResources/{monitoredResourceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>MonitoredResources_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<MonitoredResource>> GetMonitoredResourceAsync(CancellationToken cancellationToken = default)
        {
            using var scope = MonitoredResourcesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.GetMonitoredResource");
            scope.Start();
            try
            {
                var response = await MonitoredResourcesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieve the details of the monitored resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/monitoredResources/{monitoredResourceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>MonitoredResources_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<MonitoredResource> GetMonitoredResource(CancellationToken cancellationToken = default)
        {
            using var scope = MonitoredResourcesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.GetMonitoredResource");
            scope.Start();
            try
            {
                var response = MonitoredResourcesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a monitored resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/monitoredResources/{monitoredResourceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>MonitoredResources_CreateOrUpdate</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<MonitoredResource>> CreateOrUpdateMonitoredResourceAsync(CancellationToken cancellationToken = default)
        {
            using var scope = MonitoredResourcesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.CreateOrUpdateMonitoredResource");
            scope.Start();
            try
            {
                var response = await MonitoredResourcesRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a monitored resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/monitoredResources/{monitoredResourceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>MonitoredResources_CreateOrUpdate</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<MonitoredResource> CreateOrUpdateMonitoredResource(CancellationToken cancellationToken = default)
        {
            using var scope = MonitoredResourcesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.CreateOrUpdateMonitoredResource");
            scope.Start();
            try
            {
                var response = MonitoredResourcesRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a monitored resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/monitoredResources/{monitoredResourceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>MonitoredResources_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> DeleteMonitoredResourceAsync(CancellationToken cancellationToken = default)
        {
            using var scope = MonitoredResourcesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.DeleteMonitoredResource");
            scope.Start();
            try
            {
                var response = await MonitoredResourcesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a monitored resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/monitoredResources/{monitoredResourceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>MonitoredResources_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response DeleteMonitoredResource(CancellationToken cancellationToken = default)
        {
            using var scope = MonitoredResourcesClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.DeleteMonitoredResource");
            scope.Start();
            try
            {
                var response = MonitoredResourcesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// A comprehensive list of all monitored resources within a SCOM managed instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/monitoredResources</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>MonitoredResources_ListByManagedInstance</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="MonitoredResource" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<MonitoredResource> GetMonitoredResourcesByManagedInstanceAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => MonitoredResourcesRestClient.CreateListByManagedInstanceRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => MonitoredResourcesRestClient.CreateListByManagedInstanceNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, MonitoredResource.DeserializeMonitoredResource, MonitoredResourcesClientDiagnostics, Pipeline, "ResourceGroupResourceExtensionClient.GetMonitoredResourcesByManagedInstance", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// A comprehensive list of all monitored resources within a SCOM managed instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/monitoredResources</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>MonitoredResources_ListByManagedInstance</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="MonitoredResource" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<MonitoredResource> GetMonitoredResourcesByManagedInstance(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => MonitoredResourcesRestClient.CreateListByManagedInstanceRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => MonitoredResourcesRestClient.CreateListByManagedInstanceNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, MonitoredResource.DeserializeMonitoredResource, MonitoredResourcesClientDiagnostics, Pipeline, "ResourceGroupResourceExtensionClient.GetMonitoredResourcesByManagedInstance", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Retrieve the details of the gateway resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/managedGateways/{managedGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ManagedGateways_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<ManagedGateway>> GetManagedGatewayAsync(CancellationToken cancellationToken = default)
        {
            using var scope = ManagedGatewaysClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.GetManagedGateway");
            scope.Start();
            try
            {
                var response = await ManagedGatewaysRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieve the details of the gateway resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/managedGateways/{managedGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ManagedGateways_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<ManagedGateway> GetManagedGateway(CancellationToken cancellationToken = default)
        {
            using var scope = ManagedGatewaysClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.GetManagedGateway");
            scope.Start();
            try
            {
                var response = ManagedGatewaysRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a gateway resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/managedGateways/{managedGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ManagedGateways_CreateOrUpdate</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<ManagedGateway>> CreateOrUpdateManagedGatewayAsync(CancellationToken cancellationToken = default)
        {
            using var scope = ManagedGatewaysClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.CreateOrUpdateManagedGateway");
            scope.Start();
            try
            {
                var response = await ManagedGatewaysRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a gateway resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/managedGateways/{managedGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ManagedGateways_CreateOrUpdate</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<ManagedGateway> CreateOrUpdateManagedGateway(CancellationToken cancellationToken = default)
        {
            using var scope = ManagedGatewaysClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.CreateOrUpdateManagedGateway");
            scope.Start();
            try
            {
                var response = ManagedGatewaysRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove a gateway resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/managedGateways/{managedGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ManagedGateways_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> DeleteManagedGatewayAsync(CancellationToken cancellationToken = default)
        {
            using var scope = ManagedGatewaysClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.DeleteManagedGateway");
            scope.Start();
            try
            {
                var response = await ManagedGatewaysRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove a gateway resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/managedGateways/{managedGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ManagedGateways_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response DeleteManagedGateway(CancellationToken cancellationToken = default)
        {
            using var scope = ManagedGatewaysClientDiagnostics.CreateScope("ResourceGroupResourceExtensionClient.DeleteManagedGateway");
            scope.Start();
            try
            {
                var response = ManagedGatewaysRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// A comprehensive list of all gateway resources within a SCOM managed instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/managedGateways</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ManagedGateways_ListByManagedInstance</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ManagedGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ManagedGateway> GetManagedGatewaysByManagedInstanceAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => ManagedGatewaysRestClient.CreateListByManagedInstanceRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => ManagedGatewaysRestClient.CreateListByManagedInstanceNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, ManagedGateway.DeserializeManagedGateway, ManagedGatewaysClientDiagnostics, Pipeline, "ResourceGroupResourceExtensionClient.GetManagedGatewaysByManagedInstance", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// A comprehensive list of all gateway resources within a SCOM managed instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Scom/managedInstances/{instanceName}/managedGateways</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ManagedGateways_ListByManagedInstance</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ManagedGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ManagedGateway> GetManagedGatewaysByManagedInstance(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => ManagedGatewaysRestClient.CreateListByManagedInstanceRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => ManagedGatewaysRestClient.CreateListByManagedInstanceNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, ManagedGateway.DeserializeManagedGateway, ManagedGatewaysClientDiagnostics, Pipeline, "ResourceGroupResourceExtensionClient.GetManagedGatewaysByManagedInstance", "value", "nextLink", cancellationToken);
        }
    }
}
