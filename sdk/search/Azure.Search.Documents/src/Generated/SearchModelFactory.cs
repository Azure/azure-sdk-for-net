// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Search.Documents;
using Azure.Search.Documents.Indexes.Models;

namespace Azure.Search.Documents.Models
{
    /// <summary> Model factory for generated models. </summary>
    public static partial class SearchModelFactory
    {
        /// <summary> Initializes a new instance of SearchOptions. </summary>
        /// <param name="includeTotalCount"> A value that specifies whether to fetch the total count of results. Default is false. Setting this value to true may have a performance impact. Note that the count returned is an approximation. </param>
        /// <param name="facets"> The list of facet expressions to apply to the search query. Each facet expression contains a field name, optionally followed by a comma-separated list of name:value pairs. </param>
        /// <param name="filter"> The OData $filter expression to apply to the search query. </param>
        /// <param name="highlightFieldsRaw"> The comma-separated list of field names to use for hit highlights. Only searchable fields can be used for hit highlighting. </param>
        /// <param name="highlightPostTag"> A string tag that is appended to hit highlights. Must be set with highlightPreTag. Default is &amp;lt;/em&amp;gt;. </param>
        /// <param name="highlightPreTag"> A string tag that is prepended to hit highlights. Must be set with highlightPostTag. Default is &amp;lt;em&amp;gt;. </param>
        /// <param name="minimumCoverage"> A number between 0 and 100 indicating the percentage of the index that must be covered by a search query in order for the query to be reported as a success. This parameter can be useful for ensuring search availability even for services with only one replica. The default is 100. </param>
        /// <param name="orderByRaw"> The comma-separated list of OData $orderby expressions by which to sort the results. Each expression can be either a field name or a call to either the geo.distance() or the search.score() functions. Each expression can be followed by asc to indicate ascending, or desc to indicate descending. The default is ascending order. Ties will be broken by the match scores of documents. If no $orderby is specified, the default sort order is descending by document match score. There can be at most 32 $orderby clauses. </param>
        /// <param name="queryType"> A value that specifies the syntax of the search query. The default is &apos;simple&apos;. Use &apos;full&apos; if your query uses the Lucene query syntax. </param>
        /// <param name="scoringStatistics"> A value that specifies whether we want to calculate scoring statistics (such as document frequency) globally for more consistent scoring, or locally, for lower latency. The default is &apos;local&apos;. Use &apos;global&apos; to aggregate scoring statistics globally before scoring. Using global scoring statistics can increase latency of search queries. </param>
        /// <param name="sessionId"> A value to be used to create a sticky session, which can help getting more consistent results. As long as the same sessionId is used, a best-effort attempt will be made to target the same replica set. Be wary that reusing the same sessionID values repeatedly can interfere with the load balancing of the requests across replicas and adversely affect the performance of the search service. The value used as sessionId cannot start with a &apos;_&apos; character. </param>
        /// <param name="scoringParameters"> The list of parameter values to be used in scoring functions (for example, referencePointParameter) using the format name-values. For example, if the scoring profile defines a function with a parameter called &apos;mylocation&apos; the parameter string would be &quot;mylocation--122.2,44.8&quot; (without the quotes). </param>
        /// <param name="scoringProfile"> The name of a scoring profile to evaluate match scores for matching documents in order to sort the results. </param>
        /// <param name="semanticConfigurationName"> The name of a semantic configuration that will be used when processing documents for queries of type semantic. </param>
        /// <param name="searchText"> A full-text search query expression; Use &quot;*&quot; or omit this parameter to match all documents. </param>
        /// <param name="searchFieldsRaw"> The comma-separated list of field names to which to scope the full-text search. When using fielded search (fieldName:searchExpression) in a full Lucene query, the field names of each fielded search expression take precedence over any field names listed in this parameter. </param>
        /// <param name="searchMode"> A value that specifies whether any or all of the search terms must be matched in order to count the document as a match. </param>
        /// <param name="queryLanguage"> A value that specifies the language of the search query. </param>
        /// <param name="querySpeller"> A value that specified the type of the speller to use to spell-correct individual search query terms. </param>
        /// <param name="queryAnswerRaw"> A value that specifies whether answers should be returned as part of the search response. </param>
        /// <param name="selectRaw"> The comma-separated list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema are included. </param>
        /// <param name="skip"> The number of search results to skip. This value cannot be greater than 100,000. If you need to scan documents in sequence, but cannot use skip due to this limitation, consider using orderby on a totally-ordered key and filter with a range query instead. </param>
        /// <param name="size"> The number of search results to retrieve. This can be used in conjunction with $skip to implement client-side paging of search results. If results are truncated due to server-side paging, the response will include a continuation token that can be used to issue another Search request for the next page of results. </param>
        /// <param name="queryCaptionRaw"> A value that specifies whether captions should be returned as part of the search response. </param>
        /// <param name="semanticFieldsRaw"> The comma-separated list of field names used for semantic search. </param>
        /// <returns> A new <see cref="Documents.SearchOptions"/> instance for mocking. </returns>
        public static SearchOptions SearchOptions(bool? includeTotalCount = null, IEnumerable<string> facets = null, string filter = null, string highlightFieldsRaw = null, string highlightPostTag = null, string highlightPreTag = null, double? minimumCoverage = null, string orderByRaw = null, SearchQueryType? queryType = null, ScoringStatistics? scoringStatistics = null, string sessionId = null, IEnumerable<string> scoringParameters = null, string scoringProfile = null, string semanticConfigurationName = null, string searchText = null, string searchFieldsRaw = null, SearchMode? searchMode = null, QueryLanguage? queryLanguage = null, QuerySpellerType? querySpeller = null, string queryAnswerRaw = null, string selectRaw = null, int? skip = null, int? size = null, string queryCaptionRaw = null, string semanticFieldsRaw = null)
        {
            facets ??= new List<string>();
            scoringParameters ??= new List<string>();

            return new SearchOptions(includeTotalCount, facets?.ToList(), filter, highlightFieldsRaw, highlightPostTag, highlightPreTag, minimumCoverage, orderByRaw, queryType, scoringStatistics, sessionId, scoringParameters?.ToList(), scoringProfile, semanticConfigurationName, searchText, searchFieldsRaw, searchMode, queryLanguage, querySpeller, queryAnswerRaw, selectRaw, skip, size, queryCaptionRaw, semanticFieldsRaw);
        }

        /// <summary> Initializes a new instance of AnswerResult. </summary>
        /// <param name="score"> The score value represents how relevant the answer is to the query relative to other answers returned for the query. </param>
        /// <param name="key"> The key of the document the answer was extracted from. </param>
        /// <param name="text"> The text passage extracted from the document contents as the answer. </param>
        /// <param name="highlights"> Same text passage as in the Text property with highlighted text phrases most relevant to the query. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <returns> A new <see cref="Models.AnswerResult"/> instance for mocking. </returns>
        public static AnswerResult AnswerResult(double? score = null, string key = null, string text = null, string highlights = null, IReadOnlyDictionary<string, object> additionalProperties = null)
        {
            additionalProperties ??= new Dictionary<string, object>();

            return new AnswerResult(score, key, text, highlights, additionalProperties);
        }

        /// <summary> Initializes a new instance of CaptionResult. </summary>
        /// <param name="text"> A representative text passage extracted from the document most relevant to the search query. </param>
        /// <param name="highlights"> Same text passage as in the Text property with highlighted phrases most relevant to the query. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <returns> A new <see cref="Models.CaptionResult"/> instance for mocking. </returns>
        public static CaptionResult CaptionResult(string text = null, string highlights = null, IReadOnlyDictionary<string, object> additionalProperties = null)
        {
            additionalProperties ??= new Dictionary<string, object>();

            return new CaptionResult(text, highlights, additionalProperties);
        }

        /// <summary> Initializes a new instance of AutocompleteResults. </summary>
        /// <param name="coverage"> A value indicating the percentage of the index that was considered by the autocomplete request, or null if minimumCoverage was not specified in the request. </param>
        /// <param name="results"> The list of returned Autocompleted items. </param>
        /// <returns> A new <see cref="Models.AutocompleteResults"/> instance for mocking. </returns>
        public static AutocompleteResults AutocompleteResults(double? coverage = null, IEnumerable<AutocompleteItem> results = null)
        {
            results ??= new List<AutocompleteItem>();

            return new AutocompleteResults(coverage, results?.ToList());
        }

        /// <summary> Initializes a new instance of SearchIndexerDataContainer. </summary>
        /// <param name="name"> The name of the table or view (for Azure SQL data source) or collection (for CosmosDB data source) that will be indexed. </param>
        /// <param name="query"> A query that is applied to this data container. The syntax and meaning of this parameter is datasource-specific. Not supported by Azure SQL datasources. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexerDataContainer"/> instance for mocking. </returns>
        public static SearchIndexerDataContainer SearchIndexerDataContainer(string name = null, string query = null)
        {
            return new SearchIndexerDataContainer(name, query);
        }

        /// <summary> Initializes a new instance of SearchIndexerDataIdentity. </summary>
        /// <param name="oDataType"> Identifies the concrete type of the identity. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexerDataIdentity"/> instance for mocking. </returns>
        public static SearchIndexerDataIdentity SearchIndexerDataIdentity(string oDataType = null)
        {
            return new UnknownSearchIndexerDataIdentity(oDataType);
        }

        /// <summary> Initializes a new instance of SearchIndexer. </summary>
        /// <param name="name"> The name of the indexer. </param>
        /// <param name="description"> The description of the indexer. </param>
        /// <param name="dataSourceName"> The name of the datasource from which this indexer reads data. </param>
        /// <param name="skillsetName"> The name of the skillset executing with this indexer. </param>
        /// <param name="targetIndexName"> The name of the index to which this indexer writes data. </param>
        /// <param name="schedule"> The schedule for this indexer. </param>
        /// <param name="parameters"> Parameters for indexer execution. </param>
        /// <param name="fieldMappings"> Defines mappings between fields in the data source and corresponding target fields in the index. </param>
        /// <param name="outputFieldMappings"> Output field mappings are applied after enrichment and immediately before indexing. </param>
        /// <param name="isDisabled"> A value indicating whether the indexer is disabled. Default is false. </param>
        /// <param name="etag"> The ETag of the indexer. </param>
        /// <param name="encryptionKey"> A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your indexer definition (as well as indexer execution status) when you want full assurance that no one, not even Microsoft, can decrypt them in Azure Cognitive Search. Once you have encrypted your indexer definition, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your indexer definition (and indexer execution status) will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. </param>
        /// <param name="cache"> Adds caching to an enrichment pipeline to allow for incremental modification steps without having to rebuild the index every time. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexer"/> instance for mocking. </returns>
        public static SearchIndexer SearchIndexer(string name = null, string description = null, string dataSourceName = null, string skillsetName = null, string targetIndexName = null, IndexingSchedule schedule = null, IndexingParameters parameters = null, IEnumerable<FieldMapping> fieldMappings = null, IEnumerable<FieldMapping> outputFieldMappings = null, bool? isDisabled = null, string etag = null, SearchResourceEncryptionKey encryptionKey = null, SearchIndexerCache cache = null)
        {
            fieldMappings ??= new List<FieldMapping>();
            outputFieldMappings ??= new List<FieldMapping>();

            return new SearchIndexer(name, description, dataSourceName, skillsetName, targetIndexName, schedule, parameters, fieldMappings?.ToList(), outputFieldMappings?.ToList(), isDisabled, etag, encryptionKey, cache);
        }

        /// <summary> Initializes a new instance of IndexingSchedule. </summary>
        /// <param name="interval"> The interval of time between indexer executions. </param>
        /// <param name="startTime"> The time when an indexer should start running. </param>
        /// <returns> A new <see cref="Indexes.Models.IndexingSchedule"/> instance for mocking. </returns>
        public static IndexingSchedule IndexingSchedule(TimeSpan interval = default, DateTimeOffset? startTime = null)
        {
            return new IndexingSchedule(interval, startTime);
        }

        /// <summary> Initializes a new instance of IndexingParameters. </summary>
        /// <param name="batchSize"> The number of items that are read from the data source and indexed as a single batch in order to improve performance. The default depends on the data source type. </param>
        /// <param name="maxFailedItems"> The maximum number of items that can fail indexing for indexer execution to still be considered successful. -1 means no limit. Default is 0. </param>
        /// <param name="maxFailedItemsPerBatch"> The maximum number of items in a single batch that can fail indexing for the batch to still be considered successful. -1 means no limit. Default is 0. </param>
        /// <param name="indexingParametersConfiguration"> A dictionary of indexer-specific configuration properties. Each name is the name of a specific property. Each value must be of a primitive type. </param>
        /// <returns> A new <see cref="Indexes.Models.IndexingParameters"/> instance for mocking. </returns>
        public static IndexingParameters IndexingParameters(int? batchSize = null, int? maxFailedItems = null, int? maxFailedItemsPerBatch = null, IndexingParametersConfiguration indexingParametersConfiguration = null)
        {
            return new IndexingParameters(batchSize, maxFailedItems, maxFailedItemsPerBatch, indexingParametersConfiguration);
        }

        /// <summary> Initializes a new instance of IndexingParametersConfiguration. </summary>
        /// <param name="parsingMode"> Represents the parsing mode for indexing from an Azure blob data source. </param>
        /// <param name="excludedFileNameExtensions"> Comma-delimited list of filename extensions to ignore when processing from Azure blob storage.  For example, you could exclude &quot;.png, .mp4&quot; to skip over those files during indexing. </param>
        /// <param name="indexedFileNameExtensions"> Comma-delimited list of filename extensions to select when processing from Azure blob storage.  For example, you could focus indexing on specific application files &quot;.docx, .pptx, .msg&quot; to specifically include those file types. </param>
        /// <param name="failOnUnsupportedContentType"> For Azure blobs, set to false if you want to continue indexing when an unsupported content type is encountered, and you don&apos;t know all the content types (file extensions) in advance. </param>
        /// <param name="failOnUnprocessableDocument"> For Azure blobs, set to false if you want to continue indexing if a document fails indexing. </param>
        /// <param name="indexStorageMetadataOnlyForOversizedDocuments"> For Azure blobs, set this property to true to still index storage metadata for blob content that is too large to process. Oversized blobs are treated as errors by default. For limits on blob size, see https://docs.microsoft.com/azure/search/search-limits-quotas-capacity. </param>
        /// <param name="delimitedTextHeaders"> For CSV blobs, specifies a comma-delimited list of column headers, useful for mapping source fields to destination fields in an index. </param>
        /// <param name="delimitedTextDelimiter"> For CSV blobs, specifies the end-of-line single-character delimiter for CSV files where each line starts a new document (for example, &quot;|&quot;). </param>
        /// <param name="firstLineContainsHeaders"> For CSV blobs, indicates that the first (non-blank) line of each blob contains headers. </param>
        /// <param name="documentRoot"> For JSON arrays, given a structured or semi-structured document, you can specify a path to the array using this property. </param>
        /// <param name="dataToExtract"> Specifies the data to extract from Azure blob storage and tells the indexer which data to extract from image content when &quot;imageAction&quot; is set to a value other than &quot;none&quot;.  This applies to embedded image content in a .PDF or other application, or image files such as .jpg and .png, in Azure blobs. </param>
        /// <param name="imageAction"> Determines how to process embedded images and image files in Azure blob storage.  Setting the &quot;imageAction&quot; configuration to any value other than &quot;none&quot; requires that a skillset also be attached to that indexer. </param>
        /// <param name="allowSkillsetToReadFileData"> If true, will create a path //document//file_data that is an object representing the original file data downloaded from your blob data source.  This allows you to pass the original file data to a custom skill for processing within the enrichment pipeline, or to the Document Extraction skill. </param>
        /// <param name="pdfTextRotationAlgorithm"> Determines algorithm for text extraction from PDF files in Azure blob storage. </param>
        /// <param name="executionEnvironment"> Specifies the environment in which the indexer should execute. </param>
        /// <param name="queryTimeout"> Increases the timeout beyond the 5-minute default for Azure SQL database data sources, specified in the format &quot;hh:mm:ss&quot;. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <returns> A new <see cref="Indexes.Models.IndexingParametersConfiguration"/> instance for mocking. </returns>
        public static IndexingParametersConfiguration IndexingParametersConfiguration(BlobIndexerParsingMode? parsingMode = null, string excludedFileNameExtensions = null, string indexedFileNameExtensions = null, bool? failOnUnsupportedContentType = null, bool? failOnUnprocessableDocument = null, bool? indexStorageMetadataOnlyForOversizedDocuments = null, string delimitedTextHeaders = null, string delimitedTextDelimiter = null, bool? firstLineContainsHeaders = null, string documentRoot = null, BlobIndexerDataToExtract? dataToExtract = null, BlobIndexerImageAction? imageAction = null, bool? allowSkillsetToReadFileData = null, BlobIndexerPdfTextRotationAlgorithm? pdfTextRotationAlgorithm = null, IndexerExecutionEnvironment? executionEnvironment = null, string queryTimeout = null, IDictionary<string, object> additionalProperties = null)
        {
            additionalProperties ??= new Dictionary<string, object>();

            return new IndexingParametersConfiguration(parsingMode, excludedFileNameExtensions, indexedFileNameExtensions, failOnUnsupportedContentType, failOnUnprocessableDocument, indexStorageMetadataOnlyForOversizedDocuments, delimitedTextHeaders, delimitedTextDelimiter, firstLineContainsHeaders, documentRoot, dataToExtract, imageAction, allowSkillsetToReadFileData, pdfTextRotationAlgorithm, executionEnvironment, queryTimeout, additionalProperties);
        }

        /// <summary> Initializes a new instance of FieldMapping. </summary>
        /// <param name="sourceFieldName"> The name of the field in the data source. </param>
        /// <param name="targetFieldName"> The name of the target field in the index. Same as the source field name by default. </param>
        /// <param name="mappingFunction"> A function to apply to each source field value before indexing. </param>
        /// <returns> A new <see cref="Indexes.Models.FieldMapping"/> instance for mocking. </returns>
        public static FieldMapping FieldMapping(string sourceFieldName = null, string targetFieldName = null, FieldMappingFunction mappingFunction = null)
        {
            return new FieldMapping(sourceFieldName, targetFieldName, mappingFunction);
        }

        /// <summary> Initializes a new instance of FieldMappingFunction. </summary>
        /// <param name="name"> The name of the field mapping function. </param>
        /// <param name="parameters"> A dictionary of parameter name/value pairs to pass to the function. Each value must be of a primitive type. </param>
        /// <returns> A new <see cref="Indexes.Models.FieldMappingFunction"/> instance for mocking. </returns>
        public static FieldMappingFunction FieldMappingFunction(string name = null, IDictionary<string, object> parameters = null)
        {
            parameters ??= new Dictionary<string, object>();

            return new FieldMappingFunction(name, parameters);
        }

        /// <summary> Initializes a new instance of SearchIndexerCache. </summary>
        /// <param name="storageConnectionString"> The connection string to the storage account where the cache data will be persisted. </param>
        /// <param name="enableReprocessing"> Specifies whether incremental reprocessing is enabled. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexerCache"/> instance for mocking. </returns>
        public static SearchIndexerCache SearchIndexerCache(string storageConnectionString = null, bool? enableReprocessing = null)
        {
            return new SearchIndexerCache(storageConnectionString, enableReprocessing);
        }

        /// <summary> Initializes a new instance of SearchIndexerStatus. </summary>
        /// <param name="status"> Overall indexer status. </param>
        /// <param name="lastResult"> The result of the most recent or an in-progress indexer execution. </param>
        /// <param name="executionHistory"> History of the recent indexer executions, sorted in reverse chronological order. </param>
        /// <param name="limits"> The execution limits for the indexer. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexerStatus"/> instance for mocking. </returns>
        public static SearchIndexerStatus SearchIndexerStatus(IndexerStatus status = default, IndexerExecutionResult lastResult = null, IEnumerable<IndexerExecutionResult> executionHistory = null, SearchIndexerLimits limits = null)
        {
            executionHistory ??= new List<IndexerExecutionResult>();

            return new SearchIndexerStatus(status, lastResult, executionHistory?.ToList(), limits);
        }

        /// <summary> Initializes a new instance of IndexerExecutionResult. </summary>
        /// <param name="status"> The outcome of this indexer execution. </param>
        /// <param name="statusDetail"> The outcome of this indexer execution. </param>
        /// <param name="currentState"> All of the state that defines and dictates the indexer&apos;s current execution. </param>
        /// <param name="errorMessage"> The error message indicating the top-level error, if any. </param>
        /// <param name="startTime"> The start time of this indexer execution. </param>
        /// <param name="endTime"> The end time of this indexer execution, if the execution has already completed. </param>
        /// <param name="errors"> The item-level indexing errors. </param>
        /// <param name="warnings"> The item-level indexing warnings. </param>
        /// <param name="itemCount"> The number of items that were processed during this indexer execution. This includes both successfully processed items and items where indexing was attempted but failed. </param>
        /// <param name="failedItemCount"> The number of items that failed to be indexed during this indexer execution. </param>
        /// <param name="initialTrackingState"> Change tracking state with which an indexer execution started. </param>
        /// <param name="finalTrackingState"> Change tracking state with which an indexer execution finished. </param>
        /// <returns> A new <see cref="Indexes.Models.IndexerExecutionResult"/> instance for mocking. </returns>
        public static IndexerExecutionResult IndexerExecutionResult(IndexerExecutionStatus status = default, IndexerExecutionStatusDetail? statusDetail = null, IndexerState currentState = null, string errorMessage = null, DateTimeOffset? startTime = null, DateTimeOffset? endTime = null, IEnumerable<SearchIndexerError> errors = null, IEnumerable<SearchIndexerWarning> warnings = null, int itemCount = default, int failedItemCount = default, string initialTrackingState = null, string finalTrackingState = null)
        {
            errors ??= new List<SearchIndexerError>();
            warnings ??= new List<SearchIndexerWarning>();

            return new IndexerExecutionResult(status, statusDetail, currentState, errorMessage, startTime, endTime, errors?.ToList(), warnings?.ToList(), itemCount, failedItemCount, initialTrackingState, finalTrackingState);
        }

        /// <summary> Initializes a new instance of SearchIndexerSkillset. </summary>
        /// <param name="name"> The name of the skillset. </param>
        /// <param name="description"> The description of the skillset. </param>
        /// <param name="skills">
        /// A list of skills in the skillset.
        /// Please note <see cref="SearchIndexerSkill"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="AzureMachineLearningSkill"/>, <see cref="WebApiSkill"/>, <see cref="CustomEntityLookupSkill"/>, <see cref="EntityRecognitionSkill"/>, <see cref="KeyPhraseExtractionSkill"/>, <see cref="LanguageDetectionSkill"/>, <see cref="MergeSkill"/>, <see cref="PiiDetectionSkill"/>, <see cref="SentimentSkill"/>, <see cref="SplitSkill"/>, <see cref="TextTranslationSkill"/>, <see cref="EntityLinkingSkill"/>, <see cref="EntityRecognitionSkillV3"/>, <see cref="SentimentSkillV3"/>, <see cref="ConditionalSkill"/>, <see cref="DocumentExtractionSkill"/>, <see cref="ShaperSkill"/>, <see cref="ImageAnalysisSkill"/> and <see cref="OcrSkill"/>.
        /// </param>
        /// <param name="cognitiveServicesAccount">
        /// Details about cognitive services to be used when running skills.
        /// Please note <see cref="CognitiveServicesAccount"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="CognitiveServicesAccountKey"/> and <see cref="DefaultCognitiveServicesAccount"/>.
        /// </param>
        /// <param name="knowledgeStore"> Definition of additional projections to azure blob, table, or files, of enriched data. </param>
        /// <param name="etag"> The ETag of the skillset. </param>
        /// <param name="encryptionKey"> A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your skillset definition when you want full assurance that no one, not even Microsoft, can decrypt your skillset definition in Azure Cognitive Search. Once you have encrypted your skillset definition, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your skillset definition will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexerSkillset"/> instance for mocking. </returns>
        public static SearchIndexerSkillset SearchIndexerSkillset(string name = null, string description = null, IEnumerable<SearchIndexerSkill> skills = null, CognitiveServicesAccount cognitiveServicesAccount = null, KnowledgeStore knowledgeStore = null, string etag = null, SearchResourceEncryptionKey encryptionKey = null)
        {
            skills ??= new List<SearchIndexerSkill>();

            return new SearchIndexerSkillset(name, description, skills?.ToList(), cognitiveServicesAccount, knowledgeStore, etag, encryptionKey);
        }

        /// <summary> Initializes a new instance of SearchIndexerSkill. </summary>
        /// <param name="oDataType"> Identifies the concrete type of the skill. </param>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexerSkill"/> instance for mocking. </returns>
        public static SearchIndexerSkill SearchIndexerSkill(string oDataType = null, string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new UnknownSearchIndexerSkill(oDataType, name, description, context, inputs?.ToList(), outputs?.ToList());
        }

        /// <summary> Initializes a new instance of InputFieldMappingEntry. </summary>
        /// <param name="name"> The name of the input. </param>
        /// <param name="source"> The source of the input. </param>
        /// <param name="sourceContext"> The source context used for selecting recursive inputs. </param>
        /// <param name="inputs"> The recursive inputs used when creating a complex type. </param>
        /// <returns> A new <see cref="Indexes.Models.InputFieldMappingEntry"/> instance for mocking. </returns>
        public static InputFieldMappingEntry InputFieldMappingEntry(string name = null, string source = null, string sourceContext = null, IEnumerable<InputFieldMappingEntry> inputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();

            return new InputFieldMappingEntry(name, source, sourceContext, inputs?.ToList());
        }

        /// <summary> Initializes a new instance of OutputFieldMappingEntry. </summary>
        /// <param name="name"> The name of the output defined by the skill. </param>
        /// <param name="targetName"> The target name of the output. It is optional and default to name. </param>
        /// <returns> A new <see cref="Indexes.Models.OutputFieldMappingEntry"/> instance for mocking. </returns>
        public static OutputFieldMappingEntry OutputFieldMappingEntry(string name = null, string targetName = null)
        {
            return new OutputFieldMappingEntry(name, targetName);
        }

        /// <summary> Initializes a new instance of KnowledgeStoreProjection. </summary>
        /// <param name="tables"> Projections to Azure Table storage. </param>
        /// <param name="objects"> Projections to Azure Blob storage. </param>
        /// <param name="files"> Projections to Azure File storage. </param>
        /// <returns> A new <see cref="Indexes.Models.KnowledgeStoreProjection"/> instance for mocking. </returns>
        public static KnowledgeStoreProjection KnowledgeStoreProjection(IEnumerable<KnowledgeStoreTableProjectionSelector> tables = null, IEnumerable<KnowledgeStoreObjectProjectionSelector> objects = null, IEnumerable<KnowledgeStoreFileProjectionSelector> files = null)
        {
            tables ??= new List<KnowledgeStoreTableProjectionSelector>();
            objects ??= new List<KnowledgeStoreObjectProjectionSelector>();
            files ??= new List<KnowledgeStoreFileProjectionSelector>();

            return new KnowledgeStoreProjection(tables?.ToList(), objects?.ToList(), files?.ToList());
        }

        /// <summary> Initializes a new instance of KnowledgeStoreTableProjectionSelector. </summary>
        /// <param name="referenceKeyName"> Name of reference key to different projection. </param>
        /// <param name="generatedKeyName"> Name of generated key to store projection under. </param>
        /// <param name="source"> Source data to project. </param>
        /// <param name="sourceContext"> Source context for complex projections. </param>
        /// <param name="inputs"> Nested inputs for complex projections. </param>
        /// <param name="tableName"> Name of the Azure table to store projected data in. </param>
        /// <returns> A new <see cref="Indexes.Models.KnowledgeStoreTableProjectionSelector"/> instance for mocking. </returns>
        public static KnowledgeStoreTableProjectionSelector KnowledgeStoreTableProjectionSelector(string referenceKeyName = null, string generatedKeyName = null, string source = null, string sourceContext = null, IEnumerable<InputFieldMappingEntry> inputs = null, string tableName = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();

            return new KnowledgeStoreTableProjectionSelector(referenceKeyName, generatedKeyName, source, sourceContext, inputs?.ToList(), tableName);
        }

        /// <summary> Initializes a new instance of KnowledgeStoreObjectProjectionSelector. </summary>
        /// <param name="referenceKeyName"> Name of reference key to different projection. </param>
        /// <param name="generatedKeyName"> Name of generated key to store projection under. </param>
        /// <param name="source"> Source data to project. </param>
        /// <param name="sourceContext"> Source context for complex projections. </param>
        /// <param name="inputs"> Nested inputs for complex projections. </param>
        /// <param name="storageContainer"> Blob container to store projections in. </param>
        /// <returns> A new <see cref="Indexes.Models.KnowledgeStoreObjectProjectionSelector"/> instance for mocking. </returns>
        public static KnowledgeStoreObjectProjectionSelector KnowledgeStoreObjectProjectionSelector(string referenceKeyName = null, string generatedKeyName = null, string source = null, string sourceContext = null, IEnumerable<InputFieldMappingEntry> inputs = null, string storageContainer = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();

            return new KnowledgeStoreObjectProjectionSelector(referenceKeyName, generatedKeyName, source, sourceContext, inputs?.ToList(), storageContainer);
        }

        /// <summary> Initializes a new instance of KnowledgeStoreFileProjectionSelector. </summary>
        /// <param name="referenceKeyName"> Name of reference key to different projection. </param>
        /// <param name="generatedKeyName"> Name of generated key to store projection under. </param>
        /// <param name="source"> Source data to project. </param>
        /// <param name="sourceContext"> Source context for complex projections. </param>
        /// <param name="inputs"> Nested inputs for complex projections. </param>
        /// <param name="storageContainer"> Blob container to store projections in. </param>
        /// <returns> A new <see cref="Indexes.Models.KnowledgeStoreFileProjectionSelector"/> instance for mocking. </returns>
        public static KnowledgeStoreFileProjectionSelector KnowledgeStoreFileProjectionSelector(string referenceKeyName = null, string generatedKeyName = null, string source = null, string sourceContext = null, IEnumerable<InputFieldMappingEntry> inputs = null, string storageContainer = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();

            return new KnowledgeStoreFileProjectionSelector(referenceKeyName, generatedKeyName, source, sourceContext, inputs?.ToList(), storageContainer);
        }

        /// <summary> Initializes a new instance of SynonymMap. </summary>
        /// <param name="name"> The name of the synonym map. </param>
        /// <param name="format"> The format of the synonym map. Only the &apos;solr&apos; format is currently supported. </param>
        /// <param name="synonyms"> A series of synonym rules in the specified synonym map format. The rules must be separated by newlines. </param>
        /// <param name="encryptionKey"> A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your data when you want full assurance that no one, not even Microsoft, can decrypt your data in Azure Cognitive Search. Once you have encrypted your data, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your data will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. </param>
        /// <param name="etag"> The ETag of the synonym map. </param>
        /// <returns> A new <see cref="Indexes.Models.SynonymMap"/> instance for mocking. </returns>
        public static SynonymMap SynonymMap(string name = null, string format = null, string synonyms = null, SearchResourceEncryptionKey encryptionKey = null, string etag = null)
        {
            return new SynonymMap(name, format, synonyms, encryptionKey, etag);
        }

        /// <summary> Initializes a new instance of SearchIndex. </summary>
        /// <param name="name"> The name of the index. </param>
        /// <param name="fields"> The fields of the index. </param>
        /// <param name="scoringProfiles"> The scoring profiles for the index. </param>
        /// <param name="defaultScoringProfile"> The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used. </param>
        /// <param name="corsOptions"> Options to control Cross-Origin Resource Sharing (CORS) for the index. </param>
        /// <param name="suggesters"> The suggesters for the index. </param>
        /// <param name="analyzers">
        /// The analyzers for the index.
        /// Please note <see cref="LexicalAnalyzer"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="CustomAnalyzer"/>, <see cref="PatternAnalyzer"/>, <see cref="LuceneStandardAnalyzer"/> and <see cref="StopAnalyzer"/>.
        /// </param>
        /// <param name="tokenizers">
        /// The tokenizers for the index.
        /// Please note <see cref="LexicalTokenizer"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ClassicTokenizer"/>, <see cref="EdgeNGramTokenizer"/>, <see cref="KeywordTokenizer"/>, <see cref="KeywordTokenizer"/>, <see cref="MicrosoftLanguageStemmingTokenizer"/>, <see cref="MicrosoftLanguageTokenizer"/>, <see cref="NGramTokenizer"/>, <see cref="PathHierarchyTokenizer"/>, <see cref="PatternTokenizer"/>, <see cref="LuceneStandardTokenizer"/>, <see cref="LuceneStandardTokenizer"/> and <see cref="UaxUrlEmailTokenizer"/>.
        /// </param>
        /// <param name="tokenFilters">
        /// The token filters for the index.
        /// Please note <see cref="TokenFilter"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="AsciiFoldingTokenFilter"/>, <see cref="CjkBigramTokenFilter"/>, <see cref="CommonGramTokenFilter"/>, <see cref="DictionaryDecompounderTokenFilter"/>, <see cref="EdgeNGramTokenFilter"/>, <see cref="EdgeNGramTokenFilter"/>, <see cref="ElisionTokenFilter"/>, <see cref="KeepTokenFilter"/>, <see cref="KeywordMarkerTokenFilter"/>, <see cref="LengthTokenFilter"/>, <see cref="LimitTokenFilter"/>, <see cref="NGramTokenFilter"/>, <see cref="NGramTokenFilter"/>, <see cref="PatternCaptureTokenFilter"/>, <see cref="PatternReplaceTokenFilter"/>, <see cref="PhoneticTokenFilter"/>, <see cref="ShingleTokenFilter"/>, <see cref="SnowballTokenFilter"/>, <see cref="StemmerOverrideTokenFilter"/>, <see cref="StemmerTokenFilter"/>, <see cref="StopwordsTokenFilter"/>, <see cref="SynonymTokenFilter"/>, <see cref="TruncateTokenFilter"/>, <see cref="UniqueTokenFilter"/> and <see cref="WordDelimiterTokenFilter"/>.
        /// </param>
        /// <param name="charFilters">
        /// The character filters for the index.
        /// Please note <see cref="CharFilter"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="MappingCharFilter"/> and <see cref="PatternReplaceCharFilter"/>.
        /// </param>
        /// <param name="normalizers">
        /// The normalizers for the index.
        /// Please note <see cref="LexicalNormalizer"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="CustomNormalizer"/>.
        /// </param>
        /// <param name="encryptionKey"> A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your data when you want full assurance that no one, not even Microsoft, can decrypt your data in Azure Cognitive Search. Once you have encrypted your data, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your data will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. </param>
        /// <param name="similarity">
        /// The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used.
        /// Please note <see cref="SimilarityAlgorithm"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BM25Similarity"/> and <see cref="ClassicSimilarity"/>.
        /// </param>
        /// <param name="semanticSettings"> Defines parameters for a search index that influence semantic capabilities. </param>
        /// <param name="etag"> The ETag of the index. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndex"/> instance for mocking. </returns>
        public static SearchIndex SearchIndex(string name = null, IEnumerable<SearchField> fields = null, IEnumerable<ScoringProfile> scoringProfiles = null, string defaultScoringProfile = null, CorsOptions corsOptions = null, IEnumerable<SearchSuggester> suggesters = null, IEnumerable<LexicalAnalyzer> analyzers = null, IEnumerable<LexicalTokenizer> tokenizers = null, IEnumerable<TokenFilter> tokenFilters = null, IEnumerable<CharFilter> charFilters = null, IEnumerable<LexicalNormalizer> normalizers = null, SearchResourceEncryptionKey encryptionKey = null, SimilarityAlgorithm similarity = null, SemanticSettings semanticSettings = null, string etag = null)
        {
            fields ??= new List<SearchField>();
            scoringProfiles ??= new List<ScoringProfile>();
            suggesters ??= new List<SearchSuggester>();
            analyzers ??= new List<LexicalAnalyzer>();
            tokenizers ??= new List<LexicalTokenizer>();
            tokenFilters ??= new List<TokenFilter>();
            charFilters ??= new List<CharFilter>();
            normalizers ??= new List<LexicalNormalizer>();

            return new SearchIndex(name, fields?.ToList(), scoringProfiles?.ToList(), defaultScoringProfile, corsOptions, suggesters?.ToList(), analyzers?.ToList(), tokenizers?.ToList(), tokenFilters?.ToList(), charFilters?.ToList(), normalizers?.ToList(), encryptionKey, similarity, semanticSettings, etag);
        }

        /// <summary> Initializes a new instance of SearchField. </summary>
        /// <param name="name"> The name of the field, which must be unique within the fields collection of the index or parent field. </param>
        /// <param name="type"> The data type of the field. </param>
        /// <param name="isKey"> A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields. </param>
        /// <param name="isRetrievable"> A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields. </param>
        /// <param name="isSearchable"> A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like &quot;sunny day&quot;, internally it will be split into the individual tokens &quot;sunny&quot; and &quot;day&quot;. This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don&apos;t need a field to be included in searches, set searchable to false. </param>
        /// <param name="isFilterable"> A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to &quot;sunny day&quot;, $filter=f eq &apos;sunny&apos; will find no matches, but $filter=f eq &apos;sunny day&apos; will. This property must be null for complex fields. Default is true for simple fields and null for complex fields. </param>
        /// <param name="isSortable"> A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it&apos;s an immediate parent field, or an ancestor field, that&apos;s the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields. </param>
        /// <param name="isFacetable"> A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields. </param>
        /// <param name="analyzerName"> The name of the analyzer to use for the field. This option can be used only with searchable fields and it can&apos;t be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields. </param>
        /// <param name="searchAnalyzerName"> The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields. </param>
        /// <param name="indexAnalyzerName"> The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields. </param>
        /// <param name="normalizerName"> The name of the normalizer to use for the field. This option can be used only with fields with filterable, sortable, or facetable enabled. Once the normalizer is chosen, it cannot be changed for the field. Must be null for complex fields. </param>
        /// <param name="synonymMapNames"> A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields. </param>
        /// <param name="fields"> A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchField"/> instance for mocking. </returns>
        public static SearchField SearchField(string name = null, SearchFieldDataType type = default, bool? isKey = null, bool? isRetrievable = null, bool? isSearchable = null, bool? isFilterable = null, bool? isSortable = null, bool? isFacetable = null, LexicalAnalyzerName? analyzerName = null, LexicalAnalyzerName? searchAnalyzerName = null, LexicalAnalyzerName? indexAnalyzerName = null, LexicalNormalizerName? normalizerName = null, IEnumerable<string> synonymMapNames = null, IEnumerable<SearchField> fields = null)
        {
            synonymMapNames ??= new List<string>();
            fields ??= new List<SearchField>();

            return new SearchField(name, type, isKey, isRetrievable, isSearchable, isFilterable, isSortable, isFacetable, analyzerName, searchAnalyzerName, indexAnalyzerName, normalizerName, synonymMapNames?.ToList(), fields?.ToList());
        }

        /// <summary> Initializes a new instance of ScoringProfile. </summary>
        /// <param name="name"> The name of the scoring profile. </param>
        /// <param name="textWeights"> Parameters that boost scoring based on text matches in certain index fields. </param>
        /// <param name="functions">
        /// The collection of functions that influence the scoring of documents.
        /// Please note <see cref="ScoringFunction"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="DistanceScoringFunction"/>, <see cref="FreshnessScoringFunction"/>, <see cref="MagnitudeScoringFunction"/> and <see cref="TagScoringFunction"/>.
        /// </param>
        /// <param name="functionAggregation"> A value indicating how the results of individual scoring functions should be combined. Defaults to &quot;Sum&quot;. Ignored if there are no scoring functions. </param>
        /// <returns> A new <see cref="Indexes.Models.ScoringProfile"/> instance for mocking. </returns>
        public static ScoringProfile ScoringProfile(string name = null, TextWeights textWeights = null, IEnumerable<ScoringFunction> functions = null, ScoringFunctionAggregation? functionAggregation = null)
        {
            functions ??= new List<ScoringFunction>();

            return new ScoringProfile(name, textWeights, functions?.ToList(), functionAggregation);
        }

        /// <summary> Initializes a new instance of CorsOptions. </summary>
        /// <param name="allowedOrigins"> The list of origins from which JavaScript code will be granted access to your index. Can contain a list of hosts of the form {protocol}://{fully-qualified-domain-name}[:{port#}], or a single &apos;*&apos; to allow all origins (not recommended). </param>
        /// <param name="maxAgeInSeconds"> The duration for which browsers should cache CORS preflight responses. Defaults to 5 minutes. </param>
        /// <returns> A new <see cref="Indexes.Models.CorsOptions"/> instance for mocking. </returns>
        public static CorsOptions CorsOptions(IEnumerable<string> allowedOrigins = null, long? maxAgeInSeconds = null)
        {
            allowedOrigins ??= new List<string>();

            return new CorsOptions(allowedOrigins?.ToList(), maxAgeInSeconds);
        }

        /// <summary> Initializes a new instance of SearchSuggester. </summary>
        /// <param name="name"> The name of the suggester. </param>
        /// <param name="searchMode"> A value indicating the capabilities of the suggester. </param>
        /// <param name="sourceFields"> The list of field names to which the suggester applies. Each field must be searchable. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchSuggester"/> instance for mocking. </returns>
        public static SearchSuggester SearchSuggester(string name = null, string searchMode = null, IEnumerable<string> sourceFields = null)
        {
            sourceFields ??= new List<string>();

            return new SearchSuggester(name, searchMode, sourceFields?.ToList());
        }

        /// <summary> Initializes a new instance of LexicalNormalizer. </summary>
        /// <param name="oDataType"> Identifies the concrete type of the normalizer. </param>
        /// <param name="name"> The name of the normalizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. It cannot end in &apos;.microsoft&apos; nor &apos;.lucene&apos;, nor be named &apos;asciifolding&apos;, &apos;standard&apos;, &apos;lowercase&apos;, &apos;uppercase&apos;, or &apos;elision&apos;. </param>
        /// <returns> A new <see cref="Indexes.Models.LexicalNormalizer"/> instance for mocking. </returns>
        public static LexicalNormalizer LexicalNormalizer(string oDataType = null, string name = null)
        {
            return new UnknownLexicalNormalizer(oDataType, name);
        }

        /// <summary> Initializes a new instance of SemanticSettings. </summary>
        /// <param name="configurations"> The semantic configurations for the index. </param>
        /// <returns> A new <see cref="Indexes.Models.SemanticSettings"/> instance for mocking. </returns>
        public static SemanticSettings SemanticSettings(IEnumerable<SemanticConfiguration> configurations = null)
        {
            configurations ??= new List<SemanticConfiguration>();

            return new SemanticSettings(configurations?.ToList());
        }

        /// <summary> Initializes a new instance of PrioritizedFields. </summary>
        /// <param name="titleField"> Defines the title field to be used for semantic ranking, captions, highlights, and answers. If you don&apos;t have a title field in your index, leave this blank. </param>
        /// <param name="contentFields"> Defines the content fields to be used for semantic ranking, captions, highlights, and answers. For the best result, the selected fields should contain text in natural language form. The order of the fields in the array represents their priority. Fields with lower priority may get truncated if the content is long. </param>
        /// <param name="keywordFields"> Defines the keyword fields to be used for semantic ranking, captions, highlights, and answers. For the best result, the selected fields should contain a list of keywords. The order of the fields in the array represents their priority. Fields with lower priority may get truncated if the content is long. </param>
        /// <returns> A new <see cref="Indexes.Models.PrioritizedFields"/> instance for mocking. </returns>
        public static PrioritizedFields PrioritizedFields(SemanticField titleField = null, IEnumerable<SemanticField> contentFields = null, IEnumerable<SemanticField> keywordFields = null)
        {
            contentFields ??= new List<SemanticField>();
            keywordFields ??= new List<SemanticField>();

            return new PrioritizedFields(titleField, contentFields?.ToList(), keywordFields?.ToList());
        }

        /// <summary> Initializes a new instance of SemanticField. </summary>
        /// <param name="fieldName"></param>
        /// <returns> A new <see cref="Indexes.Models.SemanticField"/> instance for mocking. </returns>
        public static SemanticField SemanticField(string fieldName = null)
        {
            return new SemanticField(fieldName);
        }

        /// <summary> Initializes a new instance of SearchAlias. </summary>
        /// <param name="name"> The name of the alias. </param>
        /// <param name="indexes"> The name of the index this alias maps to. Only one index name may be specified. </param>
        /// <param name="etag"> The ETag of the alias. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchAlias"/> instance for mocking. </returns>
        public static SearchAlias SearchAlias(string name = null, IEnumerable<string> indexes = null, string etag = null)
        {
            indexes ??= new List<string>();

            return new SearchAlias(name, indexes?.ToList(), etag);
        }

        /// <summary> Initializes a new instance of CustomAnalyzer. </summary>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="tokenizerName"> The name of the tokenizer to use to divide continuous text into a sequence of tokens, such as breaking a sentence into words. </param>
        /// <param name="tokenFilters"> A list of token filters used to filter out or modify the tokens generated by a tokenizer. For example, you can specify a lowercase filter that converts all characters to lowercase. The filters are run in the order in which they are listed. </param>
        /// <param name="charFilters"> A list of character filters used to prepare input text before it is processed by the tokenizer. For instance, they can replace certain characters or symbols. The filters are run in the order in which they are listed. </param>
        /// <returns> A new <see cref="Indexes.Models.CustomAnalyzer"/> instance for mocking. </returns>
        public static CustomAnalyzer CustomAnalyzer(string name = null, LexicalTokenizerName tokenizerName = default, IEnumerable<TokenFilterName> tokenFilters = null, IEnumerable<string> charFilters = null)
        {
            tokenFilters ??= new List<TokenFilterName>();
            charFilters ??= new List<string>();

            return new CustomAnalyzer("#Microsoft.Azure.Search.CustomAnalyzer", name, tokenizerName, tokenFilters?.ToList(), charFilters?.ToList());
        }

        /// <summary> Initializes a new instance of PatternAnalyzer. </summary>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="lowerCaseTerms"> A value indicating whether terms should be lower-cased. Default is true. </param>
        /// <param name="pattern"> A regular expression pattern to match token separators. Default is an expression that matches one or more non-word characters. </param>
        /// <param name="flagsInternal"> Regular expression flags. </param>
        /// <param name="stopwords"> A list of stopwords. </param>
        /// <returns> A new <see cref="Indexes.Models.PatternAnalyzer"/> instance for mocking. </returns>
        public static PatternAnalyzer PatternAnalyzer(string name = null, bool? lowerCaseTerms = null, string pattern = null, string flagsInternal = null, IEnumerable<string> stopwords = null)
        {
            stopwords ??= new List<string>();

            return new PatternAnalyzer("#Microsoft.Azure.Search.PatternAnalyzer", name, lowerCaseTerms, pattern, flagsInternal, stopwords?.ToList());
        }

        /// <summary> Initializes a new instance of LuceneStandardAnalyzer. </summary>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <param name="stopwords"> A list of stopwords. </param>
        /// <returns> A new <see cref="Indexes.Models.LuceneStandardAnalyzer"/> instance for mocking. </returns>
        public static LuceneStandardAnalyzer LuceneStandardAnalyzer(string name = null, int? maxTokenLength = null, IEnumerable<string> stopwords = null)
        {
            stopwords ??= new List<string>();

            return new LuceneStandardAnalyzer("#Microsoft.Azure.Search.StandardAnalyzer", name, maxTokenLength, stopwords?.ToList());
        }

        /// <summary> Initializes a new instance of StopAnalyzer. </summary>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="stopwords"> A list of stopwords. </param>
        /// <returns> A new <see cref="Indexes.Models.StopAnalyzer"/> instance for mocking. </returns>
        public static StopAnalyzer StopAnalyzer(string name = null, IEnumerable<string> stopwords = null)
        {
            stopwords ??= new List<string>();

            return new StopAnalyzer("#Microsoft.Azure.Search.StopAnalyzer", name, stopwords?.ToList());
        }

        /// <summary> Initializes a new instance of CustomNormalizer. </summary>
        /// <param name="name"> The name of the normalizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. It cannot end in &apos;.microsoft&apos; nor &apos;.lucene&apos;, nor be named &apos;asciifolding&apos;, &apos;standard&apos;, &apos;lowercase&apos;, &apos;uppercase&apos;, or &apos;elision&apos;. </param>
        /// <param name="tokenFilters"> A list of token filters used to filter out or modify the input token. For example, you can specify a lowercase filter that converts all characters to lowercase. The filters are run in the order in which they are listed. </param>
        /// <param name="charFilters"> A list of character filters used to prepare input text before it is processed. For instance, they can replace certain characters or symbols. The filters are run in the order in which they are listed. </param>
        /// <returns> A new <see cref="Indexes.Models.CustomNormalizer"/> instance for mocking. </returns>
        public static CustomNormalizer CustomNormalizer(string name = null, IEnumerable<TokenFilterName> tokenFilters = null, IEnumerable<CharFilterName> charFilters = null)
        {
            tokenFilters ??= new List<TokenFilterName>();
            charFilters ??= new List<CharFilterName>();

            return new CustomNormalizer("#Microsoft.Azure.Search.CustomNormalizer", name, tokenFilters?.ToList(), charFilters?.ToList());
        }

        /// <summary> Initializes a new instance of ClassicTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <returns> A new <see cref="Indexes.Models.ClassicTokenizer"/> instance for mocking. </returns>
        public static ClassicTokenizer ClassicTokenizer(string name = null, int? maxTokenLength = null)
        {
            return new ClassicTokenizer("#Microsoft.Azure.Search.ClassicTokenizer", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of EdgeNGramTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. Maximum is 300. </param>
        /// <param name="tokenChars"> Character classes to keep in the tokens. </param>
        /// <returns> A new <see cref="Indexes.Models.EdgeNGramTokenizer"/> instance for mocking. </returns>
        public static EdgeNGramTokenizer EdgeNGramTokenizer(string name = null, int? minGram = null, int? maxGram = null, IEnumerable<TokenCharacterKind> tokenChars = null)
        {
            tokenChars ??= new List<TokenCharacterKind>();

            return new EdgeNGramTokenizer("#Microsoft.Azure.Search.EdgeNGramTokenizer", name, minGram, maxGram, tokenChars?.ToList());
        }

        /// <summary> Initializes a new instance of KeywordTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="bufferSize"> The read buffer size in bytes. Default is 256. </param>
        /// <returns> A new <see cref="Indexes.Models.KeywordTokenizer"/> instance for mocking. </returns>
        public static KeywordTokenizer KeywordTokenizer(string name = null, int? bufferSize = null)
        {
            return new KeywordTokenizer("#Microsoft.Azure.Search.KeywordTokenizer", name, bufferSize);
        }

        /// <summary> Initializes a new instance of KeywordTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 256. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <returns> A new <see cref="Indexes.Models.KeywordTokenizer"/> instance for mocking. </returns>
        public static KeywordTokenizer KeywordTokenizer(string name = null, int? maxTokenLength = null)
        {
            return new KeywordTokenizer("#Microsoft.Azure.Search.KeywordTokenizerV2", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of MicrosoftLanguageTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Tokens longer than the maximum length are split. Maximum token length that can be used is 300 characters. Tokens longer than 300 characters are first split into tokens of length 300 and then each of those tokens is split based on the max token length set. Default is 255. </param>
        /// <param name="isSearchTokenizer"> A value indicating how the tokenizer is used. Set to true if used as the search tokenizer, set to false if used as the indexing tokenizer. Default is false. </param>
        /// <param name="language"> The language to use. The default is English. </param>
        /// <returns> A new <see cref="Indexes.Models.MicrosoftLanguageTokenizer"/> instance for mocking. </returns>
        public static MicrosoftLanguageTokenizer MicrosoftLanguageTokenizer(string name = null, int? maxTokenLength = null, bool? isSearchTokenizer = null, MicrosoftTokenizerLanguage? language = null)
        {
            return new MicrosoftLanguageTokenizer("#Microsoft.Azure.Search.MicrosoftLanguageTokenizer", name, maxTokenLength, isSearchTokenizer, language);
        }

        /// <summary> Initializes a new instance of MicrosoftLanguageStemmingTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Tokens longer than the maximum length are split. Maximum token length that can be used is 300 characters. Tokens longer than 300 characters are first split into tokens of length 300 and then each of those tokens is split based on the max token length set. Default is 255. </param>
        /// <param name="isSearchTokenizer"> A value indicating how the tokenizer is used. Set to true if used as the search tokenizer, set to false if used as the indexing tokenizer. Default is false. </param>
        /// <param name="language"> The language to use. The default is English. </param>
        /// <returns> A new <see cref="Indexes.Models.MicrosoftLanguageStemmingTokenizer"/> instance for mocking. </returns>
        public static MicrosoftLanguageStemmingTokenizer MicrosoftLanguageStemmingTokenizer(string name = null, int? maxTokenLength = null, bool? isSearchTokenizer = null, MicrosoftStemmingTokenizerLanguage? language = null)
        {
            return new MicrosoftLanguageStemmingTokenizer("#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer", name, maxTokenLength, isSearchTokenizer, language);
        }

        /// <summary> Initializes a new instance of NGramTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. Maximum is 300. </param>
        /// <param name="tokenChars"> Character classes to keep in the tokens. </param>
        /// <returns> A new <see cref="Indexes.Models.NGramTokenizer"/> instance for mocking. </returns>
        public static NGramTokenizer NGramTokenizer(string name = null, int? minGram = null, int? maxGram = null, IEnumerable<TokenCharacterKind> tokenChars = null)
        {
            tokenChars ??= new List<TokenCharacterKind>();

            return new NGramTokenizer("#Microsoft.Azure.Search.NGramTokenizer", name, minGram, maxGram, tokenChars?.ToList());
        }

        /// <summary> Initializes a new instance of PathHierarchyTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="delimiter"> The delimiter character to use. Default is &quot;/&quot;. </param>
        /// <param name="replacement"> A value that, if set, replaces the delimiter character. Default is &quot;/&quot;. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default and maximum is 300. </param>
        /// <param name="reverseTokenOrder"> A value indicating whether to generate tokens in reverse order. Default is false. </param>
        /// <param name="numberOfTokensToSkip"> The number of initial tokens to skip. Default is 0. </param>
        /// <returns> A new <see cref="Indexes.Models.PathHierarchyTokenizer"/> instance for mocking. </returns>
        public static PathHierarchyTokenizer PathHierarchyTokenizer(string name = null, char? delimiter = null, char? replacement = null, int? maxTokenLength = null, bool? reverseTokenOrder = null, int? numberOfTokensToSkip = null)
        {
            return new PathHierarchyTokenizer("#Microsoft.Azure.Search.PathHierarchyTokenizerV2", name, delimiter, replacement, maxTokenLength, reverseTokenOrder, numberOfTokensToSkip);
        }

        /// <summary> Initializes a new instance of PatternTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="pattern"> A regular expression pattern to match token separators. Default is an expression that matches one or more non-word characters. </param>
        /// <param name="flagsInternal"> Regular expression flags. </param>
        /// <param name="group"> The zero-based ordinal of the matching group in the regular expression pattern to extract into tokens. Use -1 if you want to use the entire pattern to split the input into tokens, irrespective of matching groups. Default is -1. </param>
        /// <returns> A new <see cref="Indexes.Models.PatternTokenizer"/> instance for mocking. </returns>
        public static PatternTokenizer PatternTokenizer(string name = null, string pattern = null, string flagsInternal = null, int? group = null)
        {
            return new PatternTokenizer("#Microsoft.Azure.Search.PatternTokenizer", name, pattern, flagsInternal, group);
        }

        /// <summary> Initializes a new instance of LuceneStandardTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. </param>
        /// <returns> A new <see cref="Indexes.Models.LuceneStandardTokenizer"/> instance for mocking. </returns>
        public static LuceneStandardTokenizer LuceneStandardTokenizer(string name = null, int? maxTokenLength = null)
        {
            return new LuceneStandardTokenizer("#Microsoft.Azure.Search.StandardTokenizer", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of LuceneStandardTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <returns> A new <see cref="Indexes.Models.LuceneStandardTokenizer"/> instance for mocking. </returns>
        public static LuceneStandardTokenizer LuceneStandardTokenizer(string name = null, int? maxTokenLength = null)
        {
            return new LuceneStandardTokenizer("#Microsoft.Azure.Search.StandardTokenizerV2", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of UaxUrlEmailTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <returns> A new <see cref="Indexes.Models.UaxUrlEmailTokenizer"/> instance for mocking. </returns>
        public static UaxUrlEmailTokenizer UaxUrlEmailTokenizer(string name = null, int? maxTokenLength = null)
        {
            return new UaxUrlEmailTokenizer("#Microsoft.Azure.Search.UaxUrlEmailTokenizer", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of AsciiFoldingTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="preserveOriginal"> A value indicating whether the original token will be kept. Default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.AsciiFoldingTokenFilter"/> instance for mocking. </returns>
        public static AsciiFoldingTokenFilter AsciiFoldingTokenFilter(string name = null, bool? preserveOriginal = null)
        {
            return new AsciiFoldingTokenFilter("#Microsoft.Azure.Search.AsciiFoldingTokenFilter", name, preserveOriginal);
        }

        /// <summary> Initializes a new instance of CjkBigramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="ignoreScripts"> The scripts to ignore. </param>
        /// <param name="outputUnigrams"> A value indicating whether to output both unigrams and bigrams (if true), or just bigrams (if false). Default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.CjkBigramTokenFilter"/> instance for mocking. </returns>
        public static CjkBigramTokenFilter CjkBigramTokenFilter(string name = null, IEnumerable<CjkBigramTokenFilterScripts> ignoreScripts = null, bool? outputUnigrams = null)
        {
            ignoreScripts ??= new List<CjkBigramTokenFilterScripts>();

            return new CjkBigramTokenFilter("#Microsoft.Azure.Search.CjkBigramTokenFilter", name, ignoreScripts?.ToList(), outputUnigrams);
        }

        /// <summary> Initializes a new instance of CommonGramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="commonWords"> The set of common words. </param>
        /// <param name="ignoreCase"> A value indicating whether common words matching will be case insensitive. Default is false. </param>
        /// <param name="useQueryMode"> A value that indicates whether the token filter is in query mode. When in query mode, the token filter generates bigrams and then removes common words and single terms followed by a common word. Default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.CommonGramTokenFilter"/> instance for mocking. </returns>
        public static CommonGramTokenFilter CommonGramTokenFilter(string name = null, IEnumerable<string> commonWords = null, bool? ignoreCase = null, bool? useQueryMode = null)
        {
            commonWords ??= new List<string>();

            return new CommonGramTokenFilter("#Microsoft.Azure.Search.CommonGramTokenFilter", name, commonWords?.ToList(), ignoreCase, useQueryMode);
        }

        /// <summary> Initializes a new instance of DictionaryDecompounderTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="wordList"> The list of words to match against. </param>
        /// <param name="minWordSize"> The minimum word size. Only words longer than this get processed. Default is 5. Maximum is 300. </param>
        /// <param name="minSubwordSize"> The minimum subword size. Only subwords longer than this are outputted. Default is 2. Maximum is 300. </param>
        /// <param name="maxSubwordSize"> The maximum subword size. Only subwords shorter than this are outputted. Default is 15. Maximum is 300. </param>
        /// <param name="onlyLongestMatch"> A value indicating whether to add only the longest matching subword to the output. Default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.DictionaryDecompounderTokenFilter"/> instance for mocking. </returns>
        public static DictionaryDecompounderTokenFilter DictionaryDecompounderTokenFilter(string name = null, IEnumerable<string> wordList = null, int? minWordSize = null, int? minSubwordSize = null, int? maxSubwordSize = null, bool? onlyLongestMatch = null)
        {
            wordList ??= new List<string>();

            return new DictionaryDecompounderTokenFilter("#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter", name, wordList?.ToList(), minWordSize, minSubwordSize, maxSubwordSize, onlyLongestMatch);
        }

        /// <summary> Initializes a new instance of EdgeNGramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. </param>
        /// <param name="side"> Specifies which side of the input the n-gram should be generated from. Default is &quot;front&quot;. </param>
        /// <returns> A new <see cref="Indexes.Models.EdgeNGramTokenFilter"/> instance for mocking. </returns>
        public static EdgeNGramTokenFilter EdgeNGramTokenFilter(string name = null, int? minGram = null, int? maxGram = null, EdgeNGramTokenFilterSide? side = null)
        {
            return new EdgeNGramTokenFilter("#Microsoft.Azure.Search.EdgeNGramTokenFilter", name, minGram, maxGram, side);
        }

        /// <summary> Initializes a new instance of EdgeNGramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. Maximum is 300. </param>
        /// <param name="side"> Specifies which side of the input the n-gram should be generated from. Default is &quot;front&quot;. </param>
        /// <returns> A new <see cref="Indexes.Models.EdgeNGramTokenFilter"/> instance for mocking. </returns>
        public static EdgeNGramTokenFilter EdgeNGramTokenFilter(string name = null, int? minGram = null, int? maxGram = null, EdgeNGramTokenFilterSide? side = null)
        {
            return new EdgeNGramTokenFilter("#Microsoft.Azure.Search.EdgeNGramTokenFilterV2", name, minGram, maxGram, side);
        }

        /// <summary> Initializes a new instance of ElisionTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="articles"> The set of articles to remove. </param>
        /// <returns> A new <see cref="Indexes.Models.ElisionTokenFilter"/> instance for mocking. </returns>
        public static ElisionTokenFilter ElisionTokenFilter(string name = null, IEnumerable<string> articles = null)
        {
            articles ??= new List<string>();

            return new ElisionTokenFilter("#Microsoft.Azure.Search.ElisionTokenFilter", name, articles?.ToList());
        }

        /// <summary> Initializes a new instance of KeepTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="keepWords"> The list of words to keep. </param>
        /// <param name="lowerCaseKeepWords"> A value indicating whether to lower case all words first. Default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.KeepTokenFilter"/> instance for mocking. </returns>
        public static KeepTokenFilter KeepTokenFilter(string name = null, IEnumerable<string> keepWords = null, bool? lowerCaseKeepWords = null)
        {
            keepWords ??= new List<string>();

            return new KeepTokenFilter("#Microsoft.Azure.Search.KeepTokenFilter", name, keepWords?.ToList(), lowerCaseKeepWords);
        }

        /// <summary> Initializes a new instance of KeywordMarkerTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="keywords"> A list of words to mark as keywords. </param>
        /// <param name="ignoreCase"> A value indicating whether to ignore case. If true, all words are converted to lower case first. Default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.KeywordMarkerTokenFilter"/> instance for mocking. </returns>
        public static KeywordMarkerTokenFilter KeywordMarkerTokenFilter(string name = null, IEnumerable<string> keywords = null, bool? ignoreCase = null)
        {
            keywords ??= new List<string>();

            return new KeywordMarkerTokenFilter("#Microsoft.Azure.Search.KeywordMarkerTokenFilter", name, keywords?.ToList(), ignoreCase);
        }

        /// <summary> Initializes a new instance of LengthTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minLength"> The minimum length in characters. Default is 0. Maximum is 300. Must be less than the value of max. </param>
        /// <param name="maxLength"> The maximum length in characters. Default and maximum is 300. </param>
        /// <returns> A new <see cref="Indexes.Models.LengthTokenFilter"/> instance for mocking. </returns>
        public static LengthTokenFilter LengthTokenFilter(string name = null, int? minLength = null, int? maxLength = null)
        {
            return new LengthTokenFilter("#Microsoft.Azure.Search.LengthTokenFilter", name, minLength, maxLength);
        }

        /// <summary> Initializes a new instance of LimitTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenCount"> The maximum number of tokens to produce. Default is 1. </param>
        /// <param name="consumeAllTokens"> A value indicating whether all tokens from the input must be consumed even if maxTokenCount is reached. Default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.LimitTokenFilter"/> instance for mocking. </returns>
        public static LimitTokenFilter LimitTokenFilter(string name = null, int? maxTokenCount = null, bool? consumeAllTokens = null)
        {
            return new LimitTokenFilter("#Microsoft.Azure.Search.LimitTokenFilter", name, maxTokenCount, consumeAllTokens);
        }

        /// <summary> Initializes a new instance of NGramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. </param>
        /// <returns> A new <see cref="Indexes.Models.NGramTokenFilter"/> instance for mocking. </returns>
        public static NGramTokenFilter NGramTokenFilter(string name = null, int? minGram = null, int? maxGram = null)
        {
            return new NGramTokenFilter("#Microsoft.Azure.Search.NGramTokenFilter", name, minGram, maxGram);
        }

        /// <summary> Initializes a new instance of NGramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. Maximum is 300. </param>
        /// <returns> A new <see cref="Indexes.Models.NGramTokenFilter"/> instance for mocking. </returns>
        public static NGramTokenFilter NGramTokenFilter(string name = null, int? minGram = null, int? maxGram = null)
        {
            return new NGramTokenFilter("#Microsoft.Azure.Search.NGramTokenFilterV2", name, minGram, maxGram);
        }

        /// <summary> Initializes a new instance of PatternCaptureTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="patterns"> A list of patterns to match against each token. </param>
        /// <param name="preserveOriginal"> A value indicating whether to return the original token even if one of the patterns matches. Default is true. </param>
        /// <returns> A new <see cref="Indexes.Models.PatternCaptureTokenFilter"/> instance for mocking. </returns>
        public static PatternCaptureTokenFilter PatternCaptureTokenFilter(string name = null, IEnumerable<string> patterns = null, bool? preserveOriginal = null)
        {
            patterns ??= new List<string>();

            return new PatternCaptureTokenFilter("#Microsoft.Azure.Search.PatternCaptureTokenFilter", name, patterns?.ToList(), preserveOriginal);
        }

        /// <summary> Initializes a new instance of PatternReplaceTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="pattern"> A regular expression pattern. </param>
        /// <param name="replacement"> The replacement text. </param>
        /// <returns> A new <see cref="Indexes.Models.PatternReplaceTokenFilter"/> instance for mocking. </returns>
        public static PatternReplaceTokenFilter PatternReplaceTokenFilter(string name = null, string pattern = null, string replacement = null)
        {
            return new PatternReplaceTokenFilter("#Microsoft.Azure.Search.PatternReplaceTokenFilter", name, pattern, replacement);
        }

        /// <summary> Initializes a new instance of PhoneticTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="encoder"> The phonetic encoder to use. Default is &quot;metaphone&quot;. </param>
        /// <param name="replaceOriginalTokens"> A value indicating whether encoded tokens should replace original tokens. If false, encoded tokens are added as synonyms. Default is true. </param>
        /// <returns> A new <see cref="Indexes.Models.PhoneticTokenFilter"/> instance for mocking. </returns>
        public static PhoneticTokenFilter PhoneticTokenFilter(string name = null, PhoneticEncoder? encoder = null, bool? replaceOriginalTokens = null)
        {
            return new PhoneticTokenFilter("#Microsoft.Azure.Search.PhoneticTokenFilter", name, encoder, replaceOriginalTokens);
        }

        /// <summary> Initializes a new instance of ShingleTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxShingleSize"> The maximum shingle size. Default and minimum value is 2. </param>
        /// <param name="minShingleSize"> The minimum shingle size. Default and minimum value is 2. Must be less than the value of maxShingleSize. </param>
        /// <param name="outputUnigrams"> A value indicating whether the output stream will contain the input tokens (unigrams) as well as shingles. Default is true. </param>
        /// <param name="outputUnigramsIfNoShingles"> A value indicating whether to output unigrams for those times when no shingles are available. This property takes precedence when outputUnigrams is set to false. Default is false. </param>
        /// <param name="tokenSeparator"> The string to use when joining adjacent tokens to form a shingle. Default is a single space (&quot; &quot;). </param>
        /// <param name="filterToken"> The string to insert for each position at which there is no token. Default is an underscore (&quot;_&quot;). </param>
        /// <returns> A new <see cref="Indexes.Models.ShingleTokenFilter"/> instance for mocking. </returns>
        public static ShingleTokenFilter ShingleTokenFilter(string name = null, int? maxShingleSize = null, int? minShingleSize = null, bool? outputUnigrams = null, bool? outputUnigramsIfNoShingles = null, string tokenSeparator = null, string filterToken = null)
        {
            return new ShingleTokenFilter("#Microsoft.Azure.Search.ShingleTokenFilter", name, maxShingleSize, minShingleSize, outputUnigrams, outputUnigramsIfNoShingles, tokenSeparator, filterToken);
        }

        /// <summary> Initializes a new instance of SnowballTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="language"> The language to use. </param>
        /// <returns> A new <see cref="Indexes.Models.SnowballTokenFilter"/> instance for mocking. </returns>
        public static SnowballTokenFilter SnowballTokenFilter(string name = null, SnowballTokenFilterLanguage language = default)
        {
            return new SnowballTokenFilter("#Microsoft.Azure.Search.SnowballTokenFilter", name, language);
        }

        /// <summary> Initializes a new instance of StemmerTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="language"> The language to use. </param>
        /// <returns> A new <see cref="Indexes.Models.StemmerTokenFilter"/> instance for mocking. </returns>
        public static StemmerTokenFilter StemmerTokenFilter(string name = null, StemmerTokenFilterLanguage language = default)
        {
            return new StemmerTokenFilter("#Microsoft.Azure.Search.StemmerTokenFilter", name, language);
        }

        /// <summary> Initializes a new instance of StemmerOverrideTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="rules"> A list of stemming rules in the following format: &quot;word =&gt; stem&quot;, for example: &quot;ran =&gt; run&quot;. </param>
        /// <returns> A new <see cref="Indexes.Models.StemmerOverrideTokenFilter"/> instance for mocking. </returns>
        public static StemmerOverrideTokenFilter StemmerOverrideTokenFilter(string name = null, IEnumerable<string> rules = null)
        {
            rules ??= new List<string>();

            return new StemmerOverrideTokenFilter("#Microsoft.Azure.Search.StemmerOverrideTokenFilter", name, rules?.ToList());
        }

        /// <summary> Initializes a new instance of StopwordsTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="stopwords"> The list of stopwords. This property and the stopwords list property cannot both be set. </param>
        /// <param name="stopwordsList"> A predefined list of stopwords to use. This property and the stopwords property cannot both be set. Default is English. </param>
        /// <param name="ignoreCase"> A value indicating whether to ignore case. If true, all words are converted to lower case first. Default is false. </param>
        /// <param name="removeTrailingStopWords"> A value indicating whether to ignore the last search term if it&apos;s a stop word. Default is true. </param>
        /// <returns> A new <see cref="Indexes.Models.StopwordsTokenFilter"/> instance for mocking. </returns>
        public static StopwordsTokenFilter StopwordsTokenFilter(string name = null, IEnumerable<string> stopwords = null, StopwordsList? stopwordsList = null, bool? ignoreCase = null, bool? removeTrailingStopWords = null)
        {
            stopwords ??= new List<string>();

            return new StopwordsTokenFilter("#Microsoft.Azure.Search.StopwordsTokenFilter", name, stopwords?.ToList(), stopwordsList, ignoreCase, removeTrailingStopWords);
        }

        /// <summary> Initializes a new instance of SynonymTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="synonyms"> A list of synonyms in following one of two formats: 1. incredible, unbelievable, fabulous =&gt; amazing - all terms on the left side of =&gt; symbol will be replaced with all terms on its right side; 2. incredible, unbelievable, fabulous, amazing - comma separated list of equivalent words. Set the expand option to change how this list is interpreted. </param>
        /// <param name="ignoreCase"> A value indicating whether to case-fold input for matching. Default is false. </param>
        /// <param name="expand"> A value indicating whether all words in the list of synonyms (if =&gt; notation is not used) will map to one another. If true, all words in the list of synonyms (if =&gt; notation is not used) will map to one another. The following list: incredible, unbelievable, fabulous, amazing is equivalent to: incredible, unbelievable, fabulous, amazing =&gt; incredible, unbelievable, fabulous, amazing. If false, the following list: incredible, unbelievable, fabulous, amazing will be equivalent to: incredible, unbelievable, fabulous, amazing =&gt; incredible. Default is true. </param>
        /// <returns> A new <see cref="Indexes.Models.SynonymTokenFilter"/> instance for mocking. </returns>
        public static SynonymTokenFilter SynonymTokenFilter(string name = null, IEnumerable<string> synonyms = null, bool? ignoreCase = null, bool? expand = null)
        {
            synonyms ??= new List<string>();

            return new SynonymTokenFilter("#Microsoft.Azure.Search.SynonymTokenFilter", name, synonyms?.ToList(), ignoreCase, expand);
        }

        /// <summary> Initializes a new instance of TruncateTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="length"> The length at which terms will be truncated. Default and maximum is 300. </param>
        /// <returns> A new <see cref="Indexes.Models.TruncateTokenFilter"/> instance for mocking. </returns>
        public static TruncateTokenFilter TruncateTokenFilter(string name = null, int? length = null)
        {
            return new TruncateTokenFilter("#Microsoft.Azure.Search.TruncateTokenFilter", name, length);
        }

        /// <summary> Initializes a new instance of UniqueTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="onlyOnSamePosition"> A value indicating whether to remove duplicates only at the same position. Default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.UniqueTokenFilter"/> instance for mocking. </returns>
        public static UniqueTokenFilter UniqueTokenFilter(string name = null, bool? onlyOnSamePosition = null)
        {
            return new UniqueTokenFilter("#Microsoft.Azure.Search.UniqueTokenFilter", name, onlyOnSamePosition);
        }

        /// <summary> Initializes a new instance of WordDelimiterTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="generateWordParts"> A value indicating whether to generate part words. If set, causes parts of words to be generated; for example &quot;AzureSearch&quot; becomes &quot;Azure&quot; &quot;Search&quot;. Default is true. </param>
        /// <param name="generateNumberParts"> A value indicating whether to generate number subwords. Default is true. </param>
        /// <param name="catenateWords"> A value indicating whether maximum runs of word parts will be catenated. For example, if this is set to true, &quot;Azure-Search&quot; becomes &quot;AzureSearch&quot;. Default is false. </param>
        /// <param name="catenateNumbers"> A value indicating whether maximum runs of number parts will be catenated. For example, if this is set to true, &quot;1-2&quot; becomes &quot;12&quot;. Default is false. </param>
        /// <param name="catenateAll"> A value indicating whether all subword parts will be catenated. For example, if this is set to true, &quot;Azure-Search-1&quot; becomes &quot;AzureSearch1&quot;. Default is false. </param>
        /// <param name="splitOnCaseChange"> A value indicating whether to split words on caseChange. For example, if this is set to true, &quot;AzureSearch&quot; becomes &quot;Azure&quot; &quot;Search&quot;. Default is true. </param>
        /// <param name="preserveOriginal"> A value indicating whether original words will be preserved and added to the subword list. Default is false. </param>
        /// <param name="splitOnNumerics"> A value indicating whether to split on numbers. For example, if this is set to true, &quot;Azure1Search&quot; becomes &quot;Azure&quot; &quot;1&quot; &quot;Search&quot;. Default is true. </param>
        /// <param name="stemEnglishPossessive"> A value indicating whether to remove trailing &quot;&apos;s&quot; for each subword. Default is true. </param>
        /// <param name="protectedWords"> A list of tokens to protect from being delimited. </param>
        /// <returns> A new <see cref="Indexes.Models.WordDelimiterTokenFilter"/> instance for mocking. </returns>
        public static WordDelimiterTokenFilter WordDelimiterTokenFilter(string name = null, bool? generateWordParts = null, bool? generateNumberParts = null, bool? catenateWords = null, bool? catenateNumbers = null, bool? catenateAll = null, bool? splitOnCaseChange = null, bool? preserveOriginal = null, bool? splitOnNumerics = null, bool? stemEnglishPossessive = null, IEnumerable<string> protectedWords = null)
        {
            protectedWords ??= new List<string>();

            return new WordDelimiterTokenFilter("#Microsoft.Azure.Search.WordDelimiterTokenFilter", name, generateWordParts, generateNumberParts, catenateWords, catenateNumbers, catenateAll, splitOnCaseChange, preserveOriginal, splitOnNumerics, stemEnglishPossessive, protectedWords?.ToList());
        }

        /// <summary> Initializes a new instance of MappingCharFilter. </summary>
        /// <param name="name"> The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="mappings"> A list of mappings of the following format: &quot;a=&gt;b&quot; (all occurrences of the character &quot;a&quot; will be replaced with character &quot;b&quot;). </param>
        /// <returns> A new <see cref="Indexes.Models.MappingCharFilter"/> instance for mocking. </returns>
        public static MappingCharFilter MappingCharFilter(string name = null, IEnumerable<string> mappings = null)
        {
            mappings ??= new List<string>();

            return new MappingCharFilter("#Microsoft.Azure.Search.MappingCharFilter", name, mappings?.ToList());
        }

        /// <summary> Initializes a new instance of PatternReplaceCharFilter. </summary>
        /// <param name="name"> The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="pattern"> A regular expression pattern. </param>
        /// <param name="replacement"> The replacement text. </param>
        /// <returns> A new <see cref="Indexes.Models.PatternReplaceCharFilter"/> instance for mocking. </returns>
        public static PatternReplaceCharFilter PatternReplaceCharFilter(string name = null, string pattern = null, string replacement = null)
        {
            return new PatternReplaceCharFilter("#Microsoft.Azure.Search.PatternReplaceCharFilter", name, pattern, replacement);
        }

        /// <summary> Initializes a new instance of ClassicSimilarity. </summary>
        /// <returns> A new <see cref="Indexes.Models.ClassicSimilarity"/> instance for mocking. </returns>
        public static ClassicSimilarity ClassicSimilarity()
        {
            return new ClassicSimilarity("#Microsoft.Azure.Search.ClassicSimilarity");
        }

        /// <summary> Initializes a new instance of BM25Similarity. </summary>
        /// <param name="k1"> This property controls the scaling function between the term frequency of each matching terms and the final relevance score of a document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the score does not scale with an increase in term frequency. </param>
        /// <param name="b"> This property controls how the length of a document affects the relevance score. By default, a value of 0.75 is used. A value of 0.0 means no length normalization is applied, while a value of 1.0 means the score is fully normalized by the length of the document. </param>
        /// <returns> A new <see cref="Indexes.Models.BM25Similarity"/> instance for mocking. </returns>
        public static BM25Similarity BM25Similarity(double? k1 = null, double? b = null)
        {
            return new BM25Similarity("#Microsoft.Azure.Search.BM25Similarity", k1, b);
        }

        /// <summary> Initializes a new instance of SearchIndexerDataNoneIdentity. </summary>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexerDataNoneIdentity"/> instance for mocking. </returns>
        public static SearchIndexerDataNoneIdentity SearchIndexerDataNoneIdentity()
        {
            return new SearchIndexerDataNoneIdentity("#Microsoft.Azure.Search.DataNoneIdentity");
        }

        /// <summary> Initializes a new instance of SearchIndexerDataUserAssignedIdentity. </summary>
        /// <param name="userAssignedIdentity"> The fully qualified Azure resource Id of a user assigned managed identity typically in the form &quot;/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId&quot; that should have been assigned to the search service. </param>
        /// <returns> A new <see cref="Indexes.Models.SearchIndexerDataUserAssignedIdentity"/> instance for mocking. </returns>
        public static SearchIndexerDataUserAssignedIdentity SearchIndexerDataUserAssignedIdentity(string userAssignedIdentity = null)
        {
            return new SearchIndexerDataUserAssignedIdentity("#Microsoft.Azure.Search.DataUserAssignedIdentity", userAssignedIdentity);
        }

        /// <summary> Initializes a new instance of HighWaterMarkChangeDetectionPolicy. </summary>
        /// <param name="highWaterMarkColumnName"> The name of the high water mark column. </param>
        /// <returns> A new <see cref="Indexes.Models.HighWaterMarkChangeDetectionPolicy"/> instance for mocking. </returns>
        public static HighWaterMarkChangeDetectionPolicy HighWaterMarkChangeDetectionPolicy(string highWaterMarkColumnName = null)
        {
            return new HighWaterMarkChangeDetectionPolicy("#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy", highWaterMarkColumnName);
        }

        /// <summary> Initializes a new instance of SqlIntegratedChangeTrackingPolicy. </summary>
        /// <returns> A new <see cref="Indexes.Models.SqlIntegratedChangeTrackingPolicy"/> instance for mocking. </returns>
        public static SqlIntegratedChangeTrackingPolicy SqlIntegratedChangeTrackingPolicy()
        {
            return new SqlIntegratedChangeTrackingPolicy("#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy");
        }

        /// <summary> Initializes a new instance of SoftDeleteColumnDeletionDetectionPolicy. </summary>
        /// <param name="softDeleteColumnName"> The name of the column to use for soft-deletion detection. </param>
        /// <param name="softDeleteMarkerValue"> The marker value that identifies an item as deleted. </param>
        /// <returns> A new <see cref="Indexes.Models.SoftDeleteColumnDeletionDetectionPolicy"/> instance for mocking. </returns>
        public static SoftDeleteColumnDeletionDetectionPolicy SoftDeleteColumnDeletionDetectionPolicy(string softDeleteColumnName = null, string softDeleteMarkerValue = null)
        {
            return new SoftDeleteColumnDeletionDetectionPolicy("#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy", softDeleteColumnName, softDeleteMarkerValue);
        }

        /// <summary> Initializes a new instance of DistanceScoringFunction. </summary>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <param name="parameters"> Parameter values for the distance scoring function. </param>
        /// <returns> A new <see cref="Indexes.Models.DistanceScoringFunction"/> instance for mocking. </returns>
        public static DistanceScoringFunction DistanceScoringFunction(string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null, DistanceScoringParameters parameters = null)
        {
            return new DistanceScoringFunction("distance", fieldName, boost, interpolation, parameters);
        }

        /// <summary> Initializes a new instance of FreshnessScoringFunction. </summary>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <param name="parameters"> Parameter values for the freshness scoring function. </param>
        /// <returns> A new <see cref="Indexes.Models.FreshnessScoringFunction"/> instance for mocking. </returns>
        public static FreshnessScoringFunction FreshnessScoringFunction(string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null, FreshnessScoringParameters parameters = null)
        {
            return new FreshnessScoringFunction("freshness", fieldName, boost, interpolation, parameters);
        }

        /// <summary> Initializes a new instance of MagnitudeScoringFunction. </summary>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <param name="parameters"> Parameter values for the magnitude scoring function. </param>
        /// <returns> A new <see cref="Indexes.Models.MagnitudeScoringFunction"/> instance for mocking. </returns>
        public static MagnitudeScoringFunction MagnitudeScoringFunction(string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null, MagnitudeScoringParameters parameters = null)
        {
            return new MagnitudeScoringFunction("magnitude", fieldName, boost, interpolation, parameters);
        }

        /// <summary> Initializes a new instance of MagnitudeScoringParameters. </summary>
        /// <param name="boostingRangeStart"> The field value at which boosting starts. </param>
        /// <param name="boostingRangeEnd"> The field value at which boosting ends. </param>
        /// <param name="shouldBoostBeyondRangeByConstant"> A value indicating whether to apply a constant boost for field values beyond the range end value; default is false. </param>
        /// <returns> A new <see cref="Indexes.Models.MagnitudeScoringParameters"/> instance for mocking. </returns>
        public static MagnitudeScoringParameters MagnitudeScoringParameters(double boostingRangeStart = default, double boostingRangeEnd = default, bool? shouldBoostBeyondRangeByConstant = null)
        {
            return new MagnitudeScoringParameters(boostingRangeStart, boostingRangeEnd, shouldBoostBeyondRangeByConstant);
        }

        /// <summary> Initializes a new instance of TagScoringFunction. </summary>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <param name="parameters"> Parameter values for the tag scoring function. </param>
        /// <returns> A new <see cref="Indexes.Models.TagScoringFunction"/> instance for mocking. </returns>
        public static TagScoringFunction TagScoringFunction(string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null, TagScoringParameters parameters = null)
        {
            return new TagScoringFunction("tag", fieldName, boost, interpolation, parameters);
        }

        /// <summary> Initializes a new instance of DefaultCognitiveServicesAccount. </summary>
        /// <param name="description"> Description of the cognitive service resource attached to a skillset. </param>
        /// <returns> A new <see cref="Indexes.Models.DefaultCognitiveServicesAccount"/> instance for mocking. </returns>
        public static DefaultCognitiveServicesAccount DefaultCognitiveServicesAccount(string description = null)
        {
            return new DefaultCognitiveServicesAccount("#Microsoft.Azure.Search.DefaultCognitiveServices", description);
        }

        /// <summary> Initializes a new instance of CognitiveServicesAccountKey. </summary>
        /// <param name="description"> Description of the cognitive service resource attached to a skillset. </param>
        /// <param name="key"> The key used to provision the cognitive service resource attached to a skillset. </param>
        /// <returns> A new <see cref="Indexes.Models.CognitiveServicesAccountKey"/> instance for mocking. </returns>
        public static CognitiveServicesAccountKey CognitiveServicesAccountKey(string description = null, string key = null)
        {
            return new CognitiveServicesAccountKey("#Microsoft.Azure.Search.CognitiveServicesByKey", description, key);
        }

        /// <summary> Initializes a new instance of CustomEntity. </summary>
        /// <param name="name"> The top-level entity descriptor. Matches in the skill output will be grouped by this name, and it should represent the &quot;normalized&quot; form of the text being found. </param>
        /// <param name="description"> This field can be used as a passthrough for custom metadata about the matched text(s). The value of this field will appear with every match of its entity in the skill output. </param>
        /// <param name="type"> This field can be used as a passthrough for custom metadata about the matched text(s). The value of this field will appear with every match of its entity in the skill output. </param>
        /// <param name="subtype"> This field can be used as a passthrough for custom metadata about the matched text(s). The value of this field will appear with every match of its entity in the skill output. </param>
        /// <param name="id"> This field can be used as a passthrough for custom metadata about the matched text(s). The value of this field will appear with every match of its entity in the skill output. </param>
        /// <param name="caseSensitive"> Defaults to false. Boolean value denoting whether comparisons with the entity name should be sensitive to character casing. Sample case insensitive matches of &quot;Microsoft&quot; could be: microsoft, microSoft, MICROSOFT. </param>
        /// <param name="accentSensitive"> Defaults to false. Boolean value denoting whether comparisons with the entity name should be sensitive to accent. </param>
        /// <param name="fuzzyEditDistance"> Defaults to 0. Maximum value of 5. Denotes the acceptable number of divergent characters that would still constitute a match with the entity name. The smallest possible fuzziness for any given match is returned. For instance, if the edit distance is set to 3, &quot;Windows10&quot; would still match &quot;Windows&quot;, &quot;Windows10&quot; and &quot;Windows 7&quot;. When case sensitivity is set to false, case differences do NOT count towards fuzziness tolerance, but otherwise do. </param>
        /// <param name="defaultCaseSensitive"> Changes the default case sensitivity value for this entity. It be used to change the default value of all aliases caseSensitive values. </param>
        /// <param name="defaultAccentSensitive"> Changes the default accent sensitivity value for this entity. It be used to change the default value of all aliases accentSensitive values. </param>
        /// <param name="defaultFuzzyEditDistance"> Changes the default fuzzy edit distance value for this entity. It can be used to change the default value of all aliases fuzzyEditDistance values. </param>
        /// <param name="aliases"> An array of complex objects that can be used to specify alternative spellings or synonyms to the root entity name. </param>
        /// <returns> A new <see cref="Indexes.Models.CustomEntity"/> instance for mocking. </returns>
        public static CustomEntity CustomEntity(string name = null, string description = null, string type = null, string subtype = null, string id = null, bool? caseSensitive = null, bool? accentSensitive = null, int? fuzzyEditDistance = null, bool? defaultCaseSensitive = null, bool? defaultAccentSensitive = null, int? defaultFuzzyEditDistance = null, IEnumerable<CustomEntityAlias> aliases = null)
        {
            aliases ??= new List<CustomEntityAlias>();

            return new CustomEntity(name, description, type, subtype, id, caseSensitive, accentSensitive, fuzzyEditDistance, defaultCaseSensitive, defaultAccentSensitive, defaultFuzzyEditDistance, aliases?.ToList());
        }

        /// <summary> Initializes a new instance of CustomEntityAlias. </summary>
        /// <param name="text"> The text of the alias. </param>
        /// <param name="caseSensitive"> Determine if the alias is case sensitive. </param>
        /// <param name="accentSensitive"> Determine if the alias is accent sensitive. </param>
        /// <param name="fuzzyEditDistance"> Determine the fuzzy edit distance of the alias. </param>
        /// <returns> A new <see cref="Indexes.Models.CustomEntityAlias"/> instance for mocking. </returns>
        public static CustomEntityAlias CustomEntityAlias(string text = null, bool? caseSensitive = null, bool? accentSensitive = null, int? fuzzyEditDistance = null)
        {
            return new CustomEntityAlias(text, caseSensitive, accentSensitive, fuzzyEditDistance);
        }

        /// <summary> Initializes a new instance of ConditionalSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <returns> A new <see cref="Indexes.Models.ConditionalSkill"/> instance for mocking. </returns>
        public static ConditionalSkill ConditionalSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new ConditionalSkill("#Microsoft.Skills.Util.ConditionalSkill", name, description, context, inputs?.ToList(), outputs?.ToList());
        }

        /// <summary> Initializes a new instance of KeyPhraseExtractionSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="maxKeyPhraseCount"> A number indicating how many key phrases to return. If absent, all identified key phrases will be returned. </param>
        /// <param name="modelVersion"> The version of the model to use when calling the Text Analytics service. It will default to the latest available when not specified. We recommend you do not specify this value unless absolutely necessary. </param>
        /// <returns> A new <see cref="Indexes.Models.KeyPhraseExtractionSkill"/> instance for mocking. </returns>
        public static KeyPhraseExtractionSkill KeyPhraseExtractionSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, KeyPhraseExtractionSkillLanguage? defaultLanguageCode = null, int? maxKeyPhraseCount = null, string modelVersion = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new KeyPhraseExtractionSkill("#Microsoft.Skills.Text.KeyPhraseExtractionSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, maxKeyPhraseCount, modelVersion);
        }

        /// <summary> Initializes a new instance of OcrSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="shouldDetectOrientation"> A value indicating to turn orientation detection on or not. Default is false. </param>
        /// <param name="lineEnding"> Defines the sequence of characters to use between the lines of text recognized by the OCR skill. The default value is &quot;space&quot;. </param>
        /// <returns> A new <see cref="Indexes.Models.OcrSkill"/> instance for mocking. </returns>
        public static OcrSkill OcrSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, OcrSkillLanguage? defaultLanguageCode = null, bool? shouldDetectOrientation = null, LineEnding? lineEnding = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new OcrSkill("#Microsoft.Skills.Vision.OcrSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, shouldDetectOrientation, lineEnding);
        }

        /// <summary> Initializes a new instance of ImageAnalysisSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="visualFeatures"> A list of visual features. </param>
        /// <param name="details"> A string indicating which domain-specific details to return. </param>
        /// <returns> A new <see cref="Indexes.Models.ImageAnalysisSkill"/> instance for mocking. </returns>
        public static ImageAnalysisSkill ImageAnalysisSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, ImageAnalysisSkillLanguage? defaultLanguageCode = null, IEnumerable<VisualFeature> visualFeatures = null, IEnumerable<ImageDetail> details = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            visualFeatures ??= new List<VisualFeature>();
            details ??= new List<ImageDetail>();

            return new ImageAnalysisSkill("#Microsoft.Skills.Vision.ImageAnalysisSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, visualFeatures?.ToList(), details?.ToList());
        }

        /// <summary> Initializes a new instance of LanguageDetectionSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultCountryHint"> A country code to use as a hint to the language detection model if it cannot disambiguate the language. </param>
        /// <param name="modelVersion"> The version of the model to use when calling the Text Analytics service. It will default to the latest available when not specified. We recommend you do not specify this value unless absolutely necessary. </param>
        /// <returns> A new <see cref="Indexes.Models.LanguageDetectionSkill"/> instance for mocking. </returns>
        public static LanguageDetectionSkill LanguageDetectionSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, string defaultCountryHint = null, string modelVersion = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new LanguageDetectionSkill("#Microsoft.Skills.Text.LanguageDetectionSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultCountryHint, modelVersion);
        }

        /// <summary> Initializes a new instance of ShaperSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <returns> A new <see cref="Indexes.Models.ShaperSkill"/> instance for mocking. </returns>
        public static ShaperSkill ShaperSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new ShaperSkill("#Microsoft.Skills.Util.ShaperSkill", name, description, context, inputs?.ToList(), outputs?.ToList());
        }

        /// <summary> Initializes a new instance of MergeSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="insertPreTag"> The tag indicates the start of the merged text. By default, the tag is an empty space. </param>
        /// <param name="insertPostTag"> The tag indicates the end of the merged text. By default, the tag is an empty space. </param>
        /// <returns> A new <see cref="Indexes.Models.MergeSkill"/> instance for mocking. </returns>
        public static MergeSkill MergeSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, string insertPreTag = null, string insertPostTag = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new MergeSkill("#Microsoft.Skills.Text.MergeSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), insertPreTag, insertPostTag);
        }

        /// <summary> Initializes a new instance of EntityRecognitionSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="categories"> A list of entity categories that should be extracted. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="includeTypelessEntities"> Determines whether or not to include entities which are well known but don&apos;t conform to a pre-defined type. If this configuration is not set (default), set to null or set to false, entities which don&apos;t conform to one of the pre-defined types will not be surfaced. </param>
        /// <param name="minimumPrecision"> A value between 0 and 1 that be used to only include entities whose confidence score is greater than the value specified. If not set (default), or if explicitly set to null, all entities will be included. </param>
        /// <returns> A new <see cref="Indexes.Models.EntityRecognitionSkill"/> instance for mocking. </returns>
        public static EntityRecognitionSkill EntityRecognitionSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, IEnumerable<EntityCategory> categories = null, EntityRecognitionSkillLanguage? defaultLanguageCode = null, bool? includeTypelessEntities = null, double? minimumPrecision = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            categories ??= new List<EntityCategory>();

            return new EntityRecognitionSkill("#Microsoft.Skills.Text.EntityRecognitionSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), categories?.ToList(), defaultLanguageCode, includeTypelessEntities, minimumPrecision);
        }

        /// <summary> Initializes a new instance of SentimentSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <returns> A new <see cref="Indexes.Models.SentimentSkill"/> instance for mocking. </returns>
        public static SentimentSkill SentimentSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, SentimentSkillLanguage? defaultLanguageCode = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new SentimentSkill("#Microsoft.Skills.Text.SentimentSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode);
        }

        /// <summary> Initializes a new instance of EntityLinkingSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="minimumPrecision"> A value between 0 and 1 that be used to only include entities whose confidence score is greater than the value specified. If not set (default), or if explicitly set to null, all entities will be included. </param>
        /// <param name="modelVersion"> The version of the model to use when calling the Text Analytics service. It will default to the latest available when not specified. We recommend you do not specify this value unless absolutely necessary. </param>
        /// <returns> A new <see cref="Indexes.Models.EntityLinkingSkill"/> instance for mocking. </returns>
        public static EntityLinkingSkill EntityLinkingSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, string defaultLanguageCode = null, double? minimumPrecision = null, string modelVersion = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new EntityLinkingSkill("#Microsoft.Skills.Text.V3.EntityLinkingSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, minimumPrecision, modelVersion);
        }

        /// <summary> Initializes a new instance of PiiDetectionSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="minimumPrecision"> A value between 0 and 1 that be used to only include entities whose confidence score is greater than the value specified. If not set (default), or if explicitly set to null, all entities will be included. </param>
        /// <param name="maskingMode"> A parameter that provides various ways to mask the personal information detected in the input text. Default is &apos;none&apos;. </param>
        /// <param name="maskingCharacter"> The character used to mask the text if the maskingMode parameter is set to replace. Default is &apos;*&apos;. </param>
        /// <param name="modelVersion"> The version of the model to use when calling the Text Analytics service. It will default to the latest available when not specified. We recommend you do not specify this value unless absolutely necessary. </param>
        /// <param name="piiCategories"> A list of PII entity categories that should be extracted and masked. </param>
        /// <param name="domain"> If specified, will set the PII domain to include only a subset of the entity categories. Possible values include: &apos;phi&apos;, &apos;none&apos;. Default is &apos;none&apos;. </param>
        /// <returns> A new <see cref="Indexes.Models.PiiDetectionSkill"/> instance for mocking. </returns>
        public static PiiDetectionSkill PiiDetectionSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, string defaultLanguageCode = null, double? minimumPrecision = null, PiiDetectionSkillMaskingMode? maskingMode = null, string maskingCharacter = null, string modelVersion = null, IEnumerable<string> piiCategories = null, string domain = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            piiCategories ??= new List<string>();

            return new PiiDetectionSkill("#Microsoft.Skills.Text.PIIDetectionSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, minimumPrecision, maskingMode, maskingCharacter, modelVersion, piiCategories?.ToList(), domain);
        }

        /// <summary> Initializes a new instance of SplitSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="textSplitMode"> A value indicating which split mode to perform. </param>
        /// <param name="maximumPageLength"> The desired maximum page length. Default is 10000. </param>
        /// <returns> A new <see cref="Indexes.Models.SplitSkill"/> instance for mocking. </returns>
        public static SplitSkill SplitSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, SplitSkillLanguage? defaultLanguageCode = null, TextSplitMode? textSplitMode = null, int? maximumPageLength = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new SplitSkill("#Microsoft.Skills.Text.SplitSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, textSplitMode, maximumPageLength);
        }

        /// <summary> Initializes a new instance of CustomEntityLookupSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="entitiesDefinitionUri"> Path to a JSON or CSV file containing all the target text to match against. This entity definition is read at the beginning of an indexer run. Any updates to this file during an indexer run will not take effect until subsequent runs. This config must be accessible over HTTPS. </param>
        /// <param name="inlineEntitiesDefinition"> The inline CustomEntity definition. </param>
        /// <param name="globalDefaultCaseSensitive"> A global flag for CaseSensitive. If CaseSensitive is not set in CustomEntity, this value will be the default value. </param>
        /// <param name="globalDefaultAccentSensitive"> A global flag for AccentSensitive. If AccentSensitive is not set in CustomEntity, this value will be the default value. </param>
        /// <param name="globalDefaultFuzzyEditDistance"> A global flag for FuzzyEditDistance. If FuzzyEditDistance is not set in CustomEntity, this value will be the default value. </param>
        /// <returns> A new <see cref="Indexes.Models.CustomEntityLookupSkill"/> instance for mocking. </returns>
        public static CustomEntityLookupSkill CustomEntityLookupSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, CustomEntityLookupSkillLanguage? defaultLanguageCode = null, Uri entitiesDefinitionUri = null, IEnumerable<CustomEntity> inlineEntitiesDefinition = null, bool? globalDefaultCaseSensitive = null, bool? globalDefaultAccentSensitive = null, int? globalDefaultFuzzyEditDistance = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            inlineEntitiesDefinition ??= new List<CustomEntity>();

            return new CustomEntityLookupSkill("#Microsoft.Skills.Text.CustomEntityLookupSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, entitiesDefinitionUri, inlineEntitiesDefinition?.ToList(), globalDefaultCaseSensitive, globalDefaultAccentSensitive, globalDefaultFuzzyEditDistance);
        }

        /// <summary> Initializes a new instance of TextTranslationSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultToLanguageCode"> The language code to translate documents into for documents that don&apos;t specify the to language explicitly. </param>
        /// <param name="defaultFromLanguageCode"> The language code to translate documents from for documents that don&apos;t specify the from language explicitly. </param>
        /// <param name="suggestedFrom"> The language code to translate documents from when neither the fromLanguageCode input nor the defaultFromLanguageCode parameter are provided, and the automatic language detection is unsuccessful. Default is en. </param>
        /// <returns> A new <see cref="Indexes.Models.TextTranslationSkill"/> instance for mocking. </returns>
        public static TextTranslationSkill TextTranslationSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, TextTranslationSkillLanguage defaultToLanguageCode = default, TextTranslationSkillLanguage? defaultFromLanguageCode = null, TextTranslationSkillLanguage? suggestedFrom = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new TextTranslationSkill("#Microsoft.Skills.Text.TranslationSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultToLanguageCode, defaultFromLanguageCode, suggestedFrom);
        }

        /// <summary> Initializes a new instance of DocumentExtractionSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="parsingMode"> The parsingMode for the skill. Will be set to &apos;default&apos; if not defined. </param>
        /// <param name="dataToExtract"> The type of data to be extracted for the skill. Will be set to &apos;contentAndMetadata&apos; if not defined. </param>
        /// <param name="configuration"> A dictionary of configurations for the skill. </param>
        /// <returns> A new <see cref="Indexes.Models.DocumentExtractionSkill"/> instance for mocking. </returns>
        public static DocumentExtractionSkill DocumentExtractionSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, BlobIndexerParsingMode? parsingMode = null, BlobIndexerDataToExtract? dataToExtract = null, IDictionary<string, object> configuration = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            configuration ??= new Dictionary<string, object>();

            return new DocumentExtractionSkill("#Microsoft.Skills.Util.DocumentExtractionSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), parsingMode, dataToExtract, configuration);
        }

        /// <summary> Initializes a new instance of WebApiSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="uri"> The url for the Web API. </param>
        /// <param name="httpHeaders"> The headers required to make the http request. </param>
        /// <param name="httpMethod"> The method for the http request. </param>
        /// <param name="timeout"> The desired timeout for the request. Default is 30 seconds. </param>
        /// <param name="batchSize"> The desired batch size which indicates number of documents. </param>
        /// <param name="degreeOfParallelism"> If set, the number of parallel calls that can be made to the Web API. </param>
        /// <returns> A new <see cref="Indexes.Models.WebApiSkill"/> instance for mocking. </returns>
        public static WebApiSkill WebApiSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, string uri = null, IDictionary<string, string> httpHeaders = null, string httpMethod = null, TimeSpan? timeout = null, int? batchSize = null, int? degreeOfParallelism = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            httpHeaders ??= new Dictionary<string, string>();

            return new WebApiSkill("#Microsoft.Skills.Custom.WebApiSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), uri, httpHeaders, httpMethod, timeout, batchSize, degreeOfParallelism);
        }

        /// <summary> Initializes a new instance of AzureMachineLearningSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="scoringUri"> (Required for no authentication or key authentication) The scoring URI of the AML service to which the JSON payload will be sent. Only the https URI scheme is allowed. </param>
        /// <param name="authenticationKey"> (Required for key authentication) The key for the AML service. </param>
        /// <param name="rawResourceId"> (Required for token authentication). The Azure Resource Manager resource ID of the AML service. It should be in the format subscriptions/{guid}/resourceGroups/{resource-group-name}/Microsoft.MachineLearningServices/workspaces/{workspace-name}/services/{service_name}. </param>
        /// <param name="timeout"> (Optional) When specified, indicates the timeout for the http client making the API call. </param>
        /// <param name="rawLocation"> (Optional for token authentication). The region the AML service is deployed in. </param>
        /// <param name="degreeOfParallelism"> (Optional) When specified, indicates the number of calls the indexer will make in parallel to the endpoint you have provided. You can decrease this value if your endpoint is failing under too high of a request load, or raise it if your endpoint is able to accept more requests and you would like an increase in the performance of the indexer. If not set, a default value of 5 is used. The degreeOfParallelism can be set to a maximum of 10 and a minimum of 1. </param>
        /// <returns> A new <see cref="Indexes.Models.AzureMachineLearningSkill"/> instance for mocking. </returns>
        public static AzureMachineLearningSkill AzureMachineLearningSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, Uri scoringUri = null, string authenticationKey = null, string rawResourceId = null, TimeSpan? timeout = null, string rawLocation = null, int? degreeOfParallelism = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new AzureMachineLearningSkill("#Microsoft.Skills.Custom.AmlSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), scoringUri, authenticationKey, rawResourceId, timeout, rawLocation, degreeOfParallelism);
        }
    }
}
