// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Collections.Generic;
using Azure;
using Azure.Core;

namespace Azure.Search.Documents
{
    /// <summary></summary>
    public partial class SearchClient
    {
        private static ResponseClassifier _pipelineMessageClassifier200;
        private static ResponseClassifier _pipelineMessageClassifier200206;
        private static ResponseClassifier _pipelineMessageClassifier200207;

        private static ResponseClassifier PipelineMessageClassifier200 => _pipelineMessageClassifier200 = new StatusCodeClassifier(stackalloc ushort[] { 200 });

        private static ResponseClassifier PipelineMessageClassifier200206 => _pipelineMessageClassifier200206 = new StatusCodeClassifier(stackalloc ushort[] { 200, 206 });

        private static ResponseClassifier PipelineMessageClassifier200207 => _pipelineMessageClassifier200207 = new StatusCodeClassifier(stackalloc ushort[] { 200, 207 });

        internal HttpMessage CreateGetDocumentCountRequest(RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs/$count", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            return message;
        }

        internal HttpMessage CreateSearchGetRequest(string querySourceAuthorization, bool? enableElevatedRead, string searchText, bool? includeTotalResultCount, IEnumerable<string> facets, string filter, IEnumerable<string> highlightFields, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> orderBy, string queryType, IEnumerable<string> scoringParameters, string scoringProfile, IEnumerable<string> searchFields, string searchMode, string scoringStatistics, string sessionId, IEnumerable<string> @select, int? skip, int? top, string semanticConfiguration, string semanticErrorHandling, int? semanticMaxWaitInMilliseconds, string answers, string captions, string semanticQuery, string queryRewrites, string debug, string queryLanguage, string speller, IEnumerable<string> semanticFields, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (searchText != null)
            {
                uri.AppendQuery("search", searchText, true);
            }
            if (includeTotalResultCount != null)
            {
                uri.AppendQuery("$count", TypeFormatters.ConvertToString(includeTotalResultCount), true);
            }
            if (facets != null && !(facets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in facets)
                {
                    uri.AppendQuery("facet", @param, true);
                }
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (highlightFields != null && !(highlightFields is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("highlight", highlightFields, ",", escape: true);
            }
            if (highlightPostTag != null)
            {
                uri.AppendQuery("highlightPostTag", highlightPostTag, true);
            }
            if (highlightPreTag != null)
            {
                uri.AppendQuery("highlightPreTag", highlightPreTag, true);
            }
            if (minimumCoverage != null)
            {
                uri.AppendQuery("minimumCoverage", TypeFormatters.ConvertToString(minimumCoverage), true);
            }
            if (orderBy != null && !(orderBy is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                uri.AppendQueryDelimited("$orderby", orderBy, ",", escape: true);
            }
            if (queryType != null)
            {
                uri.AppendQuery("queryType", queryType, true);
            }
            if (scoringParameters != null && !(scoringParameters is ChangeTrackingList<string> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                foreach (var @param in scoringParameters)
                {
                    uri.AppendQuery("scoringParameter", @param, true);
                }
            }
            if (scoringProfile != null)
            {
                uri.AppendQuery("scoringProfile", scoringProfile, true);
            }
            if (searchFields != null && !(searchFields is ChangeTrackingList<string> changeTrackingList3 && changeTrackingList3.IsUndefined))
            {
                uri.AppendQueryDelimited("searchFields", searchFields, ",", escape: true);
            }
            if (searchMode != null)
            {
                uri.AppendQuery("searchMode", searchMode, true);
            }
            if (scoringStatistics != null)
            {
                uri.AppendQuery("scoringStatistics", scoringStatistics, true);
            }
            if (sessionId != null)
            {
                uri.AppendQuery("sessionId", sessionId, true);
            }
            if (@select != null && !(@select is ChangeTrackingList<string> changeTrackingList4 && changeTrackingList4.IsUndefined))
            {
                uri.AppendQueryDelimited("$select", @select, ",", escape: true);
            }
            if (skip != null)
            {
                uri.AppendQuery("$skip", TypeFormatters.ConvertToString(skip), true);
            }
            if (top != null)
            {
                uri.AppendQuery("$top", TypeFormatters.ConvertToString(top), true);
            }
            if (semanticConfiguration != null)
            {
                uri.AppendQuery("semanticConfiguration", semanticConfiguration, true);
            }
            if (semanticErrorHandling != null)
            {
                uri.AppendQuery("semanticErrorHandling", semanticErrorHandling, true);
            }
            if (semanticMaxWaitInMilliseconds != null)
            {
                uri.AppendQuery("semanticMaxWaitInMilliseconds", TypeFormatters.ConvertToString(semanticMaxWaitInMilliseconds), true);
            }
            if (answers != null)
            {
                uri.AppendQuery("answers", answers, true);
            }
            if (captions != null)
            {
                uri.AppendQuery("captions", captions, true);
            }
            if (semanticQuery != null)
            {
                uri.AppendQuery("semanticQuery", semanticQuery, true);
            }
            if (queryRewrites != null)
            {
                uri.AppendQuery("queryRewrites", queryRewrites, true);
            }
            if (debug != null)
            {
                uri.AppendQuery("debug", debug, true);
            }
            if (queryLanguage != null)
            {
                uri.AppendQuery("queryLanguage", queryLanguage, true);
            }
            if (speller != null)
            {
                uri.AppendQuery("speller", speller, true);
            }
            if (semanticFields != null && !(semanticFields is ChangeTrackingList<string> changeTrackingList5 && changeTrackingList5.IsUndefined))
            {
                uri.AppendQueryDelimited("semanticFields", semanticFields, ",", escape: true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200206);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            if (querySourceAuthorization != null)
            {
                request.Headers.SetValue("x-ms-query-source-authorization", querySourceAuthorization);
            }
            if (enableElevatedRead != null)
            {
                request.Headers.SetValue("x-ms-enable-elevated-read", TypeFormatters.ConvertToString(enableElevatedRead));
            }
            return message;
        }

        internal HttpMessage CreateSearchPostRequest(RequestContent content, string querySourceAuthorization, bool? enableElevatedRead, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs/search.post.search", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200206);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            if (querySourceAuthorization != null)
            {
                request.Headers.SetValue("x-ms-query-source-authorization", querySourceAuthorization);
            }
            if (enableElevatedRead != null)
            {
                request.Headers.SetValue("x-ms-enable-elevated-read", TypeFormatters.ConvertToString(enableElevatedRead));
            }
            request.Headers.SetValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDocumentRequest(string key, string querySourceAuthorization, bool? enableElevatedRead, IEnumerable<string> selectedFields, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs('", false);
            uri.AppendPath(key, true);
            uri.AppendPath("')", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (selectedFields != null && !(selectedFields is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("$select", selectedFields, ",", escape: true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            if (querySourceAuthorization != null)
            {
                request.Headers.SetValue("x-ms-query-source-authorization", querySourceAuthorization);
            }
            if (enableElevatedRead != null)
            {
                request.Headers.SetValue("x-ms-enable-elevated-read", TypeFormatters.ConvertToString(enableElevatedRead));
            }
            return message;
        }

        internal HttpMessage CreateSuggestGetRequest(string searchText, string suggesterName, string filter, bool? useFuzzyMatching, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> orderBy, IEnumerable<string> searchFields, IEnumerable<string> @select, int? top, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs/search.suggest", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            uri.AppendQuery("search", searchText, true);
            uri.AppendQuery("suggesterName", suggesterName, true);
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (useFuzzyMatching != null)
            {
                uri.AppendQuery("fuzzy", TypeFormatters.ConvertToString(useFuzzyMatching), true);
            }
            if (highlightPostTag != null)
            {
                uri.AppendQuery("highlightPostTag", highlightPostTag, true);
            }
            if (highlightPreTag != null)
            {
                uri.AppendQuery("highlightPreTag", highlightPreTag, true);
            }
            if (minimumCoverage != null)
            {
                uri.AppendQuery("minimumCoverage", TypeFormatters.ConvertToString(minimumCoverage), true);
            }
            if (orderBy != null && !(orderBy is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("$orderby", orderBy, ",", escape: true);
            }
            if (searchFields != null && !(searchFields is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("searchFields", searchFields, ",", escape: true);
            }
            if (@select != null && !(@select is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                uri.AppendQueryDelimited("$select", @select, ",", escape: true);
            }
            if (top != null)
            {
                uri.AppendQuery("$top", TypeFormatters.ConvertToString(top), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            return message;
        }

        internal HttpMessage CreateSuggestPostRequest(RequestContent content, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs/search.post.suggest", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            request.Headers.SetValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateIndexRequest(RequestContent content, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs/search.index", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200207);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            request.Headers.SetValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAutocompleteGetRequest(string searchText, string suggesterName, string autocompleteMode, string filter, bool? useFuzzyMatching, string highlightPostTag, string highlightPreTag, double? minimumCoverage, IEnumerable<string> searchFields, int? top, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs/search.autocomplete", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            uri.AppendQuery("search", searchText, true);
            uri.AppendQuery("suggesterName", suggesterName, true);
            if (autocompleteMode != null)
            {
                uri.AppendQuery("autocompleteMode", autocompleteMode, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (useFuzzyMatching != null)
            {
                uri.AppendQuery("fuzzy", TypeFormatters.ConvertToString(useFuzzyMatching), true);
            }
            if (highlightPostTag != null)
            {
                uri.AppendQuery("highlightPostTag", highlightPostTag, true);
            }
            if (highlightPreTag != null)
            {
                uri.AppendQuery("highlightPreTag", highlightPreTag, true);
            }
            if (minimumCoverage != null)
            {
                uri.AppendQuery("minimumCoverage", TypeFormatters.ConvertToString(minimumCoverage), true);
            }
            if (searchFields != null && !(searchFields is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("searchFields", searchFields, ",", escape: true);
            }
            if (top != null)
            {
                uri.AppendQuery("$top", TypeFormatters.ConvertToString(top), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            return message;
        }

        internal HttpMessage CreateAutocompletePostRequest(RequestContent content, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/indexes('", false);
            uri.AppendPath(_indexName, true);
            uri.AppendPath("')/docs/search.post.autocomplete", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Accept", "application/json;odata.metadata=none");
            request.Headers.SetValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }
    }
}
