// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// This file was automatically generated.  Do not edit.

#pragma warning disable IDE0016 // Null check can be simplified
#pragma warning disable IDE0017 // Variable declaration can be inlined
#pragma warning disable IDE0018 // Object initialization can be simplified
#pragma warning disable SA1402  // File may only contain a single type

#region Service
namespace Azure.Storage.Blobs
{
    /// <summary>
    /// Azure Blob Storage
    /// </summary>
    internal static partial class BlobRestClient
    {
        #region Service operations
        /// <summary>
        /// Service operations for Azure Blob Storage
        /// </summary>
        public static partial class Service
        {
            #region Service.SetPropertiesAsync
            /// <summary>
            /// Sets properties for a storage account's Blob service endpoint, including properties for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blobServiceProperties">The StorageService properties.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response> SetPropertiesAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.BlobServiceProperties blobServiceProperties,
                string version,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "ServiceClient.SetProperties",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetPropertiesAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        blobServiceProperties,
                        version,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetPropertiesAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Service.SetPropertiesAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blobServiceProperties">The StorageService properties.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Service.SetPropertiesAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetPropertiesAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.BlobServiceProperties blobServiceProperties,
                string version,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (blobServiceProperties == null)
                {
                    throw new System.ArgumentNullException(nameof(blobServiceProperties));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "service", escapeValue: false);
                _request.Uri.AppendQuery("comp", "properties", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                // Create the body
                System.Xml.Linq.XElement _body = Azure.Storage.Blobs.Models.BlobServiceProperties.ToXml(blobServiceProperties, "StorageServiceProperties", "");
                string _text = _body.ToString(System.Xml.Linq.SaveOptions.DisableFormatting);
                _request.Headers.SetValue("Content-Type", "application/xml");
                _request.Headers.SetValue("Content-Length", _text.Length.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Content = Azure.Core.RequestContent.Create(System.Text.Encoding.UTF8.GetBytes(_text));

                return _message;
            }

            /// <summary>
            /// Create the Service.SetPropertiesAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Service.SetPropertiesAsync Azure.Response.</returns>
            internal static Azure.Response SetPropertiesAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        return response;
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Service.SetPropertiesAsync

            #region Service.GetPropertiesAsync
            /// <summary>
            /// gets the properties of a storage account's Blob service, including properties for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Storage Service Properties.</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobServiceProperties>> GetPropertiesAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "ServiceClient.GetProperties",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetPropertiesAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetPropertiesAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Service.GetPropertiesAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Service.GetPropertiesAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetPropertiesAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "service", escapeValue: false);
                _request.Uri.AppendQuery("comp", "properties", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Service.GetPropertiesAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Service.GetPropertiesAsync Azure.Response{Azure.Storage.Blobs.Models.BlobServiceProperties}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobServiceProperties> GetPropertiesAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.BlobServiceProperties _value = Azure.Storage.Blobs.Models.BlobServiceProperties.FromXml(_xml.Root);

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobServiceProperties>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Service.GetPropertiesAsync

            #region Service.GetStatisticsAsync
            /// <summary>
            /// Retrieves statistics related to replication for the Blob service. It is only available on the secondary location endpoint when read-access geo-redundant replication is enabled for the storage account.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Statistics for the storage service.</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobServiceStatistics>> GetStatisticsAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "ServiceClient.GetStatistics",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetStatisticsAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetStatisticsAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Service.GetStatisticsAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Service.GetStatisticsAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetStatisticsAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "service", escapeValue: false);
                _request.Uri.AppendQuery("comp", "stats", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Service.GetStatisticsAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Service.GetStatisticsAsync Azure.Response{Azure.Storage.Blobs.Models.BlobServiceStatistics}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobServiceStatistics> GetStatisticsAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.BlobServiceStatistics _value = Azure.Storage.Blobs.Models.BlobServiceStatistics.FromXml(_xml.Root);

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobServiceStatistics>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Service.GetStatisticsAsync

            #region Service.ListBlobContainersSegmentAsync
            /// <summary>
            /// The List Containers Segment operation returns a list of the containers under the specified account
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="prefix">Filters the results to return only containers whose name begins with the specified prefix.</param>
            /// <param name="marker">A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.</param>
            /// <param name="maxresults">Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.</param>
            /// <param name="include">Include this parameter to specify that the container's metadata be returned as part of the response body.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>An enumeration of containers</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContainersSegment>> ListBlobContainersSegmentAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string prefix = default,
                string marker = default,
                int? maxresults = default,
                System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.ListContainersIncludeType> include = default,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "ServiceClient.ListBlobContainersSegment",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ListBlobContainersSegmentAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        prefix,
                        marker,
                        maxresults,
                        include,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ListBlobContainersSegmentAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Service.ListBlobContainersSegmentAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="prefix">Filters the results to return only containers whose name begins with the specified prefix.</param>
            /// <param name="marker">A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.</param>
            /// <param name="maxresults">Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.</param>
            /// <param name="include">Include this parameter to specify that the container's metadata be returned as part of the response body.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Service.ListBlobContainersSegmentAsync Message.</returns>
            internal static Azure.Core.HttpMessage ListBlobContainersSegmentAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string prefix = default,
                string marker = default,
                int? maxresults = default,
                System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.ListContainersIncludeType> include = default,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "list", escapeValue: false);
                if (prefix != null) { _request.Uri.AppendQuery("prefix", prefix); }
                if (marker != null) { _request.Uri.AppendQuery("marker", marker); }
                if (maxresults != null) { _request.Uri.AppendQuery("maxresults", maxresults.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (include != null) { _request.Uri.AppendQuery("include", string.Join(",", System.Linq.Enumerable.Select(include, item => Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(item)))); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Service.ListBlobContainersSegmentAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Service.ListBlobContainersSegmentAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContainersSegment}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContainersSegment> ListBlobContainersSegmentAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.BlobContainersSegment _value = Azure.Storage.Blobs.Models.BlobContainersSegment.FromXml(_xml.Root);

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobContainersSegment>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Service.ListBlobContainersSegmentAsync

            #region Service.GetUserDelegationKeyAsync
            /// <summary>
            /// Retrieves a user delegation key for the Blob service. This is only a valid operation when using bearer token authentication.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="keyInfo">Key information</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>A user delegation key</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.UserDelegationKey>> GetUserDelegationKeyAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.KeyInfo keyInfo,
                string version,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "ServiceClient.GetUserDelegationKey",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetUserDelegationKeyAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        keyInfo,
                        version,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetUserDelegationKeyAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Service.GetUserDelegationKeyAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="keyInfo">Key information</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Service.GetUserDelegationKeyAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetUserDelegationKeyAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.KeyInfo keyInfo,
                string version,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (keyInfo == null)
                {
                    throw new System.ArgumentNullException(nameof(keyInfo));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Post;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "service", escapeValue: false);
                _request.Uri.AppendQuery("comp", "userdelegationkey", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                // Create the body
                System.Xml.Linq.XElement _body = Azure.Storage.Blobs.Models.KeyInfo.ToXml(keyInfo, "KeyInfo", "");
                string _text = _body.ToString(System.Xml.Linq.SaveOptions.DisableFormatting);
                _request.Headers.SetValue("Content-Type", "application/xml");
                _request.Headers.SetValue("Content-Length", _text.Length.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Content = Azure.Core.RequestContent.Create(System.Text.Encoding.UTF8.GetBytes(_text));

                return _message;
            }

            /// <summary>
            /// Create the Service.GetUserDelegationKeyAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Service.GetUserDelegationKeyAsync Azure.Response{Azure.Storage.Blobs.Models.UserDelegationKey}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.UserDelegationKey> GetUserDelegationKeyAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.UserDelegationKey _value = Azure.Storage.Blobs.Models.UserDelegationKey.FromXml(_xml.Root);

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Service.GetUserDelegationKeyAsync

            #region Service.GetAccountInfoAsync
            /// <summary>
            /// Returns the sku name and account kind
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.AccountInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.AccountInfo>> GetAccountInfoAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                bool async = true,
                string operationName = "ServiceClient.GetAccountInfo",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetAccountInfoAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetAccountInfoAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Service.GetAccountInfoAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <returns>The Service.GetAccountInfoAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetAccountInfoAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "account", escapeValue: false);
                _request.Uri.AppendQuery("comp", "properties", escapeValue: false);

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);

                return _message;
            }

            /// <summary>
            /// Create the Service.GetAccountInfoAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Service.GetAccountInfoAsync Azure.Response{Azure.Storage.Blobs.Models.AccountInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.AccountInfo> GetAccountInfoAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.AccountInfo _value = new Azure.Storage.Blobs.Models.AccountInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-sku-name", out _header))
                        {
                            _value.SkuName = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseSkuName(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-account-kind", out _header))
                        {
                            _value.AccountKind = (Azure.Storage.Blobs.Models.AccountKind)System.Enum.Parse(typeof(Azure.Storage.Blobs.Models.AccountKind), _header, false);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.AccountInfo>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Service.GetAccountInfoAsync

            #region Service.SubmitBatchAsync
            /// <summary>
            /// The Batch operation allows multiple API calls to be embedded into a single HTTP request.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="body">Initial data</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="multipartContentType">Required. The value of this header must be multipart/mixed with a batch boundary. Example header value: multipart/mixed; boundary=batch_{GUID}</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobBatchResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobBatchResult>> SubmitBatchAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.IO.Stream body,
                long contentLength,
                string multipartContentType,
                string version,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "ServiceClient.SubmitBatch",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SubmitBatchAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        body,
                        contentLength,
                        multipartContentType,
                        version,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SubmitBatchAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Service.SubmitBatchAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="body">Initial data</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="multipartContentType">Required. The value of this header must be multipart/mixed with a batch boundary. Example header value: multipart/mixed; boundary=batch_{GUID}</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Service.SubmitBatchAsync Message.</returns>
            internal static Azure.Core.HttpMessage SubmitBatchAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.IO.Stream body,
                long contentLength,
                string multipartContentType,
                string version,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (body == null)
                {
                    throw new System.ArgumentNullException(nameof(body));
                }
                if (multipartContentType == null)
                {
                    throw new System.ArgumentNullException(nameof(multipartContentType));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Post;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "batch", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("Content-Type", multipartContentType);
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                // Create the body
                _request.Content = Azure.Core.RequestContent.Create(body);

                return _message;
            }

            /// <summary>
            /// Create the Service.SubmitBatchAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Service.SubmitBatchAsync Azure.Response{Azure.Storage.Blobs.Models.BlobBatchResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobBatchResult> SubmitBatchAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobBatchResult _value = new Azure.Storage.Blobs.Models.BlobBatchResult();
                        _value.Content = response.ContentStream; // You should manually wrap with RetriableStream!

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Content-Type", out _header))
                        {
                            _value.ContentType = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Service.SubmitBatchAsync

            #region Service.FilterBlobsAsync
            /// <summary>
            /// The Filter Blobs operation enables callers to list blobs across all containers whose tags match a given search expression.  Filter blobs searches across all containers within a storage account but can be scoped within the expression to a single container.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="where">Filters the results to return only to return only blobs whose tags match the specified expression.</param>
            /// <param name="marker">A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.</param>
            /// <param name="maxresults">Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The result of a Filter Blobs API call</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.FilterBlobSegment>> FilterBlobsAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                string where = default,
                string marker = default,
                int? maxresults = default,
                bool async = true,
                string operationName = "ServiceClient.FilterBlobs",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = FilterBlobsAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        requestId,
                        where,
                        marker,
                        maxresults))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return FilterBlobsAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Service.FilterBlobsAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="where">Filters the results to return only to return only blobs whose tags match the specified expression.</param>
            /// <param name="marker">A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.</param>
            /// <param name="maxresults">Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.</param>
            /// <returns>The Service.FilterBlobsAsync Message.</returns>
            internal static Azure.Core.HttpMessage FilterBlobsAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                string where = default,
                string marker = default,
                int? maxresults = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "blobs", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (where != null) { _request.Uri.AppendQuery("where", where); }
                if (marker != null) { _request.Uri.AppendQuery("marker", marker); }
                if (maxresults != null) { _request.Uri.AppendQuery("maxresults", maxresults.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Service.FilterBlobsAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Service.FilterBlobsAsync Azure.Response{Azure.Storage.Blobs.Models.FilterBlobSegment}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.FilterBlobSegment> FilterBlobsAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.FilterBlobSegment _value = Azure.Storage.Blobs.Models.FilterBlobSegment.FromXml(_xml.Root);

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.FilterBlobSegment>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Service.FilterBlobsAsync
        }
        #endregion Service operations

        #region Container operations
        /// <summary>
        /// Container operations for Azure Blob Storage
        /// </summary>
        public static partial class Container
        {
            #region Container.CreateAsync
            /// <summary>
            /// creates a new container under the specified account. If the container with the same name already exists, the operation fails
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="access">Specifies whether data in the container may be accessed publicly and the level of access</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="defaultEncryptionScope">Optional.  Version 2019-07-07 and later.  Specifies the default encryption scope to set on the container and use for all future writes.</param>
            /// <param name="preventEncryptionScopeOverride">Optional.  Version 2019-07-07 and newer.  If true, prevents any request from specifying a different encryption scope than the scope set on the container.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContainerInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContainerInfo>> CreateAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.PublicAccessType access,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string requestId = default,
                string defaultEncryptionScope = default,
                bool? preventEncryptionScopeOverride = default,
                bool async = true,
                string operationName = "ContainerClient.Create",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = CreateAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        access,
                        version,
                        timeout,
                        metadata,
                        requestId,
                        defaultEncryptionScope,
                        preventEncryptionScopeOverride))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return CreateAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.CreateAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="access">Specifies whether data in the container may be accessed publicly and the level of access</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="defaultEncryptionScope">Optional.  Version 2019-07-07 and later.  Specifies the default encryption scope to set on the container and use for all future writes.</param>
            /// <param name="preventEncryptionScopeOverride">Optional.  Version 2019-07-07 and newer.  If true, prevents any request from specifying a different encryption scope than the scope set on the container.</param>
            /// <returns>The Container.CreateAsync Message.</returns>
            internal static Azure.Core.HttpMessage CreateAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.PublicAccessType access,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string requestId = default,
                string defaultEncryptionScope = default,
                bool? preventEncryptionScopeOverride = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                if (access != Azure.Storage.Blobs.Models.PublicAccessType.None) { _request.Headers.SetValue("x-ms-blob-public-access", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(access)); }
                _request.Headers.SetValue("x-ms-version", version);
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (defaultEncryptionScope != null) { _request.Headers.SetValue("x-ms-default-encryption-scope", defaultEncryptionScope); }
                if (preventEncryptionScopeOverride != null) {
                #pragma warning disable CA1308 // Normalize strings to uppercase
                _request.Headers.SetValue("x-ms-deny-encryption-scope-override", preventEncryptionScopeOverride.Value.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant());
                #pragma warning restore CA1308 // Normalize strings to uppercase
                }

                return _message;
            }

            /// <summary>
            /// Create the Container.CreateAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.CreateAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContainerInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContainerInfo> CreateAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobContainerInfo _value = new Azure.Storage.Blobs.Models.BlobContainerInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.CreateAsync

            #region Container.GetPropertiesAsync
            /// <summary>
            /// returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.FlattenedContainerItem}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.FlattenedContainerItem>> GetPropertiesAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.GetProperties",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetPropertiesAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        leaseId,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetPropertiesAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.GetPropertiesAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.GetPropertiesAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetPropertiesAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.GetPropertiesAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.GetPropertiesAsync Azure.Response{Azure.Storage.Blobs.Models.FlattenedContainerItem}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.FlattenedContainerItem> GetPropertiesAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.FlattenedContainerItem _value = new Azure.Storage.Blobs.Models.FlattenedContainerItem();

                        // Get response headers
                        string _header;
                        _value.Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-meta-", System.StringComparison.InvariantCulture))
                            {
                                _value.Metadata[_headerPair.Name.Substring(10)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-duration", out _header))
                        {
                            _value.LeaseDuration = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseDurationType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-state", out _header))
                        {
                            _value.LeaseState = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseState(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-status", out _header))
                        {
                            _value.LeaseStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseStatus(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-public-access", out _header))
                        {
                            _value.BlobPublicAccess = Azure.Storage.Blobs.BlobRestClient.Serialization.ParsePublicAccessType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-has-immutability-policy", out _header))
                        {
                            _value.HasImmutabilityPolicy = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-has-legal-hold", out _header))
                        {
                            _value.HasLegalHold = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-default-encryption-scope", out _header))
                        {
                            _value.DefaultEncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-deny-encryption-scope-override", out _header))
                        {
                            _value.DenyEncryptionScopeOverride = bool.Parse(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.FlattenedContainerItem>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.GetPropertiesAsync

            #region Container.DeleteAsync
            /// <summary>
            /// operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response> DeleteAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.Delete",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = DeleteAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return DeleteAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.DeleteAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.DeleteAsync Message.</returns>
            internal static Azure.Core.HttpMessage DeleteAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Delete;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.DeleteAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.DeleteAsync Azure.Response.</returns>
            internal static Azure.Response DeleteAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        return response;
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.DeleteAsync

            #region Container.SetMetadataAsync
            /// <summary>
            /// operation sets one or more user-defined name-value pairs for the specified container.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContainerInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContainerInfo>> SetMetadataAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                System.DateTimeOffset? ifModifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.SetMetadata",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetMetadataAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        leaseId,
                        metadata,
                        ifModifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetMetadataAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.SetMetadataAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.SetMetadataAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetMetadataAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                System.DateTimeOffset? ifModifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                _request.Uri.AppendQuery("comp", "metadata", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.SetMetadataAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.SetMetadataAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContainerInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContainerInfo> SetMetadataAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobContainerInfo _value = new Azure.Storage.Blobs.Models.BlobContainerInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.SetMetadataAsync

            #region Container.GetAccessPolicyAsync
            /// <summary>
            /// gets the permissions for the specified container. The permissions indicate whether container data may be accessed publicly.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContainerAccessPolicy}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>> GetAccessPolicyAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.GetAccessPolicy",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetAccessPolicyAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        leaseId,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetAccessPolicyAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.GetAccessPolicyAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.GetAccessPolicyAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetAccessPolicyAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                _request.Uri.AppendQuery("comp", "acl", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.GetAccessPolicyAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.GetAccessPolicyAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContainerAccessPolicy}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContainerAccessPolicy> GetAccessPolicyAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.BlobContainerAccessPolicy _value = new Azure.Storage.Blobs.Models.BlobContainerAccessPolicy();
                        _value.SignedIdentifiers =
                            System.Linq.Enumerable.ToList(
                                System.Linq.Enumerable.Select(
                                    _xml.Element(System.Xml.Linq.XName.Get("SignedIdentifiers", "")).Elements(System.Xml.Linq.XName.Get("SignedIdentifier", "")),
                                    Azure.Storage.Blobs.Models.BlobSignedIdentifier.FromXml));

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-blob-public-access", out _header))
                        {
                            _value.BlobPublicAccess = Azure.Storage.Blobs.BlobRestClient.Serialization.ParsePublicAccessType(_header);
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobContainerAccessPolicy>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.GetAccessPolicyAsync

            #region Container.SetAccessPolicyAsync
            /// <summary>
            /// sets the permissions for the specified container. The permissions indicate whether blobs in a container may be accessed publicly.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="access">Specifies whether data in the container may be accessed publicly and the level of access</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="permissions">the acls for the container</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContainerInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContainerInfo>> SetAccessPolicyAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.PublicAccessType access,
                string version,
                System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobSignedIdentifier> permissions = default,
                int? timeout = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.SetAccessPolicy",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetAccessPolicyAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        access,
                        version,
                        permissions,
                        timeout,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetAccessPolicyAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.SetAccessPolicyAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="access">Specifies whether data in the container may be accessed publicly and the level of access</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="permissions">the acls for the container</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.SetAccessPolicyAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetAccessPolicyAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.PublicAccessType access,
                string version,
                System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobSignedIdentifier> permissions = default,
                int? timeout = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                _request.Uri.AppendQuery("comp", "acl", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                if (access != Azure.Storage.Blobs.Models.PublicAccessType.None) { _request.Headers.SetValue("x-ms-blob-public-access", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(access)); }
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                // Create the body
                System.Xml.Linq.XElement _body = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get("SignedIdentifiers", ""));
                if (permissions != null)
                {
                    foreach (Azure.Storage.Blobs.Models.BlobSignedIdentifier _child in permissions)
                    {
                        _body.Add(Azure.Storage.Blobs.Models.BlobSignedIdentifier.ToXml(_child));
                    }
                }
                string _text = _body.ToString(System.Xml.Linq.SaveOptions.DisableFormatting);
                _request.Headers.SetValue("Content-Type", "application/xml");
                _request.Headers.SetValue("Content-Length", _text.Length.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Content = Azure.Core.RequestContent.Create(System.Text.Encoding.UTF8.GetBytes(_text));

                return _message;
            }

            /// <summary>
            /// Create the Container.SetAccessPolicyAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.SetAccessPolicyAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContainerInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContainerInfo> SetAccessPolicyAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobContainerInfo _value = new Azure.Storage.Blobs.Models.BlobContainerInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.SetAccessPolicyAsync

            #region Container.RestoreAsync
            /// <summary>
            /// Restores a previously-deleted container.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="deletedContainerName">Optional.  Version 2019-12-12 and later.  Specifies the name of the deleted container to restore.</param>
            /// <param name="deletedContainerVersion">Optional.  Version 2019-12-12 and later.  Specifies the version of the deleted container to restore.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response> RestoreAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                string deletedContainerName = default,
                string deletedContainerVersion = default,
                bool async = true,
                string operationName = "ContainerClient.Restore",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = RestoreAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        requestId,
                        deletedContainerName,
                        deletedContainerVersion))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return RestoreAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.RestoreAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="deletedContainerName">Optional.  Version 2019-12-12 and later.  Specifies the name of the deleted container to restore.</param>
            /// <param name="deletedContainerVersion">Optional.  Version 2019-12-12 and later.  Specifies the version of the deleted container to restore.</param>
            /// <returns>The Container.RestoreAsync Message.</returns>
            internal static Azure.Core.HttpMessage RestoreAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                string deletedContainerName = default,
                string deletedContainerVersion = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                _request.Uri.AppendQuery("comp", "undelete", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (deletedContainerName != null) { _request.Headers.SetValue("x-ms-deleted-container-name", deletedContainerName); }
                if (deletedContainerVersion != null) { _request.Headers.SetValue("x-ms-deleted-container-version", deletedContainerVersion); }

                return _message;
            }

            /// <summary>
            /// Create the Container.RestoreAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.RestoreAsync Azure.Response.</returns>
            internal static Azure.Response RestoreAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        return response;
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.RestoreAsync

            #region Container.AcquireLeaseAsync
            /// <summary>
            /// [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="duration">Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change.</param>
            /// <param name="proposedLeaseId">Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobLease}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobLease>> AcquireLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                long? duration = default,
                string proposedLeaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.AcquireLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = AcquireLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        duration,
                        proposedLeaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return AcquireLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.AcquireLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="duration">Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change.</param>
            /// <param name="proposedLeaseId">Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.AcquireLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage AcquireLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                long? duration = default,
                string proposedLeaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "acquire");
                _request.Headers.SetValue("x-ms-version", version);
                if (duration != null) { _request.Headers.SetValue("x-ms-lease-duration", duration.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (proposedLeaseId != null) { _request.Headers.SetValue("x-ms-proposed-lease-id", proposedLeaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.AcquireLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.AcquireLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BlobLease}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobLease> AcquireLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobLease _value = new Azure.Storage.Blobs.Models.BlobLease();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-id", out _header))
                        {
                            _value.LeaseId = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.AcquireLeaseAsync

            #region Container.ReleaseLeaseAsync
            /// <summary>
            /// [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContainerInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContainerInfo>> ReleaseLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.ReleaseLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ReleaseLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        leaseId,
                        version,
                        timeout,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ReleaseLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.ReleaseLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.ReleaseLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage ReleaseLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (leaseId == null)
                {
                    throw new System.ArgumentNullException(nameof(leaseId));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "release");
                _request.Headers.SetValue("x-ms-lease-id", leaseId);
                _request.Headers.SetValue("x-ms-version", version);
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.ReleaseLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.ReleaseLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContainerInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContainerInfo> ReleaseLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobContainerInfo _value = new Azure.Storage.Blobs.Models.BlobContainerInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.ReleaseLeaseAsync

            #region Container.RenewLeaseAsync
            /// <summary>
            /// [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobLease}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobLease>> RenewLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.RenewLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = RenewLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        leaseId,
                        version,
                        timeout,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return RenewLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.RenewLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.RenewLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage RenewLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (leaseId == null)
                {
                    throw new System.ArgumentNullException(nameof(leaseId));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "renew");
                _request.Headers.SetValue("x-ms-lease-id", leaseId);
                _request.Headers.SetValue("x-ms-version", version);
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.RenewLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.RenewLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BlobLease}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobLease> RenewLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobLease _value = new Azure.Storage.Blobs.Models.BlobLease();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-id", out _header))
                        {
                            _value.LeaseId = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.RenewLeaseAsync

            #region Container.BreakLeaseAsync
            /// <summary>
            /// [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="breakPeriod">For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BrokenLease}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BrokenLease>> BreakLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                long? breakPeriod = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.BreakLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = BreakLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        breakPeriod,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return BreakLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.BreakLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="breakPeriod">For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.BreakLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage BreakLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                long? breakPeriod = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "break");
                _request.Headers.SetValue("x-ms-version", version);
                if (breakPeriod != null) { _request.Headers.SetValue("x-ms-lease-break-period", breakPeriod.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.BreakLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.BreakLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BrokenLease}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BrokenLease> BreakLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BrokenLease _value = new Azure.Storage.Blobs.Models.BrokenLease();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-time", out _header))
                        {
                            _value.LeaseTime = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.BreakLeaseAsync

            #region Container.ChangeLeaseAsync
            /// <summary>
            /// [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="proposedLeaseId">Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobLease}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobLease>> ChangeLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string proposedLeaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.ChangeLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ChangeLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        leaseId,
                        proposedLeaseId,
                        version,
                        timeout,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ChangeLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.ChangeLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="proposedLeaseId">Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.ChangeLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage ChangeLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string proposedLeaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (leaseId == null)
                {
                    throw new System.ArgumentNullException(nameof(leaseId));
                }
                if (proposedLeaseId == null)
                {
                    throw new System.ArgumentNullException(nameof(proposedLeaseId));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "change");
                _request.Headers.SetValue("x-ms-lease-id", leaseId);
                _request.Headers.SetValue("x-ms-proposed-lease-id", proposedLeaseId);
                _request.Headers.SetValue("x-ms-version", version);
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.ChangeLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.ChangeLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BlobLease}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobLease> ChangeLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobLease _value = new Azure.Storage.Blobs.Models.BlobLease();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-id", out _header))
                        {
                            _value.LeaseId = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.ChangeLeaseAsync

            #region Container.ListBlobsFlatSegmentAsync
            /// <summary>
            /// [Update] The List Blobs operation returns a list of the blobs under the specified container
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="prefix">Filters the results to return only containers whose name begins with the specified prefix.</param>
            /// <param name="marker">A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.</param>
            /// <param name="maxresults">Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.</param>
            /// <param name="include">Include this parameter to specify one or more datasets to include in the response.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>An enumeration of blobs</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobsFlatSegment>> ListBlobsFlatSegmentAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string prefix = default,
                string marker = default,
                int? maxresults = default,
                System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.ListBlobsIncludeItem> include = default,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.ListBlobsFlatSegment",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ListBlobsFlatSegmentAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        prefix,
                        marker,
                        maxresults,
                        include,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ListBlobsFlatSegmentAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.ListBlobsFlatSegmentAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="prefix">Filters the results to return only containers whose name begins with the specified prefix.</param>
            /// <param name="marker">A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.</param>
            /// <param name="maxresults">Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.</param>
            /// <param name="include">Include this parameter to specify one or more datasets to include in the response.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.ListBlobsFlatSegmentAsync Message.</returns>
            internal static Azure.Core.HttpMessage ListBlobsFlatSegmentAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string prefix = default,
                string marker = default,
                int? maxresults = default,
                System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.ListBlobsIncludeItem> include = default,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                _request.Uri.AppendQuery("comp", "list", escapeValue: false);
                if (prefix != null) { _request.Uri.AppendQuery("prefix", prefix); }
                if (marker != null) { _request.Uri.AppendQuery("marker", marker); }
                if (maxresults != null) { _request.Uri.AppendQuery("maxresults", maxresults.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (include != null) { _request.Uri.AppendQuery("include", string.Join(",", System.Linq.Enumerable.Select(include, item => Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(item)))); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.ListBlobsFlatSegmentAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.ListBlobsFlatSegmentAsync Azure.Response{Azure.Storage.Blobs.Models.BlobsFlatSegment}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobsFlatSegment> ListBlobsFlatSegmentAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.BlobsFlatSegment _value = Azure.Storage.Blobs.Models.BlobsFlatSegment.FromXml(_xml.Root);

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobsFlatSegment>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.ListBlobsFlatSegmentAsync

            #region Container.ListBlobsHierarchySegmentAsync
            /// <summary>
            /// [Update] The List Blobs operation returns a list of the blobs under the specified container
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="prefix">Filters the results to return only containers whose name begins with the specified prefix.</param>
            /// <param name="delimiter">When the request includes this parameter, the operation returns a BlobPrefix element in the response body that acts as a placeholder for all blobs whose names begin with the same substring up to the appearance of the delimiter character. The delimiter may be a single character or a string.</param>
            /// <param name="marker">A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.</param>
            /// <param name="maxresults">Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.</param>
            /// <param name="include">Include this parameter to specify one or more datasets to include in the response.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>An enumeration of blobs</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobsHierarchySegment>> ListBlobsHierarchySegmentAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string prefix = default,
                string delimiter = default,
                string marker = default,
                int? maxresults = default,
                System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.ListBlobsIncludeItem> include = default,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "ContainerClient.ListBlobsHierarchySegment",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ListBlobsHierarchySegmentAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        prefix,
                        delimiter,
                        marker,
                        maxresults,
                        include,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ListBlobsHierarchySegmentAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Container.ListBlobsHierarchySegmentAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="prefix">Filters the results to return only containers whose name begins with the specified prefix.</param>
            /// <param name="delimiter">When the request includes this parameter, the operation returns a BlobPrefix element in the response body that acts as a placeholder for all blobs whose names begin with the same substring up to the appearance of the delimiter character. The delimiter may be a single character or a string.</param>
            /// <param name="marker">A string value that identifies the portion of the list of containers to be returned with the next listing operation. The operation returns the NextMarker value within the response body if the listing operation did not return all containers remaining to be listed with the current page. The NextMarker value can be used as the value for the marker parameter in a subsequent call to request the next page of list items. The marker value is opaque to the client.</param>
            /// <param name="maxresults">Specifies the maximum number of containers to return. If the request does not specify maxresults, or specifies a value greater than 5000, the server will return up to 5000 items. Note that if the listing operation crosses a partition boundary, then the service will return a continuation token for retrieving the remainder of the results. For this reason, it is possible that the service will return fewer results than specified by maxresults, or than the default of 5000.</param>
            /// <param name="include">Include this parameter to specify one or more datasets to include in the response.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Container.ListBlobsHierarchySegmentAsync Message.</returns>
            internal static Azure.Core.HttpMessage ListBlobsHierarchySegmentAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string prefix = default,
                string delimiter = default,
                string marker = default,
                int? maxresults = default,
                System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.ListBlobsIncludeItem> include = default,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("restype", "container", escapeValue: false);
                _request.Uri.AppendQuery("comp", "list", escapeValue: false);
                if (prefix != null) { _request.Uri.AppendQuery("prefix", prefix); }
                if (delimiter != null) { _request.Uri.AppendQuery("delimiter", delimiter); }
                if (marker != null) { _request.Uri.AppendQuery("marker", marker); }
                if (maxresults != null) { _request.Uri.AppendQuery("maxresults", maxresults.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (include != null) { _request.Uri.AppendQuery("include", string.Join(",", System.Linq.Enumerable.Select(include, item => Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(item)))); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Container.ListBlobsHierarchySegmentAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Container.ListBlobsHierarchySegmentAsync Azure.Response{Azure.Storage.Blobs.Models.BlobsHierarchySegment}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobsHierarchySegment> ListBlobsHierarchySegmentAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.BlobsHierarchySegment _value = Azure.Storage.Blobs.Models.BlobsHierarchySegment.FromXml(_xml.Root);

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobsHierarchySegment>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Container.ListBlobsHierarchySegmentAsync
        }
        #endregion Container operations

        #region Blob operations
        /// <summary>
        /// Blob operations for Azure Blob Storage
        /// </summary>
        public static partial class Blob
        {
            #region Blob.DownloadAsync
            /// <summary>
            /// The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also call Download to read a snapshot.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="rangeGetContentHash">When set to true and specified together with the Range, the service returns the MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.</param>
            /// <param name="rangeGetContentCRC64">When set to true and specified together with the Range, the service returns the CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.FlattenedDownloadProperties}</returns>
            public static async System.Threading.Tasks.ValueTask<(Azure.Response<Azure.Storage.Blobs.Models.FlattenedDownloadProperties>, System.IO.Stream)> DownloadAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                string versionId = default,
                int? timeout = default,
                string range = default,
                string leaseId = default,
                bool? rangeGetContentHash = default,
                bool? rangeGetContentCRC64 = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.Download",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = DownloadAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        snapshot,
                        versionId,
                        timeout,
                        range,
                        leaseId,
                        rangeGetContentHash,
                        rangeGetContentCRC64,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        // Avoid buffering if stream is going to be returned to the caller
                        _message.BufferResponse = false;
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return (DownloadAsync_CreateResponse(clientDiagnostics, _response), _message.ExtractResponseContent());
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.DownloadAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="rangeGetContentHash">When set to true and specified together with the Range, the service returns the MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.</param>
            /// <param name="rangeGetContentCRC64">When set to true and specified together with the Range, the service returns the CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.DownloadAsync Message.</returns>
            internal static Azure.Core.HttpMessage DownloadAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                string versionId = default,
                int? timeout = default,
                string range = default,
                string leaseId = default,
                bool? rangeGetContentHash = default,
                bool? rangeGetContentCRC64 = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (versionId != null) { _request.Uri.AppendQuery("versionid", versionId); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (range != null) { _request.Headers.SetValue("x-ms-range", range); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (rangeGetContentHash != null) {
                #pragma warning disable CA1308 // Normalize strings to uppercase
                _request.Headers.SetValue("x-ms-range-get-content-md5", rangeGetContentHash.Value.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant());
                #pragma warning restore CA1308 // Normalize strings to uppercase
                }
                if (rangeGetContentCRC64 != null) {
                #pragma warning disable CA1308 // Normalize strings to uppercase
                _request.Headers.SetValue("x-ms-range-get-content-crc64", rangeGetContentCRC64.Value.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant());
                #pragma warning restore CA1308 // Normalize strings to uppercase
                }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.DownloadAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.DownloadAsync Azure.Response{Azure.Storage.Blobs.Models.FlattenedDownloadProperties}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.FlattenedDownloadProperties> DownloadAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.FlattenedDownloadProperties _value = new Azure.Storage.Blobs.Models.FlattenedDownloadProperties();
                        _value.Content = response.ContentStream; // You should manually wrap with RetriableStream!

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        _value.Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-meta-", System.StringComparison.InvariantCulture))
                            {
                                _value.Metadata[_headerPair.Name.Substring(10)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("x-ms-or-policy-id", out _header))
                        {
                            _value.ObjectReplicationPolicyId = _header;
                        }
                        _value.ObjectReplicationRules = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-or-", System.StringComparison.InvariantCulture))
                            {
                                _value.ObjectReplicationRules[_headerPair.Name.Substring(8)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("Content-Length", out _header))
                        {
                            _value.ContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-Type", out _header))
                        {
                            _value.ContentType = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Range", out _header))
                        {
                            _value.ContentRange = _header;
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("Content-Encoding", out _header))
                        {
                            _value.ContentEncoding = _header;
                        }
                        if (response.Headers.TryGetValue("Cache-Control", out _header))
                        {
                            _value.CacheControl = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Disposition", out _header))
                        {
                            _value.ContentDisposition = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Language", out _header))
                        {
                            _value.ContentLanguage = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-type", out _header))
                        {
                            _value.BlobType = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseBlobType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-completion-time", out _header))
                        {
                            _value.CopyCompletionTime = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status-description", out _header))
                        {
                            _value.CopyStatusDescription = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-id", out _header))
                        {
                            _value.CopyId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-progress", out _header))
                        {
                            _value.CopyProgress = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-source", out _header))
                        {
                            _value.CopySource = new System.Uri(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status", out _header))
                        {
                            _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-duration", out _header))
                        {
                            _value.LeaseDuration = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseDurationType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-state", out _header))
                        {
                            _value.LeaseState = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseState(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-status", out _header))
                        {
                            _value.LeaseStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseStatus(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("Accept-Ranges", out _header))
                        {
                            _value.AcceptRanges = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-committed-block-count", out _header))
                        {
                            _value.BlobCommittedBlockCount = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-content-md5", out _header))
                        {
                            _value.BlobContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-tag-count", out _header))
                        {
                            _value.TagCount = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sealed", out _header))
                        {
                            _value.IsSealed = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-last-access-time", out _header))
                        {
                            _value.LastAccessed = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 206:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.FlattenedDownloadProperties _value = new Azure.Storage.Blobs.Models.FlattenedDownloadProperties();
                        _value.Content = response.ContentStream; // You should manually wrap with RetriableStream!

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        _value.Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-meta-", System.StringComparison.InvariantCulture))
                            {
                                _value.Metadata[_headerPair.Name.Substring(10)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("x-ms-or-policy-id", out _header))
                        {
                            _value.ObjectReplicationPolicyId = _header;
                        }
                        _value.ObjectReplicationRules = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-or-", System.StringComparison.InvariantCulture))
                            {
                                _value.ObjectReplicationRules[_headerPair.Name.Substring(8)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("Content-Length", out _header))
                        {
                            _value.ContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-Type", out _header))
                        {
                            _value.ContentType = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Range", out _header))
                        {
                            _value.ContentRange = _header;
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("Content-Encoding", out _header))
                        {
                            _value.ContentEncoding = _header;
                        }
                        if (response.Headers.TryGetValue("Cache-Control", out _header))
                        {
                            _value.CacheControl = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Disposition", out _header))
                        {
                            _value.ContentDisposition = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Language", out _header))
                        {
                            _value.ContentLanguage = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-type", out _header))
                        {
                            _value.BlobType = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseBlobType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-completion-time", out _header))
                        {
                            _value.CopyCompletionTime = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status-description", out _header))
                        {
                            _value.CopyStatusDescription = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-id", out _header))
                        {
                            _value.CopyId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-progress", out _header))
                        {
                            _value.CopyProgress = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-source", out _header))
                        {
                            _value.CopySource = new System.Uri(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status", out _header))
                        {
                            _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-duration", out _header))
                        {
                            _value.LeaseDuration = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseDurationType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-state", out _header))
                        {
                            _value.LeaseState = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseState(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-status", out _header))
                        {
                            _value.LeaseStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseStatus(_header);
                        }
                        if (response.Headers.TryGetValue("Accept-Ranges", out _header))
                        {
                            _value.AcceptRanges = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-committed-block-count", out _header))
                        {
                            _value.BlobCommittedBlockCount = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-content-md5", out _header))
                        {
                            _value.BlobContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-tag-count", out _header))
                        {
                            _value.TagCount = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sealed", out _header))
                        {
                            _value.IsSealed = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-last-access-time", out _header))
                        {
                            _value.LastAccessed = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.FlattenedDownloadProperties>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.DownloadAsync

            #region Blob.GetPropertiesAsync
            /// <summary>
            /// The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the blob. It does not return the content of the blob.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobPropertiesInternal}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobPropertiesInternal>> GetPropertiesAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                string versionId = default,
                int? timeout = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.GetProperties",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetPropertiesAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        snapshot,
                        versionId,
                        timeout,
                        leaseId,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetPropertiesAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.GetPropertiesAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.GetPropertiesAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetPropertiesAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                string versionId = default,
                int? timeout = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Head;
                _request.Uri.Reset(resourceUri);
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (versionId != null) { _request.Uri.AppendQuery("versionid", versionId); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.GetPropertiesAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.GetPropertiesAsync Azure.Response{Azure.Storage.Blobs.Models.BlobPropertiesInternal}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobPropertiesInternal> GetPropertiesAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobPropertiesInternal _value = new Azure.Storage.Blobs.Models.BlobPropertiesInternal();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-creation-time", out _header))
                        {
                            _value.CreatedOn = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        _value.Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-meta-", System.StringComparison.InvariantCulture))
                            {
                                _value.Metadata[_headerPair.Name.Substring(10)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("x-ms-or-policy-id", out _header))
                        {
                            _value.ObjectReplicationPolicyId = _header;
                        }
                        _value.ObjectReplicationRules = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-or-", System.StringComparison.InvariantCulture))
                            {
                                _value.ObjectReplicationRules[_headerPair.Name.Substring(8)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-type", out _header))
                        {
                            _value.BlobType = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseBlobType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-completion-time", out _header))
                        {
                            _value.CopyCompletedOn = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status-description", out _header))
                        {
                            _value.CopyStatusDescription = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-id", out _header))
                        {
                            _value.CopyId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-progress", out _header))
                        {
                            _value.CopyProgress = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-source", out _header))
                        {
                            _value.CopySource = new System.Uri(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status", out _header))
                        {
                            _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-incremental-copy", out _header))
                        {
                            _value.IsIncrementalCopy = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-destination-snapshot", out _header))
                        {
                            _value.DestinationSnapshot = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-duration", out _header))
                        {
                            _value.LeaseDuration = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseDurationType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-state", out _header))
                        {
                            _value.LeaseState = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseState(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-status", out _header))
                        {
                            _value.LeaseStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseStatus(_header);
                        }
                        if (response.Headers.TryGetValue("Content-Length", out _header))
                        {
                            _value.ContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-Type", out _header))
                        {
                            _value.ContentType = _header;
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("Content-Encoding", out _header))
                        {
                            _value.ContentEncoding = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Disposition", out _header))
                        {
                            _value.ContentDisposition = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Language", out _header))
                        {
                            _value.ContentLanguage = _header;
                        }
                        if (response.Headers.TryGetValue("Cache-Control", out _header))
                        {
                            _value.CacheControl = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Accept-Ranges", out _header))
                        {
                            _value.AcceptRanges = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-committed-block-count", out _header))
                        {
                            _value.BlobCommittedBlockCount = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-access-tier", out _header))
                        {
                            _value.AccessTier = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-access-tier-inferred", out _header))
                        {
                            _value.AccessTierInferred = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-archive-status", out _header))
                        {
                            _value.ArchiveStatus = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-access-tier-change-time", out _header))
                        {
                            _value.AccessTierChangedOn = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-is-current-version", out _header))
                        {
                            _value.IsCurrentVersion = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-tag-count", out _header))
                        {
                            _value.TagCount = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-expiry-time", out _header))
                        {
                            _value.ExpiresOn = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sealed", out _header))
                        {
                            _value.IsSealed = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-rehydrate-priority", out _header))
                        {
                            _value.RehydratePriority = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-last-access-time", out _header))
                        {
                            _value.LastAccessed = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobPropertiesInternal>(response);
                    }
                    default:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.ConditionNotMetError _value = new Azure.Storage.Blobs.Models.ConditionNotMetError();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-error-code", out _header))
                        {
                            _value.ErrorCode = _header;
                        }

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.GetPropertiesAsync

            #region Blob.DeleteAsync
            /// <summary>
            /// If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently removed from the storage account. If the storage account's soft delete feature is enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot for the number of days specified by the DeleteRetentionPolicy section of [Storage service properties] (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is permanently removed from the storage account. Note that you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code of 404 (ResourceNotFound).
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="deleteSnapshots">Required if the blob has associated snapshots. Specify one of the following two options: include: Delete the base blob and all of its snapshots. only: Delete only the blob's snapshots and not the blob itself</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response> DeleteAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                string versionId = default,
                int? timeout = default,
                string leaseId = default,
                Azure.Storage.Blobs.Models.DeleteSnapshotsOption? deleteSnapshots = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.Delete",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = DeleteAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        snapshot,
                        versionId,
                        timeout,
                        leaseId,
                        deleteSnapshots,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return DeleteAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.DeleteAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="deleteSnapshots">Required if the blob has associated snapshots. Specify one of the following two options: include: Delete the base blob and all of its snapshots. only: Delete only the blob's snapshots and not the blob itself</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.DeleteAsync Message.</returns>
            internal static Azure.Core.HttpMessage DeleteAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                string versionId = default,
                int? timeout = default,
                string leaseId = default,
                Azure.Storage.Blobs.Models.DeleteSnapshotsOption? deleteSnapshots = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Delete;
                _request.Uri.Reset(resourceUri);
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (versionId != null) { _request.Uri.AppendQuery("versionid", versionId); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (deleteSnapshots != null) { _request.Headers.SetValue("x-ms-delete-snapshots", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(deleteSnapshots.Value)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.DeleteAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.DeleteAsync Azure.Response.</returns>
            internal static Azure.Response DeleteAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        return response;
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.DeleteAsync

            #region Blob.SetAccessControlAsync
            /// <summary>
            /// Set the owner, group, permissions, or access control list for a blob.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="owner">Optional. The owner of the blob or directory.</param>
            /// <param name="group">Optional. The owning group of the blob or directory.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixAcl">Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries. Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format "[scope:][type]:[id]:[permissions]".</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobSetAccessControlResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobSetAccessControlResult>> SetAccessControlAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                string owner = default,
                string group = default,
                string posixPermissions = default,
                string posixAcl = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.SetAccessControl",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetAccessControlAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        leaseId,
                        owner,
                        group,
                        posixPermissions,
                        posixAcl,
                        ifMatch,
                        ifNoneMatch,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetAccessControlAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.SetAccessControlAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="owner">Optional. The owner of the blob or directory.</param>
            /// <param name="group">Optional. The owning group of the blob or directory.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixAcl">Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries. Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format "[scope:][type]:[id]:[permissions]".</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.SetAccessControlAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetAccessControlAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                string owner = default,
                string group = default,
                string posixPermissions = default,
                string posixAcl = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Patch;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("action", "setAccessControl", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (owner != null) { _request.Headers.SetValue("x-ms-owner", owner); }
                if (group != null) { _request.Headers.SetValue("x-ms-group", group); }
                if (posixPermissions != null) { _request.Headers.SetValue("x-ms-permissions", posixPermissions); }
                if (posixAcl != null) { _request.Headers.SetValue("x-ms-acl", posixAcl); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.SetAccessControlAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.SetAccessControlAsync Azure.Response{Azure.Storage.Blobs.Models.BlobSetAccessControlResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobSetAccessControlResult> SetAccessControlAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobSetAccessControlResult _value = new Azure.Storage.Blobs.Models.BlobSetAccessControlResult();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.DataLakeStorageError _value = Azure.Storage.Blobs.Models.DataLakeStorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.SetAccessControlAsync

            #region Blob.GetAccessControlAsync
            /// <summary>
            /// Get the owner, group, permissions, or access control list for a blob.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="upn">Optional. Valid only when Hierarchical Namespace is enabled for the account. If "true", the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If "false", the values will be returned as Azure Active Directory Object IDs. The default value is false.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobGetAccessControlResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobGetAccessControlResult>> GetAccessControlAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                bool? upn = default,
                string leaseId = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.GetAccessControl",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetAccessControlAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        upn,
                        leaseId,
                        ifMatch,
                        ifNoneMatch,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetAccessControlAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.GetAccessControlAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="upn">Optional. Valid only when Hierarchical Namespace is enabled for the account. If "true", the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If "false", the values will be returned as Azure Active Directory Object IDs. The default value is false.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.GetAccessControlAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetAccessControlAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                bool? upn = default,
                string leaseId = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Head;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("action", "getAccessControl", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (upn != null) {
                #pragma warning disable CA1308 // Normalize strings to uppercase
                _request.Uri.AppendQuery("upn", upn.Value.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant());
                #pragma warning restore CA1308 // Normalize strings to uppercase
                }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.GetAccessControlAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.GetAccessControlAsync Azure.Response{Azure.Storage.Blobs.Models.BlobGetAccessControlResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobGetAccessControlResult> GetAccessControlAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobGetAccessControlResult _value = new Azure.Storage.Blobs.Models.BlobGetAccessControlResult();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-owner", out _header))
                        {
                            _value.XMSOwner = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-group", out _header))
                        {
                            _value.XMSGroup = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-permissions", out _header))
                        {
                            _value.XMSPermissions = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-acl", out _header))
                        {
                            _value.XMSAcl = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobGetAccessControlResult>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.DataLakeStorageError _value = Azure.Storage.Blobs.Models.DataLakeStorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.GetAccessControlAsync

            #region Blob.RenameAsync
            /// <summary>
            /// Rename a blob/file.  By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: "*".
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="renameSource">The file or directory to be renamed. The value must have the following format: "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="pathRenameMode">Determines the behavior of the rename operation</param>
            /// <param name="directoryProperties">Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixUmask">Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used.</param>
            /// <param name="cacheControl">Cache control for given resource</param>
            /// <param name="contentType">Content type for given resource</param>
            /// <param name="contentEncoding">Content encoding for given resource</param>
            /// <param name="contentLanguage">Content language for given resource</param>
            /// <param name="contentDisposition">Content disposition for given resource</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="sourceLeaseId">A lease ID for the source path. If specified, the source path must have an active lease and the lease ID must match.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobRenameResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobRenameResult>> RenameAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string renameSource,
                string version,
                int? timeout = default,
                Azure.Storage.Blobs.Models.PathRenameMode? pathRenameMode = default,
                string directoryProperties = default,
                string posixPermissions = default,
                string posixUmask = default,
                string cacheControl = default,
                string contentType = default,
                string contentEncoding = default,
                string contentLanguage = default,
                string contentDisposition = default,
                string leaseId = default,
                string sourceLeaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.Rename",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = RenameAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        renameSource,
                        version,
                        timeout,
                        pathRenameMode,
                        directoryProperties,
                        posixPermissions,
                        posixUmask,
                        cacheControl,
                        contentType,
                        contentEncoding,
                        contentLanguage,
                        contentDisposition,
                        leaseId,
                        sourceLeaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        sourceIfModifiedSince,
                        sourceIfUnmodifiedSince,
                        sourceIfMatch,
                        sourceIfNoneMatch,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return RenameAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.RenameAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="renameSource">The file or directory to be renamed. The value must have the following format: "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="pathRenameMode">Determines the behavior of the rename operation</param>
            /// <param name="directoryProperties">Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixUmask">Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used.</param>
            /// <param name="cacheControl">Cache control for given resource</param>
            /// <param name="contentType">Content type for given resource</param>
            /// <param name="contentEncoding">Content encoding for given resource</param>
            /// <param name="contentLanguage">Content language for given resource</param>
            /// <param name="contentDisposition">Content disposition for given resource</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="sourceLeaseId">A lease ID for the source path. If specified, the source path must have an active lease and the lease ID must match.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.RenameAsync Message.</returns>
            internal static Azure.Core.HttpMessage RenameAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string renameSource,
                string version,
                int? timeout = default,
                Azure.Storage.Blobs.Models.PathRenameMode? pathRenameMode = default,
                string directoryProperties = default,
                string posixPermissions = default,
                string posixUmask = default,
                string cacheControl = default,
                string contentType = default,
                string contentEncoding = default,
                string contentLanguage = default,
                string contentDisposition = default,
                string leaseId = default,
                string sourceLeaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (renameSource == null)
                {
                    throw new System.ArgumentNullException(nameof(renameSource));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (pathRenameMode != null) { _request.Uri.AppendQuery("mode", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(pathRenameMode.Value)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-rename-source", renameSource);
                _request.Headers.SetValue("x-ms-version", version);
                if (directoryProperties != null) { _request.Headers.SetValue("x-ms-properties", directoryProperties); }
                if (posixPermissions != null) { _request.Headers.SetValue("x-ms-permissions", posixPermissions); }
                if (posixUmask != null) { _request.Headers.SetValue("x-ms-umask", posixUmask); }
                if (cacheControl != null) { _request.Headers.SetValue("x-ms-cache-control", cacheControl); }
                if (contentType != null) { _request.Headers.SetValue("x-ms-content-type", contentType); }
                if (contentEncoding != null) { _request.Headers.SetValue("x-ms-content-encoding", contentEncoding); }
                if (contentLanguage != null) { _request.Headers.SetValue("x-ms-content-language", contentLanguage); }
                if (contentDisposition != null) { _request.Headers.SetValue("x-ms-content-disposition", contentDisposition); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (sourceLeaseId != null) { _request.Headers.SetValue("x-ms-source-lease-id", sourceLeaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (sourceIfModifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-modified-since", sourceIfModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfUnmodifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfMatch != null) { _request.Headers.SetValue("x-ms-source-if-match", sourceIfMatch.Value.ToString()); }
                if (sourceIfNoneMatch != null) { _request.Headers.SetValue("x-ms-source-if-none-match", sourceIfNoneMatch.Value.ToString()); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.RenameAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.RenameAsync Azure.Response{Azure.Storage.Blobs.Models.BlobRenameResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobRenameResult> RenameAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobRenameResult _value = new Azure.Storage.Blobs.Models.BlobRenameResult();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-Length", out _header))
                        {
                            _value.ContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.DataLakeStorageError _value = Azure.Storage.Blobs.Models.DataLakeStorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.RenameAsync

            #region Blob.UndeleteAsync
            /// <summary>
            /// Undelete a blob that was previously soft deleted
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response> UndeleteAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.Undelete",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = UndeleteAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return UndeleteAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.UndeleteAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.UndeleteAsync Message.</returns>
            internal static Azure.Core.HttpMessage UndeleteAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "undelete", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.UndeleteAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.UndeleteAsync Azure.Response.</returns>
            internal static Azure.Response UndeleteAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        return response;
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.UndeleteAsync

            #region Blob.SetExpiryAsync
            /// <summary>
            /// Sets the time a blob will expire and be deleted.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="expiryOptions">Required. Indicates mode of the expiry time</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="expiresOn">The time to set the blob to expiry</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobSetExpiryInternal}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobSetExpiryInternal>> SetExpiryAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                Azure.Storage.Blobs.Models.BlobExpiryOptions expiryOptions,
                int? timeout = default,
                string requestId = default,
                string expiresOn = default,
                bool async = true,
                string operationName = "BlobClient.SetExpiry",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetExpiryAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        expiryOptions,
                        timeout,
                        requestId,
                        expiresOn))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetExpiryAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.SetExpiryAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="expiryOptions">Required. Indicates mode of the expiry time</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="expiresOn">The time to set the blob to expiry</param>
            /// <returns>The Blob.SetExpiryAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetExpiryAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                Azure.Storage.Blobs.Models.BlobExpiryOptions expiryOptions,
                int? timeout = default,
                string requestId = default,
                string expiresOn = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "expiry", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                _request.Headers.SetValue("x-ms-expiry-option", expiryOptions.ToString());
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (expiresOn != null) { _request.Headers.SetValue("x-ms-expiry-time", expiresOn); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.SetExpiryAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.SetExpiryAsync Azure.Response{Azure.Storage.Blobs.Models.BlobSetExpiryInternal}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobSetExpiryInternal> SetExpiryAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobSetExpiryInternal _value = new Azure.Storage.Blobs.Models.BlobSetExpiryInternal();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.SetExpiryAsync

            #region Blob.SetHttpHeadersAsync
            /// <summary>
            /// The Set HTTP Headers operation sets system properties on the blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.SetHttpHeadersOperation}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.SetHttpHeadersOperation>> SetHttpHeadersAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string blobCacheControl = default,
                string blobContentType = default,
                byte[] blobContentHash = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string blobContentDisposition = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.SetHttpHeaders",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetHttpHeadersAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        blobCacheControl,
                        blobContentType,
                        blobContentHash,
                        blobContentEncoding,
                        blobContentLanguage,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        blobContentDisposition,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetHttpHeadersAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.SetHttpHeadersAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.SetHttpHeadersAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetHttpHeadersAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string blobCacheControl = default,
                string blobContentType = default,
                byte[] blobContentHash = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string blobContentDisposition = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "properties", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (blobCacheControl != null) { _request.Headers.SetValue("x-ms-blob-cache-control", blobCacheControl); }
                if (blobContentType != null) { _request.Headers.SetValue("x-ms-blob-content-type", blobContentType); }
                if (blobContentHash != null) { _request.Headers.SetValue("x-ms-blob-content-md5", System.Convert.ToBase64String(blobContentHash)); }
                if (blobContentEncoding != null) { _request.Headers.SetValue("x-ms-blob-content-encoding", blobContentEncoding); }
                if (blobContentLanguage != null) { _request.Headers.SetValue("x-ms-blob-content-language", blobContentLanguage); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (blobContentDisposition != null) { _request.Headers.SetValue("x-ms-blob-content-disposition", blobContentDisposition); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.SetHttpHeadersAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.SetHttpHeadersAsync Azure.Response{Azure.Storage.Blobs.Models.SetHttpHeadersOperation}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.SetHttpHeadersOperation> SetHttpHeadersAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.SetHttpHeadersOperation _value = new Azure.Storage.Blobs.Models.SetHttpHeadersOperation();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.SetHttpHeadersAsync

            #region Blob.SetMetadataAsync
            /// <summary>
            /// The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.SetMetadataOperation}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.SetMetadataOperation>> SetMetadataAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.SetMetadata",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetMetadataAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        metadata,
                        leaseId,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetMetadataAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.SetMetadataAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.SetMetadataAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetMetadataAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "metadata", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.SetMetadataAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.SetMetadataAsync Azure.Response{Azure.Storage.Blobs.Models.SetMetadataOperation}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.SetMetadataOperation> SetMetadataAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.SetMetadataOperation _value = new Azure.Storage.Blobs.Models.SetMetadataOperation();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-request-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.SetMetadataAsync

            #region Blob.AcquireLeaseAsync
            /// <summary>
            /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="duration">Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change.</param>
            /// <param name="proposedLeaseId">Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobLease}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobLease>> AcquireLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                long? duration = default,
                string proposedLeaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.AcquireLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = AcquireLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        duration,
                        proposedLeaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return AcquireLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.AcquireLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="duration">Specifies the duration of the lease, in seconds, or negative one (-1) for a lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease duration cannot be changed using renew or change.</param>
            /// <param name="proposedLeaseId">Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.AcquireLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage AcquireLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                long? duration = default,
                string proposedLeaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "acquire");
                _request.Headers.SetValue("x-ms-version", version);
                if (duration != null) { _request.Headers.SetValue("x-ms-lease-duration", duration.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (proposedLeaseId != null) { _request.Headers.SetValue("x-ms-proposed-lease-id", proposedLeaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.AcquireLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.AcquireLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BlobLease}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobLease> AcquireLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobLease _value = new Azure.Storage.Blobs.Models.BlobLease();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-id", out _header))
                        {
                            _value.LeaseId = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.AcquireLeaseAsync

            #region Blob.ReleaseLeaseAsync
            /// <summary>
            /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobInfo>> ReleaseLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.ReleaseLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ReleaseLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        leaseId,
                        version,
                        timeout,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ReleaseLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.ReleaseLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.ReleaseLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage ReleaseLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (leaseId == null)
                {
                    throw new System.ArgumentNullException(nameof(leaseId));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "release");
                _request.Headers.SetValue("x-ms-lease-id", leaseId);
                _request.Headers.SetValue("x-ms-version", version);
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.ReleaseLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.ReleaseLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BlobInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobInfo> ReleaseLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobInfo _value = new Azure.Storage.Blobs.Models.BlobInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.ReleaseLeaseAsync

            #region Blob.RenewLeaseAsync
            /// <summary>
            /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobLease}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobLease>> RenewLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.RenewLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = RenewLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        leaseId,
                        version,
                        timeout,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return RenewLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.RenewLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.RenewLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage RenewLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (leaseId == null)
                {
                    throw new System.ArgumentNullException(nameof(leaseId));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "renew");
                _request.Headers.SetValue("x-ms-lease-id", leaseId);
                _request.Headers.SetValue("x-ms-version", version);
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.RenewLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.RenewLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BlobLease}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobLease> RenewLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobLease _value = new Azure.Storage.Blobs.Models.BlobLease();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-id", out _header))
                        {
                            _value.LeaseId = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.RenewLeaseAsync

            #region Blob.ChangeLeaseAsync
            /// <summary>
            /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="proposedLeaseId">Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobLease}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobLease>> ChangeLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string proposedLeaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.ChangeLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ChangeLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        leaseId,
                        proposedLeaseId,
                        version,
                        timeout,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ChangeLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.ChangeLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="leaseId">Specifies the current lease ID on the resource.</param>
            /// <param name="proposedLeaseId">Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID string formats.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.ChangeLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage ChangeLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string leaseId,
                string proposedLeaseId,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (leaseId == null)
                {
                    throw new System.ArgumentNullException(nameof(leaseId));
                }
                if (proposedLeaseId == null)
                {
                    throw new System.ArgumentNullException(nameof(proposedLeaseId));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "change");
                _request.Headers.SetValue("x-ms-lease-id", leaseId);
                _request.Headers.SetValue("x-ms-proposed-lease-id", proposedLeaseId);
                _request.Headers.SetValue("x-ms-version", version);
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.ChangeLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.ChangeLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BlobLease}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobLease> ChangeLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobLease _value = new Azure.Storage.Blobs.Models.BlobLease();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-id", out _header))
                        {
                            _value.LeaseId = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.ChangeLeaseAsync

            #region Blob.BreakLeaseAsync
            /// <summary>
            /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="breakPeriod">For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BrokenLease}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BrokenLease>> BreakLeaseAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                long? breakPeriod = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.BreakLease",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = BreakLeaseAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        breakPeriod,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return BreakLeaseAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.BreakLeaseAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="breakPeriod">For a break operation, proposed duration the lease should continue before it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter than the time remaining on the lease. If longer, the time remaining on the lease is used. A new lease will not be available before the break period has expired, but the lease may be held for longer than the break period. If this header does not appear with a break operation, a fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease breaks immediately.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.BreakLeaseAsync Message.</returns>
            internal static Azure.Core.HttpMessage BreakLeaseAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                long? breakPeriod = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "lease", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-lease-action", "break");
                _request.Headers.SetValue("x-ms-version", version);
                if (breakPeriod != null) { _request.Headers.SetValue("x-ms-lease-break-period", breakPeriod.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.BreakLeaseAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.BreakLeaseAsync Azure.Response{Azure.Storage.Blobs.Models.BrokenLease}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BrokenLease> BreakLeaseAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BrokenLease _value = new Azure.Storage.Blobs.Models.BrokenLease();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-time", out _header))
                        {
                            _value.LeaseTime = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.BreakLeaseAsync

            #region Blob.CreateSnapshotAsync
            /// <summary>
            /// The Create Snapshot operation creates a read-only snapshot of a blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobSnapshotInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobSnapshotInfo>> CreateSnapshotAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string leaseId = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.CreateSnapshot",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = CreateSnapshotAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        metadata,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        leaseId,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return CreateSnapshotAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.CreateSnapshotAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.CreateSnapshotAsync Message.</returns>
            internal static Azure.Core.HttpMessage CreateSnapshotAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string leaseId = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "snapshot", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.CreateSnapshotAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.CreateSnapshotAsync Azure.Response{Azure.Storage.Blobs.Models.BlobSnapshotInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobSnapshotInfo> CreateSnapshotAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobSnapshotInfo _value = new Azure.Storage.Blobs.Models.BlobSnapshotInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-snapshot", out _header))
                        {
                            _value.Snapshot = _header;
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-request-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.CreateSnapshotAsync

            #region Blob.StartCopyFromUriAsync
            /// <summary>
            /// The Start Copy From URL operation copies a blob or an internet resource to a new blob.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="copySource">Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="tier">Optional. Indicates the tier to be set on the blob.</param>
            /// <param name="rehydratePriority">Optional: Indicates the priority with which to rehydrate an archived blob.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="sourceIfTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <param name="sealBlob">Overrides the sealed state of the destination blob.  Service version 2019-12-12 and newer.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobCopyInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobCopyInfo>> StartCopyFromUriAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri copySource,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                Azure.Storage.Blobs.Models.RehydratePriority? rehydratePriority = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string sourceIfTags = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string leaseId = default,
                string requestId = default,
                string blobTagsString = default,
                bool? sealBlob = default,
                bool async = true,
                string operationName = "BlobClient.StartCopyFromUri",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = StartCopyFromUriAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        copySource,
                        version,
                        timeout,
                        metadata,
                        tier,
                        rehydratePriority,
                        sourceIfModifiedSince,
                        sourceIfUnmodifiedSince,
                        sourceIfMatch,
                        sourceIfNoneMatch,
                        sourceIfTags,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        leaseId,
                        requestId,
                        blobTagsString,
                        sealBlob))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return StartCopyFromUriAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.StartCopyFromUriAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="copySource">Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="tier">Optional. Indicates the tier to be set on the blob.</param>
            /// <param name="rehydratePriority">Optional: Indicates the priority with which to rehydrate an archived blob.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="sourceIfTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <param name="sealBlob">Overrides the sealed state of the destination blob.  Service version 2019-12-12 and newer.</param>
            /// <returns>The Blob.StartCopyFromUriAsync Message.</returns>
            internal static Azure.Core.HttpMessage StartCopyFromUriAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri copySource,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                Azure.Storage.Blobs.Models.RehydratePriority? rehydratePriority = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string sourceIfTags = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string leaseId = default,
                string requestId = default,
                string blobTagsString = default,
                bool? sealBlob = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (copySource == null)
                {
                    throw new System.ArgumentNullException(nameof(copySource));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-copy-source", copySource.AbsoluteUri);
                _request.Headers.SetValue("x-ms-version", version);
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (tier != null) { _request.Headers.SetValue("x-ms-access-tier", tier.ToString()); }
                if (rehydratePriority != null) { _request.Headers.SetValue("x-ms-rehydrate-priority", rehydratePriority.Value.ToString()); }
                if (sourceIfModifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-modified-since", sourceIfModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfUnmodifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfMatch != null) { _request.Headers.SetValue("x-ms-source-if-match", sourceIfMatch.Value.ToString()); }
                if (sourceIfNoneMatch != null) { _request.Headers.SetValue("x-ms-source-if-none-match", sourceIfNoneMatch.Value.ToString()); }
                if (sourceIfTags != null) { _request.Headers.SetValue("x-ms-source-if-tags", sourceIfTags); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (blobTagsString != null) { _request.Headers.SetValue("x-ms-tags", blobTagsString); }
                if (sealBlob != null) {
                #pragma warning disable CA1308 // Normalize strings to uppercase
                _request.Headers.SetValue("x-ms-seal-blob", sealBlob.Value.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant());
                #pragma warning restore CA1308 // Normalize strings to uppercase
                }

                return _message;
            }

            /// <summary>
            /// Create the Blob.StartCopyFromUriAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.StartCopyFromUriAsync Azure.Response{Azure.Storage.Blobs.Models.BlobCopyInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobCopyInfo> StartCopyFromUriAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobCopyInfo _value = new Azure.Storage.Blobs.Models.BlobCopyInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-id", out _header))
                        {
                            _value.CopyId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status", out _header))
                        {
                            _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.StartCopyFromUriAsync

            #region Blob.CopyFromUriAsync
            /// <summary>
            /// The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the copy is complete.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="copySource">Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="tier">Optional. Indicates the tier to be set on the blob.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="sourceContentHash">Specify the md5 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobCopyInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobCopyInfo>> CopyFromUriAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri copySource,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string leaseId = default,
                string requestId = default,
                byte[] sourceContentHash = default,
                string blobTagsString = default,
                bool async = true,
                string operationName = "BlobClient.CopyFromUri",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = CopyFromUriAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        copySource,
                        version,
                        timeout,
                        metadata,
                        tier,
                        sourceIfModifiedSince,
                        sourceIfUnmodifiedSince,
                        sourceIfMatch,
                        sourceIfNoneMatch,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        leaseId,
                        requestId,
                        sourceContentHash,
                        blobTagsString))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return CopyFromUriAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.CopyFromUriAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="copySource">Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="tier">Optional. Indicates the tier to be set on the blob.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="sourceContentHash">Specify the md5 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <returns>The Blob.CopyFromUriAsync Message.</returns>
            internal static Azure.Core.HttpMessage CopyFromUriAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri copySource,
                string version,
                int? timeout = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string leaseId = default,
                string requestId = default,
                byte[] sourceContentHash = default,
                string blobTagsString = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (copySource == null)
                {
                    throw new System.ArgumentNullException(nameof(copySource));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-requires-sync", "true");
                _request.Headers.SetValue("x-ms-copy-source", copySource.AbsoluteUri);
                _request.Headers.SetValue("x-ms-version", version);
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (tier != null) { _request.Headers.SetValue("x-ms-access-tier", tier.ToString()); }
                if (sourceIfModifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-modified-since", sourceIfModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfUnmodifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfMatch != null) { _request.Headers.SetValue("x-ms-source-if-match", sourceIfMatch.Value.ToString()); }
                if (sourceIfNoneMatch != null) { _request.Headers.SetValue("x-ms-source-if-none-match", sourceIfNoneMatch.Value.ToString()); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (sourceContentHash != null) { _request.Headers.SetValue("x-ms-source-content-md5", System.Convert.ToBase64String(sourceContentHash)); }
                if (blobTagsString != null) { _request.Headers.SetValue("x-ms-tags", blobTagsString); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.CopyFromUriAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.CopyFromUriAsync Azure.Response{Azure.Storage.Blobs.Models.BlobCopyInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobCopyInfo> CopyFromUriAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobCopyInfo _value = new Azure.Storage.Blobs.Models.BlobCopyInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-id", out _header))
                        {
                            _value.CopyId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status", out _header))
                        {
                            _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.ConditionNotMetError _value = new Azure.Storage.Blobs.Models.ConditionNotMetError();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-error-code", out _header))
                        {
                            _value.ErrorCode = _header;
                        }

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.CopyFromUriAsync

            #region Blob.AbortCopyFromUriAsync
            /// <summary>
            /// The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length and full metadata.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="copyId">The copy identifier provided in the x-ms-copy-id header of the original Copy Blob operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response> AbortCopyFromUriAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string copyId,
                string version,
                int? timeout = default,
                string leaseId = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.AbortCopyFromUri",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = AbortCopyFromUriAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        copyId,
                        version,
                        timeout,
                        leaseId,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return AbortCopyFromUriAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.AbortCopyFromUriAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="copyId">The copy identifier provided in the x-ms-copy-id header of the original Copy Blob operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.AbortCopyFromUriAsync Message.</returns>
            internal static Azure.Core.HttpMessage AbortCopyFromUriAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string copyId,
                string version,
                int? timeout = default,
                string leaseId = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (copyId == null)
                {
                    throw new System.ArgumentNullException(nameof(copyId));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "copy", escapeValue: false);
                _request.Uri.AppendQuery("copyid", copyId);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-copy-action", "abort");
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.AbortCopyFromUriAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.AbortCopyFromUriAsync Azure.Response.</returns>
            internal static Azure.Response AbortCopyFromUriAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 204:
                    {
                        return response;
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.AbortCopyFromUriAsync

            #region Blob.SetAccessTierAsync
            /// <summary>
            /// The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage account and on a block blob in a blob storage account (locally redundant storage only). A premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's ETag.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="tier">Indicates the tier to be set on the blob.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="rehydratePriority">Optional: Indicates the priority with which to rehydrate an archived blob.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response> SetAccessTierAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.AccessTier tier,
                string version,
                string snapshot = default,
                string versionId = default,
                int? timeout = default,
                Azure.Storage.Blobs.Models.RehydratePriority? rehydratePriority = default,
                string requestId = default,
                string leaseId = default,
                string ifTags = default,
                bool async = true,
                string operationName = "BlobClient.SetAccessTier",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetAccessTierAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        tier,
                        version,
                        snapshot,
                        versionId,
                        timeout,
                        rehydratePriority,
                        requestId,
                        leaseId,
                        ifTags))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetAccessTierAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.SetAccessTierAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="tier">Indicates the tier to be set on the blob.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="rehydratePriority">Optional: Indicates the priority with which to rehydrate an archived blob.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <returns>The Blob.SetAccessTierAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetAccessTierAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.AccessTier tier,
                string version,
                string snapshot = default,
                string versionId = default,
                int? timeout = default,
                Azure.Storage.Blobs.Models.RehydratePriority? rehydratePriority = default,
                string requestId = default,
                string leaseId = default,
                string ifTags = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "tier", escapeValue: false);
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (versionId != null) { _request.Uri.AppendQuery("versionid", versionId); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-access-tier", tier.ToString());
                _request.Headers.SetValue("x-ms-version", version);
                if (rehydratePriority != null) { _request.Headers.SetValue("x-ms-rehydrate-priority", rehydratePriority.Value.ToString()); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.SetAccessTierAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.SetAccessTierAsync Azure.Response.</returns>
            internal static Azure.Response SetAccessTierAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        return response;
                    }
                    case 202:
                    {
                        return response;
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.SetAccessTierAsync

            #region Blob.QueryAsync
            /// <summary>
            /// The Query operation enables users to select/project on blob data by providing simple query expressions.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="queryRequest">the query request</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobQueryResult}</returns>
            public static async System.Threading.Tasks.ValueTask<(Azure.Response<Azure.Storage.Blobs.Models.BlobQueryResult>, System.IO.Stream)> QueryAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                Azure.Storage.Blobs.Models.QueryRequest queryRequest = default,
                string snapshot = default,
                int? timeout = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlobClient.Query",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = QueryAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        queryRequest,
                        snapshot,
                        timeout,
                        leaseId,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        // Avoid buffering if stream is going to be returned to the caller
                        _message.BufferResponse = false;
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return (QueryAsync_CreateResponse(clientDiagnostics, _response), _message.ExtractResponseContent());
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.QueryAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="queryRequest">the query request</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Blob.QueryAsync Message.</returns>
            internal static Azure.Core.HttpMessage QueryAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                Azure.Storage.Blobs.Models.QueryRequest queryRequest = default,
                string snapshot = default,
                int? timeout = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Post;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "query", escapeValue: false);
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                // Create the body
                if (queryRequest != null)
                {
                    System.Xml.Linq.XElement _body = Azure.Storage.Blobs.Models.QueryRequest.ToXml(queryRequest, "QueryRequest", "");
                    string _text = _body.ToString(System.Xml.Linq.SaveOptions.DisableFormatting);
                    _request.Headers.SetValue("Content-Type", "application/xml");
                    _request.Headers.SetValue("Content-Length", _text.Length.ToString(System.Globalization.CultureInfo.InvariantCulture));
                    _request.Content = Azure.Core.RequestContent.Create(System.Text.Encoding.UTF8.GetBytes(_text));
                }

                return _message;
            }

            /// <summary>
            /// Create the Blob.QueryAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.QueryAsync Azure.Response{Azure.Storage.Blobs.Models.BlobQueryResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobQueryResult> QueryAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobQueryResult _value = new Azure.Storage.Blobs.Models.BlobQueryResult();
                        _value.Body = response.ContentStream; // You should manually wrap with RetriableStream!

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        _value.Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-meta-", System.StringComparison.InvariantCulture))
                            {
                                _value.Metadata[_headerPair.Name.Substring(10)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("Content-Length", out _header))
                        {
                            _value.ContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-Type", out _header))
                        {
                            _value.ContentType = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Range", out _header))
                        {
                            _value.ContentRange = _header;
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("Content-Encoding", out _header))
                        {
                            _value.ContentEncoding = _header;
                        }
                        if (response.Headers.TryGetValue("Cache-Control", out _header))
                        {
                            _value.CacheControl = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Disposition", out _header))
                        {
                            _value.ContentDisposition = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Language", out _header))
                        {
                            _value.ContentLanguage = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-type", out _header))
                        {
                            _value.BlobType = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseBlobType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-completion-time", out _header))
                        {
                            _value.CopyCompletionTime = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status-description", out _header))
                        {
                            _value.CopyStatusDescription = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-id", out _header))
                        {
                            _value.CopyId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-progress", out _header))
                        {
                            _value.CopyProgress = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-source", out _header))
                        {
                            _value.CopySource = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status", out _header))
                        {
                            _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-duration", out _header))
                        {
                            _value.LeaseDuration = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseDurationType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-state", out _header))
                        {
                            _value.LeaseState = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseState(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-status", out _header))
                        {
                            _value.LeaseStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseStatus(_header);
                        }
                        if (response.Headers.TryGetValue("Accept-Ranges", out _header))
                        {
                            _value.AcceptRanges = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-committed-block-count", out _header))
                        {
                            _value.BlobCommittedBlockCount = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-content-md5", out _header))
                        {
                            _value.BlobContentMD5 = System.Convert.FromBase64String(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 206:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobQueryResult _value = new Azure.Storage.Blobs.Models.BlobQueryResult();
                        _value.Body = response.ContentStream; // You should manually wrap with RetriableStream!

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        _value.Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                        foreach (Azure.Core.HttpHeader _headerPair in response.Headers)
                        {
                            if (_headerPair.Name.StartsWith("x-ms-meta-", System.StringComparison.InvariantCulture))
                            {
                                _value.Metadata[_headerPair.Name.Substring(10)] = _headerPair.Value;
                            }
                        }
                        if (response.Headers.TryGetValue("Content-Length", out _header))
                        {
                            _value.ContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-Type", out _header))
                        {
                            _value.ContentType = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Range", out _header))
                        {
                            _value.ContentRange = _header;
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("Content-Encoding", out _header))
                        {
                            _value.ContentEncoding = _header;
                        }
                        if (response.Headers.TryGetValue("Cache-Control", out _header))
                        {
                            _value.CacheControl = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Disposition", out _header))
                        {
                            _value.ContentDisposition = _header;
                        }
                        if (response.Headers.TryGetValue("Content-Language", out _header))
                        {
                            _value.ContentLanguage = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-type", out _header))
                        {
                            _value.BlobType = (Azure.Storage.Blobs.Models.BlobType)System.Enum.Parse(typeof(Azure.Storage.Blobs.Models.BlobType), _header, false);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-completion-time", out _header))
                        {
                            _value.CopyCompletionTime = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status-description", out _header))
                        {
                            _value.CopyStatusDescription = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-id", out _header))
                        {
                            _value.CopyId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-progress", out _header))
                        {
                            _value.CopyProgress = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-source", out _header))
                        {
                            _value.CopySource = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status", out _header))
                        {
                            _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-duration", out _header))
                        {
                            _value.LeaseDuration = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseDurationType(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-state", out _header))
                        {
                            _value.LeaseState = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseState(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-lease-status", out _header))
                        {
                            _value.LeaseStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseStatus(_header);
                        }
                        if (response.Headers.TryGetValue("Accept-Ranges", out _header))
                        {
                            _value.AcceptRanges = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-committed-block-count", out _header))
                        {
                            _value.BlobCommittedBlockCount = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-content-md5", out _header))
                        {
                            _value.BlobContentMD5 = System.Convert.FromBase64String(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.FailureNoContent _value = new Azure.Storage.Blobs.Models.FailureNoContent();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-error-code", out _header))
                        {
                            _value.ErrorCode = _header;
                        }

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.QueryAsync

            #region Blob.GetTagsAsync
            /// <summary>
            /// The Get Tags operation enables users to get the tags associated with a blob.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Blob tags</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobTags>> GetTagsAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                string snapshot = default,
                string versionId = default,
                string ifTags = default,
                bool async = true,
                string operationName = "BlobClient.GetTags",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetTagsAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        requestId,
                        snapshot,
                        versionId,
                        ifTags))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetTagsAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.GetTagsAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <returns>The Blob.GetTagsAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetTagsAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                string snapshot = default,
                string versionId = default,
                string ifTags = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "tags", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (versionId != null) { _request.Uri.AppendQuery("versionid", versionId); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }

                return _message;
            }

            /// <summary>
            /// Create the Blob.GetTagsAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.GetTagsAsync Azure.Response{Azure.Storage.Blobs.Models.BlobTags}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobTags> GetTagsAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.BlobTags _value = Azure.Storage.Blobs.Models.BlobTags.FromXml(_xml.Root);

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.BlobTags>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.GetTagsAsync

            #region Blob.SetTagsAsync
            /// <summary>
            /// The Set Tags operation enables users to set tags on a blob.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="tags">Blob tags</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response> SetTagsAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string versionId = default,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                string requestId = default,
                string ifTags = default,
                Azure.Storage.Blobs.Models.BlobTags tags = default,
                bool async = true,
                string operationName = "BlobClient.SetTags",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetTagsAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        versionId,
                        transactionalContentHash,
                        transactionalContentCrc64,
                        requestId,
                        ifTags,
                        tags))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetTagsAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Blob.SetTagsAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="versionId">The version id parameter is an opaque DateTime value that, when present, specifies the version of the blob to operate on. It's for service version 2019-10-10 and newer.</param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="tags">Blob tags</param>
            /// <returns>The Blob.SetTagsAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetTagsAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string versionId = default,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                string requestId = default,
                string ifTags = default,
                Azure.Storage.Blobs.Models.BlobTags tags = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "tags", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (versionId != null) { _request.Uri.AppendQuery("versionid", versionId); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (transactionalContentHash != null) { _request.Headers.SetValue("Content-MD5", System.Convert.ToBase64String(transactionalContentHash)); }
                if (transactionalContentCrc64 != null) { _request.Headers.SetValue("x-ms-content-crc64", System.Convert.ToBase64String(transactionalContentCrc64)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }

                // Create the body
                if (tags != null)
                {
                    System.Xml.Linq.XElement _body = Azure.Storage.Blobs.Models.BlobTags.ToXml(tags, "Tags", "");
                    string _text = _body.ToString(System.Xml.Linq.SaveOptions.DisableFormatting);
                    _request.Headers.SetValue("Content-Type", "application/xml");
                    _request.Headers.SetValue("Content-Length", _text.Length.ToString(System.Globalization.CultureInfo.InvariantCulture));
                    _request.Content = Azure.Core.RequestContent.Create(System.Text.Encoding.UTF8.GetBytes(_text));
                }

                return _message;
            }

            /// <summary>
            /// Create the Blob.SetTagsAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Blob.SetTagsAsync Azure.Response.</returns>
            internal static Azure.Response SetTagsAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 204:
                    {
                        return response;
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Blob.SetTagsAsync
        }
        #endregion Blob operations

        #region PageBlob operations
        /// <summary>
        /// PageBlob operations for Azure Blob Storage
        /// </summary>
        public static partial class PageBlob
        {
            #region PageBlob.CreateAsync
            /// <summary>
            /// The Create operation creates a new page blob.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="blobContentLength">This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned to a 512-byte boundary.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="tier">Optional. Indicates the tier to be set on the page blob.</param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="blobSequenceNumber">Set for page blobs only. The sequence number is a user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 2^63 - 1.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContentInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContentInfo>> CreateAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                long contentLength,
                long blobContentLength,
                string version,
                int? timeout = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                string blobContentType = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                byte[] blobContentHash = default,
                string blobCacheControl = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string blobContentDisposition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                long? blobSequenceNumber = default,
                string requestId = default,
                string blobTagsString = default,
                bool async = true,
                string operationName = "PageBlobClient.Create",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = CreateAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        contentLength,
                        blobContentLength,
                        version,
                        timeout,
                        tier,
                        blobContentType,
                        blobContentEncoding,
                        blobContentLanguage,
                        blobContentHash,
                        blobCacheControl,
                        metadata,
                        leaseId,
                        blobContentDisposition,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        blobSequenceNumber,
                        requestId,
                        blobTagsString))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return CreateAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.CreateAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="blobContentLength">This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned to a 512-byte boundary.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="tier">Optional. Indicates the tier to be set on the page blob.</param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="blobSequenceNumber">Set for page blobs only. The sequence number is a user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 2^63 - 1.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <returns>The PageBlob.CreateAsync Message.</returns>
            internal static Azure.Core.HttpMessage CreateAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                long contentLength,
                long blobContentLength,
                string version,
                int? timeout = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                string blobContentType = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                byte[] blobContentHash = default,
                string blobCacheControl = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string blobContentDisposition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                long? blobSequenceNumber = default,
                string requestId = default,
                string blobTagsString = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-blob-type", "PageBlob");
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-blob-content-length", blobContentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (tier != null) { _request.Headers.SetValue("x-ms-access-tier", tier.ToString()); }
                if (blobContentType != null) { _request.Headers.SetValue("x-ms-blob-content-type", blobContentType); }
                if (blobContentEncoding != null) { _request.Headers.SetValue("x-ms-blob-content-encoding", blobContentEncoding); }
                if (blobContentLanguage != null) { _request.Headers.SetValue("x-ms-blob-content-language", blobContentLanguage); }
                if (blobContentHash != null) { _request.Headers.SetValue("x-ms-blob-content-md5", System.Convert.ToBase64String(blobContentHash)); }
                if (blobCacheControl != null) { _request.Headers.SetValue("x-ms-blob-cache-control", blobCacheControl); }
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (blobContentDisposition != null) { _request.Headers.SetValue("x-ms-blob-content-disposition", blobContentDisposition); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (blobSequenceNumber != null) { _request.Headers.SetValue("x-ms-blob-sequence-number", blobSequenceNumber.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (blobTagsString != null) { _request.Headers.SetValue("x-ms-tags", blobTagsString); }

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.CreateAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.CreateAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContentInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContentInfo> CreateAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobContentInfo _value = new Azure.Storage.Blobs.Models.BlobContentInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.CreateAsync

            #region PageBlob.UploadPagesAsync
            /// <summary>
            /// The Upload Pages operation writes a range of pages to a page blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="body">Initial data</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifSequenceNumberLessThanOrEqualTo">Specify this header value to operate only on a blob if it has a sequence number less than or equal to the specified.</param>
            /// <param name="ifSequenceNumberLessThan">Specify this header value to operate only on a blob if it has a sequence number less than the specified.</param>
            /// <param name="ifSequenceNumberEqualTo">Specify this header value to operate only on a blob if it has the specified sequence number.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.PageInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.PageInfo>> UploadPagesAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.IO.Stream body,
                long contentLength,
                string version,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                int? timeout = default,
                string range = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                long? ifSequenceNumberLessThanOrEqualTo = default,
                long? ifSequenceNumberLessThan = default,
                long? ifSequenceNumberEqualTo = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "PageBlobClient.UploadPages",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = UploadPagesAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        body,
                        contentLength,
                        version,
                        transactionalContentHash,
                        transactionalContentCrc64,
                        timeout,
                        range,
                        leaseId,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        ifSequenceNumberLessThanOrEqualTo,
                        ifSequenceNumberLessThan,
                        ifSequenceNumberEqualTo,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return UploadPagesAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.UploadPagesAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="body">Initial data</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifSequenceNumberLessThanOrEqualTo">Specify this header value to operate only on a blob if it has a sequence number less than or equal to the specified.</param>
            /// <param name="ifSequenceNumberLessThan">Specify this header value to operate only on a blob if it has a sequence number less than the specified.</param>
            /// <param name="ifSequenceNumberEqualTo">Specify this header value to operate only on a blob if it has the specified sequence number.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The PageBlob.UploadPagesAsync Message.</returns>
            internal static Azure.Core.HttpMessage UploadPagesAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.IO.Stream body,
                long contentLength,
                string version,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                int? timeout = default,
                string range = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                long? ifSequenceNumberLessThanOrEqualTo = default,
                long? ifSequenceNumberLessThan = default,
                long? ifSequenceNumberEqualTo = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (body == null)
                {
                    throw new System.ArgumentNullException(nameof(body));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "page", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-page-write", "update");
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (transactionalContentHash != null) { _request.Headers.SetValue("Content-MD5", System.Convert.ToBase64String(transactionalContentHash)); }
                if (transactionalContentCrc64 != null) { _request.Headers.SetValue("x-ms-content-crc64", System.Convert.ToBase64String(transactionalContentCrc64)); }
                if (range != null) { _request.Headers.SetValue("x-ms-range", range); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (ifSequenceNumberLessThanOrEqualTo != null) { _request.Headers.SetValue("x-ms-if-sequence-number-le", ifSequenceNumberLessThanOrEqualTo.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifSequenceNumberLessThan != null) { _request.Headers.SetValue("x-ms-if-sequence-number-lt", ifSequenceNumberLessThan.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifSequenceNumberEqualTo != null) { _request.Headers.SetValue("x-ms-if-sequence-number-eq", ifSequenceNumberEqualTo.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                // Create the body
                _request.Content = Azure.Core.RequestContent.Create(body);

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.UploadPagesAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.UploadPagesAsync Azure.Response{Azure.Storage.Blobs.Models.PageInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.PageInfo> UploadPagesAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.PageInfo _value = new Azure.Storage.Blobs.Models.PageInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.UploadPagesAsync

            #region PageBlob.ClearPagesAsync
            /// <summary>
            /// The Clear Pages operation clears a set of pages from a page blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifSequenceNumberLessThanOrEqualTo">Specify this header value to operate only on a blob if it has a sequence number less than or equal to the specified.</param>
            /// <param name="ifSequenceNumberLessThan">Specify this header value to operate only on a blob if it has a sequence number less than the specified.</param>
            /// <param name="ifSequenceNumberEqualTo">Specify this header value to operate only on a blob if it has the specified sequence number.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.PageInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.PageInfo>> ClearPagesAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                long contentLength,
                string version,
                int? timeout = default,
                string range = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                long? ifSequenceNumberLessThanOrEqualTo = default,
                long? ifSequenceNumberLessThan = default,
                long? ifSequenceNumberEqualTo = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "PageBlobClient.ClearPages",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ClearPagesAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        contentLength,
                        version,
                        timeout,
                        range,
                        leaseId,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        ifSequenceNumberLessThanOrEqualTo,
                        ifSequenceNumberLessThan,
                        ifSequenceNumberEqualTo,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ClearPagesAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.ClearPagesAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifSequenceNumberLessThanOrEqualTo">Specify this header value to operate only on a blob if it has a sequence number less than or equal to the specified.</param>
            /// <param name="ifSequenceNumberLessThan">Specify this header value to operate only on a blob if it has a sequence number less than the specified.</param>
            /// <param name="ifSequenceNumberEqualTo">Specify this header value to operate only on a blob if it has the specified sequence number.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The PageBlob.ClearPagesAsync Message.</returns>
            internal static Azure.Core.HttpMessage ClearPagesAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                long contentLength,
                string version,
                int? timeout = default,
                string range = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                long? ifSequenceNumberLessThanOrEqualTo = default,
                long? ifSequenceNumberLessThan = default,
                long? ifSequenceNumberEqualTo = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "page", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-page-write", "clear");
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (range != null) { _request.Headers.SetValue("x-ms-range", range); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (ifSequenceNumberLessThanOrEqualTo != null) { _request.Headers.SetValue("x-ms-if-sequence-number-le", ifSequenceNumberLessThanOrEqualTo.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifSequenceNumberLessThan != null) { _request.Headers.SetValue("x-ms-if-sequence-number-lt", ifSequenceNumberLessThan.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifSequenceNumberEqualTo != null) { _request.Headers.SetValue("x-ms-if-sequence-number-eq", ifSequenceNumberEqualTo.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.ClearPagesAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.ClearPagesAsync Azure.Response{Azure.Storage.Blobs.Models.PageInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.PageInfo> ClearPagesAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.PageInfo _value = new Azure.Storage.Blobs.Models.PageInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.ClearPagesAsync

            #region PageBlob.UploadPagesFromUriAsync
            /// <summary>
            /// The Upload Pages operation writes a range of pages to a page blob where the contents are read from a URL
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="sourceUri">Specify a URL to the copy source.</param>
            /// <param name="sourceRange">Bytes of source data in the specified range. The length of this range should match the ContentLength header and x-ms-range/Range destination range header.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="range">The range of bytes to which the source range would be written. The range should be 512 aligned and range-end is required.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="sourceContentHash">Specify the md5 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="sourceContentcrc64">Specify the crc64 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifSequenceNumberLessThanOrEqualTo">Specify this header value to operate only on a blob if it has a sequence number less than or equal to the specified.</param>
            /// <param name="ifSequenceNumberLessThan">Specify this header value to operate only on a blob if it has a sequence number less than the specified.</param>
            /// <param name="ifSequenceNumberEqualTo">Specify this header value to operate only on a blob if it has the specified sequence number.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.PageInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.PageInfo>> UploadPagesFromUriAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri sourceUri,
                string sourceRange,
                long contentLength,
                string range,
                string version,
                byte[] sourceContentHash = default,
                byte[] sourceContentcrc64 = default,
                int? timeout = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                string leaseId = default,
                long? ifSequenceNumberLessThanOrEqualTo = default,
                long? ifSequenceNumberLessThan = default,
                long? ifSequenceNumberEqualTo = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default,
                bool async = true,
                string operationName = "PageBlobClient.UploadPagesFromUri",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = UploadPagesFromUriAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        sourceUri,
                        sourceRange,
                        contentLength,
                        range,
                        version,
                        sourceContentHash,
                        sourceContentcrc64,
                        timeout,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        leaseId,
                        ifSequenceNumberLessThanOrEqualTo,
                        ifSequenceNumberLessThan,
                        ifSequenceNumberEqualTo,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        sourceIfModifiedSince,
                        sourceIfUnmodifiedSince,
                        sourceIfMatch,
                        sourceIfNoneMatch,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return UploadPagesFromUriAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.UploadPagesFromUriAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="sourceUri">Specify a URL to the copy source.</param>
            /// <param name="sourceRange">Bytes of source data in the specified range. The length of this range should match the ContentLength header and x-ms-range/Range destination range header.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="range">The range of bytes to which the source range would be written. The range should be 512 aligned and range-end is required.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="sourceContentHash">Specify the md5 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="sourceContentcrc64">Specify the crc64 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifSequenceNumberLessThanOrEqualTo">Specify this header value to operate only on a blob if it has a sequence number less than or equal to the specified.</param>
            /// <param name="ifSequenceNumberLessThan">Specify this header value to operate only on a blob if it has a sequence number less than the specified.</param>
            /// <param name="ifSequenceNumberEqualTo">Specify this header value to operate only on a blob if it has the specified sequence number.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The PageBlob.UploadPagesFromUriAsync Message.</returns>
            internal static Azure.Core.HttpMessage UploadPagesFromUriAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri sourceUri,
                string sourceRange,
                long contentLength,
                string range,
                string version,
                byte[] sourceContentHash = default,
                byte[] sourceContentcrc64 = default,
                int? timeout = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                string leaseId = default,
                long? ifSequenceNumberLessThanOrEqualTo = default,
                long? ifSequenceNumberLessThan = default,
                long? ifSequenceNumberEqualTo = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (sourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(sourceUri));
                }
                if (sourceRange == null)
                {
                    throw new System.ArgumentNullException(nameof(sourceRange));
                }
                if (range == null)
                {
                    throw new System.ArgumentNullException(nameof(range));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "page", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-page-write", "update");
                _request.Headers.SetValue("x-ms-copy-source", sourceUri.AbsoluteUri);
                _request.Headers.SetValue("x-ms-source-range", sourceRange);
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-range", range);
                _request.Headers.SetValue("x-ms-version", version);
                if (sourceContentHash != null) { _request.Headers.SetValue("x-ms-source-content-md5", System.Convert.ToBase64String(sourceContentHash)); }
                if (sourceContentcrc64 != null) { _request.Headers.SetValue("x-ms-source-content-crc64", System.Convert.ToBase64String(sourceContentcrc64)); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifSequenceNumberLessThanOrEqualTo != null) { _request.Headers.SetValue("x-ms-if-sequence-number-le", ifSequenceNumberLessThanOrEqualTo.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifSequenceNumberLessThan != null) { _request.Headers.SetValue("x-ms-if-sequence-number-lt", ifSequenceNumberLessThan.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifSequenceNumberEqualTo != null) { _request.Headers.SetValue("x-ms-if-sequence-number-eq", ifSequenceNumberEqualTo.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (sourceIfModifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-modified-since", sourceIfModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfUnmodifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfMatch != null) { _request.Headers.SetValue("x-ms-source-if-match", sourceIfMatch.Value.ToString()); }
                if (sourceIfNoneMatch != null) { _request.Headers.SetValue("x-ms-source-if-none-match", sourceIfNoneMatch.Value.ToString()); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.UploadPagesFromUriAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.UploadPagesFromUriAsync Azure.Response{Azure.Storage.Blobs.Models.PageInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.PageInfo> UploadPagesFromUriAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.PageInfo _value = new Azure.Storage.Blobs.Models.PageInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.ConditionNotMetError _value = new Azure.Storage.Blobs.Models.ConditionNotMetError();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-error-code", out _header))
                        {
                            _value.ErrorCode = _header;
                        }

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.UploadPagesFromUriAsync

            #region PageBlob.GetPageRangesAsync
            /// <summary>
            /// The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot of a page blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.PageRangesInfoInternal}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.PageRangesInfoInternal>> GetPageRangesAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                int? timeout = default,
                string range = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "PageBlobClient.GetPageRanges",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetPageRangesAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        snapshot,
                        timeout,
                        range,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetPageRangesAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.GetPageRangesAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The PageBlob.GetPageRangesAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetPageRangesAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                int? timeout = default,
                string range = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "pagelist", escapeValue: false);
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (range != null) { _request.Headers.SetValue("x-ms-range", range); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.GetPageRangesAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.GetPageRangesAsync Azure.Response{Azure.Storage.Blobs.Models.PageRangesInfoInternal}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.PageRangesInfoInternal> GetPageRangesAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.PageRangesInfoInternal _value = new Azure.Storage.Blobs.Models.PageRangesInfoInternal();
                        _value.Body = Azure.Storage.Blobs.Models.PageList.FromXml(_xml.Root);

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-content-length", out _header))
                        {
                            _value.BlobContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.PageRangesInfoInternal>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.GetPageRangesAsync

            #region PageBlob.GetPageRangesDiffAsync
            /// <summary>
            /// The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob that were changed between target blob and previous snapshot.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="prevsnapshot">Optional in version 2015-07-08 and newer. The prevsnapshot parameter is a DateTime value that specifies that the response will contain only pages that were changed between target blob and previous snapshot. Changed pages include both updated and cleared pages. The target blob may be a snapshot, as long as the snapshot specified by prevsnapshot is the older of the two. Note that incremental snapshots are currently supported only for blobs created on or after January 1, 2016.</param>
            /// <param name="prevSnapshotUrl">Optional. This header is only supported in service versions 2019-04-19 and after and specifies the URL of a previous snapshot of the target blob. The response will only contain pages that were changed between the target blob and its previous snapshot.</param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.PageRangesInfoInternal}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.PageRangesInfoInternal>> GetPageRangesDiffAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                int? timeout = default,
                string prevsnapshot = default,
                System.Uri prevSnapshotUrl = default,
                string range = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "PageBlobClient.GetPageRangesDiff",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetPageRangesDiffAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        snapshot,
                        timeout,
                        prevsnapshot,
                        prevSnapshotUrl,
                        range,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetPageRangesDiffAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.GetPageRangesDiffAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="prevsnapshot">Optional in version 2015-07-08 and newer. The prevsnapshot parameter is a DateTime value that specifies that the response will contain only pages that were changed between target blob and previous snapshot. Changed pages include both updated and cleared pages. The target blob may be a snapshot, as long as the snapshot specified by prevsnapshot is the older of the two. Note that incremental snapshots are currently supported only for blobs created on or after January 1, 2016.</param>
            /// <param name="prevSnapshotUrl">Optional. This header is only supported in service versions 2019-04-19 and after and specifies the URL of a previous snapshot of the target blob. The response will only contain pages that were changed between the target blob and its previous snapshot.</param>
            /// <param name="range">Return only the bytes of the blob in the specified range.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The PageBlob.GetPageRangesDiffAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetPageRangesDiffAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                string snapshot = default,
                int? timeout = default,
                string prevsnapshot = default,
                System.Uri prevSnapshotUrl = default,
                string range = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "pagelist", escapeValue: false);
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (prevsnapshot != null) { _request.Uri.AppendQuery("prevsnapshot", prevsnapshot); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (prevSnapshotUrl != null) { _request.Headers.SetValue("x-ms-previous-snapshot-url", prevSnapshotUrl.AbsoluteUri); }
                if (range != null) { _request.Headers.SetValue("x-ms-range", range); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.GetPageRangesDiffAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.GetPageRangesDiffAsync Azure.Response{Azure.Storage.Blobs.Models.PageRangesInfoInternal}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.PageRangesInfoInternal> GetPageRangesDiffAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.PageRangesInfoInternal _value = new Azure.Storage.Blobs.Models.PageRangesInfoInternal();
                        _value.Body = Azure.Storage.Blobs.Models.PageList.FromXml(_xml.Root);

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-content-length", out _header))
                        {
                            _value.BlobContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.PageRangesInfoInternal>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.GetPageRangesDiffAsync

            #region PageBlob.ResizeAsync
            /// <summary>
            /// Resize the Blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blobContentLength">This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned to a 512-byte boundary.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.PageBlobInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.PageBlobInfo>> ResizeAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                long blobContentLength,
                string version,
                int? timeout = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "PageBlobClient.Resize",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = ResizeAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        blobContentLength,
                        version,
                        timeout,
                        leaseId,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return ResizeAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.ResizeAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blobContentLength">This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned to a 512-byte boundary.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The PageBlob.ResizeAsync Message.</returns>
            internal static Azure.Core.HttpMessage ResizeAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                long blobContentLength,
                string version,
                int? timeout = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "properties", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-blob-content-length", blobContentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.ResizeAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.ResizeAsync Azure.Response{Azure.Storage.Blobs.Models.PageBlobInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.PageBlobInfo> ResizeAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.PageBlobInfo _value = new Azure.Storage.Blobs.Models.PageBlobInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.ResizeAsync

            #region PageBlob.UpdateSequenceNumberAsync
            /// <summary>
            /// Update the sequence number of the blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="sequenceNumberAction">Required if the x-ms-blob-sequence-number header is set for the request. This property applies to page blobs only. This property indicates how the service should modify the blob's sequence number</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="blobSequenceNumber">Set for page blobs only. The sequence number is a user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 2^63 - 1.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.PageBlobInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.PageBlobInfo>> UpdateSequenceNumberAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.SequenceNumberAction sequenceNumberAction,
                string version,
                int? timeout = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                long? blobSequenceNumber = default,
                string requestId = default,
                bool async = true,
                string operationName = "PageBlobClient.UpdateSequenceNumber",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = UpdateSequenceNumberAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        sequenceNumberAction,
                        version,
                        timeout,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        blobSequenceNumber,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return UpdateSequenceNumberAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.UpdateSequenceNumberAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="sequenceNumberAction">Required if the x-ms-blob-sequence-number header is set for the request. This property applies to page blobs only. This property indicates how the service should modify the blob's sequence number</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="blobSequenceNumber">Set for page blobs only. The sequence number is a user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 2^63 - 1.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The PageBlob.UpdateSequenceNumberAsync Message.</returns>
            internal static Azure.Core.HttpMessage UpdateSequenceNumberAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.SequenceNumberAction sequenceNumberAction,
                string version,
                int? timeout = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                long? blobSequenceNumber = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "properties", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-sequence-number-action", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(sequenceNumberAction));
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (blobSequenceNumber != null) { _request.Headers.SetValue("x-ms-blob-sequence-number", blobSequenceNumber.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.UpdateSequenceNumberAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.UpdateSequenceNumberAsync Azure.Response{Azure.Storage.Blobs.Models.PageBlobInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.PageBlobInfo> UpdateSequenceNumberAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.PageBlobInfo _value = new Azure.Storage.Blobs.Models.PageBlobInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.UpdateSequenceNumberAsync

            #region PageBlob.CopyIncrementalAsync
            /// <summary>
            /// The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob. The snapshot is copied such that only the differential changes between the previously copied snapshot are transferred to the destination. The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual. This API is supported since REST version 2016-05-31.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="copySource">Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobCopyInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobCopyInfo>> CopyIncrementalAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri copySource,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "PageBlobClient.CopyIncremental",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = CopyIncrementalAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        copySource,
                        version,
                        timeout,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return CopyIncrementalAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the PageBlob.CopyIncrementalAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="copySource">Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The PageBlob.CopyIncrementalAsync Message.</returns>
            internal static Azure.Core.HttpMessage CopyIncrementalAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri copySource,
                string version,
                int? timeout = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (copySource == null)
                {
                    throw new System.ArgumentNullException(nameof(copySource));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "incrementalcopy", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-copy-source", copySource.AbsoluteUri);
                _request.Headers.SetValue("x-ms-version", version);
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the PageBlob.CopyIncrementalAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The PageBlob.CopyIncrementalAsync Azure.Response{Azure.Storage.Blobs.Models.BlobCopyInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobCopyInfo> CopyIncrementalAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 202:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobCopyInfo _value = new Azure.Storage.Blobs.Models.BlobCopyInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-id", out _header))
                        {
                            _value.CopyId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-copy-status", out _header))
                        {
                            _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion PageBlob.CopyIncrementalAsync
        }
        #endregion PageBlob operations

        #region AppendBlob operations
        /// <summary>
        /// AppendBlob operations for Azure Blob Storage
        /// </summary>
        public static partial class AppendBlob
        {
            #region AppendBlob.CreateAsync
            /// <summary>
            /// The Create Append Blob operation creates a new append blob.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContentInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContentInfo>> CreateAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                long contentLength,
                string version,
                int? timeout = default,
                string blobContentType = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                byte[] blobContentHash = default,
                string blobCacheControl = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string blobContentDisposition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                string blobTagsString = default,
                bool async = true,
                string operationName = "AppendBlobClient.Create",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = CreateAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        contentLength,
                        version,
                        timeout,
                        blobContentType,
                        blobContentEncoding,
                        blobContentLanguage,
                        blobContentHash,
                        blobCacheControl,
                        metadata,
                        leaseId,
                        blobContentDisposition,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId,
                        blobTagsString))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return CreateAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the AppendBlob.CreateAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <returns>The AppendBlob.CreateAsync Message.</returns>
            internal static Azure.Core.HttpMessage CreateAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                long contentLength,
                string version,
                int? timeout = default,
                string blobContentType = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                byte[] blobContentHash = default,
                string blobCacheControl = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string blobContentDisposition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                string blobTagsString = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-blob-type", "AppendBlob");
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (blobContentType != null) { _request.Headers.SetValue("x-ms-blob-content-type", blobContentType); }
                if (blobContentEncoding != null) { _request.Headers.SetValue("x-ms-blob-content-encoding", blobContentEncoding); }
                if (blobContentLanguage != null) { _request.Headers.SetValue("x-ms-blob-content-language", blobContentLanguage); }
                if (blobContentHash != null) { _request.Headers.SetValue("x-ms-blob-content-md5", System.Convert.ToBase64String(blobContentHash)); }
                if (blobCacheControl != null) { _request.Headers.SetValue("x-ms-blob-cache-control", blobCacheControl); }
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (blobContentDisposition != null) { _request.Headers.SetValue("x-ms-blob-content-disposition", blobContentDisposition); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (blobTagsString != null) { _request.Headers.SetValue("x-ms-tags", blobTagsString); }

                return _message;
            }

            /// <summary>
            /// Create the AppendBlob.CreateAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The AppendBlob.CreateAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContentInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContentInfo> CreateAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobContentInfo _value = new Azure.Storage.Blobs.Models.BlobContentInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion AppendBlob.CreateAsync

            #region AppendBlob.AppendBlockAsync
            /// <summary>
            /// The Append Block operation commits a new block of data to the end of an existing append blob. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="body">Initial data</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="maxSize">Optional conditional header. The max length in bytes permitted for the append blob. If the Append Block operation would cause the blob to exceed that limit or if the blob size is already greater than the value specified in this header, the request will fail with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="appendPosition">Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare. Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobAppendInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobAppendInfo>> AppendBlockAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.IO.Stream body,
                long contentLength,
                string version,
                int? timeout = default,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                string leaseId = default,
                long? maxSize = default,
                long? appendPosition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "AppendBlobClient.AppendBlock",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = AppendBlockAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        body,
                        contentLength,
                        version,
                        timeout,
                        transactionalContentHash,
                        transactionalContentCrc64,
                        leaseId,
                        maxSize,
                        appendPosition,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return AppendBlockAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the AppendBlob.AppendBlockAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="body">Initial data</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="maxSize">Optional conditional header. The max length in bytes permitted for the append blob. If the Append Block operation would cause the blob to exceed that limit or if the blob size is already greater than the value specified in this header, the request will fail with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="appendPosition">Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare. Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The AppendBlob.AppendBlockAsync Message.</returns>
            internal static Azure.Core.HttpMessage AppendBlockAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.IO.Stream body,
                long contentLength,
                string version,
                int? timeout = default,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                string leaseId = default,
                long? maxSize = default,
                long? appendPosition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (body == null)
                {
                    throw new System.ArgumentNullException(nameof(body));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "appendblock", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (transactionalContentHash != null) { _request.Headers.SetValue("Content-MD5", System.Convert.ToBase64String(transactionalContentHash)); }
                if (transactionalContentCrc64 != null) { _request.Headers.SetValue("x-ms-content-crc64", System.Convert.ToBase64String(transactionalContentCrc64)); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (maxSize != null) { _request.Headers.SetValue("x-ms-blob-condition-maxsize", maxSize.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (appendPosition != null) { _request.Headers.SetValue("x-ms-blob-condition-appendpos", appendPosition.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                // Create the body
                _request.Content = Azure.Core.RequestContent.Create(body);

                return _message;
            }

            /// <summary>
            /// Create the AppendBlob.AppendBlockAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The AppendBlob.AppendBlockAsync Azure.Response{Azure.Storage.Blobs.Models.BlobAppendInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobAppendInfo> AppendBlockAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobAppendInfo _value = new Azure.Storage.Blobs.Models.BlobAppendInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-append-offset", out _header))
                        {
                            _value.BlobAppendOffset = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-committed-block-count", out _header))
                        {
                            _value.BlobCommittedBlockCount = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-request-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion AppendBlob.AppendBlockAsync

            #region AppendBlob.AppendBlockFromUriAsync
            /// <summary>
            /// The Append Block operation commits a new block of data to the end of an existing append blob where the contents are read from a source url. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="sourceUri">Specify a URL to the copy source.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="sourceRange">Bytes of source data in the specified range.</param>
            /// <param name="sourceContentHash">Specify the md5 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="sourceContentcrc64">Specify the crc64 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="maxSize">Optional conditional header. The max length in bytes permitted for the append blob. If the Append Block operation would cause the blob to exceed that limit or if the blob size is already greater than the value specified in this header, the request will fail with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="appendPosition">Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare. Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobAppendInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobAppendInfo>> AppendBlockFromUriAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri sourceUri,
                long contentLength,
                string version,
                string sourceRange = default,
                byte[] sourceContentHash = default,
                byte[] sourceContentcrc64 = default,
                int? timeout = default,
                byte[] transactionalContentHash = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                string leaseId = default,
                long? maxSize = default,
                long? appendPosition = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default,
                bool async = true,
                string operationName = "AppendBlobClient.AppendBlockFromUri",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = AppendBlockFromUriAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        sourceUri,
                        contentLength,
                        version,
                        sourceRange,
                        sourceContentHash,
                        sourceContentcrc64,
                        timeout,
                        transactionalContentHash,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        leaseId,
                        maxSize,
                        appendPosition,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        sourceIfModifiedSince,
                        sourceIfUnmodifiedSince,
                        sourceIfMatch,
                        sourceIfNoneMatch,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return AppendBlockFromUriAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the AppendBlob.AppendBlockFromUriAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="sourceUri">Specify a URL to the copy source.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="sourceRange">Bytes of source data in the specified range.</param>
            /// <param name="sourceContentHash">Specify the md5 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="sourceContentcrc64">Specify the crc64 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="maxSize">Optional conditional header. The max length in bytes permitted for the append blob. If the Append Block operation would cause the blob to exceed that limit or if the blob size is already greater than the value specified in this header, the request will fail with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="appendPosition">Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare. Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The AppendBlob.AppendBlockFromUriAsync Message.</returns>
            internal static Azure.Core.HttpMessage AppendBlockFromUriAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.Uri sourceUri,
                long contentLength,
                string version,
                string sourceRange = default,
                byte[] sourceContentHash = default,
                byte[] sourceContentcrc64 = default,
                int? timeout = default,
                byte[] transactionalContentHash = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                string leaseId = default,
                long? maxSize = default,
                long? appendPosition = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (sourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(sourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "appendblock", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-copy-source", sourceUri.AbsoluteUri);
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (sourceRange != null) { _request.Headers.SetValue("x-ms-source-range", sourceRange); }
                if (sourceContentHash != null) { _request.Headers.SetValue("x-ms-source-content-md5", System.Convert.ToBase64String(sourceContentHash)); }
                if (sourceContentcrc64 != null) { _request.Headers.SetValue("x-ms-source-content-crc64", System.Convert.ToBase64String(sourceContentcrc64)); }
                if (transactionalContentHash != null) { _request.Headers.SetValue("Content-MD5", System.Convert.ToBase64String(transactionalContentHash)); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (maxSize != null) { _request.Headers.SetValue("x-ms-blob-condition-maxsize", maxSize.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (appendPosition != null) { _request.Headers.SetValue("x-ms-blob-condition-appendpos", appendPosition.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (sourceIfModifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-modified-since", sourceIfModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfUnmodifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfMatch != null) { _request.Headers.SetValue("x-ms-source-if-match", sourceIfMatch.Value.ToString()); }
                if (sourceIfNoneMatch != null) { _request.Headers.SetValue("x-ms-source-if-none-match", sourceIfNoneMatch.Value.ToString()); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the AppendBlob.AppendBlockFromUriAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The AppendBlob.AppendBlockFromUriAsync Azure.Response{Azure.Storage.Blobs.Models.BlobAppendInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobAppendInfo> AppendBlockFromUriAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobAppendInfo _value = new Azure.Storage.Blobs.Models.BlobAppendInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-append-offset", out _header))
                        {
                            _value.BlobAppendOffset = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-committed-block-count", out _header))
                        {
                            _value.BlobCommittedBlockCount = int.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-request-server-encrypted", out _header))
                        {
                            _value.IsServerEncrypted = bool.Parse(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.ConditionNotMetError _value = new Azure.Storage.Blobs.Models.ConditionNotMetError();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-error-code", out _header))
                        {
                            _value.ErrorCode = _header;
                        }

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion AppendBlob.AppendBlockFromUriAsync

            #region AppendBlob.SealAsync
            /// <summary>
            /// The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version 2019-12-12 version or later.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="appendPosition">Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare. Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.AppendBlobSealInternal}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.AppendBlobSealInternal>> SealAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                long? appendPosition = default,
                bool async = true,
                string operationName = "AppendBlobClient.Seal",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SealAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        requestId,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        appendPosition))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SealAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the AppendBlob.SealAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="appendPosition">Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare. Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).</param>
            /// <returns>The AppendBlob.SealAsync Message.</returns>
            internal static Azure.Core.HttpMessage SealAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string requestId = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                long? appendPosition = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "seal", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (appendPosition != null) { _request.Headers.SetValue("x-ms-blob-condition-appendpos", appendPosition.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                return _message;
            }

            /// <summary>
            /// Create the AppendBlob.SealAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The AppendBlob.SealAsync Azure.Response{Azure.Storage.Blobs.Models.AppendBlobSealInternal}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.AppendBlobSealInternal> SealAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.AppendBlobSealInternal _value = new Azure.Storage.Blobs.Models.AppendBlobSealInternal();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sealed", out _header))
                        {
                            _value.IsSealed = bool.Parse(_header);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion AppendBlob.SealAsync
        }
        #endregion AppendBlob operations

        #region BlockBlob operations
        /// <summary>
        /// BlockBlob operations for Azure Blob Storage
        /// </summary>
        public static partial class BlockBlob
        {
            #region BlockBlob.UploadAsync
            /// <summary>
            /// The Upload Block Blob operation updates the content of an existing block blob. Updating an existing block blob overwrites any existing metadata on the blob. Partial updates are not supported with Put Blob; the content of the existing blob is overwritten with the content of the new blob. To perform a partial update of the content of a block blob, use the Put Block List operation.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="body">Initial data</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="tier">Optional. Indicates the tier to be set on the blob.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContentInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContentInfo>> UploadAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.IO.Stream body,
                long contentLength,
                string version,
                int? timeout = default,
                byte[] transactionalContentHash = default,
                string blobContentType = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                byte[] blobContentHash = default,
                string blobCacheControl = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string blobContentDisposition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                string blobTagsString = default,
                bool async = true,
                string operationName = "BlockBlobClient.Upload",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = UploadAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        body,
                        contentLength,
                        version,
                        timeout,
                        transactionalContentHash,
                        blobContentType,
                        blobContentEncoding,
                        blobContentLanguage,
                        blobContentHash,
                        blobCacheControl,
                        metadata,
                        leaseId,
                        blobContentDisposition,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        tier,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId,
                        blobTagsString))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return UploadAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the BlockBlob.UploadAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="body">Initial data</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="tier">Optional. Indicates the tier to be set on the blob.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <returns>The BlockBlob.UploadAsync Message.</returns>
            internal static Azure.Core.HttpMessage UploadAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                System.IO.Stream body,
                long contentLength,
                string version,
                int? timeout = default,
                byte[] transactionalContentHash = default,
                string blobContentType = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                byte[] blobContentHash = default,
                string blobCacheControl = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string blobContentDisposition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                string blobTagsString = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (body == null)
                {
                    throw new System.ArgumentNullException(nameof(body));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-blob-type", "BlockBlob");
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (transactionalContentHash != null) { _request.Headers.SetValue("Content-MD5", System.Convert.ToBase64String(transactionalContentHash)); }
                if (blobContentType != null) { _request.Headers.SetValue("x-ms-blob-content-type", blobContentType); }
                if (blobContentEncoding != null) { _request.Headers.SetValue("x-ms-blob-content-encoding", blobContentEncoding); }
                if (blobContentLanguage != null) { _request.Headers.SetValue("x-ms-blob-content-language", blobContentLanguage); }
                if (blobContentHash != null) { _request.Headers.SetValue("x-ms-blob-content-md5", System.Convert.ToBase64String(blobContentHash)); }
                if (blobCacheControl != null) { _request.Headers.SetValue("x-ms-blob-cache-control", blobCacheControl); }
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (blobContentDisposition != null) { _request.Headers.SetValue("x-ms-blob-content-disposition", blobContentDisposition); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (tier != null) { _request.Headers.SetValue("x-ms-access-tier", tier.ToString()); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (blobTagsString != null) { _request.Headers.SetValue("x-ms-tags", blobTagsString); }

                // Create the body
                _request.Content = Azure.Core.RequestContent.Create(body);

                return _message;
            }

            /// <summary>
            /// Create the BlockBlob.UploadAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The BlockBlob.UploadAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContentInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContentInfo> UploadAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobContentInfo _value = new Azure.Storage.Blobs.Models.BlobContentInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion BlockBlob.UploadAsync

            #region BlockBlob.StageBlockAsync
            /// <summary>
            /// The Stage Block operation creates a new block to be committed as part of a blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blockId">A valid Base64 string value that identifies the block. Prior to encoding, the string must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified for the blockid parameter must be the same size for each block.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="body">Initial data</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlockInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlockInfo>> StageBlockAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string blockId,
                long contentLength,
                System.IO.Stream body,
                string version,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                int? timeout = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlockBlobClient.StageBlock",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = StageBlockAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        blockId,
                        contentLength,
                        body,
                        version,
                        transactionalContentHash,
                        transactionalContentCrc64,
                        timeout,
                        leaseId,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return StageBlockAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the BlockBlob.StageBlockAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blockId">A valid Base64 string value that identifies the block. Prior to encoding, the string must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified for the blockid parameter must be the same size for each block.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="body">Initial data</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The BlockBlob.StageBlockAsync Message.</returns>
            internal static Azure.Core.HttpMessage StageBlockAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string blockId,
                long contentLength,
                System.IO.Stream body,
                string version,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                int? timeout = default,
                string leaseId = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (blockId == null)
                {
                    throw new System.ArgumentNullException(nameof(blockId));
                }
                if (body == null)
                {
                    throw new System.ArgumentNullException(nameof(body));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "block", escapeValue: false);
                _request.Uri.AppendQuery("blockid", blockId);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-version", version);
                if (transactionalContentHash != null) { _request.Headers.SetValue("Content-MD5", System.Convert.ToBase64String(transactionalContentHash)); }
                if (transactionalContentCrc64 != null) { _request.Headers.SetValue("x-ms-content-crc64", System.Convert.ToBase64String(transactionalContentCrc64)); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                // Create the body
                _request.Content = Azure.Core.RequestContent.Create(body);

                return _message;
            }

            /// <summary>
            /// Create the BlockBlob.StageBlockAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The BlockBlob.StageBlockAsync Azure.Response{Azure.Storage.Blobs.Models.BlockInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlockInfo> StageBlockAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlockInfo _value = new Azure.Storage.Blobs.Models.BlockInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion BlockBlob.StageBlockAsync

            #region BlockBlob.StageBlockFromUriAsync
            /// <summary>
            /// The Stage Block operation creates a new block to be committed as part of a blob where the contents are read from a URL.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blockId">A valid Base64 string value that identifies the block. Prior to encoding, the string must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified for the blockid parameter must be the same size for each block.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="sourceUri">Specify a URL to the copy source.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="sourceRange">Bytes of source data in the specified range.</param>
            /// <param name="sourceContentHash">Specify the md5 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="sourceContentcrc64">Specify the crc64 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlockInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlockInfo>> StageBlockFromUriAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string blockId,
                long contentLength,
                System.Uri sourceUri,
                string version,
                string sourceRange = default,
                byte[] sourceContentHash = default,
                byte[] sourceContentcrc64 = default,
                int? timeout = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                string leaseId = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlockBlobClient.StageBlockFromUri",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = StageBlockFromUriAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        blockId,
                        contentLength,
                        sourceUri,
                        version,
                        sourceRange,
                        sourceContentHash,
                        sourceContentcrc64,
                        timeout,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        leaseId,
                        sourceIfModifiedSince,
                        sourceIfUnmodifiedSince,
                        sourceIfMatch,
                        sourceIfNoneMatch,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return StageBlockFromUriAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the BlockBlob.StageBlockFromUriAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blockId">A valid Base64 string value that identifies the block. Prior to encoding, the string must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified for the blockid parameter must be the same size for each block.</param>
            /// <param name="contentLength">The length of the request.</param>
            /// <param name="sourceUri">Specify a URL to the copy source.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="sourceRange">Bytes of source data in the specified range.</param>
            /// <param name="sourceContentHash">Specify the md5 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="sourceContentcrc64">Specify the crc64 calculated for the range of bytes that must be read from the copy source.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The BlockBlob.StageBlockFromUriAsync Message.</returns>
            internal static Azure.Core.HttpMessage StageBlockFromUriAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string blockId,
                long contentLength,
                System.Uri sourceUri,
                string version,
                string sourceRange = default,
                byte[] sourceContentHash = default,
                byte[] sourceContentcrc64 = default,
                int? timeout = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                string leaseId = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (blockId == null)
                {
                    throw new System.ArgumentNullException(nameof(blockId));
                }
                if (sourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(sourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "block", escapeValue: false);
                _request.Uri.AppendQuery("blockid", blockId);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("Content-Length", contentLength.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Headers.SetValue("x-ms-copy-source", sourceUri.AbsoluteUri);
                _request.Headers.SetValue("x-ms-version", version);
                if (sourceRange != null) { _request.Headers.SetValue("x-ms-source-range", sourceRange); }
                if (sourceContentHash != null) { _request.Headers.SetValue("x-ms-source-content-md5", System.Convert.ToBase64String(sourceContentHash)); }
                if (sourceContentcrc64 != null) { _request.Headers.SetValue("x-ms-source-content-crc64", System.Convert.ToBase64String(sourceContentcrc64)); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (sourceIfModifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-modified-since", sourceIfModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfUnmodifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfMatch != null) { _request.Headers.SetValue("x-ms-source-if-match", sourceIfMatch.Value.ToString()); }
                if (sourceIfNoneMatch != null) { _request.Headers.SetValue("x-ms-source-if-none-match", sourceIfNoneMatch.Value.ToString()); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the BlockBlob.StageBlockFromUriAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The BlockBlob.StageBlockFromUriAsync Azure.Response{Azure.Storage.Blobs.Models.BlockInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlockInfo> StageBlockFromUriAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlockInfo _value = new Azure.Storage.Blobs.Models.BlockInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-content-crc64", out _header))
                        {
                            _value.ContentCrc64 = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.ConditionNotMetError _value = new Azure.Storage.Blobs.Models.ConditionNotMetError();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-error-code", out _header))
                        {
                            _value.ErrorCode = _header;
                        }

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion BlockBlob.StageBlockFromUriAsync

            #region BlockBlob.CommitBlockListAsync
            /// <summary>
            /// The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob. In order to be written as part of a blob, a block must have been successfully written to the server in a prior Put Block operation. You can call Put Block List to update a blob by uploading only those blocks that have changed, then committing the new and existing blocks together. You can do this by specifying whether to commit a block from the committed block list or from the uncommitted block list, or to commit the most recently uploaded version of the block, whichever list it may belong to.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blocks">A list of block IDs split between the committed block list, in the uncommitted block list, or in the uncommitted block list first and then in the committed block list.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="tier">Optional. Indicates the tier to be set on the blob.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.BlobContentInfo}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.BlobContentInfo>> CommitBlockListAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.BlockLookupList blocks,
                string version,
                int? timeout = default,
                string blobCacheControl = default,
                string blobContentType = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                byte[] blobContentHash = default,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string blobContentDisposition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                string blobTagsString = default,
                bool async = true,
                string operationName = "BlockBlobClient.CommitBlockList",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = CommitBlockListAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        blocks,
                        version,
                        timeout,
                        blobCacheControl,
                        blobContentType,
                        blobContentEncoding,
                        blobContentLanguage,
                        blobContentHash,
                        transactionalContentHash,
                        transactionalContentCrc64,
                        metadata,
                        leaseId,
                        blobContentDisposition,
                        encryptionKey,
                        encryptionKeySha256,
                        encryptionAlgorithm,
                        encryptionScope,
                        tier,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        ifTags,
                        requestId,
                        blobTagsString))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return CommitBlockListAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the BlockBlob.CommitBlockListAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="blocks">A list of block IDs split between the committed block list, in the uncommitted block list, or in the uncommitted block list first and then in the committed block list.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="blobCacheControl">Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentType">Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentEncoding">Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentLanguage">Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read request.</param>
            /// <param name="blobContentHash">Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks were validated when each was uploaded.</param>
            /// <param name="transactionalContentHash">Specify the transactional md5 for the body, to be validated by the service.</param>
            /// <param name="transactionalContentCrc64">Specify the transactional crc64 for the body, to be validated by the service.</param>
            /// <param name="metadata">Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="blobContentDisposition">Optional. Sets the blob's Content-Disposition header.</param>
            /// <param name="encryptionKey">Optional. Specifies the encryption key to use to encrypt the data provided in the request. If not specified, encryption is performed with the root account encryption key.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="encryptionKeySha256">The SHA-256 hash of the provided encryption key. Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionAlgorithm">The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.</param>
            /// <param name="encryptionScope">Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.</param>
            /// <param name="tier">Optional. Indicates the tier to be set on the blob.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="blobTagsString">Optional. A URL encoded query param string which specifies the tags to be created with the Blob object. e.g. TagName1=TagValue1&amp;TagName2=TagValue2. The x-ms-tags header may contain up to 2kb of tags.</param>
            /// <returns>The BlockBlob.CommitBlockListAsync Message.</returns>
            internal static Azure.Core.HttpMessage CommitBlockListAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.BlockLookupList blocks,
                string version,
                int? timeout = default,
                string blobCacheControl = default,
                string blobContentType = default,
                string blobContentEncoding = default,
                string blobContentLanguage = default,
                byte[] blobContentHash = default,
                byte[] transactionalContentHash = default,
                byte[] transactionalContentCrc64 = default,
                System.Collections.Generic.IDictionary<string, string> metadata = default,
                string leaseId = default,
                string blobContentDisposition = default,
                string encryptionKey = default,
                string encryptionKeySha256 = default,
                Azure.Storage.Blobs.Models.EncryptionAlgorithmType? encryptionAlgorithm = default,
                string encryptionScope = default,
                Azure.Storage.Blobs.Models.AccessTier? tier = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string ifTags = default,
                string requestId = default,
                string blobTagsString = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (blocks == null)
                {
                    throw new System.ArgumentNullException(nameof(blocks));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "blocklist", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (blobCacheControl != null) { _request.Headers.SetValue("x-ms-blob-cache-control", blobCacheControl); }
                if (blobContentType != null) { _request.Headers.SetValue("x-ms-blob-content-type", blobContentType); }
                if (blobContentEncoding != null) { _request.Headers.SetValue("x-ms-blob-content-encoding", blobContentEncoding); }
                if (blobContentLanguage != null) { _request.Headers.SetValue("x-ms-blob-content-language", blobContentLanguage); }
                if (blobContentHash != null) { _request.Headers.SetValue("x-ms-blob-content-md5", System.Convert.ToBase64String(blobContentHash)); }
                if (transactionalContentHash != null) { _request.Headers.SetValue("Content-MD5", System.Convert.ToBase64String(transactionalContentHash)); }
                if (transactionalContentCrc64 != null) { _request.Headers.SetValue("x-ms-content-crc64", System.Convert.ToBase64String(transactionalContentCrc64)); }
                if (metadata != null) {
                    foreach (System.Collections.Generic.KeyValuePair<string, string> _pair in metadata)
                    {
                        _request.Headers.SetValue("x-ms-meta-" + _pair.Key, _pair.Value);
                    }
                }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (blobContentDisposition != null) { _request.Headers.SetValue("x-ms-blob-content-disposition", blobContentDisposition); }
                if (encryptionKey != null) { _request.Headers.SetValue("x-ms-encryption-key", encryptionKey); }
                if (encryptionKeySha256 != null) { _request.Headers.SetValue("x-ms-encryption-key-sha256", encryptionKeySha256); }
                if (encryptionAlgorithm != null) { _request.Headers.SetValue("x-ms-encryption-algorithm", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(encryptionAlgorithm.Value)); }
                if (encryptionScope != null) { _request.Headers.SetValue("x-ms-encryption-scope", encryptionScope); }
                if (tier != null) { _request.Headers.SetValue("x-ms-access-tier", tier.ToString()); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }
                if (blobTagsString != null) { _request.Headers.SetValue("x-ms-tags", blobTagsString); }

                // Create the body
                System.Xml.Linq.XElement _body = Azure.Storage.Blobs.Models.BlockLookupList.ToXml(blocks, "BlockList", "");
                string _text = _body.ToString(System.Xml.Linq.SaveOptions.DisableFormatting);
                _request.Headers.SetValue("Content-Type", "application/xml");
                _request.Headers.SetValue("Content-Length", _text.Length.ToString(System.Globalization.CultureInfo.InvariantCulture));
                _request.Content = Azure.Core.RequestContent.Create(System.Text.Encoding.UTF8.GetBytes(_text));

                return _message;
            }

            /// <summary>
            /// Create the BlockBlob.CommitBlockListAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The BlockBlob.CommitBlockListAsync Azure.Response{Azure.Storage.Blobs.Models.BlobContentInfo}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.BlobContentInfo> CommitBlockListAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.BlobContentInfo _value = new Azure.Storage.Blobs.Models.BlobContentInfo();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-MD5", out _header))
                        {
                            _value.ContentHash = System.Convert.FromBase64String(_header);
                        }
                        if (response.Headers.TryGetValue("x-ms-version-id", out _header))
                        {
                            _value.VersionId = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-key-sha256", out _header))
                        {
                            _value.EncryptionKeySha256 = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-encryption-scope", out _header))
                        {
                            _value.EncryptionScope = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-sequence-number", out _header))
                        {
                            _value.BlobSequenceNumber = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion BlockBlob.CommitBlockListAsync

            #region BlockBlob.GetBlockListAsync
            /// <summary>
            /// The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block blob
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="listType">Specifies whether to return the list of committed blocks, the list of uncommitted blocks, or both lists together.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.GetBlockListOperation}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.GetBlockListOperation>> GetBlockListAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.BlockListType listType,
                string version,
                string snapshot = default,
                int? timeout = default,
                string leaseId = default,
                string ifTags = default,
                string requestId = default,
                bool async = true,
                string operationName = "BlockBlobClient.GetBlockList",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetBlockListAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        listType,
                        version,
                        snapshot,
                        timeout,
                        leaseId,
                        ifTags,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetBlockListAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the BlockBlob.GetBlockListAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="listType">Specifies whether to return the list of committed blocks, the list of uncommitted blocks, or both lists together.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="snapshot">The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob">Creating a Snapshot of a Blob.</a></param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifTags">Specify a SQL where clause on blob tags to operate only on blobs with a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The BlockBlob.GetBlockListAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetBlockListAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                Azure.Storage.Blobs.Models.BlockListType listType,
                string version,
                string snapshot = default,
                int? timeout = default,
                string leaseId = default,
                string ifTags = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Get;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("comp", "blocklist", escapeValue: false);
                _request.Uri.AppendQuery("blocklisttype", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(listType));
                if (snapshot != null) { _request.Uri.AppendQuery("snapshot", snapshot); }
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifTags != null) { _request.Headers.SetValue("x-ms-if-tags", ifTags); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the BlockBlob.GetBlockListAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The BlockBlob.GetBlockListAsync Azure.Response{Azure.Storage.Blobs.Models.GetBlockListOperation}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.GetBlockListOperation> GetBlockListAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.GetBlockListOperation _value = new Azure.Storage.Blobs.Models.GetBlockListOperation();
                        _value.Body = Azure.Storage.Blobs.Models.BlockList.FromXml(_xml.Root);

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Content-Type", out _header))
                        {
                            _value.ContentType = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-blob-content-length", out _header))
                        {
                            _value.BlobContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.GetBlockListOperation>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.StorageError _value = Azure.Storage.Blobs.Models.StorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion BlockBlob.GetBlockListAsync
        }
        #endregion BlockBlob operations

        #region Directory operations
        /// <summary>
        /// Directory operations for Azure Blob Storage
        /// </summary>
        public static partial class Directory
        {
            #region Directory.CreateAsync
            /// <summary>
            /// Create a directory. By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: "*".
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="directoryProperties">Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixUmask">Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used.</param>
            /// <param name="cacheControl">Cache control for given resource</param>
            /// <param name="contentType">Content type for given resource</param>
            /// <param name="contentEncoding">Content encoding for given resource</param>
            /// <param name="contentLanguage">Content language for given resource</param>
            /// <param name="contentDisposition">Content disposition for given resource</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.DirectoryCreateResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.DirectoryCreateResult>> CreateAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string directoryProperties = default,
                string posixPermissions = default,
                string posixUmask = default,
                string cacheControl = default,
                string contentType = default,
                string contentEncoding = default,
                string contentLanguage = default,
                string contentDisposition = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string requestId = default,
                bool async = true,
                string operationName = "DirectoryClient.Create",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = CreateAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        directoryProperties,
                        posixPermissions,
                        posixUmask,
                        cacheControl,
                        contentType,
                        contentEncoding,
                        contentLanguage,
                        contentDisposition,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return CreateAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Directory.CreateAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="directoryProperties">Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixUmask">Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used.</param>
            /// <param name="cacheControl">Cache control for given resource</param>
            /// <param name="contentType">Content type for given resource</param>
            /// <param name="contentEncoding">Content encoding for given resource</param>
            /// <param name="contentLanguage">Content language for given resource</param>
            /// <param name="contentDisposition">Content disposition for given resource</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Directory.CreateAsync Message.</returns>
            internal static Azure.Core.HttpMessage CreateAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string directoryProperties = default,
                string posixPermissions = default,
                string posixUmask = default,
                string cacheControl = default,
                string contentType = default,
                string contentEncoding = default,
                string contentLanguage = default,
                string contentDisposition = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("resource", "directory", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (directoryProperties != null) { _request.Headers.SetValue("x-ms-properties", directoryProperties); }
                if (posixPermissions != null) { _request.Headers.SetValue("x-ms-permissions", posixPermissions); }
                if (posixUmask != null) { _request.Headers.SetValue("x-ms-umask", posixUmask); }
                if (cacheControl != null) { _request.Headers.SetValue("x-ms-cache-control", cacheControl); }
                if (contentType != null) { _request.Headers.SetValue("x-ms-content-type", contentType); }
                if (contentEncoding != null) { _request.Headers.SetValue("x-ms-content-encoding", contentEncoding); }
                if (contentLanguage != null) { _request.Headers.SetValue("x-ms-content-language", contentLanguage); }
                if (contentDisposition != null) { _request.Headers.SetValue("x-ms-content-disposition", contentDisposition); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Directory.CreateAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Directory.CreateAsync Azure.Response{Azure.Storage.Blobs.Models.DirectoryCreateResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.DirectoryCreateResult> CreateAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.DirectoryCreateResult _value = new Azure.Storage.Blobs.Models.DirectoryCreateResult();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-Length", out _header))
                        {
                            _value.ContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.DataLakeStorageError _value = Azure.Storage.Blobs.Models.DataLakeStorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Directory.CreateAsync

            #region Directory.RenameAsync
            /// <summary>
            /// Rename a directory. By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken. This operation supports conditional HTTP requests. For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations). To fail if the destination already exists, use a conditional request with If-None-Match: "*".
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="renameSource">The file or directory to be renamed. The value must have the following format: "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="marker">When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.</param>
            /// <param name="pathRenameMode">Determines the behavior of the rename operation</param>
            /// <param name="directoryProperties">Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixUmask">Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used.</param>
            /// <param name="cacheControl">Cache control for given resource</param>
            /// <param name="contentType">Content type for given resource</param>
            /// <param name="contentEncoding">Content encoding for given resource</param>
            /// <param name="contentLanguage">Content language for given resource</param>
            /// <param name="contentDisposition">Content disposition for given resource</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="sourceLeaseId">A lease ID for the source path. If specified, the source path must have an active lease and the lease ID must match.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.DirectoryRenameResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.DirectoryRenameResult>> RenameAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string renameSource,
                string version,
                int? timeout = default,
                string marker = default,
                Azure.Storage.Blobs.Models.PathRenameMode? pathRenameMode = default,
                string directoryProperties = default,
                string posixPermissions = default,
                string posixUmask = default,
                string cacheControl = default,
                string contentType = default,
                string contentEncoding = default,
                string contentLanguage = default,
                string contentDisposition = default,
                string leaseId = default,
                string sourceLeaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default,
                bool async = true,
                string operationName = "DirectoryClient.Rename",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = RenameAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        renameSource,
                        version,
                        timeout,
                        marker,
                        pathRenameMode,
                        directoryProperties,
                        posixPermissions,
                        posixUmask,
                        cacheControl,
                        contentType,
                        contentEncoding,
                        contentLanguage,
                        contentDisposition,
                        leaseId,
                        sourceLeaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        sourceIfModifiedSince,
                        sourceIfUnmodifiedSince,
                        sourceIfMatch,
                        sourceIfNoneMatch,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return RenameAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Directory.RenameAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="renameSource">The file or directory to be renamed. The value must have the following format: "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="marker">When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.</param>
            /// <param name="pathRenameMode">Determines the behavior of the rename operation</param>
            /// <param name="directoryProperties">Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixUmask">Only valid if Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory, and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used.</param>
            /// <param name="cacheControl">Cache control for given resource</param>
            /// <param name="contentType">Content type for given resource</param>
            /// <param name="contentEncoding">Content encoding for given resource</param>
            /// <param name="contentLanguage">Content language for given resource</param>
            /// <param name="contentDisposition">Content disposition for given resource</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="sourceLeaseId">A lease ID for the source path. If specified, the source path must have an active lease and the lease ID must match.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="sourceIfModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="sourceIfUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="sourceIfMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="sourceIfNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Directory.RenameAsync Message.</returns>
            internal static Azure.Core.HttpMessage RenameAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string renameSource,
                string version,
                int? timeout = default,
                string marker = default,
                Azure.Storage.Blobs.Models.PathRenameMode? pathRenameMode = default,
                string directoryProperties = default,
                string posixPermissions = default,
                string posixUmask = default,
                string cacheControl = default,
                string contentType = default,
                string contentEncoding = default,
                string contentLanguage = default,
                string contentDisposition = default,
                string leaseId = default,
                string sourceLeaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? sourceIfModifiedSince = default,
                System.DateTimeOffset? sourceIfUnmodifiedSince = default,
                Azure.ETag? sourceIfMatch = default,
                Azure.ETag? sourceIfNoneMatch = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (renameSource == null)
                {
                    throw new System.ArgumentNullException(nameof(renameSource));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Put;
                _request.Uri.Reset(resourceUri);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (marker != null) { _request.Uri.AppendQuery("continuation", marker); }
                if (pathRenameMode != null) { _request.Uri.AppendQuery("mode", Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(pathRenameMode.Value)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-rename-source", renameSource);
                _request.Headers.SetValue("x-ms-version", version);
                if (directoryProperties != null) { _request.Headers.SetValue("x-ms-properties", directoryProperties); }
                if (posixPermissions != null) { _request.Headers.SetValue("x-ms-permissions", posixPermissions); }
                if (posixUmask != null) { _request.Headers.SetValue("x-ms-umask", posixUmask); }
                if (cacheControl != null) { _request.Headers.SetValue("x-ms-cache-control", cacheControl); }
                if (contentType != null) { _request.Headers.SetValue("x-ms-content-type", contentType); }
                if (contentEncoding != null) { _request.Headers.SetValue("x-ms-content-encoding", contentEncoding); }
                if (contentLanguage != null) { _request.Headers.SetValue("x-ms-content-language", contentLanguage); }
                if (contentDisposition != null) { _request.Headers.SetValue("x-ms-content-disposition", contentDisposition); }
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (sourceLeaseId != null) { _request.Headers.SetValue("x-ms-source-lease-id", sourceLeaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (sourceIfModifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-modified-since", sourceIfModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfUnmodifiedSince != null) { _request.Headers.SetValue("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (sourceIfMatch != null) { _request.Headers.SetValue("x-ms-source-if-match", sourceIfMatch.Value.ToString()); }
                if (sourceIfNoneMatch != null) { _request.Headers.SetValue("x-ms-source-if-none-match", sourceIfNoneMatch.Value.ToString()); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Directory.RenameAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Directory.RenameAsync Azure.Response{Azure.Storage.Blobs.Models.DirectoryRenameResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.DirectoryRenameResult> RenameAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 201:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.DirectoryRenameResult _value = new Azure.Storage.Blobs.Models.DirectoryRenameResult();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-continuation", out _header))
                        {
                            _value.Marker = _header;
                        }
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("Content-Length", out _header))
                        {
                            _value.ContentLength = long.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.DataLakeStorageError _value = Azure.Storage.Blobs.Models.DataLakeStorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Directory.RenameAsync

            #region Directory.DeleteAsync
            /// <summary>
            /// Deletes the directory
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="recursiveDirectoryDelete">If "true", all paths beneath the directory will be deleted. If "false" and the directory is non-empty, an error occurs.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="marker">When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.DirectoryDeleteResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.DirectoryDeleteResult>> DeleteAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                bool recursiveDirectoryDelete,
                string version,
                int? timeout = default,
                string marker = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string requestId = default,
                bool async = true,
                string operationName = "DirectoryClient.Delete",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = DeleteAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        recursiveDirectoryDelete,
                        version,
                        timeout,
                        marker,
                        leaseId,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        ifMatch,
                        ifNoneMatch,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return DeleteAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Directory.DeleteAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="recursiveDirectoryDelete">If "true", all paths beneath the directory will be deleted. If "false" and the directory is non-empty, an error occurs.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="marker">When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Directory.DeleteAsync Message.</returns>
            internal static Azure.Core.HttpMessage DeleteAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                bool recursiveDirectoryDelete,
                string version,
                int? timeout = default,
                string marker = default,
                string leaseId = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Delete;
                _request.Uri.Reset(resourceUri);

                #pragma warning disable CA1308 // Normalize strings to uppercase
                _request.Uri.AppendQuery("recursive", recursiveDirectoryDelete.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant());
                #pragma warning restore CA1308 // Normalize strings to uppercase

                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (marker != null) { _request.Uri.AppendQuery("continuation", marker); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Directory.DeleteAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Directory.DeleteAsync Azure.Response{Azure.Storage.Blobs.Models.DirectoryDeleteResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.DirectoryDeleteResult> DeleteAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.DirectoryDeleteResult _value = new Azure.Storage.Blobs.Models.DirectoryDeleteResult();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("x-ms-continuation", out _header))
                        {
                            _value.Marker = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.DataLakeStorageError _value = Azure.Storage.Blobs.Models.DataLakeStorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Directory.DeleteAsync

            #region Directory.SetAccessControlAsync
            /// <summary>
            /// Set the owner, group, permissions, or access control list for a directory.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="owner">Optional. The owner of the blob or directory.</param>
            /// <param name="group">Optional. The owning group of the blob or directory.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixAcl">Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries. Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format "[scope:][type]:[id]:[permissions]".</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.DirectorySetAccessControlResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.DirectorySetAccessControlResult>> SetAccessControlAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                string owner = default,
                string group = default,
                string posixPermissions = default,
                string posixAcl = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "DirectoryClient.SetAccessControl",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = SetAccessControlAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        leaseId,
                        owner,
                        group,
                        posixPermissions,
                        posixAcl,
                        ifMatch,
                        ifNoneMatch,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return SetAccessControlAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Directory.SetAccessControlAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="owner">Optional. The owner of the blob or directory.</param>
            /// <param name="group">Optional. The owning group of the blob or directory.</param>
            /// <param name="posixPermissions">Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.</param>
            /// <param name="posixAcl">Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries. Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format "[scope:][type]:[id]:[permissions]".</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Directory.SetAccessControlAsync Message.</returns>
            internal static Azure.Core.HttpMessage SetAccessControlAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                string leaseId = default,
                string owner = default,
                string group = default,
                string posixPermissions = default,
                string posixAcl = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Patch;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("action", "setAccessControl", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (owner != null) { _request.Headers.SetValue("x-ms-owner", owner); }
                if (group != null) { _request.Headers.SetValue("x-ms-group", group); }
                if (posixPermissions != null) { _request.Headers.SetValue("x-ms-permissions", posixPermissions); }
                if (posixAcl != null) { _request.Headers.SetValue("x-ms-acl", posixAcl); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Directory.SetAccessControlAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Directory.SetAccessControlAsync Azure.Response{Azure.Storage.Blobs.Models.DirectorySetAccessControlResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.DirectorySetAccessControlResult> SetAccessControlAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.DirectorySetAccessControlResult _value = new Azure.Storage.Blobs.Models.DirectorySetAccessControlResult();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.DataLakeStorageError _value = Azure.Storage.Blobs.Models.DataLakeStorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Directory.SetAccessControlAsync

            #region Directory.GetAccessControlAsync
            /// <summary>
            /// Get the owner, group, permissions, or access control list for a directory.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance used for operation reporting.</param>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="upn">Optional. Valid only when Hierarchical Namespace is enabled for the account. If "true", the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If "false", the values will be returned as Azure Active Directory Object IDs. The default value is false.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <param name="async">Whether to invoke the operation asynchronously.  The default value is true.</param>
            /// <param name="operationName">Operation name.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>Azure.Response{Azure.Storage.Blobs.Models.DirectoryGetAccessControlResult}</returns>
            public static async System.Threading.Tasks.ValueTask<Azure.Response<Azure.Storage.Blobs.Models.DirectoryGetAccessControlResult>> GetAccessControlAsync(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                bool? upn = default,
                string leaseId = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default,
                bool async = true,
                string operationName = "DirectoryClient.GetAccessControl",
                System.Threading.CancellationToken cancellationToken = default)
            {
                Azure.Core.Pipeline.DiagnosticScope _scope = clientDiagnostics.CreateScope(operationName);
                try
                {
                    _scope.AddAttribute("url", resourceUri);
                    _scope.Start();
                    using (Azure.Core.HttpMessage _message = GetAccessControlAsync_CreateMessage(
                        pipeline,
                        resourceUri,
                        version,
                        timeout,
                        upn,
                        leaseId,
                        ifMatch,
                        ifNoneMatch,
                        ifModifiedSince,
                        ifUnmodifiedSince,
                        requestId))
                    {
                        if (async)
                        {
                            // Send the request asynchronously if we're being called via an async path
                            await pipeline.SendAsync(_message, cancellationToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Send the request synchronously through the API that blocks if we're being called via a sync path
                            // (this is safe because the Task will complete before the user can call Wait)
                            pipeline.Send(_message, cancellationToken);
                        }
                        Azure.Response _response = _message.Response;
                        cancellationToken.ThrowIfCancellationRequested();
                        return GetAccessControlAsync_CreateResponse(clientDiagnostics, _response);
                    }
                }
                catch (System.Exception ex)
                {
                    _scope.Failed(ex);
                    throw;
                }
                finally
                {
                    _scope.Dispose();
                }
            }

            /// <summary>
            /// Create the Directory.GetAccessControlAsync request.
            /// </summary>
            /// <param name="pipeline">The pipeline used for sending requests.</param>
            /// <param name="resourceUri">The URL of the service account, container, or blob that is the targe of the desired operation.</param>
            /// <param name="version">Specifies the version of the operation to use for this request.</param>
            /// <param name="timeout">The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting Timeouts for Blob Service Operations.</a></param>
            /// <param name="upn">Optional. Valid only when Hierarchical Namespace is enabled for the account. If "true", the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If "false", the values will be returned as Azure Active Directory Object IDs. The default value is false.</param>
            /// <param name="leaseId">If specified, the operation only succeeds if the resource's lease is active and matches this ID.</param>
            /// <param name="ifMatch">Specify an ETag value to operate only on blobs with a matching value.</param>
            /// <param name="ifNoneMatch">Specify an ETag value to operate only on blobs without a matching value.</param>
            /// <param name="ifModifiedSince">Specify this header value to operate only on a blob if it has been modified since the specified date/time.</param>
            /// <param name="ifUnmodifiedSince">Specify this header value to operate only on a blob if it has not been modified since the specified date/time.</param>
            /// <param name="requestId">Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.</param>
            /// <returns>The Directory.GetAccessControlAsync Message.</returns>
            internal static Azure.Core.HttpMessage GetAccessControlAsync_CreateMessage(
                Azure.Core.Pipeline.HttpPipeline pipeline,
                System.Uri resourceUri,
                string version,
                int? timeout = default,
                bool? upn = default,
                string leaseId = default,
                Azure.ETag? ifMatch = default,
                Azure.ETag? ifNoneMatch = default,
                System.DateTimeOffset? ifModifiedSince = default,
                System.DateTimeOffset? ifUnmodifiedSince = default,
                string requestId = default)
            {
                // Validation
                if (resourceUri == null)
                {
                    throw new System.ArgumentNullException(nameof(resourceUri));
                }
                if (version == null)
                {
                    throw new System.ArgumentNullException(nameof(version));
                }

                // Create the request
                Azure.Core.HttpMessage _message = pipeline.CreateMessage();
                Azure.Core.Request _request = _message.Request;

                // Set the endpoint
                _request.Method = Azure.Core.RequestMethod.Head;
                _request.Uri.Reset(resourceUri);
                _request.Uri.AppendQuery("action", "getAccessControl", escapeValue: false);
                if (timeout != null) { _request.Uri.AppendQuery("timeout", timeout.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)); }
                if (upn != null) {
                #pragma warning disable CA1308 // Normalize strings to uppercase
                _request.Uri.AppendQuery("upn", upn.Value.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant());
                #pragma warning restore CA1308 // Normalize strings to uppercase
                }

                // Add request headers
                _request.Headers.SetValue("x-ms-version", version);
                if (leaseId != null) { _request.Headers.SetValue("x-ms-lease-id", leaseId); }
                if (ifMatch != null) { _request.Headers.SetValue("If-Match", ifMatch.Value.ToString()); }
                if (ifNoneMatch != null) { _request.Headers.SetValue("If-None-Match", ifNoneMatch.Value.ToString()); }
                if (ifModifiedSince != null) { _request.Headers.SetValue("If-Modified-Since", ifModifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (ifUnmodifiedSince != null) { _request.Headers.SetValue("If-Unmodified-Since", ifUnmodifiedSince.Value.ToString("R", System.Globalization.CultureInfo.InvariantCulture)); }
                if (requestId != null) { _request.Headers.SetValue("x-ms-client-request-id", requestId); }

                return _message;
            }

            /// <summary>
            /// Create the Directory.GetAccessControlAsync response or throw a failure exception.
            /// </summary>
            /// <param name="clientDiagnostics">The ClientDiagnostics instance to use.</param>
            /// <param name="response">The raw Response.</param>
            /// <returns>The Directory.GetAccessControlAsync Azure.Response{Azure.Storage.Blobs.Models.DirectoryGetAccessControlResult}.</returns>
            internal static Azure.Response<Azure.Storage.Blobs.Models.DirectoryGetAccessControlResult> GetAccessControlAsync_CreateResponse(
                Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics,
                Azure.Response response)
            {
                // Process the response
                switch (response.Status)
                {
                    case 200:
                    {
                        // Create the result
                        Azure.Storage.Blobs.Models.DirectoryGetAccessControlResult _value = new Azure.Storage.Blobs.Models.DirectoryGetAccessControlResult();

                        // Get response headers
                        string _header;
                        if (response.Headers.TryGetValue("ETag", out _header))
                        {
                            _value.ETag = new Azure.ETag(_header);
                        }
                        if (response.Headers.TryGetValue("Last-Modified", out _header))
                        {
                            _value.LastModified = System.DateTimeOffset.Parse(_header, System.Globalization.CultureInfo.InvariantCulture);
                        }
                        if (response.Headers.TryGetValue("x-ms-owner", out _header))
                        {
                            _value.XMSOwner = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-group", out _header))
                        {
                            _value.XMSGroup = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-permissions", out _header))
                        {
                            _value.XMSPermissions = _header;
                        }
                        if (response.Headers.TryGetValue("x-ms-acl", out _header))
                        {
                            _value.XMSAcl = _header;
                        }

                        // Create the response
                        return Response.FromValue(_value, response);
                    }
                    case 304:
                    {
                        return new Azure.NoBodyResponse<Azure.Storage.Blobs.Models.DirectoryGetAccessControlResult>(response);
                    }
                    default:
                    {
                        // Create the result
                        System.Xml.Linq.XDocument _xml = System.Xml.Linq.XDocument.Load(response.ContentStream, System.Xml.Linq.LoadOptions.PreserveWhitespace);
                        Azure.Storage.Blobs.Models.DataLakeStorageError _value = Azure.Storage.Blobs.Models.DataLakeStorageError.FromXml(_xml.Root);

                        throw _value.CreateException(clientDiagnostics, response);
                    }
                }
            }
            #endregion Directory.GetAccessControlAsync
        }
        #endregion Directory operations
    }
}
#endregion Service

#region Models
#region enum strings AccessTier
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Indicates the tier to be set on the blob.
    /// </summary>
    public readonly struct AccessTier : System.IEquatable<AccessTier>
    {
        /// <summary>
        /// The AccessTier value.
        /// </summary>
        private readonly string _value;

        /// <summary>
        /// Initializes a new instance of the <see cref="AccessTier"/> structure.
        /// </summary>
        /// <param name="value">The string value of the instance.</param>
        public AccessTier(string value) { _value = value ?? throw new System.ArgumentNullException(nameof(value)); }

        /// <summary>
        /// P4
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P4 { get; } = new AccessTier(@"P4");

        /// <summary>
        /// P6
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P6 { get; } = new AccessTier(@"P6");

        /// <summary>
        /// P10
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P10 { get; } = new AccessTier(@"P10");

        /// <summary>
        /// P15
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P15 { get; } = new AccessTier(@"P15");

        /// <summary>
        /// P20
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P20 { get; } = new AccessTier(@"P20");

        /// <summary>
        /// P30
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P30 { get; } = new AccessTier(@"P30");

        /// <summary>
        /// P40
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P40 { get; } = new AccessTier(@"P40");

        /// <summary>
        /// P50
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P50 { get; } = new AccessTier(@"P50");

        /// <summary>
        /// P60
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P60 { get; } = new AccessTier(@"P60");

        /// <summary>
        /// P70
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P70 { get; } = new AccessTier(@"P70");

        /// <summary>
        /// P80
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier P80 { get; } = new AccessTier(@"P80");

        /// <summary>
        /// Hot
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier Hot { get; } = new AccessTier(@"Hot");

        /// <summary>
        /// Cool
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier Cool { get; } = new AccessTier(@"Cool");

        /// <summary>
        /// Archive
        /// </summary>
        public static Azure.Storage.Blobs.Models.AccessTier Archive { get; } = new AccessTier(@"Archive");

        /// <summary>
        /// Determines if two <see cref="AccessTier"/> values are the same.
        /// </summary>
        /// <param name="left">The first <see cref="AccessTier"/> to compare.</param>
        /// <param name="right">The second <see cref="AccessTier"/> to compare.</param>
        /// <returns>True if <paramref name="left"/> and <paramref name="right"/> are the same; otherwise, false.</returns>
        public static bool operator ==(Azure.Storage.Blobs.Models.AccessTier left, Azure.Storage.Blobs.Models.AccessTier right) => left.Equals(right);

        /// <summary>
        /// Determines if two <see cref="AccessTier"/> values are different.
        /// </summary>
        /// <param name="left">The first <see cref="AccessTier"/> to compare.</param>
        /// <param name="right">The second <see cref="AccessTier"/> to compare.</param>
        /// <returns>True if <paramref name="left"/> and <paramref name="right"/> are different; otherwise, false.</returns>
        public static bool operator !=(Azure.Storage.Blobs.Models.AccessTier left, Azure.Storage.Blobs.Models.AccessTier right) => !left.Equals(right);

        /// <summary>
        /// Converts a string to a <see cref="AccessTier"/>.
        /// </summary>
        /// <param name="value">The string value to convert.</param>
        /// <returns>The AccessTier value.</returns>
        public static implicit operator AccessTier(string value) => new Azure.Storage.Blobs.Models.AccessTier(value);

        /// <summary>
        /// Check if two <see cref="AccessTier"/> instances are equal.
        /// </summary>
        /// <param name="obj">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is Azure.Storage.Blobs.Models.AccessTier other && Equals(other);

        /// <summary>
        /// Check if two <see cref="AccessTier"/> instances are equal.
        /// </summary>
        /// <param name="other">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        public bool Equals(Azure.Storage.Blobs.Models.AccessTier other) => string.Equals(_value, other._value, System.StringComparison.Ordinal);

        /// <summary>
        /// Get a hash code for the <see cref="AccessTier"/>.
        /// </summary>
        /// <returns>Hash code for the AccessTier.</returns>
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        /// <summary>
        /// Convert the <see cref="AccessTier"/> to a string.
        /// </summary>
        /// <returns>String representation of the AccessTier.</returns>
        public override string ToString() => _value;
    }
}
#endregion enum strings AccessTier

#region class AccountInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// AccountInfo
    /// </summary>
    public partial class AccountInfo
    {
        /// <summary>
        /// Identifies the sku name of the account
        /// </summary>
        public Azure.Storage.Blobs.Models.SkuName SkuName { get; internal set; }

        /// <summary>
        /// Identifies the account kind
        /// </summary>
        public Azure.Storage.Blobs.Models.AccountKind AccountKind { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of AccountInfo instances.
        /// You can use BlobsModelFactory.AccountInfo instead.
        /// </summary>
        internal AccountInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new AccountInfo instance for mocking.
        /// </summary>
        public static AccountInfo AccountInfo(
            Azure.Storage.Blobs.Models.SkuName skuName,
            Azure.Storage.Blobs.Models.AccountKind accountKind)
        {
            return new AccountInfo()
            {
                SkuName = skuName,
                AccountKind = accountKind,
            };
        }
    }
}
#endregion class AccountInfo

#region enum AccountKind
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Identifies the account kind
    /// </summary>
    public enum AccountKind
    {
        /// <summary>
        /// Storage
        /// </summary>
        Storage,

        /// <summary>
        /// BlobStorage
        /// </summary>
        BlobStorage,

        /// <summary>
        /// StorageV2
        /// </summary>
        StorageV2,

        /// <summary>
        /// FileStorage
        /// </summary>
        FileStorage,

        /// <summary>
        /// BlockBlobStorage
        /// </summary>
        BlockBlobStorage
    }
}
#endregion enum AccountKind

#region class AppendBlobSealInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// AppendBlobSealInternal
    /// </summary>
    internal partial class AppendBlobSealInternal
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// If this blob has been sealed
        /// </summary>
        public bool IsSealed { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of AppendBlobSealInternal instances.
        /// You can use BlobsModelFactory.AppendBlobSealInternal instead.
        /// </summary>
        internal AppendBlobSealInternal() { }
    }
}
#endregion class AppendBlobSealInternal

#region enum ArchiveStatus
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// ArchiveStatus values
    /// </summary>
    #pragma warning disable CA1717 // Only FlagsAttribute enums should have plural names
    public enum ArchiveStatus
    #pragma warning restore CA1717 // Only FlagsAttribute enums should have plural names
    {
        /// <summary>
        /// rehydrate-pending-to-hot
        /// </summary>
        RehydratePendingToHot,

        /// <summary>
        /// rehydrate-pending-to-cool
        /// </summary>
        RehydratePendingToCool
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.ArchiveStatus value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.ArchiveStatus.RehydratePendingToHot => "rehydrate-pending-to-hot",
                    Azure.Storage.Blobs.Models.ArchiveStatus.RehydratePendingToCool => "rehydrate-pending-to-cool",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.ArchiveStatus value.")
                };
            }

            public static Azure.Storage.Blobs.Models.ArchiveStatus ParseArchiveStatus(string value)
            {
                return value switch
                {
                    "rehydrate-pending-to-hot" => Azure.Storage.Blobs.Models.ArchiveStatus.RehydratePendingToHot,
                    "rehydrate-pending-to-cool" => Azure.Storage.Blobs.Models.ArchiveStatus.RehydratePendingToCool,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.ArchiveStatus value.")
                };
            }
        }
    }
}
#endregion enum ArchiveStatus

#region class ArrowFieldInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// field of an arrow schema
    /// </summary>
    internal partial class ArrowFieldInternal
    {
        /// <summary>
        /// Type
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Precision
        /// </summary>
        public int? Precision { get; set; }

        /// <summary>
        /// Scale
        /// </summary>
        public int? Scale { get; set; }

        /// <summary>
        /// Creates a new ArrowFieldInternal instance
        /// </summary>
        public ArrowFieldInternal() { }

        /// <summary>
        /// Serialize a ArrowFieldInternal instance as XML.
        /// </summary>
        /// <param name="value">The ArrowFieldInternal instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "Field".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.ArrowFieldInternal value, string name = "Field", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Type", ""),
                value.Type));
            if (value.Name != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Name", ""),
                    value.Name));
            }
            if (value.Precision != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Precision", ""),
                    value.Precision.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)));
            }
            if (value.Scale != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Scale", ""),
                    value.Scale.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)));
            }
            return _element;
        }
    }
}
#endregion class ArrowFieldInternal

#region class ArrowTextConfigurationInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// arrow configuration
    /// </summary>
    internal partial class ArrowTextConfigurationInternal
    {
        /// <summary>
        /// Schema
        /// </summary>
        public System.Collections.Generic.IList<Azure.Storage.Blobs.Models.ArrowFieldInternal> Schema { get; internal set; }

        /// <summary>
        /// Creates a new ArrowTextConfigurationInternal instance
        /// </summary>
        public ArrowTextConfigurationInternal()
        {
            Schema = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.ArrowFieldInternal>();
        }

        /// <summary>
        /// Serialize a ArrowTextConfigurationInternal instance as XML.
        /// </summary>
        /// <param name="value">The ArrowTextConfigurationInternal instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "ArrowConfiguration".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.ArrowTextConfigurationInternal value, string name = "ArrowConfiguration", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            System.Xml.Linq.XElement _elements = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get("Schema", ""));
            foreach (Azure.Storage.Blobs.Models.ArrowFieldInternal _child in value.Schema)
            {
                _elements.Add(Azure.Storage.Blobs.Models.ArrowFieldInternal.ToXml(_child));
            }
            _element.Add(_elements);return _element;
        }
    }
}
#endregion class ArrowTextConfigurationInternal

#region class BlobGetAccessControlResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Blob GetAccessControlResult
    /// </summary>
    internal partial class BlobGetAccessControlResult
    {
        /// <summary>
        /// An HTTP entity tag associated with the file or directory.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The data and time the file or directory was last modified. Write operations on the file or directory update the last modified time.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The owner of the file or directory. Included in the response if Hierarchical Namespace is enabled for the account.
        /// </summary>
        public string XMSOwner { get; internal set; }

        /// <summary>
        /// The owning group of the file or directory. Included in the response if Hierarchical Namespace is enabled for the account.
        /// </summary>
        public string XMSGroup { get; internal set; }

        /// <summary>
        /// The POSIX access permissions for the file owner, the file owning group, and others. Included in the response if Hierarchical Namespace is enabled for the account.
        /// </summary>
        public string XMSPermissions { get; internal set; }

        /// <summary>
        /// The POSIX access control list for the file or directory.  Included in the response only if the action is "getAccessControl" and Hierarchical Namespace is enabled for the account.
        /// </summary>
        public string XMSAcl { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobGetAccessControlResult instances.
        /// You can use BlobsModelFactory.BlobGetAccessControlResult instead.
        /// </summary>
        internal BlobGetAccessControlResult() { }
    }
}
#endregion class BlobGetAccessControlResult

#region class BlobQueryResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Blob QueryResult
    /// </summary>
    internal partial class BlobQueryResult
    {
        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// x-ms-meta
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; internal set; }

        /// <summary>
        /// The number of bytes present in the response body.
        /// </summary>
        public long ContentLength { get; internal set; }

        /// <summary>
        /// The media type of the body of the response. For Download Blob this is 'application/octet-stream'
        /// </summary>
        public string ContentType { get; internal set; }

        /// <summary>
        /// Indicates the range of bytes returned in the event that the client requested a subset of the blob by setting the 'Range' request header.
        /// </summary>
        public string ContentRange { get; internal set; }

        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// If the blob has an MD5 hash and this operation is to read the full blob, this response header is returned so that the client can check for message content integrity.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// This header returns the value that was specified for the Content-Encoding request header
        /// </summary>
        public string ContentEncoding { get; internal set; }

        /// <summary>
        /// This header is returned if it was previously specified for the blob.
        /// </summary>
        public string CacheControl { get; internal set; }

        /// <summary>
        /// This header returns the value that was specified for the 'x-ms-blob-content-disposition' header. The Content-Disposition response header field conveys additional information about how to process the response payload, and also can be used to attach additional metadata. For example, if set to attachment, it indicates that the user-agent should not display the response, but instead show a Save As dialog with a filename other than the blob name specified.
        /// </summary>
        public string ContentDisposition { get; internal set; }

        /// <summary>
        /// This header returns the value that was specified for the Content-Language request header.
        /// </summary>
        public string ContentLanguage { get; internal set; }

        /// <summary>
        /// The current sequence number for a page blob. This header is not returned for block blobs or append blobs
        /// </summary>
        public long BlobSequenceNumber { get; internal set; }

        /// <summary>
        /// The blob's type.
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobType BlobType { get; internal set; }

        /// <summary>
        /// If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to true, then the request returns a crc64 for the range, as long as the range size is less than or equal to 4 MB. If both x-ms-range-get-content-crc64 and x-ms-range-get-content-md5 is specified in the same request, it will fail with 400(Bad Request)
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentCrc64 { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// Conclusion time of the last attempted Copy Blob operation where this blob was the destination blob. This value can specify the time of a completed, aborted, or failed copy attempt. This header does not appear if a copy is pending, if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List.
        /// </summary>
        public System.DateTimeOffset CopyCompletionTime { get; internal set; }

        /// <summary>
        /// Only appears when x-ms-copy-status is failed or pending. Describes the cause of the last fatal or non-fatal copy operation failure. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List
        /// </summary>
        public string CopyStatusDescription { get; internal set; }

        /// <summary>
        /// String identifier for this copy operation. Use with Get Blob Properties to check the status of this copy operation, or pass to Abort Copy Blob to abort a pending copy.
        /// </summary>
        public string CopyId { get; internal set; }

        /// <summary>
        /// Contains the number of bytes copied and the total bytes in the source in the last attempted Copy Blob operation where this blob was the destination blob. Can show between 0 and Content-Length bytes copied. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List
        /// </summary>
        public string CopyProgress { get; internal set; }

        /// <summary>
        /// URL up to 2 KB in length that specifies the source blob or file used in the last attempted Copy Blob operation where this blob was the destination blob. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List.
        /// </summary>
        public string CopySource { get; internal set; }

        /// <summary>
        /// State of the copy operation identified by x-ms-copy-id.
        /// </summary>
        public Azure.Storage.Blobs.Models.CopyStatus CopyStatus { get; internal set; }

        /// <summary>
        /// When a blob is leased, specifies whether the lease is of infinite or fixed duration.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseDurationType LeaseDuration { get; internal set; }

        /// <summary>
        /// Lease state of the blob.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseState LeaseState { get; internal set; }

        /// <summary>
        /// The current lease status of the blob.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseStatus LeaseStatus { get; internal set; }

        /// <summary>
        /// Indicates that the service supports requests for partial blob content.
        /// </summary>
        public string AcceptRanges { get; internal set; }

        /// <summary>
        /// The number of committed blocks present in the blob. This header is returned only for append blobs.
        /// </summary>
        public int BlobCommittedBlockCount { get; internal set; }

        /// <summary>
        /// The value of this header is set to true if the blob data and application metadata are completely encrypted using the specified algorithm. Otherwise, the value is set to false (when the blob is unencrypted, or if only parts of the blob/application metadata are encrypted).
        /// </summary>
        public bool IsServerEncrypted { get; internal set; }

        /// <summary>
        /// The SHA-256 hash of the encryption key used to encrypt the blob. This header is only returned when the blob was encrypted with a customer-provided key.
        /// </summary>
        public string EncryptionKeySha256 { get; internal set; }

        /// <summary>
        /// Returns the name of the encryption scope used to encrypt the blob contents and application metadata.  Note that the absence of this header implies use of the default account encryption scope.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// If the blob has a MD5 hash, and if request contains range header (Range or x-ms-range), this response header is returned with the value of the whole blob's MD5 value. This value may or may not be equal to the value returned in Content-MD5 header, with the latter calculated from the requested range
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] BlobContentMD5 { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// Body
        /// </summary>
        public System.IO.Stream Body { get; internal set; }

        /// <summary>
        /// Creates a new BlobQueryResult instance
        /// </summary>
        public BlobQueryResult()
        {
            Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
        }
    }
}
#endregion class BlobQueryResult

#region class BlobRenameResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Blob RenameResult
    /// </summary>
    internal partial class BlobRenameResult
    {
        /// <summary>
        /// An HTTP entity tag associated with the file or directory.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The data and time the file or directory was last modified.  Write operations on the file or directory update the last modified time.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The size of the resource in bytes.
        /// </summary>
        public long ContentLength { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobRenameResult instances.
        /// You can use BlobsModelFactory.BlobRenameResult instead.
        /// </summary>
        internal BlobRenameResult() { }
    }
}
#endregion class BlobRenameResult

#region class BlobSetAccessControlResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Blob SetAccessControlResult
    /// </summary>
    internal partial class BlobSetAccessControlResult
    {
        /// <summary>
        /// An HTTP entity tag associated with the file or directory.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The data and time the file or directory was last modified. Write operations on the file or directory update the last modified time.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobSetAccessControlResult instances.
        /// You can use BlobsModelFactory.BlobSetAccessControlResult instead.
        /// </summary>
        internal BlobSetAccessControlResult() { }
    }
}
#endregion class BlobSetAccessControlResult

#region class BlobAccessPolicy
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// An Access policy
    /// </summary>
    public partial class BlobAccessPolicy
    {
        /// <summary>
        /// the date-time the policy is active
        /// </summary>
        public System.DateTimeOffset? PolicyStartsOn { get; set; }

        /// <summary>
        /// the date-time the policy expires
        /// </summary>
        public System.DateTimeOffset? PolicyExpiresOn { get; set; }

        /// <summary>
        /// the permissions for the acl policy
        /// </summary>
        public string Permissions { get; set; }

        /// <summary>
        /// Creates a new BlobAccessPolicy instance
        /// </summary>
        public BlobAccessPolicy() { }

        /// <summary>
        /// Serialize a BlobAccessPolicy instance as XML.
        /// </summary>
        /// <param name="value">The BlobAccessPolicy instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "AccessPolicy".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobAccessPolicy value, string name = "AccessPolicy", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            if (value.PolicyStartsOn != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Start", ""),
                    value.PolicyStartsOn.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffZ", System.Globalization.CultureInfo.InvariantCulture)));
            }
            if (value.PolicyExpiresOn != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Expiry", ""),
                    value.PolicyExpiresOn.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffZ", System.Globalization.CultureInfo.InvariantCulture)));
            }
            if (value.Permissions != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Permission", ""),
                    value.Permissions));
            }
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobAccessPolicy instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobAccessPolicy instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobAccessPolicy FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobAccessPolicy _value = new Azure.Storage.Blobs.Models.BlobAccessPolicy();
            _child = element.Element(System.Xml.Linq.XName.Get("Start", ""));
            if (_child != null)
            {
                _value.PolicyStartsOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Expiry", ""));
            if (_child != null)
            {
                _value.PolicyExpiresOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Permission", ""));
            if (_child != null)
            {
                _value.Permissions = _child.Value;
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobAccessPolicy value);
    }
}
#endregion class BlobAccessPolicy

#region class BlobAnalyticsLogging
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Azure Analytics Logging settings.
    /// </summary>
    public partial class BlobAnalyticsLogging
    {
        /// <summary>
        /// The version of Storage Analytics to configure.
        /// </summary>
        public string Version { get; set; }

        /// <summary>
        /// Indicates whether all delete requests should be logged.
        /// </summary>
        public bool Delete { get; set; }

        /// <summary>
        /// Indicates whether all read requests should be logged.
        /// </summary>
        public bool Read { get; set; }

        /// <summary>
        /// Indicates whether all write requests should be logged.
        /// </summary>
        public bool Write { get; set; }

        /// <summary>
        /// the retention policy which determines how long the associated data should persist
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobRetentionPolicy RetentionPolicy { get; set; }

        /// <summary>
        /// Creates a new BlobAnalyticsLogging instance
        /// </summary>
        public BlobAnalyticsLogging()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobAnalyticsLogging instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobAnalyticsLogging(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                RetentionPolicy = new Azure.Storage.Blobs.Models.BlobRetentionPolicy();
            }
        }

        /// <summary>
        /// Serialize a BlobAnalyticsLogging instance as XML.
        /// </summary>
        /// <param name="value">The BlobAnalyticsLogging instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "Logging".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobAnalyticsLogging value, string name = "Logging", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Version", ""),
                value.Version));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Delete", ""),
                #pragma warning disable CA1308 // Normalize strings to uppercase
                value.Delete.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant()));
                #pragma warning restore CA1308 // Normalize strings to uppercase
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Read", ""),
                #pragma warning disable CA1308 // Normalize strings to uppercase
                value.Read.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant()));
                #pragma warning restore CA1308 // Normalize strings to uppercase
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Write", ""),
                #pragma warning disable CA1308 // Normalize strings to uppercase
                value.Write.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant()));
                #pragma warning restore CA1308 // Normalize strings to uppercase
            _element.Add(Azure.Storage.Blobs.Models.BlobRetentionPolicy.ToXml(value.RetentionPolicy, "RetentionPolicy", ""));
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobAnalyticsLogging instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobAnalyticsLogging instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobAnalyticsLogging FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobAnalyticsLogging _value = new Azure.Storage.Blobs.Models.BlobAnalyticsLogging(true);
            _child = element.Element(System.Xml.Linq.XName.Get("Version", ""));
            if (_child != null)
            {
                _value.Version = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Delete", ""));
            if (_child != null)
            {
                _value.Delete = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Read", ""));
            if (_child != null)
            {
                _value.Read = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Write", ""));
            if (_child != null)
            {
                _value.Write = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("RetentionPolicy", ""));
            if (_child != null)
            {
                _value.RetentionPolicy = Azure.Storage.Blobs.Models.BlobRetentionPolicy.FromXml(_child);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobAnalyticsLogging value);
    }
}
#endregion class BlobAnalyticsLogging

#region class BlobAppendInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobAppendInfo
    /// </summary>
    public partial class BlobAppendInfo
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// If the blob has an MD5 hash and this operation is to read the full blob, this response header is returned so that the client can check for message content integrity.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// This header is returned so that the client can check for message content integrity. The value of this header is computed by the Blob service; it is not necessarily the same value specified in the request headers.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentCrc64 { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// This response header is returned only for append operations. It returns the offset at which the block was committed, in bytes.
        /// </summary>
        public string BlobAppendOffset { get; internal set; }

        /// <summary>
        /// The number of committed blocks present in the blob. This header is returned only for append blobs.
        /// </summary>
        public int BlobCommittedBlockCount { get; internal set; }

        /// <summary>
        /// The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise.
        /// </summary>
        public bool IsServerEncrypted { get; internal set; }

        /// <summary>
        /// The SHA-256 hash of the encryption key used to encrypt the block. This header is only returned when the block was encrypted with a customer-provided key.
        /// </summary>
        public string EncryptionKeySha256 { get; internal set; }

        /// <summary>
        /// Returns the name of the encryption scope used to encrypt the blob contents and application metadata.  Note that the absence of this header implies use of the default account encryption scope.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobAppendInfo instances.
        /// You can use BlobsModelFactory.BlobAppendInfo instead.
        /// </summary>
        internal BlobAppendInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobAppendInfo instance for mocking.
        /// </summary>
        public static BlobAppendInfo BlobAppendInfo(
            Azure.ETag eTag,
            System.DateTimeOffset lastModified,
            byte[] contentHash,
            byte[] contentCrc64,
            string blobAppendOffset,
            int blobCommittedBlockCount,
            bool isServerEncrypted,
            string encryptionKeySha256,
            string encryptionScope)
        {
            return new BlobAppendInfo()
            {
                ETag = eTag,
                LastModified = lastModified,
                ContentHash = contentHash,
                ContentCrc64 = contentCrc64,
                BlobAppendOffset = blobAppendOffset,
                BlobCommittedBlockCount = blobCommittedBlockCount,
                IsServerEncrypted = isServerEncrypted,
                EncryptionKeySha256 = encryptionKeySha256,
                EncryptionScope = encryptionScope,
            };
        }
    }
}
#endregion class BlobAppendInfo

#region class BlobBatchResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobBatchResult
    /// </summary>
    internal partial class BlobBatchResult
    {
        /// <summary>
        /// The media type of the body of the response. For batch requests, this is multipart/mixed; boundary=batchresponse_GUID
        /// </summary>
        public string ContentType { get; internal set; }

        /// <summary>
        /// Content
        /// </summary>
        public System.IO.Stream Content { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobBatchResult instances.
        /// You can use BlobsModelFactory.BlobBatchResult instead.
        /// </summary>
        internal BlobBatchResult() { }
    }
}
#endregion class BlobBatchResult

#region struct BlobBlock
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Represents a single block in a block blob.  It describes the block's ID and size.
    /// </summary>
    public readonly partial struct BlobBlock: System.IEquatable<BlobBlock>
    {
        /// <summary>
        /// The base64 encoded block ID.
        /// </summary>
        public string Name { get; }

        /// <summary>
        /// The block size in bytes.
        /// </summary>
        public int Size { get; }

        /// <summary>
        /// Prevent direct instantiation of BlobBlock instances.
        /// You can use BlobsModelFactory.BlobBlock instead.
        /// </summary>
        internal BlobBlock(
            string name,
            int size)
            {
                Name = name;
                Size = size;
            }

        /// <summary>
        /// Check if two BlobBlock instances are equal.
        /// </summary>
        /// <param name="other">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        [System.ComponentModel.EditorBrowsable((System.ComponentModel.EditorBrowsableState.Never))]
        public bool Equals(BlobBlock other)
        {
            if (!System.StringComparer.Ordinal.Equals(Name, other.Name))
            {
                return false;
            }
            if (!Size.Equals(other.Size))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Check if two BlobBlock instances are equal.
        /// </summary>
        /// <param name="obj">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        [System.ComponentModel.EditorBrowsable((System.ComponentModel.EditorBrowsableState.Never))]
        public override bool Equals(object obj) => obj is BlobBlock && Equals((BlobBlock)obj);

        /// <summary>
        /// Get a hash code for the BlobBlock.
        /// </summary>
        [System.ComponentModel.EditorBrowsable((System.ComponentModel.EditorBrowsableState.Never))]
        public override int GetHashCode()
        {
            var hashCode = new Azure.Core.HashCodeBuilder();
            if (Name != null)
            {
                hashCode.Add(Name, System.StringComparer.Ordinal);
            }
            hashCode.Add(Size);

            return hashCode.ToHashCode();
        }

        /// <summary>
        /// Deserializes XML into a new BlobBlock instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobBlock instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobBlock FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            string name = default;
            int size = default;
            _child = element.Element(System.Xml.Linq.XName.Get("Name", ""));
            if (_child != null)
            {
                name = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Size", ""));
            if (_child != null)
            {
                size = int.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            Azure.Storage.Blobs.Models.BlobBlock _value = new Azure.Storage.Blobs.Models.BlobBlock(name, size);
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobBlock value);
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobBlock instance for mocking.
        /// </summary>
        public static BlobBlock BlobBlock(
            string name,
            int size)
        {
            return new BlobBlock(name, size);
        }
    }
}
#endregion struct BlobBlock

#region class BlobContainerAccessPolicy
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobContainerAccessPolicy
    /// </summary>
    public partial class BlobContainerAccessPolicy
    {
        /// <summary>
        /// Indicated whether data in the container may be accessed publicly and the level of access
        /// </summary>
        public Azure.Storage.Blobs.Models.PublicAccessType BlobPublicAccess { get; internal set; }

        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// a collection of signed identifiers
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobSignedIdentifier> SignedIdentifiers { get; internal set; }

        /// <summary>
        /// Creates a new BlobContainerAccessPolicy instance
        /// </summary>
        public BlobContainerAccessPolicy()
        {
            SignedIdentifiers = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobSignedIdentifier>();
        }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobContainerAccessPolicy instance for mocking.
        /// </summary>
        public static BlobContainerAccessPolicy BlobContainerAccessPolicy(
            Azure.Storage.Blobs.Models.PublicAccessType blobPublicAccess,
            Azure.ETag eTag,
            System.DateTimeOffset lastModified,
            System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobSignedIdentifier> signedIdentifiers)
        {
            return new BlobContainerAccessPolicy()
            {
                BlobPublicAccess = blobPublicAccess,
                ETag = eTag,
                LastModified = lastModified,
                SignedIdentifiers = signedIdentifiers,
            };
        }
    }
}
#endregion class BlobContainerAccessPolicy

#region class BlobContainerInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobContainerInfo
    /// </summary>
    public partial class BlobContainerInfo
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobContainerInfo instances.
        /// You can use BlobsModelFactory.BlobContainerInfo instead.
        /// </summary>
        internal BlobContainerInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobContainerInfo instance for mocking.
        /// </summary>
        public static BlobContainerInfo BlobContainerInfo(
            Azure.ETag eTag,
            System.DateTimeOffset lastModified)
        {
            return new BlobContainerInfo()
            {
                ETag = eTag,
                LastModified = lastModified,
            };
        }
    }
}
#endregion class BlobContainerInfo

#region class BlobContainerItem
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// An Azure Storage container
    /// </summary>
    public partial class BlobContainerItem
    {
        /// <summary>
        /// Name
        /// </summary>
        public string Name { get; internal set; }

        /// <summary>
        /// Deleted
        /// </summary>
        public bool? IsDeleted { get; internal set; }

        /// <summary>
        /// Version
        /// </summary>
        public string VersionId { get; internal set; }

        /// <summary>
        /// Properties of a container
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobContainerProperties Properties { get; internal set; }

        /// <summary>
        /// Creates a new BlobContainerItem instance
        /// </summary>
        internal BlobContainerItem()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobContainerItem instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobContainerItem(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                Properties = new Azure.Storage.Blobs.Models.BlobContainerProperties();
            }
        }

        /// <summary>
        /// Deserializes XML into a new BlobContainerItem instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobContainerItem instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobContainerItem FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobContainerItem _value = new Azure.Storage.Blobs.Models.BlobContainerItem(true);
            _child = element.Element(System.Xml.Linq.XName.Get("Name", ""));
            if (_child != null)
            {
                _value.Name = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Deleted", ""));
            if (_child != null)
            {
                _value.IsDeleted = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Version", ""));
            if (_child != null)
            {
                _value.VersionId = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Properties", ""));
            if (_child != null)
            {
                _value.Properties = Azure.Storage.Blobs.Models.BlobContainerProperties.FromXml(_child);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobContainerItem value);
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobContainerItem instance for mocking.
        /// </summary>
        public static BlobContainerItem BlobContainerItem(
            string name,
            Azure.Storage.Blobs.Models.BlobContainerProperties properties,
            bool? isDeleted = default,
            string versionId = default)
        {
            return new BlobContainerItem()
            {
                Name = name,
                Properties = properties,
                IsDeleted = isDeleted,
                VersionId = versionId,
            };
        }
    }
}
#endregion class BlobContainerItem

#region class BlobContainerProperties
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Properties of a container
    /// </summary>
    public partial class BlobContainerProperties
    {
        /// <summary>
        /// Last-Modified
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// LeaseStatus
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseStatus? LeaseStatus { get; internal set; }

        /// <summary>
        /// LeaseState
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseState? LeaseState { get; internal set; }

        /// <summary>
        /// LeaseDuration
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseDurationType? LeaseDuration { get; internal set; }

        /// <summary>
        /// PublicAccess
        /// </summary>
        public Azure.Storage.Blobs.Models.PublicAccessType? PublicAccess { get; internal set; }

        /// <summary>
        /// HasImmutabilityPolicy
        /// </summary>
        public bool? HasImmutabilityPolicy { get; internal set; }

        /// <summary>
        /// HasLegalHold
        /// </summary>
        public bool? HasLegalHold { get; internal set; }

        /// <summary>
        /// DefaultEncryptionScope
        /// </summary>
        public string DefaultEncryptionScope { get; internal set; }

        /// <summary>
        /// DenyEncryptionScopeOverride
        /// </summary>
        public bool? PreventEncryptionScopeOverride { get; internal set; }

        /// <summary>
        /// DeletedTime
        /// </summary>
        public System.DateTimeOffset? DeletedOn { get; internal set; }

        /// <summary>
        /// RemainingRetentionDays
        /// </summary>
        public int? RemainingRetentionDays { get; internal set; }

        /// <summary>
        /// ETag
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Metadata
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; internal set; }

        /// <summary>
        /// Creates a new BlobContainerProperties instance
        /// </summary>
        internal BlobContainerProperties()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobContainerProperties instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobContainerProperties(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
            }
        }

        /// <summary>
        /// Deserializes XML into a new BlobContainerProperties instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobContainerProperties instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobContainerProperties FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobContainerProperties _value = new Azure.Storage.Blobs.Models.BlobContainerProperties(true);
            _child = element.Element(System.Xml.Linq.XName.Get("Last-Modified", ""));
            if (_child != null)
            {
                _value.LastModified = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("LeaseStatus", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.LeaseStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseStatus(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("LeaseState", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.LeaseState = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseState(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("LeaseDuration", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.LeaseDuration = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseDurationType(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("PublicAccess", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.PublicAccess = Azure.Storage.Blobs.BlobRestClient.Serialization.ParsePublicAccessType(_child?.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("HasImmutabilityPolicy", ""));
            if (_child != null)
            {
                _value.HasImmutabilityPolicy = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("HasLegalHold", ""));
            if (_child != null)
            {
                _value.HasLegalHold = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("DefaultEncryptionScope", ""));
            if (_child != null)
            {
                _value.DefaultEncryptionScope = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("DenyEncryptionScopeOverride", ""));
            if (_child != null)
            {
                _value.PreventEncryptionScopeOverride = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("DeletedTime", ""));
            if (_child != null)
            {
                _value.DeletedOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("RemainingRetentionDays", ""));
            if (_child != null)
            {
                _value.RemainingRetentionDays = int.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Etag", ""));
            if (_child != null)
            {
                _value.ETag = new Azure.ETag(_child.Value);
            }
            _value.Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
            _child = element.Element(System.Xml.Linq.XName.Get("Metadata", ""));
            if (_child != null)
            {
                foreach (System.Xml.Linq.XElement _pair in _child.Elements())
                {
                    _value.Metadata[_pair.Name.LocalName] = _pair.Value;
                }
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobContainerProperties value);
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobContainerProperties instance for mocking.
        /// </summary>
        public static BlobContainerProperties BlobContainerProperties(
            System.DateTimeOffset lastModified,
            Azure.ETag eTag,
            Azure.Storage.Blobs.Models.LeaseState? leaseState = default,
            Azure.Storage.Blobs.Models.LeaseDurationType? leaseDuration = default,
            Azure.Storage.Blobs.Models.PublicAccessType? publicAccess = default,
            bool? hasImmutabilityPolicy = default,
            Azure.Storage.Blobs.Models.LeaseStatus? leaseStatus = default,
            string defaultEncryptionScope = default,
            bool? preventEncryptionScopeOverride = default,
            System.DateTimeOffset? deletedOn = default,
            int? remainingRetentionDays = default,
            System.Collections.Generic.IDictionary<string, string> metadata = default,
            bool? hasLegalHold = default)
        {
            return new BlobContainerProperties()
            {
                LastModified = lastModified,
                ETag = eTag,
                LeaseState = leaseState,
                LeaseDuration = leaseDuration,
                PublicAccess = publicAccess,
                HasImmutabilityPolicy = hasImmutabilityPolicy,
                LeaseStatus = leaseStatus,
                DefaultEncryptionScope = defaultEncryptionScope,
                PreventEncryptionScopeOverride = preventEncryptionScopeOverride,
                DeletedOn = deletedOn,
                RemainingRetentionDays = remainingRetentionDays,
                Metadata = metadata,
                HasLegalHold = hasLegalHold,
            };
        }
    }
}
#endregion class BlobContainerProperties

#region class BlobContainersSegment
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// An enumeration of containers
    /// </summary>
    internal partial class BlobContainersSegment
    {
        /// <summary>
        /// ServiceEndpoint
        /// </summary>
        public string ServiceEndpoint { get; internal set; }

        /// <summary>
        /// Prefix
        /// </summary>
        public string Prefix { get; internal set; }

        /// <summary>
        /// Marker
        /// </summary>
        public string Marker { get; internal set; }

        /// <summary>
        /// MaxResults
        /// </summary>
        public int? MaxResults { get; internal set; }

        /// <summary>
        /// NextMarker
        /// </summary>
        public string NextMarker { get; internal set; }

        /// <summary>
        /// BlobContainerItems
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobContainerItem> BlobContainerItems { get; internal set; }

        /// <summary>
        /// Creates a new BlobContainersSegment instance
        /// </summary>
        public BlobContainersSegment()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobContainersSegment instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobContainersSegment(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                BlobContainerItems = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobContainerItem>();
            }
        }

        /// <summary>
        /// Deserializes XML into a new BlobContainersSegment instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobContainersSegment instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobContainersSegment FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            System.Xml.Linq.XAttribute _attribute;
            Azure.Storage.Blobs.Models.BlobContainersSegment _value = new Azure.Storage.Blobs.Models.BlobContainersSegment(true);
            _attribute = element.Attribute(System.Xml.Linq.XName.Get("ServiceEndpoint", ""));
            if (_attribute != null)
            {
                _value.ServiceEndpoint = _attribute.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Prefix", ""));
            if (_child != null)
            {
                _value.Prefix = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Marker", ""));
            if (_child != null)
            {
                _value.Marker = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("MaxResults", ""));
            if (_child != null)
            {
                _value.MaxResults = int.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("NextMarker", ""));
            if (_child != null)
            {
                _value.NextMarker = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Containers", ""));
            if (_child != null)
            {
                _value.BlobContainerItems = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("Container", "")),
                        e => Azure.Storage.Blobs.Models.BlobContainerItem.FromXml(e)));
            }
            else
            {
                _value.BlobContainerItems = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobContainerItem>();
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobContainersSegment value);
    }
}
#endregion class BlobContainersSegment

#region class BlobContentInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobContentInfo
    /// </summary>
    public partial class BlobContentInfo
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// If the blob has an MD5 hash and this operation is to read the full blob, this response header is returned so that the client can check for message content integrity.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// A DateTime value returned by the service that uniquely identifies the blob. The value of this header indicates the blob version, and may be used in subsequent requests to access this version of the blob.
        /// </summary>
        public string VersionId { get; internal set; }

        /// <summary>
        /// The SHA-256 hash of the encryption key used to encrypt the blob. This header is only returned when the blob was encrypted with a customer-provided key.
        /// </summary>
        public string EncryptionKeySha256 { get; internal set; }

        /// <summary>
        /// Returns the name of the encryption scope used to encrypt the blob contents and application metadata.  Note that the absence of this header implies use of the default account encryption scope.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// The current sequence number for the page blob.  This is only returned for page blobs.
        /// </summary>
        public long BlobSequenceNumber { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobContentInfo instances.
        /// You can use BlobsModelFactory.BlobContentInfo instead.
        /// </summary>
        internal BlobContentInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobContentInfo instance for mocking.
        /// </summary>
        public static BlobContentInfo BlobContentInfo(
            Azure.ETag eTag,
            System.DateTimeOffset lastModified,
            byte[] contentHash,
            string versionId,
            string encryptionKeySha256,
            string encryptionScope,
            long blobSequenceNumber)
        {
            return new BlobContentInfo()
            {
                ETag = eTag,
                LastModified = lastModified,
                ContentHash = contentHash,
                VersionId = versionId,
                EncryptionKeySha256 = encryptionKeySha256,
                EncryptionScope = encryptionScope,
                BlobSequenceNumber = blobSequenceNumber,
            };
        }
    }
}
#endregion class BlobContentInfo

#region class BlobCopyInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobCopyInfo
    /// </summary>
    public partial class BlobCopyInfo
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// A DateTime value returned by the service that uniquely identifies the blob. The value of this header indicates the blob version, and may be used in subsequent requests to access this version of the blob.
        /// </summary>
        public string VersionId { get; internal set; }

        /// <summary>
        /// String identifier for this copy operation. Use with Get Blob Properties to check the status of this copy operation, or pass to Abort Copy Blob to abort a pending copy.
        /// </summary>
        public string CopyId { get; internal set; }

        /// <summary>
        /// State of the copy operation identified by x-ms-copy-id.
        /// </summary>
        public Azure.Storage.Blobs.Models.CopyStatus CopyStatus { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobCopyInfo instances.
        /// You can use BlobsModelFactory.BlobCopyInfo instead.
        /// </summary>
        internal BlobCopyInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobCopyInfo instance for mocking.
        /// </summary>
        public static BlobCopyInfo BlobCopyInfo(
            Azure.ETag eTag,
            System.DateTimeOffset lastModified,
            string versionId,
            string copyId,
            Azure.Storage.Blobs.Models.CopyStatus copyStatus)
        {
            return new BlobCopyInfo()
            {
                ETag = eTag,
                LastModified = lastModified,
                VersionId = versionId,
                CopyId = copyId,
                CopyStatus = copyStatus,
            };
        }
    }
}
#endregion class BlobCopyInfo

#region class BlobCorsRule
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// CORS is an HTTP feature that enables a web application running under one domain to access resources in another domain. Web browsers implement a security restriction known as same-origin policy that prevents a web page from calling APIs in a different domain; CORS provides a secure way to allow one domain (the origin domain) to call APIs in another domain
    /// </summary>
    public partial class BlobCorsRule
    {
        /// <summary>
        /// The origin domains that are permitted to make a request against the storage service via CORS. The origin domain is the domain from which the request originates. Note that the origin must be an exact case-sensitive match with the origin that the user age sends to the service. You can also use the wildcard character '*' to allow all origin domains to make requests via CORS.
        /// </summary>
        public string AllowedOrigins { get; set; }

        /// <summary>
        /// The methods (HTTP request verbs) that the origin domain may use for a CORS request. (comma separated)
        /// </summary>
        public string AllowedMethods { get; set; }

        /// <summary>
        /// the request headers that the origin domain may specify on the CORS request.
        /// </summary>
        public string AllowedHeaders { get; set; }

        /// <summary>
        /// The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer
        /// </summary>
        public string ExposedHeaders { get; set; }

        /// <summary>
        /// The maximum amount time that a browser should cache the preflight OPTIONS request.
        /// </summary>
        public int MaxAgeInSeconds { get; set; }

        /// <summary>
        /// Creates a new BlobCorsRule instance
        /// </summary>
        public BlobCorsRule() { }

        /// <summary>
        /// Serialize a BlobCorsRule instance as XML.
        /// </summary>
        /// <param name="value">The BlobCorsRule instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "CorsRule".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobCorsRule value, string name = "CorsRule", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("AllowedOrigins", ""),
                value.AllowedOrigins));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("AllowedMethods", ""),
                value.AllowedMethods));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("AllowedHeaders", ""),
                value.AllowedHeaders));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("ExposedHeaders", ""),
                value.ExposedHeaders));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("MaxAgeInSeconds", ""),
                value.MaxAgeInSeconds.ToString(System.Globalization.CultureInfo.InvariantCulture)));
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobCorsRule instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobCorsRule instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobCorsRule FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobCorsRule _value = new Azure.Storage.Blobs.Models.BlobCorsRule();
            _child = element.Element(System.Xml.Linq.XName.Get("AllowedOrigins", ""));
            if (_child != null)
            {
                _value.AllowedOrigins = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("AllowedMethods", ""));
            if (_child != null)
            {
                _value.AllowedMethods = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("AllowedHeaders", ""));
            if (_child != null)
            {
                _value.AllowedHeaders = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("ExposedHeaders", ""));
            if (_child != null)
            {
                _value.ExposedHeaders = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("MaxAgeInSeconds", ""));
            if (_child != null)
            {
                _value.MaxAgeInSeconds = int.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobCorsRule value);
    }
}
#endregion class BlobCorsRule

#region enum strings BlobErrorCode
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Error codes returned by the service
    /// </summary>
    public readonly struct BlobErrorCode : System.IEquatable<BlobErrorCode>
    {
        /// <summary>
        /// The BlobErrorCode value.
        /// </summary>
        private readonly string _value;

        /// <summary>
        /// Initializes a new instance of the <see cref="BlobErrorCode"/> structure.
        /// </summary>
        /// <param name="value">The string value of the instance.</param>
        public BlobErrorCode(string value) { _value = value ?? throw new System.ArgumentNullException(nameof(value)); }

        /// <summary>
        /// AccountAlreadyExists
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AccountAlreadyExists { get; } = new BlobErrorCode(@"AccountAlreadyExists");

        /// <summary>
        /// AccountBeingCreated
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AccountBeingCreated { get; } = new BlobErrorCode(@"AccountBeingCreated");

        /// <summary>
        /// AccountIsDisabled
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AccountIsDisabled { get; } = new BlobErrorCode(@"AccountIsDisabled");

        /// <summary>
        /// AuthenticationFailed
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AuthenticationFailed { get; } = new BlobErrorCode(@"AuthenticationFailed");

        /// <summary>
        /// AuthorizationFailure
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AuthorizationFailure { get; } = new BlobErrorCode(@"AuthorizationFailure");

        /// <summary>
        /// ConditionHeadersNotSupported
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ConditionHeadersNotSupported { get; } = new BlobErrorCode(@"ConditionHeadersNotSupported");

        /// <summary>
        /// ConditionNotMet
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ConditionNotMet { get; } = new BlobErrorCode(@"ConditionNotMet");

        /// <summary>
        /// EmptyMetadataKey
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode EmptyMetadataKey { get; } = new BlobErrorCode(@"EmptyMetadataKey");

        /// <summary>
        /// InsufficientAccountPermissions
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InsufficientAccountPermissions { get; } = new BlobErrorCode(@"InsufficientAccountPermissions");

        /// <summary>
        /// InternalError
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InternalError { get; } = new BlobErrorCode(@"InternalError");

        /// <summary>
        /// InvalidAuthenticationInfo
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidAuthenticationInfo { get; } = new BlobErrorCode(@"InvalidAuthenticationInfo");

        /// <summary>
        /// InvalidHeaderValue
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidHeaderValue { get; } = new BlobErrorCode(@"InvalidHeaderValue");

        /// <summary>
        /// InvalidHttpVerb
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidHttpVerb { get; } = new BlobErrorCode(@"InvalidHttpVerb");

        /// <summary>
        /// InvalidInput
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidInput { get; } = new BlobErrorCode(@"InvalidInput");

        /// <summary>
        /// InvalidMd5
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidMd5 { get; } = new BlobErrorCode(@"InvalidMd5");

        /// <summary>
        /// InvalidMetadata
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidMetadata { get; } = new BlobErrorCode(@"InvalidMetadata");

        /// <summary>
        /// InvalidQueryParameterValue
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidQueryParameterValue { get; } = new BlobErrorCode(@"InvalidQueryParameterValue");

        /// <summary>
        /// InvalidRange
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidRange { get; } = new BlobErrorCode(@"InvalidRange");

        /// <summary>
        /// InvalidResourceName
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidResourceName { get; } = new BlobErrorCode(@"InvalidResourceName");

        /// <summary>
        /// InvalidUri
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidUri { get; } = new BlobErrorCode(@"InvalidUri");

        /// <summary>
        /// InvalidXmlDocument
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidXmlDocument { get; } = new BlobErrorCode(@"InvalidXmlDocument");

        /// <summary>
        /// InvalidXmlNodeValue
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidXmlNodeValue { get; } = new BlobErrorCode(@"InvalidXmlNodeValue");

        /// <summary>
        /// Md5Mismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode Md5Mismatch { get; } = new BlobErrorCode(@"Md5Mismatch");

        /// <summary>
        /// MetadataTooLarge
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode MetadataTooLarge { get; } = new BlobErrorCode(@"MetadataTooLarge");

        /// <summary>
        /// MissingContentLengthHeader
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode MissingContentLengthHeader { get; } = new BlobErrorCode(@"MissingContentLengthHeader");

        /// <summary>
        /// MissingRequiredQueryParameter
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode MissingRequiredQueryParameter { get; } = new BlobErrorCode(@"MissingRequiredQueryParameter");

        /// <summary>
        /// MissingRequiredHeader
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode MissingRequiredHeader { get; } = new BlobErrorCode(@"MissingRequiredHeader");

        /// <summary>
        /// MissingRequiredXmlNode
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode MissingRequiredXmlNode { get; } = new BlobErrorCode(@"MissingRequiredXmlNode");

        /// <summary>
        /// MultipleConditionHeadersNotSupported
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode MultipleConditionHeadersNotSupported { get; } = new BlobErrorCode(@"MultipleConditionHeadersNotSupported");

        /// <summary>
        /// OperationTimedOut
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode OperationTimedOut { get; } = new BlobErrorCode(@"OperationTimedOut");

        /// <summary>
        /// OutOfRangeInput
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode OutOfRangeInput { get; } = new BlobErrorCode(@"OutOfRangeInput");

        /// <summary>
        /// OutOfRangeQueryParameterValue
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode OutOfRangeQueryParameterValue { get; } = new BlobErrorCode(@"OutOfRangeQueryParameterValue");

        /// <summary>
        /// RequestBodyTooLarge
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode RequestBodyTooLarge { get; } = new BlobErrorCode(@"RequestBodyTooLarge");

        /// <summary>
        /// ResourceTypeMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ResourceTypeMismatch { get; } = new BlobErrorCode(@"ResourceTypeMismatch");

        /// <summary>
        /// RequestUrlFailedToParse
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode RequestUrlFailedToParse { get; } = new BlobErrorCode(@"RequestUrlFailedToParse");

        /// <summary>
        /// ResourceAlreadyExists
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ResourceAlreadyExists { get; } = new BlobErrorCode(@"ResourceAlreadyExists");

        /// <summary>
        /// ResourceNotFound
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ResourceNotFound { get; } = new BlobErrorCode(@"ResourceNotFound");

        /// <summary>
        /// ServerBusy
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ServerBusy { get; } = new BlobErrorCode(@"ServerBusy");

        /// <summary>
        /// UnsupportedHeader
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode UnsupportedHeader { get; } = new BlobErrorCode(@"UnsupportedHeader");

        /// <summary>
        /// UnsupportedXmlNode
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode UnsupportedXmlNode { get; } = new BlobErrorCode(@"UnsupportedXmlNode");

        /// <summary>
        /// UnsupportedQueryParameter
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode UnsupportedQueryParameter { get; } = new BlobErrorCode(@"UnsupportedQueryParameter");

        /// <summary>
        /// UnsupportedHttpVerb
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode UnsupportedHttpVerb { get; } = new BlobErrorCode(@"UnsupportedHttpVerb");

        /// <summary>
        /// AppendPositionConditionNotMet
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AppendPositionConditionNotMet { get; } = new BlobErrorCode(@"AppendPositionConditionNotMet");

        /// <summary>
        /// BlobAlreadyExists
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlobAlreadyExists { get; } = new BlobErrorCode(@"BlobAlreadyExists");

        /// <summary>
        /// BlobImmutableDueToPolicy
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlobImmutableDueToPolicy { get; } = new BlobErrorCode(@"BlobImmutableDueToPolicy");

        /// <summary>
        /// BlobNotFound
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlobNotFound { get; } = new BlobErrorCode(@"BlobNotFound");

        /// <summary>
        /// BlobOverwritten
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlobOverwritten { get; } = new BlobErrorCode(@"BlobOverwritten");

        /// <summary>
        /// BlobTierInadequateForContentLength
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlobTierInadequateForContentLength { get; } = new BlobErrorCode(@"BlobTierInadequateForContentLength");

        /// <summary>
        /// BlockCountExceedsLimit
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlockCountExceedsLimit { get; } = new BlobErrorCode(@"BlockCountExceedsLimit");

        /// <summary>
        /// BlockListTooLong
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlockListTooLong { get; } = new BlobErrorCode(@"BlockListTooLong");

        /// <summary>
        /// CannotChangeToLowerTier
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode CannotChangeToLowerTier { get; } = new BlobErrorCode(@"CannotChangeToLowerTier");

        /// <summary>
        /// CannotVerifyCopySource
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode CannotVerifyCopySource { get; } = new BlobErrorCode(@"CannotVerifyCopySource");

        /// <summary>
        /// ContainerAlreadyExists
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ContainerAlreadyExists { get; } = new BlobErrorCode(@"ContainerAlreadyExists");

        /// <summary>
        /// ContainerBeingDeleted
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ContainerBeingDeleted { get; } = new BlobErrorCode(@"ContainerBeingDeleted");

        /// <summary>
        /// ContainerDisabled
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ContainerDisabled { get; } = new BlobErrorCode(@"ContainerDisabled");

        /// <summary>
        /// ContainerNotFound
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ContainerNotFound { get; } = new BlobErrorCode(@"ContainerNotFound");

        /// <summary>
        /// ContentLengthLargerThanTierLimit
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode ContentLengthLargerThanTierLimit { get; } = new BlobErrorCode(@"ContentLengthLargerThanTierLimit");

        /// <summary>
        /// CopyAcrossAccountsNotSupported
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode CopyAcrossAccountsNotSupported { get; } = new BlobErrorCode(@"CopyAcrossAccountsNotSupported");

        /// <summary>
        /// CopyIdMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode CopyIdMismatch { get; } = new BlobErrorCode(@"CopyIdMismatch");

        /// <summary>
        /// FeatureVersionMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode FeatureVersionMismatch { get; } = new BlobErrorCode(@"FeatureVersionMismatch");

        /// <summary>
        /// IncrementalCopyBlobMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode IncrementalCopyBlobMismatch { get; } = new BlobErrorCode(@"IncrementalCopyBlobMismatch");

        /// <summary>
        /// IncrementalCopyOfEralierVersionSnapshotNotAllowed
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode IncrementalCopyOfEralierVersionSnapshotNotAllowed { get; } = new BlobErrorCode(@"IncrementalCopyOfEralierVersionSnapshotNotAllowed");

        /// <summary>
        /// IncrementalCopySourceMustBeSnapshot
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode IncrementalCopySourceMustBeSnapshot { get; } = new BlobErrorCode(@"IncrementalCopySourceMustBeSnapshot");

        /// <summary>
        /// InfiniteLeaseDurationRequired
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InfiniteLeaseDurationRequired { get; } = new BlobErrorCode(@"InfiniteLeaseDurationRequired");

        /// <summary>
        /// InvalidBlobOrBlock
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidBlobOrBlock { get; } = new BlobErrorCode(@"InvalidBlobOrBlock");

        /// <summary>
        /// InvalidBlobTier
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidBlobTier { get; } = new BlobErrorCode(@"InvalidBlobTier");

        /// <summary>
        /// InvalidBlobType
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidBlobType { get; } = new BlobErrorCode(@"InvalidBlobType");

        /// <summary>
        /// InvalidBlockId
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidBlockId { get; } = new BlobErrorCode(@"InvalidBlockId");

        /// <summary>
        /// InvalidBlockList
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidBlockList { get; } = new BlobErrorCode(@"InvalidBlockList");

        /// <summary>
        /// InvalidOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidOperation { get; } = new BlobErrorCode(@"InvalidOperation");

        /// <summary>
        /// InvalidPageRange
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidPageRange { get; } = new BlobErrorCode(@"InvalidPageRange");

        /// <summary>
        /// InvalidSourceBlobType
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidSourceBlobType { get; } = new BlobErrorCode(@"InvalidSourceBlobType");

        /// <summary>
        /// InvalidSourceBlobUrl
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidSourceBlobUrl { get; } = new BlobErrorCode(@"InvalidSourceBlobUrl");

        /// <summary>
        /// InvalidVersionForPageBlobOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode InvalidVersionForPageBlobOperation { get; } = new BlobErrorCode(@"InvalidVersionForPageBlobOperation");

        /// <summary>
        /// LeaseAlreadyPresent
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseAlreadyPresent { get; } = new BlobErrorCode(@"LeaseAlreadyPresent");

        /// <summary>
        /// LeaseAlreadyBroken
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseAlreadyBroken { get; } = new BlobErrorCode(@"LeaseAlreadyBroken");

        /// <summary>
        /// LeaseIdMismatchWithBlobOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseIdMismatchWithBlobOperation { get; } = new BlobErrorCode(@"LeaseIdMismatchWithBlobOperation");

        /// <summary>
        /// LeaseIdMismatchWithContainerOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseIdMismatchWithContainerOperation { get; } = new BlobErrorCode(@"LeaseIdMismatchWithContainerOperation");

        /// <summary>
        /// LeaseIdMismatchWithLeaseOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseIdMismatchWithLeaseOperation { get; } = new BlobErrorCode(@"LeaseIdMismatchWithLeaseOperation");

        /// <summary>
        /// LeaseIdMissing
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseIdMissing { get; } = new BlobErrorCode(@"LeaseIdMissing");

        /// <summary>
        /// LeaseIsBreakingAndCannotBeAcquired
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseIsBreakingAndCannotBeAcquired { get; } = new BlobErrorCode(@"LeaseIsBreakingAndCannotBeAcquired");

        /// <summary>
        /// LeaseIsBreakingAndCannotBeChanged
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseIsBreakingAndCannotBeChanged { get; } = new BlobErrorCode(@"LeaseIsBreakingAndCannotBeChanged");

        /// <summary>
        /// LeaseIsBrokenAndCannotBeRenewed
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseIsBrokenAndCannotBeRenewed { get; } = new BlobErrorCode(@"LeaseIsBrokenAndCannotBeRenewed");

        /// <summary>
        /// LeaseLost
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseLost { get; } = new BlobErrorCode(@"LeaseLost");

        /// <summary>
        /// LeaseNotPresentWithBlobOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseNotPresentWithBlobOperation { get; } = new BlobErrorCode(@"LeaseNotPresentWithBlobOperation");

        /// <summary>
        /// LeaseNotPresentWithContainerOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseNotPresentWithContainerOperation { get; } = new BlobErrorCode(@"LeaseNotPresentWithContainerOperation");

        /// <summary>
        /// LeaseNotPresentWithLeaseOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode LeaseNotPresentWithLeaseOperation { get; } = new BlobErrorCode(@"LeaseNotPresentWithLeaseOperation");

        /// <summary>
        /// MaxBlobSizeConditionNotMet
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode MaxBlobSizeConditionNotMet { get; } = new BlobErrorCode(@"MaxBlobSizeConditionNotMet");

        /// <summary>
        /// NoAuthenticationInformation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode NoAuthenticationInformation { get; } = new BlobErrorCode(@"NoAuthenticationInformation");

        /// <summary>
        /// NoPendingCopyOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode NoPendingCopyOperation { get; } = new BlobErrorCode(@"NoPendingCopyOperation");

        /// <summary>
        /// OperationNotAllowedOnIncrementalCopyBlob
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode OperationNotAllowedOnIncrementalCopyBlob { get; } = new BlobErrorCode(@"OperationNotAllowedOnIncrementalCopyBlob");

        /// <summary>
        /// PendingCopyOperation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode PendingCopyOperation { get; } = new BlobErrorCode(@"PendingCopyOperation");

        /// <summary>
        /// PreviousSnapshotCannotBeNewer
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode PreviousSnapshotCannotBeNewer { get; } = new BlobErrorCode(@"PreviousSnapshotCannotBeNewer");

        /// <summary>
        /// PreviousSnapshotNotFound
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode PreviousSnapshotNotFound { get; } = new BlobErrorCode(@"PreviousSnapshotNotFound");

        /// <summary>
        /// PreviousSnapshotOperationNotSupported
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode PreviousSnapshotOperationNotSupported { get; } = new BlobErrorCode(@"PreviousSnapshotOperationNotSupported");

        /// <summary>
        /// SequenceNumberConditionNotMet
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode SequenceNumberConditionNotMet { get; } = new BlobErrorCode(@"SequenceNumberConditionNotMet");

        /// <summary>
        /// SequenceNumberIncrementTooLarge
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode SequenceNumberIncrementTooLarge { get; } = new BlobErrorCode(@"SequenceNumberIncrementTooLarge");

        /// <summary>
        /// SnapshotCountExceeded
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode SnapshotCountExceeded { get; } = new BlobErrorCode(@"SnapshotCountExceeded");

        /// <summary>
        /// SnaphotOperationRateExceeded
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode SnaphotOperationRateExceeded { get; } = new BlobErrorCode(@"SnaphotOperationRateExceeded");

        /// <summary>
        /// SnapshotsPresent
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode SnapshotsPresent { get; } = new BlobErrorCode(@"SnapshotsPresent");

        /// <summary>
        /// SourceConditionNotMet
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode SourceConditionNotMet { get; } = new BlobErrorCode(@"SourceConditionNotMet");

        /// <summary>
        /// SystemInUse
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode SystemInUse { get; } = new BlobErrorCode(@"SystemInUse");

        /// <summary>
        /// TargetConditionNotMet
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode TargetConditionNotMet { get; } = new BlobErrorCode(@"TargetConditionNotMet");

        /// <summary>
        /// UnauthorizedBlobOverwrite
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode UnauthorizedBlobOverwrite { get; } = new BlobErrorCode(@"UnauthorizedBlobOverwrite");

        /// <summary>
        /// BlobBeingRehydrated
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlobBeingRehydrated { get; } = new BlobErrorCode(@"BlobBeingRehydrated");

        /// <summary>
        /// BlobArchived
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlobArchived { get; } = new BlobErrorCode(@"BlobArchived");

        /// <summary>
        /// BlobNotArchived
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode BlobNotArchived { get; } = new BlobErrorCode(@"BlobNotArchived");

        /// <summary>
        /// AuthorizationSourceIPMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AuthorizationSourceIPMismatch { get; } = new BlobErrorCode(@"AuthorizationSourceIPMismatch");

        /// <summary>
        /// AuthorizationProtocolMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AuthorizationProtocolMismatch { get; } = new BlobErrorCode(@"AuthorizationProtocolMismatch");

        /// <summary>
        /// AuthorizationPermissionMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AuthorizationPermissionMismatch { get; } = new BlobErrorCode(@"AuthorizationPermissionMismatch");

        /// <summary>
        /// AuthorizationServiceMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AuthorizationServiceMismatch { get; } = new BlobErrorCode(@"AuthorizationServiceMismatch");

        /// <summary>
        /// AuthorizationResourceTypeMismatch
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobErrorCode AuthorizationResourceTypeMismatch { get; } = new BlobErrorCode(@"AuthorizationResourceTypeMismatch");

        /// <summary>
        /// Determines if two <see cref="BlobErrorCode"/> values are the same.
        /// </summary>
        /// <param name="left">The first <see cref="BlobErrorCode"/> to compare.</param>
        /// <param name="right">The second <see cref="BlobErrorCode"/> to compare.</param>
        /// <returns>True if <paramref name="left"/> and <paramref name="right"/> are the same; otherwise, false.</returns>
        public static bool operator ==(Azure.Storage.Blobs.Models.BlobErrorCode left, Azure.Storage.Blobs.Models.BlobErrorCode right) => left.Equals(right);

        /// <summary>
        /// Determines if two <see cref="BlobErrorCode"/> values are different.
        /// </summary>
        /// <param name="left">The first <see cref="BlobErrorCode"/> to compare.</param>
        /// <param name="right">The second <see cref="BlobErrorCode"/> to compare.</param>
        /// <returns>True if <paramref name="left"/> and <paramref name="right"/> are different; otherwise, false.</returns>
        public static bool operator !=(Azure.Storage.Blobs.Models.BlobErrorCode left, Azure.Storage.Blobs.Models.BlobErrorCode right) => !left.Equals(right);

        /// <summary>
        /// Converts a string to a <see cref="BlobErrorCode"/>.
        /// </summary>
        /// <param name="value">The string value to convert.</param>
        /// <returns>The BlobErrorCode value.</returns>
        public static implicit operator BlobErrorCode(string value) => new Azure.Storage.Blobs.Models.BlobErrorCode(value);

        /// <summary>
        /// Check if two <see cref="BlobErrorCode"/> instances are equal.
        /// </summary>
        /// <param name="obj">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is Azure.Storage.Blobs.Models.BlobErrorCode other && Equals(other);

        /// <summary>
        /// Check if two <see cref="BlobErrorCode"/> instances are equal.
        /// </summary>
        /// <param name="other">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        public bool Equals(Azure.Storage.Blobs.Models.BlobErrorCode other) => string.Equals(_value, other._value, System.StringComparison.Ordinal);

        /// <summary>
        /// Get a hash code for the <see cref="BlobErrorCode"/>.
        /// </summary>
        /// <returns>Hash code for the BlobErrorCode.</returns>
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        /// <summary>
        /// Convert the <see cref="BlobErrorCode"/> to a string.
        /// </summary>
        /// <returns>String representation of the BlobErrorCode.</returns>
        public override string ToString() => _value;
    }
}
#endregion enum strings BlobErrorCode

#region enum strings BlobExpiryOptions
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Required. Indicates mode of the expiry time
    /// </summary>
    internal readonly struct BlobExpiryOptions : System.IEquatable<BlobExpiryOptions>
    {
        /// <summary>
        /// The BlobExpiryOptions value.
        /// </summary>
        private readonly string _value;

        /// <summary>
        /// Initializes a new instance of the <see cref="BlobExpiryOptions"/> structure.
        /// </summary>
        /// <param name="value">The string value of the instance.</param>
        public BlobExpiryOptions(string value) { _value = value ?? throw new System.ArgumentNullException(nameof(value)); }

        /// <summary>
        /// NeverExpire
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobExpiryOptions NeverExpire { get; } = new BlobExpiryOptions(@"NeverExpire");

        /// <summary>
        /// RelativeToCreation
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobExpiryOptions RelativeToCreation { get; } = new BlobExpiryOptions(@"RelativeToCreation");

        /// <summary>
        /// RelativeToNow
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobExpiryOptions RelativeToNow { get; } = new BlobExpiryOptions(@"RelativeToNow");

        /// <summary>
        /// Absolute
        /// </summary>
        public static Azure.Storage.Blobs.Models.BlobExpiryOptions Absolute { get; } = new BlobExpiryOptions(@"Absolute");

        /// <summary>
        /// Determines if two <see cref="BlobExpiryOptions"/> values are the same.
        /// </summary>
        /// <param name="left">The first <see cref="BlobExpiryOptions"/> to compare.</param>
        /// <param name="right">The second <see cref="BlobExpiryOptions"/> to compare.</param>
        /// <returns>True if <paramref name="left"/> and <paramref name="right"/> are the same; otherwise, false.</returns>
        public static bool operator ==(Azure.Storage.Blobs.Models.BlobExpiryOptions left, Azure.Storage.Blobs.Models.BlobExpiryOptions right) => left.Equals(right);

        /// <summary>
        /// Determines if two <see cref="BlobExpiryOptions"/> values are different.
        /// </summary>
        /// <param name="left">The first <see cref="BlobExpiryOptions"/> to compare.</param>
        /// <param name="right">The second <see cref="BlobExpiryOptions"/> to compare.</param>
        /// <returns>True if <paramref name="left"/> and <paramref name="right"/> are different; otherwise, false.</returns>
        public static bool operator !=(Azure.Storage.Blobs.Models.BlobExpiryOptions left, Azure.Storage.Blobs.Models.BlobExpiryOptions right) => !left.Equals(right);

        /// <summary>
        /// Converts a string to a <see cref="BlobExpiryOptions"/>.
        /// </summary>
        /// <param name="value">The string value to convert.</param>
        /// <returns>The BlobExpiryOptions value.</returns>
        public static implicit operator BlobExpiryOptions(string value) => new Azure.Storage.Blobs.Models.BlobExpiryOptions(value);

        /// <summary>
        /// Check if two <see cref="BlobExpiryOptions"/> instances are equal.
        /// </summary>
        /// <param name="obj">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is Azure.Storage.Blobs.Models.BlobExpiryOptions other && Equals(other);

        /// <summary>
        /// Check if two <see cref="BlobExpiryOptions"/> instances are equal.
        /// </summary>
        /// <param name="other">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        public bool Equals(Azure.Storage.Blobs.Models.BlobExpiryOptions other) => string.Equals(_value, other._value, System.StringComparison.Ordinal);

        /// <summary>
        /// Get a hash code for the <see cref="BlobExpiryOptions"/>.
        /// </summary>
        /// <returns>Hash code for the BlobExpiryOptions.</returns>
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        /// <summary>
        /// Convert the <see cref="BlobExpiryOptions"/> to a string.
        /// </summary>
        /// <returns>String representation of the BlobExpiryOptions.</returns>
        public override string ToString() => _value;
    }
}
#endregion enum strings BlobExpiryOptions

#region class BlobGeoReplication
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Geo-Replication information for the Secondary Storage Service
    /// </summary>
    public partial class BlobGeoReplication
    {
        /// <summary>
        /// The status of the secondary location
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobGeoReplicationStatus Status { get; internal set; }

        /// <summary>
        /// A GMT date/time value, to the second. All primary writes preceding this value are guaranteed to be available for read operations at the secondary. Primary writes after this point in time may or may not be available for reads.
        /// </summary>
        public System.DateTimeOffset? LastSyncedOn { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobGeoReplication instances.
        /// You can use BlobsModelFactory.BlobGeoReplication instead.
        /// </summary>
        internal BlobGeoReplication() { }

        /// <summary>
        /// Deserializes XML into a new BlobGeoReplication instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobGeoReplication instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobGeoReplication FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobGeoReplication _value = new Azure.Storage.Blobs.Models.BlobGeoReplication();
            _child = element.Element(System.Xml.Linq.XName.Get("Status", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.Status = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseBlobGeoReplicationStatus(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("LastSyncTime", ""));
            if (_child != null)
            {
                _value.LastSyncedOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobGeoReplication value);
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobGeoReplication instance for mocking.
        /// </summary>
        public static BlobGeoReplication BlobGeoReplication(
            Azure.Storage.Blobs.Models.BlobGeoReplicationStatus status,
            System.DateTimeOffset? lastSyncedOn = default)
        {
            return new BlobGeoReplication()
            {
                Status = status,
                LastSyncedOn = lastSyncedOn,
            };
        }
    }
}
#endregion class BlobGeoReplication

#region enum BlobGeoReplicationStatus
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// The status of the secondary location
    /// </summary>
    #pragma warning disable CA1717 // Only FlagsAttribute enums should have plural names
    public enum BlobGeoReplicationStatus
    #pragma warning restore CA1717 // Only FlagsAttribute enums should have plural names
    {
        /// <summary>
        /// live
        /// </summary>
        Live,

        /// <summary>
        /// bootstrap
        /// </summary>
        Bootstrap,

        /// <summary>
        /// unavailable
        /// </summary>
        Unavailable
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.BlobGeoReplicationStatus value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.BlobGeoReplicationStatus.Live => "live",
                    Azure.Storage.Blobs.Models.BlobGeoReplicationStatus.Bootstrap => "bootstrap",
                    Azure.Storage.Blobs.Models.BlobGeoReplicationStatus.Unavailable => "unavailable",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.BlobGeoReplicationStatus value.")
                };
            }

            public static Azure.Storage.Blobs.Models.BlobGeoReplicationStatus ParseBlobGeoReplicationStatus(string value)
            {
                return value switch
                {
                    "live" => Azure.Storage.Blobs.Models.BlobGeoReplicationStatus.Live,
                    "bootstrap" => Azure.Storage.Blobs.Models.BlobGeoReplicationStatus.Bootstrap,
                    "unavailable" => Azure.Storage.Blobs.Models.BlobGeoReplicationStatus.Unavailable,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.BlobGeoReplicationStatus value.")
                };
            }
        }
    }
}
#endregion enum BlobGeoReplicationStatus

#region class BlobInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobInfo
    /// </summary>
    public partial class BlobInfo
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the blob was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobInfo instances.
        /// You can use BlobsModelFactory.BlobInfo instead.
        /// </summary>
        internal BlobInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobInfo instance for mocking.
        /// </summary>
        public static BlobInfo BlobInfo(
            Azure.ETag eTag,
            System.DateTimeOffset lastModified)
        {
            return new BlobInfo()
            {
                ETag = eTag,
                LastModified = lastModified,
            };
        }
    }
}
#endregion class BlobInfo

#region class BlobItemInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// An Azure Storage blob
    /// </summary>
    internal partial class BlobItemInternal
    {
        /// <summary>
        /// Name
        /// </summary>
        public string Name { get; internal set; }

        /// <summary>
        /// Deleted
        /// </summary>
        public bool Deleted { get; internal set; }

        /// <summary>
        /// Snapshot
        /// </summary>
        public string Snapshot { get; internal set; }

        /// <summary>
        /// VersionId
        /// </summary>
        public string VersionId { get; internal set; }

        /// <summary>
        /// IsCurrentVersion
        /// </summary>
        public bool? IsCurrentVersion { get; internal set; }

        /// <summary>
        /// Properties of a blob
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobItemProperties Properties { get; internal set; }

        /// <summary>
        /// Metadata
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; internal set; }

        /// <summary>
        /// Blob tags
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobTags BlobTags { get; internal set; }

        /// <summary>
        /// ObjectReplicationMetadata
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> ObjectReplicationMetadata { get; internal set; }

        /// <summary>
        /// Creates a new BlobItemInternal instance
        /// </summary>
        public BlobItemInternal()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobItemInternal instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobItemInternal(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                Properties = new Azure.Storage.Blobs.Models.BlobItemProperties();
                Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
                BlobTags = new Azure.Storage.Blobs.Models.BlobTags();
                ObjectReplicationMetadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
            }
        }

        /// <summary>
        /// Deserializes XML into a new BlobItemInternal instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobItemInternal instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobItemInternal FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobItemInternal _value = new Azure.Storage.Blobs.Models.BlobItemInternal(true);
            _child = element.Element(System.Xml.Linq.XName.Get("Name", ""));
            if (_child != null)
            {
                _value.Name = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Deleted", ""));
            if (_child != null)
            {
                _value.Deleted = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Snapshot", ""));
            if (_child != null)
            {
                _value.Snapshot = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("VersionId", ""));
            if (_child != null)
            {
                _value.VersionId = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("IsCurrentVersion", ""));
            if (_child != null)
            {
                _value.IsCurrentVersion = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Properties", ""));
            if (_child != null)
            {
                _value.Properties = Azure.Storage.Blobs.Models.BlobItemProperties.FromXml(_child);
            }
            _value.Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
            _child = element.Element(System.Xml.Linq.XName.Get("Metadata", ""));
            if (_child != null)
            {
                foreach (System.Xml.Linq.XElement _pair in _child.Elements())
                {
                    _value.Metadata[_pair.Name.LocalName] = _pair.Value;
                }
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Tags", ""));
            if (_child != null)
            {
                _value.BlobTags = Azure.Storage.Blobs.Models.BlobTags.FromXml(_child);
            }
            _value.ObjectReplicationMetadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
            _child = element.Element(System.Xml.Linq.XName.Get("OrMetadata", ""));
            if (_child != null)
            {
                foreach (System.Xml.Linq.XElement _pair in _child.Elements())
                {
                    _value.ObjectReplicationMetadata[_pair.Name.LocalName] = _pair.Value;
                }
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobItemInternal value);
    }
}
#endregion class BlobItemInternal

#region class BlobItemProperties
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Properties of a blob
    /// </summary>
    public partial class BlobItemProperties
    {
        /// <summary>
        /// Last-Modified
        /// </summary>
        public System.DateTimeOffset? LastModified { get; internal set; }

        /// <summary>
        /// Size in bytes
        /// </summary>
        public long? ContentLength { get; internal set; }

        /// <summary>
        /// Content-Type
        /// </summary>
        public string ContentType { get; internal set; }

        /// <summary>
        /// Content-Encoding
        /// </summary>
        public string ContentEncoding { get; internal set; }

        /// <summary>
        /// Content-Language
        /// </summary>
        public string ContentLanguage { get; internal set; }

        /// <summary>
        /// Content-MD5
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// Content-Disposition
        /// </summary>
        public string ContentDisposition { get; internal set; }

        /// <summary>
        /// Cache-Control
        /// </summary>
        public string CacheControl { get; internal set; }

        /// <summary>
        /// x-ms-blob-sequence-number
        /// </summary>
        public long? BlobSequenceNumber { get; internal set; }

        /// <summary>
        /// BlobType
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobType? BlobType { get; internal set; }

        /// <summary>
        /// LeaseStatus
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseStatus? LeaseStatus { get; internal set; }

        /// <summary>
        /// LeaseState
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseState? LeaseState { get; internal set; }

        /// <summary>
        /// LeaseDuration
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseDurationType? LeaseDuration { get; internal set; }

        /// <summary>
        /// CopyId
        /// </summary>
        public string CopyId { get; internal set; }

        /// <summary>
        /// CopyStatus
        /// </summary>
        public Azure.Storage.Blobs.Models.CopyStatus? CopyStatus { get; internal set; }

        /// <summary>
        /// CopySource
        /// </summary>
        public System.Uri CopySource { get; internal set; }

        /// <summary>
        /// CopyProgress
        /// </summary>
        public string CopyProgress { get; internal set; }

        /// <summary>
        /// CopyStatusDescription
        /// </summary>
        public string CopyStatusDescription { get; internal set; }

        /// <summary>
        /// ServerEncrypted
        /// </summary>
        public bool? ServerEncrypted { get; internal set; }

        /// <summary>
        /// IncrementalCopy
        /// </summary>
        public bool? IncrementalCopy { get; internal set; }

        /// <summary>
        /// DestinationSnapshot
        /// </summary>
        public string DestinationSnapshot { get; internal set; }

        /// <summary>
        /// RemainingRetentionDays
        /// </summary>
        public int? RemainingRetentionDays { get; internal set; }

        /// <summary>
        /// AccessTier
        /// </summary>
        public Azure.Storage.Blobs.Models.AccessTier? AccessTier { get; internal set; }

        /// <summary>
        /// AccessTierInferred
        /// </summary>
        public bool AccessTierInferred { get; internal set; }

        /// <summary>
        /// ArchiveStatus
        /// </summary>
        public Azure.Storage.Blobs.Models.ArchiveStatus? ArchiveStatus { get; internal set; }

        /// <summary>
        /// CustomerProvidedKeySha256
        /// </summary>
        public string CustomerProvidedKeySha256 { get; internal set; }

        /// <summary>
        /// The name of the encryption scope under which the blob is encrypted.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// TagCount
        /// </summary>
        public long? TagCount { get; internal set; }

        /// <summary>
        /// Expiry-Time
        /// </summary>
        public System.DateTimeOffset? ExpiresOn { get; internal set; }

        /// <summary>
        /// Sealed
        /// </summary>
        public bool? IsSealed { get; internal set; }

        /// <summary>
        /// If an object is in rehydrate pending state then this header is returned with priority of rehydrate. Valid values are High and Standard.
        /// </summary>
        public Azure.Storage.Blobs.Models.RehydratePriority? RehydratePriority { get; internal set; }

        /// <summary>
        /// LastAccessTime
        /// </summary>
        public System.DateTimeOffset? LastAccessedOn { get; internal set; }

        /// <summary>
        /// ETag
        /// </summary>
        public Azure.ETag? ETag { get; internal set; }

        /// <summary>
        /// CreatedOn
        /// </summary>
        public System.DateTimeOffset? CreatedOn { get; internal set; }

        /// <summary>
        /// CopyCompletedOn
        /// </summary>
        public System.DateTimeOffset? CopyCompletedOn { get; internal set; }

        /// <summary>
        /// DeletedOn
        /// </summary>
        public System.DateTimeOffset? DeletedOn { get; internal set; }

        /// <summary>
        /// AccessTierChangedOn
        /// </summary>
        public System.DateTimeOffset? AccessTierChangedOn { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobItemProperties instances.
        /// You can use BlobsModelFactory.BlobItemProperties instead.
        /// </summary>
        internal BlobItemProperties() { }

        /// <summary>
        /// Deserializes XML into a new BlobItemProperties instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobItemProperties instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobItemProperties FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobItemProperties _value = new Azure.Storage.Blobs.Models.BlobItemProperties();
            _child = element.Element(System.Xml.Linq.XName.Get("Last-Modified", ""));
            if (_child != null)
            {
                _value.LastModified = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Content-Length", ""));
            if (_child != null)
            {
                _value.ContentLength = long.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Content-Type", ""));
            if (_child != null)
            {
                _value.ContentType = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Content-Encoding", ""));
            if (_child != null)
            {
                _value.ContentEncoding = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Content-Language", ""));
            if (_child != null)
            {
                _value.ContentLanguage = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Content-MD5", ""));
            if (_child != null)
            {
                _value.ContentHash = System.Convert.FromBase64String(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Content-Disposition", ""));
            if (_child != null)
            {
                _value.ContentDisposition = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Cache-Control", ""));
            if (_child != null)
            {
                _value.CacheControl = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("x-ms-blob-sequence-number", ""));
            if (_child != null)
            {
                _value.BlobSequenceNumber = long.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("BlobType", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.BlobType = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseBlobType(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("LeaseStatus", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.LeaseStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseStatus(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("LeaseState", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.LeaseState = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseState(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("LeaseDuration", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.LeaseDuration = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseLeaseDurationType(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("CopyId", ""));
            if (_child != null)
            {
                _value.CopyId = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("CopyStatus", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.CopyStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseCopyStatus(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("CopySource", ""));
            if (_child != null)
            {
                _value.CopySource = new System.Uri(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("CopyProgress", ""));
            if (_child != null)
            {
                _value.CopyProgress = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("CopyStatusDescription", ""));
            if (_child != null)
            {
                _value.CopyStatusDescription = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("ServerEncrypted", ""));
            if (_child != null)
            {
                _value.ServerEncrypted = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("IncrementalCopy", ""));
            if (_child != null)
            {
                _value.IncrementalCopy = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("DestinationSnapshot", ""));
            if (_child != null)
            {
                _value.DestinationSnapshot = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("RemainingRetentionDays", ""));
            if (_child != null)
            {
                _value.RemainingRetentionDays = int.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("AccessTier", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.AccessTier = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("AccessTierInferred", ""));
            if (_child != null)
            {
                _value.AccessTierInferred = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("ArchiveStatus", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.ArchiveStatus = Azure.Storage.Blobs.BlobRestClient.Serialization.ParseArchiveStatus(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("CustomerProvidedKeySha256", ""));
            if (_child != null)
            {
                _value.CustomerProvidedKeySha256 = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("EncryptionScope", ""));
            if (_child != null)
            {
                _value.EncryptionScope = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("TagCount", ""));
            if (_child != null)
            {
                _value.TagCount = long.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Expiry-Time", ""));
            if (_child != null)
            {
                _value.ExpiresOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Sealed", ""));
            if (_child != null)
            {
                _value.IsSealed = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("RehydratePriority", ""));
            if (_child != null && !string.IsNullOrEmpty(_child.Value))
            {
                _value.RehydratePriority = (Azure.Storage.Blobs.Models.RehydratePriority)System.Enum.Parse(typeof(Azure.Storage.Blobs.Models.RehydratePriority), _child.Value, false);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("LastAccessTime", ""));
            if (_child != null)
            {
                _value.LastAccessedOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Etag", ""));
            if (_child != null)
            {
                _value.ETag = new Azure.ETag(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Creation-Time", ""));
            if (_child != null)
            {
                _value.CreatedOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("CopyCompletionTime", ""));
            if (_child != null)
            {
                _value.CopyCompletedOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("DeletedTime", ""));
            if (_child != null)
            {
                _value.DeletedOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("AccessTierChangeTime", ""));
            if (_child != null)
            {
                _value.AccessTierChangedOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobItemProperties value);
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobItemProperties instance for mocking.
        /// </summary>
        public static BlobItemProperties BlobItemProperties(
            bool accessTierInferred,
            bool? serverEncrypted = default,
            string contentType = default,
            string contentEncoding = default,
            string contentLanguage = default,
            byte[] contentHash = default,
            string contentDisposition = default,
            string cacheControl = default,
            long? blobSequenceNumber = default,
            Azure.Storage.Blobs.Models.BlobType? blobType = default,
            Azure.Storage.Blobs.Models.LeaseStatus? leaseStatus = default,
            Azure.Storage.Blobs.Models.LeaseState? leaseState = default,
            Azure.Storage.Blobs.Models.LeaseDurationType? leaseDuration = default,
            string copyId = default,
            Azure.Storage.Blobs.Models.CopyStatus? copyStatus = default,
            System.Uri copySource = default,
            string copyProgress = default,
            string copyStatusDescription = default,
            long? contentLength = default,
            bool? incrementalCopy = default,
            string destinationSnapshot = default,
            int? remainingRetentionDays = default,
            Azure.Storage.Blobs.Models.AccessTier? accessTier = default,
            System.DateTimeOffset? lastModified = default,
            Azure.Storage.Blobs.Models.ArchiveStatus? archiveStatus = default,
            string customerProvidedKeySha256 = default,
            string encryptionScope = default,
            long? tagCount = default,
            System.DateTimeOffset? expiresOn = default,
            bool? isSealed = default,
            Azure.Storage.Blobs.Models.RehydratePriority? rehydratePriority = default,
            System.DateTimeOffset? lastAccessedOn = default,
            Azure.ETag? eTag = default,
            System.DateTimeOffset? createdOn = default,
            System.DateTimeOffset? copyCompletedOn = default,
            System.DateTimeOffset? deletedOn = default,
            System.DateTimeOffset? accessTierChangedOn = default)
        {
            return new BlobItemProperties()
            {
                AccessTierInferred = accessTierInferred,
                ServerEncrypted = serverEncrypted,
                ContentType = contentType,
                ContentEncoding = contentEncoding,
                ContentLanguage = contentLanguage,
                ContentHash = contentHash,
                ContentDisposition = contentDisposition,
                CacheControl = cacheControl,
                BlobSequenceNumber = blobSequenceNumber,
                BlobType = blobType,
                LeaseStatus = leaseStatus,
                LeaseState = leaseState,
                LeaseDuration = leaseDuration,
                CopyId = copyId,
                CopyStatus = copyStatus,
                CopySource = copySource,
                CopyProgress = copyProgress,
                CopyStatusDescription = copyStatusDescription,
                ContentLength = contentLength,
                IncrementalCopy = incrementalCopy,
                DestinationSnapshot = destinationSnapshot,
                RemainingRetentionDays = remainingRetentionDays,
                AccessTier = accessTier,
                LastModified = lastModified,
                ArchiveStatus = archiveStatus,
                CustomerProvidedKeySha256 = customerProvidedKeySha256,
                EncryptionScope = encryptionScope,
                TagCount = tagCount,
                ExpiresOn = expiresOn,
                IsSealed = isSealed,
                RehydratePriority = rehydratePriority,
                LastAccessedOn = lastAccessedOn,
                ETag = eTag,
                CreatedOn = createdOn,
                CopyCompletedOn = copyCompletedOn,
                DeletedOn = deletedOn,
                AccessTierChangedOn = accessTierChangedOn,
            };
        }
    }
}
#endregion class BlobItemProperties

#region class BlobLease
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobLease
    /// </summary>
    public partial class BlobLease
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// Uniquely identifies a container's or blob's lease
        /// </summary>
        public string LeaseId { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobLease instances.
        /// You can use BlobsModelFactory.BlobLease instead.
        /// </summary>
        internal BlobLease() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobLease instance for mocking.
        /// </summary>
        public static BlobLease BlobLease(
            Azure.ETag eTag,
            System.DateTimeOffset lastModified,
            string leaseId)
        {
            return new BlobLease()
            {
                ETag = eTag,
                LastModified = lastModified,
                LeaseId = leaseId,
            };
        }
    }
}
#endregion class BlobLease

#region class BlobMetrics
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// a summary of request statistics grouped by API in hour or minute aggregates for blobs
    /// </summary>
    public partial class BlobMetrics
    {
        /// <summary>
        /// The version of Storage Analytics to configure.
        /// </summary>
        public string Version { get; set; }

        /// <summary>
        /// Indicates whether metrics are enabled for the Blob service.
        /// </summary>
        public bool Enabled { get; set; }

        /// <summary>
        /// the retention policy which determines how long the associated data should persist
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobRetentionPolicy RetentionPolicy { get; set; }

        /// <summary>
        /// Indicates whether metrics should generate summary statistics for called API operations.
        /// </summary>
        public bool? IncludeApis { get; set; }

        /// <summary>
        /// Creates a new BlobMetrics instance
        /// </summary>
        public BlobMetrics()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobMetrics instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobMetrics(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                RetentionPolicy = new Azure.Storage.Blobs.Models.BlobRetentionPolicy();
            }
        }

        /// <summary>
        /// Serialize a BlobMetrics instance as XML.
        /// </summary>
        /// <param name="value">The BlobMetrics instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "Metrics".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobMetrics value, string name = "Metrics", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            if (value.Version != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Version", ""),
                    value.Version));
            }
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Enabled", ""),
                #pragma warning disable CA1308 // Normalize strings to uppercase
                value.Enabled.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant()));
                #pragma warning restore CA1308 // Normalize strings to uppercase
            if (value.RetentionPolicy != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.BlobRetentionPolicy.ToXml(value.RetentionPolicy, "RetentionPolicy", ""));
            }
            if (value.IncludeApis != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("IncludeAPIs", ""),
                    #pragma warning disable CA1308 // Normalize strings to uppercase
                    value.IncludeApis.Value.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant()));
                    #pragma warning restore CA1308 // Normalize strings to uppercase
            }
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobMetrics instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobMetrics instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobMetrics FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobMetrics _value = new Azure.Storage.Blobs.Models.BlobMetrics(true);
            _child = element.Element(System.Xml.Linq.XName.Get("Version", ""));
            if (_child != null)
            {
                _value.Version = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Enabled", ""));
            if (_child != null)
            {
                _value.Enabled = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("RetentionPolicy", ""));
            if (_child != null)
            {
                _value.RetentionPolicy = Azure.Storage.Blobs.Models.BlobRetentionPolicy.FromXml(_child);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("IncludeAPIs", ""));
            if (_child != null)
            {
                _value.IncludeApis = bool.Parse(_child.Value);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobMetrics value);
    }
}
#endregion class BlobMetrics

#region class BlobPrefix
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobPrefix
    /// </summary>
    internal partial class BlobPrefix
    {
        /// <summary>
        /// Name
        /// </summary>
        public string Name { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobPrefix instances.
        /// You can use BlobsModelFactory.BlobPrefix instead.
        /// </summary>
        internal BlobPrefix() { }

        /// <summary>
        /// Deserializes XML into a new BlobPrefix instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobPrefix instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobPrefix FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobPrefix _value = new Azure.Storage.Blobs.Models.BlobPrefix();
            _child = element.Element(System.Xml.Linq.XName.Get("Name", ""));
            if (_child != null)
            {
                _value.Name = _child.Value;
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobPrefix value);
    }
}
#endregion class BlobPrefix

#region class BlobPropertiesInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobPropertiesInternal
    /// </summary>
    internal partial class BlobPropertiesInternal
    {
        /// <summary>
        /// Returns the date and time the blob was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// Returns the date and time the blob was created.
        /// </summary>
        public System.DateTimeOffset CreatedOn { get; internal set; }

        /// <summary>
        /// x-ms-meta
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; internal set; }

        /// <summary>
        /// Optional. Only valid when Object Replication is enabled for the storage container and on the destination blob of the replication.
        /// </summary>
        public string ObjectReplicationPolicyId { get; internal set; }

        /// <summary>
        /// Optional. Only valid when Object Replication is enabled for the storage container and on the source blob of the replication. When retrieving this header, it will return the header with the policy id and rule id (e.g. x-ms-or-policyid_ruleid), and the value will be the status of the replication (e.g. complete, failed).
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> ObjectReplicationRules { get; internal set; }

        /// <summary>
        /// The blob's type.
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobType BlobType { get; internal set; }

        /// <summary>
        /// Conclusion time of the last attempted Copy Blob operation where this blob was the destination blob. This value can specify the time of a completed, aborted, or failed copy attempt. This header does not appear if a copy is pending, if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List.
        /// </summary>
        public System.DateTimeOffset CopyCompletedOn { get; internal set; }

        /// <summary>
        /// Only appears when x-ms-copy-status is failed or pending. Describes the cause of the last fatal or non-fatal copy operation failure. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List
        /// </summary>
        public string CopyStatusDescription { get; internal set; }

        /// <summary>
        /// String identifier for this copy operation. Use with Get Blob Properties to check the status of this copy operation, or pass to Abort Copy Blob to abort a pending copy.
        /// </summary>
        public string CopyId { get; internal set; }

        /// <summary>
        /// Contains the number of bytes copied and the total bytes in the source in the last attempted Copy Blob operation where this blob was the destination blob. Can show between 0 and Content-Length bytes copied. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List
        /// </summary>
        public string CopyProgress { get; internal set; }

        /// <summary>
        /// URL up to 2 KB in length that specifies the source blob or file used in the last attempted Copy Blob operation where this blob was the destination blob. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List.
        /// </summary>
        public System.Uri CopySource { get; internal set; }

        /// <summary>
        /// State of the copy operation identified by x-ms-copy-id.
        /// </summary>
        public Azure.Storage.Blobs.Models.CopyStatus CopyStatus { get; internal set; }

        /// <summary>
        /// Included if the blob is incremental copy blob.
        /// </summary>
        public bool IsIncrementalCopy { get; internal set; }

        /// <summary>
        /// Included if the blob is incremental copy blob or incremental copy snapshot, if x-ms-copy-status is success. Snapshot time of the last successful incremental copy snapshot for this blob.
        /// </summary>
        public string DestinationSnapshot { get; internal set; }

        /// <summary>
        /// When a blob is leased, specifies whether the lease is of infinite or fixed duration.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseDurationType LeaseDuration { get; internal set; }

        /// <summary>
        /// Lease state of the blob.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseState LeaseState { get; internal set; }

        /// <summary>
        /// The current lease status of the blob.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseStatus LeaseStatus { get; internal set; }

        /// <summary>
        /// The number of bytes present in the response body.
        /// </summary>
        public long ContentLength { get; internal set; }

        /// <summary>
        /// The content type specified for the blob. The default content type is 'application/octet-stream'
        /// </summary>
        public string ContentType { get; internal set; }

        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// If the blob has an MD5 hash and this operation is to read the full blob, this response header is returned so that the client can check for message content integrity.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// This header returns the value that was specified for the Content-Encoding request header
        /// </summary>
        public string ContentEncoding { get; internal set; }

        /// <summary>
        /// This header returns the value that was specified for the 'x-ms-blob-content-disposition' header. The Content-Disposition response header field conveys additional information about how to process the response payload, and also can be used to attach additional metadata. For example, if set to attachment, it indicates that the user-agent should not display the response, but instead show a Save As dialog with a filename other than the blob name specified.
        /// </summary>
        public string ContentDisposition { get; internal set; }

        /// <summary>
        /// This header returns the value that was specified for the Content-Language request header.
        /// </summary>
        public string ContentLanguage { get; internal set; }

        /// <summary>
        /// This header is returned if it was previously specified for the blob.
        /// </summary>
        public string CacheControl { get; internal set; }

        /// <summary>
        /// The current sequence number for a page blob. This header is not returned for block blobs or append blobs
        /// </summary>
        public long BlobSequenceNumber { get; internal set; }

        /// <summary>
        /// Indicates that the service supports requests for partial blob content.
        /// </summary>
        public string AcceptRanges { get; internal set; }

        /// <summary>
        /// The number of committed blocks present in the blob. This header is returned only for append blobs.
        /// </summary>
        public int BlobCommittedBlockCount { get; internal set; }

        /// <summary>
        /// The value of this header is set to true if the blob data and application metadata are completely encrypted using the specified algorithm. Otherwise, the value is set to false (when the blob is unencrypted, or if only parts of the blob/application metadata are encrypted).
        /// </summary>
        public bool IsServerEncrypted { get; internal set; }

        /// <summary>
        /// The SHA-256 hash of the encryption key used to encrypt the metadata. This header is only returned when the metadata was encrypted with a customer-provided key.
        /// </summary>
        public string EncryptionKeySha256 { get; internal set; }

        /// <summary>
        /// Returns the name of the encryption scope used to encrypt the blob contents and application metadata.  Note that the absence of this header implies use of the default account encryption scope.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// The tier of page blob on a premium storage account or tier of block blob on blob storage LRS accounts. For a list of allowed premium page blob tiers, see https://docs.microsoft.com/en-us/azure/virtual-machines/windows/premium-storage#features. For blob storage LRS accounts, valid values are Hot/Cool/Archive.
        /// </summary>
        public string AccessTier { get; internal set; }

        /// <summary>
        /// For page blobs on a premium storage account only. If the access tier is not explicitly set on the blob, the tier is inferred based on its content length and this header will be returned with true value.
        /// </summary>
        public bool AccessTierInferred { get; internal set; }

        /// <summary>
        /// For blob storage LRS accounts, valid values are rehydrate-pending-to-hot/rehydrate-pending-to-cool. If the blob is being rehydrated and is not complete then this header is returned indicating that rehydrate is pending and also tells the destination tier.
        /// </summary>
        public string ArchiveStatus { get; internal set; }

        /// <summary>
        /// The time the tier was changed on the object. This is only returned if the tier on the block blob was ever set.
        /// </summary>
        public System.DateTimeOffset AccessTierChangedOn { get; internal set; }

        /// <summary>
        /// A DateTime value returned by the service that uniquely identifies the blob. The value of this header indicates the blob version, and may be used in subsequent requests to access this version of the blob.
        /// </summary>
        public string VersionId { get; internal set; }

        /// <summary>
        /// The value of this header indicates whether version of this blob is a current version, see also x-ms-version-id header.
        /// </summary>
        public bool IsCurrentVersion { get; internal set; }

        /// <summary>
        /// The number of tags associated with the blob
        /// </summary>
        public long TagCount { get; internal set; }

        /// <summary>
        /// The time this blob will expire.
        /// </summary>
        public System.DateTimeOffset ExpiresOn { get; internal set; }

        /// <summary>
        /// If this blob has been sealed
        /// </summary>
        public bool IsSealed { get; internal set; }

        /// <summary>
        /// If an object is in rehydrate pending state then this header is returned with priority of rehydrate. Valid values are High and Standard.
        /// </summary>
        public string RehydratePriority { get; internal set; }

        /// <summary>
        /// UTC date/time value generated by the service that indicates the time at which the blob was last read or written to
        /// </summary>
        public System.DateTimeOffset LastAccessed { get; internal set; }

        /// <summary>
        /// Creates a new BlobPropertiesInternal instance
        /// </summary>
        public BlobPropertiesInternal()
        {
            Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
            ObjectReplicationRules = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
        }
    }
}
#endregion class BlobPropertiesInternal

#region class BlobRetentionPolicy
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// the retention policy which determines how long the associated data should persist
    /// </summary>
    public partial class BlobRetentionPolicy
    {
        /// <summary>
        /// Indicates whether a retention policy is enabled for the storage service
        /// </summary>
        public bool Enabled { get; set; }

        /// <summary>
        /// Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this value will be deleted
        /// </summary>
        public int? Days { get; set; }

        /// <summary>
        /// Creates a new BlobRetentionPolicy instance
        /// </summary>
        public BlobRetentionPolicy() { }

        /// <summary>
        /// Serialize a BlobRetentionPolicy instance as XML.
        /// </summary>
        /// <param name="value">The BlobRetentionPolicy instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "RetentionPolicy".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobRetentionPolicy value, string name = "RetentionPolicy", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Enabled", ""),
                #pragma warning disable CA1308 // Normalize strings to uppercase
                value.Enabled.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant()));
                #pragma warning restore CA1308 // Normalize strings to uppercase
            if (value.Days != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Days", ""),
                    value.Days.Value.ToString(System.Globalization.CultureInfo.InvariantCulture)));
            }
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobRetentionPolicy instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobRetentionPolicy instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobRetentionPolicy FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobRetentionPolicy _value = new Azure.Storage.Blobs.Models.BlobRetentionPolicy();
            _child = element.Element(System.Xml.Linq.XName.Get("Enabled", ""));
            if (_child != null)
            {
                _value.Enabled = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Days", ""));
            if (_child != null)
            {
                _value.Days = int.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobRetentionPolicy value);
    }
}
#endregion class BlobRetentionPolicy

#region class BlobServiceProperties
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Storage Service Properties.
    /// </summary>
    public partial class BlobServiceProperties
    {
        /// <summary>
        /// Azure Analytics Logging settings.
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobAnalyticsLogging Logging { get; set; }

        /// <summary>
        /// a summary of request statistics grouped by API in hour or minute aggregates for blobs
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobMetrics HourMetrics { get; set; }

        /// <summary>
        /// a summary of request statistics grouped by API in hour or minute aggregates for blobs
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobMetrics MinuteMetrics { get; set; }

        /// <summary>
        /// The set of CORS rules.
        /// </summary>
        public System.Collections.Generic.IList<Azure.Storage.Blobs.Models.BlobCorsRule> Cors { get; set; }

        /// <summary>
        /// The default version to use for requests to the Blob service if an incoming request's version is not specified. Possible values include version 2008-10-27 and all more recent versions
        /// </summary>
        public string DefaultServiceVersion { get; set; }

        /// <summary>
        /// the retention policy which determines how long the associated data should persist
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobRetentionPolicy DeleteRetentionPolicy { get; set; }

        /// <summary>
        /// The properties that enable an account to host a static website
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobStaticWebsite StaticWebsite { get; set; }

        /// <summary>
        /// Creates a new BlobServiceProperties instance
        /// </summary>
        public BlobServiceProperties()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobServiceProperties instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobServiceProperties(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                Logging = new Azure.Storage.Blobs.Models.BlobAnalyticsLogging();
                HourMetrics = new Azure.Storage.Blobs.Models.BlobMetrics();
                MinuteMetrics = new Azure.Storage.Blobs.Models.BlobMetrics();
                DeleteRetentionPolicy = new Azure.Storage.Blobs.Models.BlobRetentionPolicy();
                StaticWebsite = new Azure.Storage.Blobs.Models.BlobStaticWebsite();
            }
        }

        /// <summary>
        /// Serialize a BlobServiceProperties instance as XML.
        /// </summary>
        /// <param name="value">The BlobServiceProperties instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "StorageServiceProperties".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobServiceProperties value, string name = "StorageServiceProperties", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            if (value.Logging != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.BlobAnalyticsLogging.ToXml(value.Logging, "Logging", ""));
            }
            if (value.HourMetrics != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.BlobMetrics.ToXml(value.HourMetrics, "HourMetrics", ""));
            }
            if (value.MinuteMetrics != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.BlobMetrics.ToXml(value.MinuteMetrics, "MinuteMetrics", ""));
            }
            if (value.Cors != null)
            {
                System.Xml.Linq.XElement _elements = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get("Cors", ""));
                foreach (Azure.Storage.Blobs.Models.BlobCorsRule _child in value.Cors)
                {
                    _elements.Add(Azure.Storage.Blobs.Models.BlobCorsRule.ToXml(_child));
                }
                _element.Add(_elements);
            }
            if (value.DefaultServiceVersion != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("DefaultServiceVersion", ""),
                    value.DefaultServiceVersion));
            }
            if (value.DeleteRetentionPolicy != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.BlobRetentionPolicy.ToXml(value.DeleteRetentionPolicy, "DeleteRetentionPolicy", ""));
            }
            if (value.StaticWebsite != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.BlobStaticWebsite.ToXml(value.StaticWebsite, "StaticWebsite", ""));
            }
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobServiceProperties instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobServiceProperties instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobServiceProperties FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobServiceProperties _value = new Azure.Storage.Blobs.Models.BlobServiceProperties(true);
            _child = element.Element(System.Xml.Linq.XName.Get("Logging", ""));
            if (_child != null)
            {
                _value.Logging = Azure.Storage.Blobs.Models.BlobAnalyticsLogging.FromXml(_child);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("HourMetrics", ""));
            if (_child != null)
            {
                _value.HourMetrics = Azure.Storage.Blobs.Models.BlobMetrics.FromXml(_child);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("MinuteMetrics", ""));
            if (_child != null)
            {
                _value.MinuteMetrics = Azure.Storage.Blobs.Models.BlobMetrics.FromXml(_child);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Cors", ""));
            if (_child != null)
            {
                _value.Cors = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("CorsRule", "")),
                        e => Azure.Storage.Blobs.Models.BlobCorsRule.FromXml(e)));
            }
            else
            {
                _value.Cors = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobCorsRule>();
            }
            _child = element.Element(System.Xml.Linq.XName.Get("DefaultServiceVersion", ""));
            if (_child != null)
            {
                _value.DefaultServiceVersion = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("DeleteRetentionPolicy", ""));
            if (_child != null)
            {
                _value.DeleteRetentionPolicy = Azure.Storage.Blobs.Models.BlobRetentionPolicy.FromXml(_child);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("StaticWebsite", ""));
            if (_child != null)
            {
                _value.StaticWebsite = Azure.Storage.Blobs.Models.BlobStaticWebsite.FromXml(_child);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobServiceProperties value);
    }
}
#endregion class BlobServiceProperties

#region class BlobServiceStatistics
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Statistics for the storage service.
    /// </summary>
    public partial class BlobServiceStatistics
    {
        /// <summary>
        /// Geo-Replication information for the Secondary Storage Service
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobGeoReplication GeoReplication { get; internal set; }

        /// <summary>
        /// Creates a new BlobServiceStatistics instance
        /// </summary>
        internal BlobServiceStatistics()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobServiceStatistics instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobServiceStatistics(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                GeoReplication = new Azure.Storage.Blobs.Models.BlobGeoReplication();
            }
        }

        /// <summary>
        /// Deserializes XML into a new BlobServiceStatistics instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobServiceStatistics instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobServiceStatistics FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobServiceStatistics _value = new Azure.Storage.Blobs.Models.BlobServiceStatistics(true);
            _child = element.Element(System.Xml.Linq.XName.Get("GeoReplication", ""));
            if (_child != null)
            {
                _value.GeoReplication = Azure.Storage.Blobs.Models.BlobGeoReplication.FromXml(_child);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobServiceStatistics value);
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobServiceStatistics instance for mocking.
        /// </summary>
        public static BlobServiceStatistics BlobServiceStatistics(
            Azure.Storage.Blobs.Models.BlobGeoReplication geoReplication = default)
        {
            return new BlobServiceStatistics()
            {
                GeoReplication = geoReplication,
            };
        }
    }
}
#endregion class BlobServiceStatistics

#region class BlobSetExpiryInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobSetExpiryInternal
    /// </summary>
    internal partial class BlobSetExpiryInternal
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobSetExpiryInternal instances.
        /// You can use BlobsModelFactory.BlobSetExpiryInternal instead.
        /// </summary>
        internal BlobSetExpiryInternal() { }
    }
}
#endregion class BlobSetExpiryInternal

#region class BlobSignedIdentifier
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// signed identifier
    /// </summary>
    public partial class BlobSignedIdentifier
    {
        /// <summary>
        /// a unique id
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// An Access policy
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobAccessPolicy AccessPolicy { get; set; }

        /// <summary>
        /// Creates a new BlobSignedIdentifier instance
        /// </summary>
        public BlobSignedIdentifier()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobSignedIdentifier instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobSignedIdentifier(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                AccessPolicy = new Azure.Storage.Blobs.Models.BlobAccessPolicy();
            }
        }

        /// <summary>
        /// Serialize a BlobSignedIdentifier instance as XML.
        /// </summary>
        /// <param name="value">The BlobSignedIdentifier instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "SignedIdentifier".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobSignedIdentifier value, string name = "SignedIdentifier", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Id", ""),
                value.Id));
            _element.Add(Azure.Storage.Blobs.Models.BlobAccessPolicy.ToXml(value.AccessPolicy, "AccessPolicy", ""));
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobSignedIdentifier instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobSignedIdentifier instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobSignedIdentifier FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobSignedIdentifier _value = new Azure.Storage.Blobs.Models.BlobSignedIdentifier(true);
            _child = element.Element(System.Xml.Linq.XName.Get("Id", ""));
            if (_child != null)
            {
                _value.Id = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("AccessPolicy", ""));
            if (_child != null)
            {
                _value.AccessPolicy = Azure.Storage.Blobs.Models.BlobAccessPolicy.FromXml(_child);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobSignedIdentifier value);
    }
}
#endregion class BlobSignedIdentifier

#region class BlobSnapshotInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobSnapshotInfo
    /// </summary>
    public partial class BlobSnapshotInfo
    {
        /// <summary>
        /// Uniquely identifies the snapshot and indicates the snapshot version. It may be used in subsequent requests to access the snapshot
        /// </summary>
        public string Snapshot { get; internal set; }

        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// A DateTime value returned by the service that uniquely identifies the blob. The value of this header indicates the blob version, and may be used in subsequent requests to access this version of the blob.
        /// </summary>
        public string VersionId { get; internal set; }

        /// <summary>
        /// True if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. For a snapshot request, this header is set to true when metadata was provided in the request and encrypted with a customer-provided key.
        /// </summary>
        public bool IsServerEncrypted { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlobSnapshotInfo instances.
        /// You can use BlobsModelFactory.BlobSnapshotInfo instead.
        /// </summary>
        internal BlobSnapshotInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlobSnapshotInfo instance for mocking.
        /// </summary>
        public static BlobSnapshotInfo BlobSnapshotInfo(
            string snapshot,
            Azure.ETag eTag,
            System.DateTimeOffset lastModified,
            string versionId,
            bool isServerEncrypted)
        {
            return new BlobSnapshotInfo()
            {
                Snapshot = snapshot,
                ETag = eTag,
                LastModified = lastModified,
                VersionId = versionId,
                IsServerEncrypted = isServerEncrypted,
            };
        }
    }
}
#endregion class BlobSnapshotInfo

#region class BlobStaticWebsite
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// The properties that enable an account to host a static website
    /// </summary>
    public partial class BlobStaticWebsite
    {
        /// <summary>
        /// Indicates whether this account is hosting a static website
        /// </summary>
        public bool Enabled { get; set; }

        /// <summary>
        /// The default name of the index page under each directory
        /// </summary>
        public string IndexDocument { get; set; }

        /// <summary>
        /// The absolute path of the custom 404 page
        /// </summary>
        public string ErrorDocument404Path { get; set; }

        /// <summary>
        /// Absolute path of the default index page
        /// </summary>
        public string DefaultIndexDocumentPath { get; set; }

        /// <summary>
        /// Creates a new BlobStaticWebsite instance
        /// </summary>
        public BlobStaticWebsite() { }

        /// <summary>
        /// Serialize a BlobStaticWebsite instance as XML.
        /// </summary>
        /// <param name="value">The BlobStaticWebsite instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "StaticWebsite".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobStaticWebsite value, string name = "StaticWebsite", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Enabled", ""),
                #pragma warning disable CA1308 // Normalize strings to uppercase
                value.Enabled.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant()));
                #pragma warning restore CA1308 // Normalize strings to uppercase
            if (value.IndexDocument != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("IndexDocument", ""),
                    value.IndexDocument));
            }
            if (value.ErrorDocument404Path != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("ErrorDocument404Path", ""),
                    value.ErrorDocument404Path));
            }
            if (value.DefaultIndexDocumentPath != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("DefaultIndexDocumentPath", ""),
                    value.DefaultIndexDocumentPath));
            }
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobStaticWebsite instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobStaticWebsite instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobStaticWebsite FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobStaticWebsite _value = new Azure.Storage.Blobs.Models.BlobStaticWebsite();
            _child = element.Element(System.Xml.Linq.XName.Get("Enabled", ""));
            if (_child != null)
            {
                _value.Enabled = bool.Parse(_child.Value);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("IndexDocument", ""));
            if (_child != null)
            {
                _value.IndexDocument = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("ErrorDocument404Path", ""));
            if (_child != null)
            {
                _value.ErrorDocument404Path = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("DefaultIndexDocumentPath", ""));
            if (_child != null)
            {
                _value.DefaultIndexDocumentPath = _child.Value;
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobStaticWebsite value);
    }
}
#endregion class BlobStaticWebsite

#region class BlobTag
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobTag
    /// </summary>
    internal partial class BlobTag
    {
        /// <summary>
        /// Key
        /// </summary>
        public string Key { get; set; }

        /// <summary>
        /// Value
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Creates a new BlobTag instance
        /// </summary>
        public BlobTag() { }

        /// <summary>
        /// Serialize a BlobTag instance as XML.
        /// </summary>
        /// <param name="value">The BlobTag instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "Tag".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobTag value, string name = "Tag", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Key", ""),
                value.Key));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Value", ""),
                value.Value));
            return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobTag instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobTag instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobTag FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobTag _value = new Azure.Storage.Blobs.Models.BlobTag();
            _child = element.Element(System.Xml.Linq.XName.Get("Key", ""));
            if (_child != null)
            {
                _value.Key = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Value", ""));
            if (_child != null)
            {
                _value.Value = _child.Value;
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobTag value);
    }
}
#endregion class BlobTag

#region class BlobTags
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Blob tags
    /// </summary>
    internal partial class BlobTags
    {
        /// <summary>
        /// BlobTagSet
        /// </summary>
        public System.Collections.Generic.IList<Azure.Storage.Blobs.Models.BlobTag> BlobTagSet { get; internal set; }

        /// <summary>
        /// Creates a new BlobTags instance
        /// </summary>
        public BlobTags()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobTags instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobTags(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                BlobTagSet = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobTag>();
            }
        }

        /// <summary>
        /// Serialize a BlobTags instance as XML.
        /// </summary>
        /// <param name="value">The BlobTags instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "Tags".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlobTags value, string name = "Tags", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            System.Xml.Linq.XElement _elements = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get("TagSet", ""));
            foreach (Azure.Storage.Blobs.Models.BlobTag _child in value.BlobTagSet)
            {
                _elements.Add(Azure.Storage.Blobs.Models.BlobTag.ToXml(_child));
            }
            _element.Add(_elements);return _element;
        }

        /// <summary>
        /// Deserializes XML into a new BlobTags instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobTags instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobTags FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlobTags _value = new Azure.Storage.Blobs.Models.BlobTags(true);
            _child = element.Element(System.Xml.Linq.XName.Get("TagSet", ""));
            if (_child != null)
            {
                _value.BlobTagSet = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("Tag", "")),
                        e => Azure.Storage.Blobs.Models.BlobTag.FromXml(e)));
            }
            else
            {
                _value.BlobTagSet = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobTag>();
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobTags value);
    }
}
#endregion class BlobTags

#region enum BlobType
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlobType values
    /// </summary>
    public enum BlobType
    {
        /// <summary>
        /// BlockBlob
        /// </summary>
        Block,

        /// <summary>
        /// PageBlob
        /// </summary>
        Page,

        /// <summary>
        /// AppendBlob
        /// </summary>
        Append
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.BlobType value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.BlobType.Block => "BlockBlob",
                    Azure.Storage.Blobs.Models.BlobType.Page => "PageBlob",
                    Azure.Storage.Blobs.Models.BlobType.Append => "AppendBlob",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.BlobType value.")
                };
            }

            public static Azure.Storage.Blobs.Models.BlobType ParseBlobType(string value)
            {
                return value switch
                {
                    "BlockBlob" => Azure.Storage.Blobs.Models.BlobType.Block,
                    "PageBlob" => Azure.Storage.Blobs.Models.BlobType.Page,
                    "AppendBlob" => Azure.Storage.Blobs.Models.BlobType.Append,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.BlobType value.")
                };
            }
        }
    }
}
#endregion enum BlobType

#region class BlobsFlatSegment
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// An enumeration of blobs
    /// </summary>
    internal partial class BlobsFlatSegment
    {
        /// <summary>
        /// ServiceEndpoint
        /// </summary>
        public string ServiceEndpoint { get; internal set; }

        /// <summary>
        /// ContainerName
        /// </summary>
        public string ContainerName { get; internal set; }

        /// <summary>
        /// Prefix
        /// </summary>
        public string Prefix { get; internal set; }

        /// <summary>
        /// Marker
        /// </summary>
        public string Marker { get; internal set; }

        /// <summary>
        /// MaxResults
        /// </summary>
        public int? MaxResults { get; internal set; }

        /// <summary>
        /// NextMarker
        /// </summary>
        public string NextMarker { get; internal set; }

        /// <summary>
        /// BlobItems
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobItemInternal> BlobItems { get; internal set; }

        /// <summary>
        /// Creates a new BlobsFlatSegment instance
        /// </summary>
        public BlobsFlatSegment()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobsFlatSegment instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobsFlatSegment(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                BlobItems = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobItemInternal>();
            }
        }

        /// <summary>
        /// Deserializes XML into a new BlobsFlatSegment instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobsFlatSegment instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobsFlatSegment FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            System.Xml.Linq.XAttribute _attribute;
            Azure.Storage.Blobs.Models.BlobsFlatSegment _value = new Azure.Storage.Blobs.Models.BlobsFlatSegment(true);
            _attribute = element.Attribute(System.Xml.Linq.XName.Get("ServiceEndpoint", ""));
            if (_attribute != null)
            {
                _value.ServiceEndpoint = _attribute.Value;
            }
            _attribute = element.Attribute(System.Xml.Linq.XName.Get("ContainerName", ""));
            if (_attribute != null)
            {
                _value.ContainerName = _attribute.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Prefix", ""));
            if (_child != null)
            {
                _value.Prefix = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Marker", ""));
            if (_child != null)
            {
                _value.Marker = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("MaxResults", ""));
            if (_child != null)
            {
                _value.MaxResults = int.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("NextMarker", ""));
            if (_child != null)
            {
                _value.NextMarker = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Blobs", ""));
            if (_child != null)
            {
                _value.BlobItems = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("Blob", "")),
                        e => Azure.Storage.Blobs.Models.BlobItemInternal.FromXml(e)));
            }
            else
            {
                _value.BlobItems = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobItemInternal>();
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobsFlatSegment value);
    }
}
#endregion class BlobsFlatSegment

#region class BlobsHierarchySegment
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// An enumeration of blobs
    /// </summary>
    internal partial class BlobsHierarchySegment
    {
        /// <summary>
        /// ServiceEndpoint
        /// </summary>
        public string ServiceEndpoint { get; internal set; }

        /// <summary>
        /// ContainerName
        /// </summary>
        public string ContainerName { get; internal set; }

        /// <summary>
        /// Prefix
        /// </summary>
        public string Prefix { get; internal set; }

        /// <summary>
        /// Marker
        /// </summary>
        public string Marker { get; internal set; }

        /// <summary>
        /// MaxResults
        /// </summary>
        public int? MaxResults { get; internal set; }

        /// <summary>
        /// Delimiter
        /// </summary>
        public string Delimiter { get; internal set; }

        /// <summary>
        /// NextMarker
        /// </summary>
        public string NextMarker { get; internal set; }

        /// <summary>
        /// BlobItems
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobItemInternal> BlobItems { get; internal set; }

        /// <summary>
        /// BlobPrefixes
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobPrefix> BlobPrefixes { get; internal set; }

        /// <summary>
        /// Creates a new BlobsHierarchySegment instance
        /// </summary>
        public BlobsHierarchySegment()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlobsHierarchySegment instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlobsHierarchySegment(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                BlobItems = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobItemInternal>();
                BlobPrefixes = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobPrefix>();
            }
        }

        /// <summary>
        /// Deserializes XML into a new BlobsHierarchySegment instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlobsHierarchySegment instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlobsHierarchySegment FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            System.Xml.Linq.XAttribute _attribute;
            Azure.Storage.Blobs.Models.BlobsHierarchySegment _value = new Azure.Storage.Blobs.Models.BlobsHierarchySegment(true);
            _attribute = element.Attribute(System.Xml.Linq.XName.Get("ServiceEndpoint", ""));
            if (_attribute != null)
            {
                _value.ServiceEndpoint = _attribute.Value;
            }
            _attribute = element.Attribute(System.Xml.Linq.XName.Get("ContainerName", ""));
            if (_attribute != null)
            {
                _value.ContainerName = _attribute.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Prefix", ""));
            if (_child != null)
            {
                _value.Prefix = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Marker", ""));
            if (_child != null)
            {
                _value.Marker = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("MaxResults", ""));
            if (_child != null)
            {
                _value.MaxResults = int.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Delimiter", ""));
            if (_child != null)
            {
                _value.Delimiter = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("NextMarker", ""));
            if (_child != null)
            {
                _value.NextMarker = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Blobs", ""));
            if (_child != null)
            {
                _value.BlobItems = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("Blob", "")),
                        e => Azure.Storage.Blobs.Models.BlobItemInternal.FromXml(e)));
            }
            else
            {
                _value.BlobItems = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobItemInternal>();
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Blobs", ""));
            if (_child != null)
            {
                _value.BlobPrefixes = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("BlobPrefix", "")),
                        e => Azure.Storage.Blobs.Models.BlobPrefix.FromXml(e)));
            }
            else
            {
                _value.BlobPrefixes = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobPrefix>();
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlobsHierarchySegment value);
    }
}
#endregion class BlobsHierarchySegment

#region class BlockInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlockInfo
    /// </summary>
    public partial class BlockInfo
    {
        /// <summary>
        /// This header is returned so that the client can check for message content integrity. The value of this header is computed by the Blob service; it is not necessarily the same value specified in the request headers.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// This header is returned so that the client can check for message content integrity. The value of this header is computed by the Blob service; it is not necessarily the same value specified in the request headers.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentCrc64 { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// The SHA-256 hash of the encryption key used to encrypt the block. This header is only returned when the block was encrypted with a customer-provided key.
        /// </summary>
        public string EncryptionKeySha256 { get; internal set; }

        /// <summary>
        /// Returns the name of the encryption scope used to encrypt the blob contents and application metadata.  Note that the absence of this header implies use of the default account encryption scope.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BlockInfo instances.
        /// You can use BlobsModelFactory.BlockInfo instead.
        /// </summary>
        internal BlockInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlockInfo instance for mocking.
        /// </summary>
        public static BlockInfo BlockInfo(
            byte[] contentHash,
            byte[] contentCrc64,
            string encryptionKeySha256,
            string encryptionScope)
        {
            return new BlockInfo()
            {
                ContentHash = contentHash,
                ContentCrc64 = contentCrc64,
                EncryptionKeySha256 = encryptionKeySha256,
                EncryptionScope = encryptionScope,
            };
        }
    }
}
#endregion class BlockInfo

#region class BlockList
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BlockList
    /// </summary>
    public partial class BlockList
    {
        /// <summary>
        /// CommittedBlocks
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobBlock> CommittedBlocks { get; internal set; }

        /// <summary>
        /// UncommittedBlocks
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobBlock> UncommittedBlocks { get; internal set; }

        /// <summary>
        /// Creates a new BlockList instance
        /// </summary>
        internal BlockList()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new BlockList instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal BlockList(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                CommittedBlocks = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobBlock>();
                UncommittedBlocks = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobBlock>();
            }
        }

        /// <summary>
        /// Deserializes XML into a new BlockList instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized BlockList instance.</returns>
        internal static Azure.Storage.Blobs.Models.BlockList FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.BlockList _value = new Azure.Storage.Blobs.Models.BlockList(true);
            _child = element.Element(System.Xml.Linq.XName.Get("CommittedBlocks", ""));
            if (_child != null)
            {
                _value.CommittedBlocks = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("Block", "")),
                        e => Azure.Storage.Blobs.Models.BlobBlock.FromXml(e)));
            }
            else
            {
                _value.CommittedBlocks = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobBlock>();
            }
            _child = element.Element(System.Xml.Linq.XName.Get("UncommittedBlocks", ""));
            if (_child != null)
            {
                _value.UncommittedBlocks = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("Block", "")),
                        e => Azure.Storage.Blobs.Models.BlobBlock.FromXml(e)));
            }
            else
            {
                _value.UncommittedBlocks = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.BlobBlock>();
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.BlockList value);
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new BlockList instance for mocking.
        /// </summary>
        public static BlockList BlockList(
            System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobBlock> committedBlocks = default,
            System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.BlobBlock> uncommittedBlocks = default)
        {
            return new BlockList()
            {
                CommittedBlocks = committedBlocks,
                UncommittedBlocks = uncommittedBlocks,
            };
        }
    }
}
#endregion class BlockList

#region enum BlockListType
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Specifies whether to return the list of committed blocks, the list of uncommitted blocks, or both lists together.
    /// </summary>
    internal enum BlockListType
    {
        /// <summary>
        /// committed
        /// </summary>
        Committed,

        /// <summary>
        /// uncommitted
        /// </summary>
        Uncommitted,

        /// <summary>
        /// all
        /// </summary>
        All
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.BlockListType value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.BlockListType.Committed => "committed",
                    Azure.Storage.Blobs.Models.BlockListType.Uncommitted => "uncommitted",
                    Azure.Storage.Blobs.Models.BlockListType.All => "all",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.BlockListType value.")
                };
            }

            public static Azure.Storage.Blobs.Models.BlockListType ParseBlockListType(string value)
            {
                return value switch
                {
                    "committed" => Azure.Storage.Blobs.Models.BlockListType.Committed,
                    "uncommitted" => Azure.Storage.Blobs.Models.BlockListType.Uncommitted,
                    "all" => Azure.Storage.Blobs.Models.BlockListType.All,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.BlockListType value.")
                };
            }
        }
    }
}
#endregion enum BlockListType

#region class BlockLookupList
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// A list of block IDs split between the committed block list, in the uncommitted block list, or in the uncommitted block list first and then in the committed block list.
    /// </summary>
    internal partial class BlockLookupList
    {
        /// <summary>
        /// Committed
        /// </summary>
        public System.Collections.Generic.IList<string> Committed { get; internal set; }

        /// <summary>
        /// Uncommitted
        /// </summary>
        public System.Collections.Generic.IList<string> Uncommitted { get; internal set; }

        /// <summary>
        /// Latest
        /// </summary>
        public System.Collections.Generic.IList<string> Latest { get; internal set; }

        /// <summary>
        /// Creates a new BlockLookupList instance
        /// </summary>
        public BlockLookupList()
        {
            Committed = new System.Collections.Generic.List<string>();
            Uncommitted = new System.Collections.Generic.List<string>();
            Latest = new System.Collections.Generic.List<string>();
        }

        /// <summary>
        /// Serialize a BlockLookupList instance as XML.
        /// </summary>
        /// <param name="value">The BlockLookupList instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "BlockList".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.BlockLookupList value, string name = "BlockList", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            if (value.Committed != null)
            {
                foreach (string _child in value.Committed)
                {
                    _element.Add(new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get("Committed", ""), _child));
                }
            }
            if (value.Uncommitted != null)
            {
                foreach (string _child in value.Uncommitted)
                {
                    _element.Add(new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get("Uncommitted", ""), _child));
                }
            }
            if (value.Latest != null)
            {
                foreach (string _child in value.Latest)
                {
                    _element.Add(new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get("Latest", ""), _child));
                }
            }
            return _element;
        }
    }
}
#endregion class BlockLookupList

#region class BrokenLease
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// BrokenLease
    /// </summary>
    internal partial class BrokenLease
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// Approximate time remaining in the lease period, in seconds.
        /// </summary>
        public int LeaseTime { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of BrokenLease instances.
        /// You can use BlobsModelFactory.BrokenLease instead.
        /// </summary>
        internal BrokenLease() { }
    }
}
#endregion class BrokenLease

#region class ClearRange
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// ClearRange
    /// </summary>
    internal partial class ClearRange
    {
        /// <summary>
        /// Start
        /// </summary>
        public long Start { get; internal set; }

        /// <summary>
        /// End
        /// </summary>
        public long End { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of ClearRange instances.
        /// You can use BlobsModelFactory.ClearRange instead.
        /// </summary>
        internal ClearRange() { }

        /// <summary>
        /// Deserializes XML into a new ClearRange instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized ClearRange instance.</returns>
        internal static Azure.Storage.Blobs.Models.ClearRange FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.ClearRange _value = new Azure.Storage.Blobs.Models.ClearRange();
            _child = element.Element(System.Xml.Linq.XName.Get("Start", ""));
            if (_child != null)
            {
                _value.Start = long.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("End", ""));
            if (_child != null)
            {
                _value.End = long.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.ClearRange value);
    }
}
#endregion class ClearRange

#region class ConditionNotMetError
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// ConditionNotMetError
    /// </summary>
    internal partial class ConditionNotMetError
    {
        /// <summary>
        /// x-ms-error-code
        /// </summary>
        public string ErrorCode { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of ConditionNotMetError instances.
        /// You can use BlobsModelFactory.ConditionNotMetError instead.
        /// </summary>
        internal ConditionNotMetError() { }
    }
}
#endregion class ConditionNotMetError

#region enum CopyStatus
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// CopyStatus values
    /// </summary>
    #pragma warning disable CA1717 // Only FlagsAttribute enums should have plural names
    public enum CopyStatus
    #pragma warning restore CA1717 // Only FlagsAttribute enums should have plural names
    {
        /// <summary>
        /// pending
        /// </summary>
        Pending,

        /// <summary>
        /// success
        /// </summary>
        Success,

        /// <summary>
        /// aborted
        /// </summary>
        Aborted,

        /// <summary>
        /// failed
        /// </summary>
        Failed
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.CopyStatus value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.CopyStatus.Pending => "pending",
                    Azure.Storage.Blobs.Models.CopyStatus.Success => "success",
                    Azure.Storage.Blobs.Models.CopyStatus.Aborted => "aborted",
                    Azure.Storage.Blobs.Models.CopyStatus.Failed => "failed",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.CopyStatus value.")
                };
            }

            public static Azure.Storage.Blobs.Models.CopyStatus ParseCopyStatus(string value)
            {
                return value switch
                {
                    "pending" => Azure.Storage.Blobs.Models.CopyStatus.Pending,
                    "success" => Azure.Storage.Blobs.Models.CopyStatus.Success,
                    "aborted" => Azure.Storage.Blobs.Models.CopyStatus.Aborted,
                    "failed" => Azure.Storage.Blobs.Models.CopyStatus.Failed,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.CopyStatus value.")
                };
            }
        }
    }
}
#endregion enum CopyStatus

#region class DataLakeStorageError
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// DataLakeStorageError
    /// </summary>
    internal partial class DataLakeStorageError
    {
        /// <summary>
        /// The service error response object.
        /// </summary>
        public Azure.Storage.Blobs.Models.DataLakeStorageErrorDetails DataLakeStorageErrorDetails { get; internal set; }

        /// <summary>
        /// Creates a new DataLakeStorageError instance
        /// </summary>
        public DataLakeStorageError()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new DataLakeStorageError instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal DataLakeStorageError(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                DataLakeStorageErrorDetails = new Azure.Storage.Blobs.Models.DataLakeStorageErrorDetails();
            }
        }

        /// <summary>
        /// Deserializes XML into a new DataLakeStorageError instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized DataLakeStorageError instance.</returns>
        internal static Azure.Storage.Blobs.Models.DataLakeStorageError FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.DataLakeStorageError _value = new Azure.Storage.Blobs.Models.DataLakeStorageError(true);
            _child = element.Element(System.Xml.Linq.XName.Get("error", ""));
            if (_child != null)
            {
                _value.DataLakeStorageErrorDetails = Azure.Storage.Blobs.Models.DataLakeStorageErrorDetails.FromXml(_child);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.DataLakeStorageError value);
    }
}
#endregion class DataLakeStorageError

#region class DataLakeStorageErrorDetails
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// The service error response object.
    /// </summary>
    internal partial class DataLakeStorageErrorDetails
    {
        /// <summary>
        /// The service error code.
        /// </summary>
        public string Code { get; internal set; }

        /// <summary>
        /// The service error message.
        /// </summary>
        public string Message { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of DataLakeStorageErrorDetails instances.
        /// You can use BlobsModelFactory.DataLakeStorageErrorDetails instead.
        /// </summary>
        internal DataLakeStorageErrorDetails() { }

        /// <summary>
        /// Deserializes XML into a new DataLakeStorageErrorDetails instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized DataLakeStorageErrorDetails instance.</returns>
        internal static Azure.Storage.Blobs.Models.DataLakeStorageErrorDetails FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.DataLakeStorageErrorDetails _value = new Azure.Storage.Blobs.Models.DataLakeStorageErrorDetails();
            _child = element.Element(System.Xml.Linq.XName.Get("Code", ""));
            if (_child != null)
            {
                _value.Code = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Message", ""));
            if (_child != null)
            {
                _value.Message = _child.Value;
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.DataLakeStorageErrorDetails value);
    }
}
#endregion class DataLakeStorageErrorDetails

#region enum DeleteSnapshotsOption
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Required if the blob has associated snapshots. Specify one of the following two options: include: Delete the base blob and all of its snapshots. only: Delete only the blob's snapshots and not the blob itself
    /// </summary>
    public enum DeleteSnapshotsOption
    {
        /// <summary>
        /// none
        /// </summary>
        None,

        /// <summary>
        /// include
        /// </summary>
        IncludeSnapshots,

        /// <summary>
        /// only
        /// </summary>
        OnlySnapshots
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.DeleteSnapshotsOption value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.DeleteSnapshotsOption.None => null,
                    Azure.Storage.Blobs.Models.DeleteSnapshotsOption.IncludeSnapshots => "include",
                    Azure.Storage.Blobs.Models.DeleteSnapshotsOption.OnlySnapshots => "only",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.DeleteSnapshotsOption value.")
                };
            }

            public static Azure.Storage.Blobs.Models.DeleteSnapshotsOption ParseDeleteSnapshotsOption(string value)
            {
                return value switch
                {
                    null => Azure.Storage.Blobs.Models.DeleteSnapshotsOption.None,
                    "include" => Azure.Storage.Blobs.Models.DeleteSnapshotsOption.IncludeSnapshots,
                    "only" => Azure.Storage.Blobs.Models.DeleteSnapshotsOption.OnlySnapshots,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.DeleteSnapshotsOption value.")
                };
            }
        }
    }
}
#endregion enum DeleteSnapshotsOption

#region class DelimitedTextConfigurationInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// delimited text configuration
    /// </summary>
    internal partial class DelimitedTextConfigurationInternal
    {
        /// <summary>
        /// column separator
        /// </summary>
        public string ColumnSeparator { get; set; }

        /// <summary>
        /// field quote
        /// </summary>
        public string FieldQuote { get; set; }

        /// <summary>
        /// record separator
        /// </summary>
        public string RecordSeparator { get; set; }

        /// <summary>
        /// escape char
        /// </summary>
        public string EscapeChar { get; set; }

        /// <summary>
        /// has headers
        /// </summary>
        public bool HeadersPresent { get; set; }

        /// <summary>
        /// Creates a new DelimitedTextConfigurationInternal instance
        /// </summary>
        public DelimitedTextConfigurationInternal() { }

        /// <summary>
        /// Serialize a DelimitedTextConfigurationInternal instance as XML.
        /// </summary>
        /// <param name="value">The DelimitedTextConfigurationInternal instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "DelimitedTextConfiguration".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.DelimitedTextConfigurationInternal value, string name = "DelimitedTextConfiguration", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("ColumnSeparator", ""),
                value.ColumnSeparator));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("FieldQuote", ""),
                value.FieldQuote));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("RecordSeparator", ""),
                value.RecordSeparator));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("EscapeChar", ""),
                value.EscapeChar));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("HasHeaders", ""),
                #pragma warning disable CA1308 // Normalize strings to uppercase
                value.HeadersPresent.ToString(System.Globalization.CultureInfo.InvariantCulture).ToLowerInvariant()));
                #pragma warning restore CA1308 // Normalize strings to uppercase
            return _element;
        }
    }
}
#endregion class DelimitedTextConfigurationInternal

#region class DirectoryCreateResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Directory CreateResult
    /// </summary>
    internal partial class DirectoryCreateResult
    {
        /// <summary>
        /// An HTTP entity tag associated with the file or directory.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The data and time the file or directory was last modified. Write operations on the file or directory update the last modified time.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The size of the resource in bytes.
        /// </summary>
        public long ContentLength { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of DirectoryCreateResult instances.
        /// You can use BlobsModelFactory.DirectoryCreateResult instead.
        /// </summary>
        internal DirectoryCreateResult() { }
    }
}
#endregion class DirectoryCreateResult

#region class DirectoryDeleteResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Directory DeleteResult
    /// </summary>
    internal partial class DirectoryDeleteResult
    {
        /// <summary>
        /// When renaming a directory, the number of paths that are renamed with each invocation is limited. If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header. When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.
        /// </summary>
        public string Marker { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of DirectoryDeleteResult instances.
        /// You can use BlobsModelFactory.DirectoryDeleteResult instead.
        /// </summary>
        internal DirectoryDeleteResult() { }
    }
}
#endregion class DirectoryDeleteResult

#region class DirectoryGetAccessControlResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Directory GetAccessControlResult
    /// </summary>
    internal partial class DirectoryGetAccessControlResult
    {
        /// <summary>
        /// An HTTP entity tag associated with the file or directory.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The data and time the file or directory was last modified. Write operations on the file or directory update the last modified time.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The owner of the file or directory. Included in the response if Hierarchical Namespace is enabled for the account.
        /// </summary>
        public string XMSOwner { get; internal set; }

        /// <summary>
        /// The owning group of the file or directory. Included in the response if Hierarchical Namespace is enabled for the account.
        /// </summary>
        public string XMSGroup { get; internal set; }

        /// <summary>
        /// The POSIX access permissions for the file owner, the file owning group, and others. Included in the response if Hierarchical Namespace is enabled for the account.
        /// </summary>
        public string XMSPermissions { get; internal set; }

        /// <summary>
        /// The POSIX access control list for the file or directory.  Included in the response only if the action is "getAccessControl" and Hierarchical Namespace is enabled for the account.
        /// </summary>
        public string XMSAcl { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of DirectoryGetAccessControlResult instances.
        /// You can use BlobsModelFactory.DirectoryGetAccessControlResult instead.
        /// </summary>
        internal DirectoryGetAccessControlResult() { }
    }
}
#endregion class DirectoryGetAccessControlResult

#region class DirectoryRenameResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Directory RenameResult
    /// </summary>
    internal partial class DirectoryRenameResult
    {
        /// <summary>
        /// When renaming a directory, the number of paths that are renamed with each invocation is limited. If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header. When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.
        /// </summary>
        public string Marker { get; internal set; }

        /// <summary>
        /// An HTTP entity tag associated with the file or directory.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The data and time the file or directory was last modified. Write operations on the file or directory update the last modified time.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The size of the resource in bytes.
        /// </summary>
        public long ContentLength { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of DirectoryRenameResult instances.
        /// You can use BlobsModelFactory.DirectoryRenameResult instead.
        /// </summary>
        internal DirectoryRenameResult() { }
    }
}
#endregion class DirectoryRenameResult

#region class DirectorySetAccessControlResult
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Directory SetAccessControlResult
    /// </summary>
    internal partial class DirectorySetAccessControlResult
    {
        /// <summary>
        /// An HTTP entity tag associated with the file or directory.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The data and time the file or directory was last modified. Write operations on the file or directory update the last modified time.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of DirectorySetAccessControlResult instances.
        /// You can use BlobsModelFactory.DirectorySetAccessControlResult instead.
        /// </summary>
        internal DirectorySetAccessControlResult() { }
    }
}
#endregion class DirectorySetAccessControlResult

#region enum EncryptionAlgorithmType
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// The algorithm used to produce the encryption key hash. Currently, the only accepted value is "AES256". Must be provided if the x-ms-encryption-key header is provided.
    /// </summary>
    public enum EncryptionAlgorithmType
    {
        /// <summary>
        /// AES256
        /// </summary>
        Aes256
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.EncryptionAlgorithmType value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.EncryptionAlgorithmType.Aes256 => "AES256",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.EncryptionAlgorithmType value.")
                };
            }

            public static Azure.Storage.Blobs.Models.EncryptionAlgorithmType ParseEncryptionAlgorithmType(string value)
            {
                return value switch
                {
                    "AES256" => Azure.Storage.Blobs.Models.EncryptionAlgorithmType.Aes256,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.EncryptionAlgorithmType value.")
                };
            }
        }
    }
}
#endregion enum EncryptionAlgorithmType

#region class FailureNoContent
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// FailureNoContent
    /// </summary>
    internal partial class FailureNoContent
    {
        /// <summary>
        /// x-ms-error-code
        /// </summary>
        public string ErrorCode { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of FailureNoContent instances.
        /// You can use BlobsModelFactory.FailureNoContent instead.
        /// </summary>
        internal FailureNoContent() { }
    }
}
#endregion class FailureNoContent

#region class FilterBlobItem
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Blob info from a Filter Blobs API call
    /// </summary>
    internal partial class FilterBlobItem
    {
        /// <summary>
        /// Name
        /// </summary>
        public string BlobName { get; internal set; }

        /// <summary>
        /// ContainerName
        /// </summary>
        public string BlobContainerName { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of FilterBlobItem instances.
        /// You can use BlobsModelFactory.FilterBlobItem instead.
        /// </summary>
        internal FilterBlobItem() { }

        /// <summary>
        /// Deserializes XML into a new FilterBlobItem instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized FilterBlobItem instance.</returns>
        internal static Azure.Storage.Blobs.Models.FilterBlobItem FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.FilterBlobItem _value = new Azure.Storage.Blobs.Models.FilterBlobItem();
            _child = element.Element(System.Xml.Linq.XName.Get("Name", ""));
            if (_child != null)
            {
                _value.BlobName = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("ContainerName", ""));
            if (_child != null)
            {
                _value.BlobContainerName = _child.Value;
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.FilterBlobItem value);
    }
}
#endregion class FilterBlobItem

#region class FilterBlobSegment
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// The result of a Filter Blobs API call
    /// </summary>
    internal partial class FilterBlobSegment
    {
        /// <summary>
        /// ServiceEndpoint
        /// </summary>
        public string ServiceEndpoint { get; internal set; }

        /// <summary>
        /// Where
        /// </summary>
        public string Where { get; internal set; }

        /// <summary>
        /// Blobs
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.FilterBlobItem> Blobs { get; internal set; }

        /// <summary>
        /// NextMarker
        /// </summary>
        public string NextMarker { get; internal set; }

        /// <summary>
        /// Creates a new FilterBlobSegment instance
        /// </summary>
        public FilterBlobSegment()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new FilterBlobSegment instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal FilterBlobSegment(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                Blobs = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.FilterBlobItem>();
            }
        }

        /// <summary>
        /// Deserializes XML into a new FilterBlobSegment instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized FilterBlobSegment instance.</returns>
        internal static Azure.Storage.Blobs.Models.FilterBlobSegment FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            System.Xml.Linq.XAttribute _attribute;
            Azure.Storage.Blobs.Models.FilterBlobSegment _value = new Azure.Storage.Blobs.Models.FilterBlobSegment(true);
            _attribute = element.Attribute(System.Xml.Linq.XName.Get("ServiceEndpoint", ""));
            if (_attribute != null)
            {
                _value.ServiceEndpoint = _attribute.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Where", ""));
            if (_child != null)
            {
                _value.Where = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Blobs", ""));
            if (_child != null)
            {
                _value.Blobs = System.Linq.Enumerable.ToList(
                    System.Linq.Enumerable.Select(
                        _child.Elements(System.Xml.Linq.XName.Get("Blob", "")),
                        e => Azure.Storage.Blobs.Models.FilterBlobItem.FromXml(e)));
            }
            else
            {
                _value.Blobs = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.FilterBlobItem>();
            }
            _child = element.Element(System.Xml.Linq.XName.Get("NextMarker", ""));
            if (_child != null)
            {
                _value.NextMarker = _child.Value;
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.FilterBlobSegment value);
    }
}
#endregion class FilterBlobSegment

#region class FlattenedContainerItem
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// FlattenedContainerItem
    /// </summary>
    internal partial class FlattenedContainerItem
    {
        /// <summary>
        /// x-ms-meta
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; internal set; }

        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// When a blob is leased, specifies whether the lease is of infinite or fixed duration.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseDurationType LeaseDuration { get; internal set; }

        /// <summary>
        /// Lease state of the blob.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseState LeaseState { get; internal set; }

        /// <summary>
        /// The current lease status of the blob.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseStatus LeaseStatus { get; internal set; }

        /// <summary>
        /// Indicated whether data in the container may be accessed publicly and the level of access
        /// </summary>
        public Azure.Storage.Blobs.Models.PublicAccessType BlobPublicAccess { get; internal set; }

        /// <summary>
        /// Indicates whether the container has an immutability policy set on it.
        /// </summary>
        public bool HasImmutabilityPolicy { get; internal set; }

        /// <summary>
        /// Indicates whether the container has a legal hold.
        /// </summary>
        public bool HasLegalHold { get; internal set; }

        /// <summary>
        /// The default encryption scope for the container.
        /// </summary>
        public string DefaultEncryptionScope { get; internal set; }

        /// <summary>
        /// Indicates whether the container's default encryption scope can be overriden.
        /// </summary>
        public bool DenyEncryptionScopeOverride { get; internal set; }

        /// <summary>
        /// Creates a new FlattenedContainerItem instance
        /// </summary>
        public FlattenedContainerItem()
        {
            Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
        }
    }
}
#endregion class FlattenedContainerItem

#region class FlattenedDownloadProperties
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// FlattenedDownloadProperties
    /// </summary>
    internal partial class FlattenedDownloadProperties
    {
        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// x-ms-meta
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; internal set; }

        /// <summary>
        /// Optional. Only valid when Object Replication is enabled for the storage container and on the destination blob of the replication.
        /// </summary>
        public string ObjectReplicationPolicyId { get; internal set; }

        /// <summary>
        /// Optional. Only valid when Object Replication is enabled for the storage container and on the source blob of the replication. When retrieving this header, it will return the header with the policy id and rule id (e.g. x-ms-or-policyid_ruleid), and the value will be the status of the replication (e.g. complete, failed).
        /// </summary>
        public System.Collections.Generic.IDictionary<string, string> ObjectReplicationRules { get; internal set; }

        /// <summary>
        /// The number of bytes present in the response body.
        /// </summary>
        public long ContentLength { get; internal set; }

        /// <summary>
        /// The media type of the body of the response. For Download Blob this is 'application/octet-stream'
        /// </summary>
        public string ContentType { get; internal set; }

        /// <summary>
        /// Indicates the range of bytes returned in the event that the client requested a subset of the blob by setting the 'Range' request header.
        /// </summary>
        public string ContentRange { get; internal set; }

        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// If the blob has an MD5 hash and this operation is to read the full blob, this response header is returned so that the client can check for message content integrity.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// This header returns the value that was specified for the Content-Encoding request header
        /// </summary>
        public string ContentEncoding { get; internal set; }

        /// <summary>
        /// This header is returned if it was previously specified for the blob.
        /// </summary>
        public string CacheControl { get; internal set; }

        /// <summary>
        /// This header returns the value that was specified for the 'x-ms-blob-content-disposition' header. The Content-Disposition response header field conveys additional information about how to process the response payload, and also can be used to attach additional metadata. For example, if set to attachment, it indicates that the user-agent should not display the response, but instead show a Save As dialog with a filename other than the blob name specified.
        /// </summary>
        public string ContentDisposition { get; internal set; }

        /// <summary>
        /// This header returns the value that was specified for the Content-Language request header.
        /// </summary>
        public string ContentLanguage { get; internal set; }

        /// <summary>
        /// The current sequence number for a page blob. This header is not returned for block blobs or append blobs
        /// </summary>
        public long BlobSequenceNumber { get; internal set; }

        /// <summary>
        /// The blob's type.
        /// </summary>
        public Azure.Storage.Blobs.Models.BlobType BlobType { get; internal set; }

        /// <summary>
        /// If the request is to read a specified range and the x-ms-range-get-content-crc64 is set to true, then the request returns a crc64 for the range, as long as the range size is less than or equal to 4 MB. If both x-ms-range-get-content-crc64 and x-ms-range-get-content-md5 is specified in the same request, it will fail with 400(Bad Request)
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentCrc64 { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// Conclusion time of the last attempted Copy Blob operation where this blob was the destination blob. This value can specify the time of a completed, aborted, or failed copy attempt. This header does not appear if a copy is pending, if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List.
        /// </summary>
        public System.DateTimeOffset CopyCompletionTime { get; internal set; }

        /// <summary>
        /// Only appears when x-ms-copy-status is failed or pending. Describes the cause of the last fatal or non-fatal copy operation failure. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List
        /// </summary>
        public string CopyStatusDescription { get; internal set; }

        /// <summary>
        /// String identifier for this copy operation. Use with Get Blob Properties to check the status of this copy operation, or pass to Abort Copy Blob to abort a pending copy.
        /// </summary>
        public string CopyId { get; internal set; }

        /// <summary>
        /// Contains the number of bytes copied and the total bytes in the source in the last attempted Copy Blob operation where this blob was the destination blob. Can show between 0 and Content-Length bytes copied. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List
        /// </summary>
        public string CopyProgress { get; internal set; }

        /// <summary>
        /// URL up to 2 KB in length that specifies the source blob or file used in the last attempted Copy Blob operation where this blob was the destination blob. This header does not appear if this blob has never been the destination in a Copy Blob operation, or if this blob has been modified after a concluded Copy Blob operation using Set Blob Properties, Put Blob, or Put Block List.
        /// </summary>
        public System.Uri CopySource { get; internal set; }

        /// <summary>
        /// State of the copy operation identified by x-ms-copy-id.
        /// </summary>
        public Azure.Storage.Blobs.Models.CopyStatus CopyStatus { get; internal set; }

        /// <summary>
        /// When a blob is leased, specifies whether the lease is of infinite or fixed duration.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseDurationType LeaseDuration { get; internal set; }

        /// <summary>
        /// Lease state of the blob.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseState LeaseState { get; internal set; }

        /// <summary>
        /// The current lease status of the blob.
        /// </summary>
        public Azure.Storage.Blobs.Models.LeaseStatus LeaseStatus { get; internal set; }

        /// <summary>
        /// Indicates that the service supports requests for partial blob content.
        /// </summary>
        public string AcceptRanges { get; internal set; }

        /// <summary>
        /// The number of committed blocks present in the blob. This header is returned only for append blobs.
        /// </summary>
        public int BlobCommittedBlockCount { get; internal set; }

        /// <summary>
        /// The value of this header is set to true if the blob data and application metadata are completely encrypted using the specified algorithm. Otherwise, the value is set to false (when the blob is unencrypted, or if only parts of the blob/application metadata are encrypted).
        /// </summary>
        public bool IsServerEncrypted { get; internal set; }

        /// <summary>
        /// The SHA-256 hash of the encryption key used to encrypt the blob. This header is only returned when the blob was encrypted with a customer-provided key.
        /// </summary>
        public string EncryptionKeySha256 { get; internal set; }

        /// <summary>
        /// Returns the name of the encryption scope used to encrypt the blob contents and application metadata.  Note that the absence of this header implies use of the default account encryption scope.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// If the blob has a MD5 hash, and if request contains range header (Range or x-ms-range), this response header is returned with the value of the whole blob's MD5 value. This value may or may not be equal to the value returned in Content-MD5 header, with the latter calculated from the requested range
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] BlobContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// The number of tags associated with the blob
        /// </summary>
        public long TagCount { get; internal set; }

        /// <summary>
        /// If this blob has been sealed
        /// </summary>
        public bool IsSealed { get; internal set; }

        /// <summary>
        /// UTC date/time value generated by the service that indicates the time at which the blob was last read or written to
        /// </summary>
        public System.DateTimeOffset LastAccessed { get; internal set; }

        /// <summary>
        /// A DateTime value returned by the service that uniquely identifies the blob. The value of this header indicates the blob version, and may be used in subsequent requests to access this version of the blob.
        /// </summary>
        public string VersionId { get; internal set; }

        /// <summary>
        /// Content
        /// </summary>
        public System.IO.Stream Content { get; internal set; }

        /// <summary>
        /// Creates a new FlattenedDownloadProperties instance
        /// </summary>
        public FlattenedDownloadProperties()
        {
            Metadata = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
            ObjectReplicationRules = new System.Collections.Generic.Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
        }
    }
}
#endregion class FlattenedDownloadProperties

#region class GetBlockListOperation
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// GetBlockListOperation
    /// </summary>
    internal partial class GetBlockListOperation
    {
        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The media type of the body of the response. For Get Block List this is 'application/xml'
        /// </summary>
        public string ContentType { get; internal set; }

        /// <summary>
        /// The size of the blob in bytes.
        /// </summary>
        public long BlobContentLength { get; internal set; }

        /// <summary>
        /// Body
        /// </summary>
        public Azure.Storage.Blobs.Models.BlockList Body { get; internal set; }

        /// <summary>
        /// Creates a new GetBlockListOperation instance
        /// </summary>
        public GetBlockListOperation()
        {
            Body = new Azure.Storage.Blobs.Models.BlockList();
        }
    }
}
#endregion class GetBlockListOperation

#region class JsonTextConfigurationInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// json text configuration
    /// </summary>
    internal partial class JsonTextConfigurationInternal
    {
        /// <summary>
        /// record separator
        /// </summary>
        public string RecordSeparator { get; set; }

        /// <summary>
        /// Creates a new JsonTextConfigurationInternal instance
        /// </summary>
        public JsonTextConfigurationInternal() { }

        /// <summary>
        /// Serialize a JsonTextConfigurationInternal instance as XML.
        /// </summary>
        /// <param name="value">The JsonTextConfigurationInternal instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "JsonTextConfiguration".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.JsonTextConfigurationInternal value, string name = "JsonTextConfiguration", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("RecordSeparator", ""),
                value.RecordSeparator));
            return _element;
        }
    }
}
#endregion class JsonTextConfigurationInternal

#region class KeyInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Key information
    /// </summary>
    internal partial class KeyInfo
    {
        /// <summary>
        /// The date-time the key is active in ISO 8601 UTC time
        /// </summary>
        public System.DateTimeOffset? StartsOn { get; set; }

        /// <summary>
        /// The date-time the key expires in ISO 8601 UTC time
        /// </summary>
        public System.DateTimeOffset ExpiresOn { get; set; }

        /// <summary>
        /// Creates a new KeyInfo instance
        /// </summary>
        public KeyInfo() { }

        /// <summary>
        /// Serialize a KeyInfo instance as XML.
        /// </summary>
        /// <param name="value">The KeyInfo instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "KeyInfo".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.KeyInfo value, string name = "KeyInfo", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            if (value.StartsOn != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Start", ""),
                    value.StartsOn.Value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ssZ", System.Globalization.CultureInfo.InvariantCulture)));
            }
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Expiry", ""),
                value.ExpiresOn.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ssZ", System.Globalization.CultureInfo.InvariantCulture)));
            return _element;
        }
    }
}
#endregion class KeyInfo

#region enum LeaseDurationType
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// LeaseDurationType values
    /// </summary>
    public enum LeaseDurationType
    {
        /// <summary>
        /// infinite
        /// </summary>
        Infinite,

        /// <summary>
        /// fixed
        /// </summary>
        Fixed
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.LeaseDurationType value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.LeaseDurationType.Infinite => "infinite",
                    Azure.Storage.Blobs.Models.LeaseDurationType.Fixed => "fixed",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.LeaseDurationType value.")
                };
            }

            public static Azure.Storage.Blobs.Models.LeaseDurationType ParseLeaseDurationType(string value)
            {
                return value switch
                {
                    "infinite" => Azure.Storage.Blobs.Models.LeaseDurationType.Infinite,
                    "fixed" => Azure.Storage.Blobs.Models.LeaseDurationType.Fixed,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.LeaseDurationType value.")
                };
            }
        }
    }
}
#endregion enum LeaseDurationType

#region enum LeaseState
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// LeaseState values
    /// </summary>
    public enum LeaseState
    {
        /// <summary>
        /// available
        /// </summary>
        Available,

        /// <summary>
        /// leased
        /// </summary>
        Leased,

        /// <summary>
        /// expired
        /// </summary>
        Expired,

        /// <summary>
        /// breaking
        /// </summary>
        Breaking,

        /// <summary>
        /// broken
        /// </summary>
        Broken
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.LeaseState value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.LeaseState.Available => "available",
                    Azure.Storage.Blobs.Models.LeaseState.Leased => "leased",
                    Azure.Storage.Blobs.Models.LeaseState.Expired => "expired",
                    Azure.Storage.Blobs.Models.LeaseState.Breaking => "breaking",
                    Azure.Storage.Blobs.Models.LeaseState.Broken => "broken",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.LeaseState value.")
                };
            }

            public static Azure.Storage.Blobs.Models.LeaseState ParseLeaseState(string value)
            {
                return value switch
                {
                    "available" => Azure.Storage.Blobs.Models.LeaseState.Available,
                    "leased" => Azure.Storage.Blobs.Models.LeaseState.Leased,
                    "expired" => Azure.Storage.Blobs.Models.LeaseState.Expired,
                    "breaking" => Azure.Storage.Blobs.Models.LeaseState.Breaking,
                    "broken" => Azure.Storage.Blobs.Models.LeaseState.Broken,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.LeaseState value.")
                };
            }
        }
    }
}
#endregion enum LeaseState

#region enum LeaseStatus
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// LeaseStatus values
    /// </summary>
    #pragma warning disable CA1717 // Only FlagsAttribute enums should have plural names
    public enum LeaseStatus
    #pragma warning restore CA1717 // Only FlagsAttribute enums should have plural names
    {
        /// <summary>
        /// locked
        /// </summary>
        Locked,

        /// <summary>
        /// unlocked
        /// </summary>
        Unlocked
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.LeaseStatus value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.LeaseStatus.Locked => "locked",
                    Azure.Storage.Blobs.Models.LeaseStatus.Unlocked => "unlocked",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.LeaseStatus value.")
                };
            }

            public static Azure.Storage.Blobs.Models.LeaseStatus ParseLeaseStatus(string value)
            {
                return value switch
                {
                    "locked" => Azure.Storage.Blobs.Models.LeaseStatus.Locked,
                    "unlocked" => Azure.Storage.Blobs.Models.LeaseStatus.Unlocked,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.LeaseStatus value.")
                };
            }
        }
    }
}
#endregion enum LeaseStatus

#region enum ListBlobsIncludeItem
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// ListBlobsIncludeItem values
    /// </summary>
    internal enum ListBlobsIncludeItem
    {
        /// <summary>
        /// copy
        /// </summary>
        Copy,

        /// <summary>
        /// deleted
        /// </summary>
        Deleted,

        /// <summary>
        /// metadata
        /// </summary>
        Metadata,

        /// <summary>
        /// snapshots
        /// </summary>
        Snapshots,

        /// <summary>
        /// uncommittedblobs
        /// </summary>
        Uncommittedblobs,

        /// <summary>
        /// versions
        /// </summary>
        Versions,

        /// <summary>
        /// tags
        /// </summary>
        Tags
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.ListBlobsIncludeItem value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Copy => "copy",
                    Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Deleted => "deleted",
                    Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Metadata => "metadata",
                    Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Snapshots => "snapshots",
                    Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Uncommittedblobs => "uncommittedblobs",
                    Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Versions => "versions",
                    Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Tags => "tags",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.ListBlobsIncludeItem value.")
                };
            }

            public static Azure.Storage.Blobs.Models.ListBlobsIncludeItem ParseListBlobsIncludeItem(string value)
            {
                return value switch
                {
                    "copy" => Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Copy,
                    "deleted" => Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Deleted,
                    "metadata" => Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Metadata,
                    "snapshots" => Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Snapshots,
                    "uncommittedblobs" => Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Uncommittedblobs,
                    "versions" => Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Versions,
                    "tags" => Azure.Storage.Blobs.Models.ListBlobsIncludeItem.Tags,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.ListBlobsIncludeItem value.")
                };
            }
        }
    }
}
#endregion enum ListBlobsIncludeItem

#region enum ListContainersIncludeType
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// ListContainersIncludeType values
    /// </summary>
    internal enum ListContainersIncludeType
    {
        /// <summary>
        /// metadata
        /// </summary>
        Metadata,

        /// <summary>
        /// deleted
        /// </summary>
        Deleted
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.ListContainersIncludeType value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.ListContainersIncludeType.Metadata => "metadata",
                    Azure.Storage.Blobs.Models.ListContainersIncludeType.Deleted => "deleted",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.ListContainersIncludeType value.")
                };
            }

            public static Azure.Storage.Blobs.Models.ListContainersIncludeType ParseListContainersIncludeType(string value)
            {
                return value switch
                {
                    "metadata" => Azure.Storage.Blobs.Models.ListContainersIncludeType.Metadata,
                    "deleted" => Azure.Storage.Blobs.Models.ListContainersIncludeType.Deleted,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.ListContainersIncludeType value.")
                };
            }
        }
    }
}
#endregion enum ListContainersIncludeType

#region class PageBlobInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// PageBlobInfo
    /// </summary>
    public partial class PageBlobInfo
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the blob was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The current sequence number for the page blob.  This is only returned for page blobs.
        /// </summary>
        public long BlobSequenceNumber { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of PageBlobInfo instances.
        /// You can use BlobsModelFactory.PageBlobInfo instead.
        /// </summary>
        internal PageBlobInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new PageBlobInfo instance for mocking.
        /// </summary>
        public static PageBlobInfo PageBlobInfo(
            Azure.ETag eTag,
            System.DateTimeOffset lastModified,
            long blobSequenceNumber)
        {
            return new PageBlobInfo()
            {
                ETag = eTag,
                LastModified = lastModified,
                BlobSequenceNumber = blobSequenceNumber,
            };
        }
    }
}
#endregion class PageBlobInfo

#region class PageInfo
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// PageInfo
    /// </summary>
    public partial class PageInfo
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// If the blob has an MD5 hash and this operation is to read the full blob, this response header is returned so that the client can check for message content integrity.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentHash { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// This header is returned so that the client can check for message content integrity. The value of this header is computed by the Blob service; it is not necessarily the same value specified in the request headers.
        /// </summary>
        #pragma warning disable CA1819 // Properties should not return arrays
        public byte[] ContentCrc64 { get; internal set; }
        #pragma warning restore CA1819 // Properties should not return arrays

        /// <summary>
        /// The current sequence number for the page blob.  This is only returned for page blobs.
        /// </summary>
        public long BlobSequenceNumber { get; internal set; }

        /// <summary>
        /// The SHA-256 hash of the encryption key used to encrypt the pages. This header is only returned when the pages were encrypted with a customer-provided key.
        /// </summary>
        public string EncryptionKeySha256 { get; internal set; }

        /// <summary>
        /// Returns the name of the encryption scope used to encrypt the blob contents and application metadata.  Note that the absence of this header implies use of the default account encryption scope.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of PageInfo instances.
        /// You can use BlobsModelFactory.PageInfo instead.
        /// </summary>
        internal PageInfo() { }
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new PageInfo instance for mocking.
        /// </summary>
        public static PageInfo PageInfo(
            Azure.ETag eTag,
            System.DateTimeOffset lastModified,
            byte[] contentHash,
            byte[] contentCrc64,
            long blobSequenceNumber,
            string encryptionKeySha256,
            string encryptionScope)
        {
            return new PageInfo()
            {
                ETag = eTag,
                LastModified = lastModified,
                ContentHash = contentHash,
                ContentCrc64 = contentCrc64,
                BlobSequenceNumber = blobSequenceNumber,
                EncryptionKeySha256 = encryptionKeySha256,
                EncryptionScope = encryptionScope,
            };
        }
    }
}
#endregion class PageInfo

#region class PageList
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// the list of pages
    /// </summary>
    internal partial class PageList
    {
        /// <summary>
        /// PageRange
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.PageRange> PageRange { get; internal set; }

        /// <summary>
        /// ClearRange
        /// </summary>
        public System.Collections.Generic.IEnumerable<Azure.Storage.Blobs.Models.ClearRange> ClearRange { get; internal set; }

        /// <summary>
        /// Creates a new PageList instance
        /// </summary>
        public PageList()
            : this(false)
        {
        }

        /// <summary>
        /// Creates a new PageList instance
        /// </summary>
        /// <param name="skipInitialization">Whether to skip initializing nested objects.</param>
        internal PageList(bool skipInitialization)
        {
            if (!skipInitialization)
            {
                PageRange = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.PageRange>();
                ClearRange = new System.Collections.Generic.List<Azure.Storage.Blobs.Models.ClearRange>();
            }
        }

        /// <summary>
        /// Deserializes XML into a new PageList instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized PageList instance.</returns>
        internal static Azure.Storage.Blobs.Models.PageList FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            Azure.Storage.Blobs.Models.PageList _value = new Azure.Storage.Blobs.Models.PageList(true);
            _value.PageRange = System.Linq.Enumerable.ToList(
                System.Linq.Enumerable.Select(
                    element.Elements(System.Xml.Linq.XName.Get("PageRange", "")),
                    e => Azure.Storage.Blobs.Models.PageRange.FromXml(e)));
            _value.ClearRange = System.Linq.Enumerable.ToList(
                System.Linq.Enumerable.Select(
                    element.Elements(System.Xml.Linq.XName.Get("ClearRange", "")),
                    e => Azure.Storage.Blobs.Models.ClearRange.FromXml(e)));
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.PageList value);
    }
}
#endregion class PageList

#region struct PageRange
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// PageRange
    /// </summary>
    internal readonly partial struct PageRange: System.IEquatable<PageRange>
    {
        /// <summary>
        /// Start
        /// </summary>
        public long Start { get; }

        /// <summary>
        /// End
        /// </summary>
        public long End { get; }

        /// <summary>
        /// Prevent direct instantiation of PageRange instances.
        /// You can use BlobsModelFactory.PageRange instead.
        /// </summary>
        internal PageRange(
            long start,
            long end)
            {
                Start = start;
                End = end;
            }

        /// <summary>
        /// Check if two PageRange instances are equal.
        /// </summary>
        /// <param name="other">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        [System.ComponentModel.EditorBrowsable((System.ComponentModel.EditorBrowsableState.Never))]
        public bool Equals(PageRange other)
        {
            if (!Start.Equals(other.Start))
            {
                return false;
            }
            if (!End.Equals(other.End))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Check if two PageRange instances are equal.
        /// </summary>
        /// <param name="obj">The instance to compare to.</param>
        /// <returns>True if they're equal, false otherwise.</returns>
        [System.ComponentModel.EditorBrowsable((System.ComponentModel.EditorBrowsableState.Never))]
        public override bool Equals(object obj) => obj is PageRange && Equals((PageRange)obj);

        /// <summary>
        /// Get a hash code for the PageRange.
        /// </summary>
        [System.ComponentModel.EditorBrowsable((System.ComponentModel.EditorBrowsableState.Never))]
        public override int GetHashCode()
        {
            var hashCode = new Azure.Core.HashCodeBuilder();
            hashCode.Add(Start);
            hashCode.Add(End);

            return hashCode.ToHashCode();
        }

        /// <summary>
        /// Deserializes XML into a new PageRange instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized PageRange instance.</returns>
        internal static Azure.Storage.Blobs.Models.PageRange FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            long start = default;
            long end = default;
            _child = element.Element(System.Xml.Linq.XName.Get("Start", ""));
            if (_child != null)
            {
                start = long.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("End", ""));
            if (_child != null)
            {
                end = long.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            Azure.Storage.Blobs.Models.PageRange _value = new Azure.Storage.Blobs.Models.PageRange(start, end);
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.PageRange value);
    }
}
#endregion struct PageRange

#region class PageRangesInfoInternal
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// PageRangesInfoInternal
    /// </summary>
    internal partial class PageRangesInfoInternal
    {
        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// The size of the blob in bytes.
        /// </summary>
        public long BlobContentLength { get; internal set; }

        /// <summary>
        /// the list of pages
        /// </summary>
        public Azure.Storage.Blobs.Models.PageList Body { get; internal set; }

        /// <summary>
        /// Creates a new PageRangesInfoInternal instance
        /// </summary>
        public PageRangesInfoInternal()
        {
            Body = new Azure.Storage.Blobs.Models.PageList();
        }
    }
}
#endregion class PageRangesInfoInternal

#region enum PathRenameMode
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Determines the behavior of the rename operation
    /// </summary>
    public enum PathRenameMode
    {
        /// <summary>
        /// legacy
        /// </summary>
        Legacy,

        /// <summary>
        /// posix
        /// </summary>
        Posix
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.PathRenameMode value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.PathRenameMode.Legacy => "legacy",
                    Azure.Storage.Blobs.Models.PathRenameMode.Posix => "posix",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.PathRenameMode value.")
                };
            }

            public static Azure.Storage.Blobs.Models.PathRenameMode ParsePathRenameMode(string value)
            {
                return value switch
                {
                    "legacy" => Azure.Storage.Blobs.Models.PathRenameMode.Legacy,
                    "posix" => Azure.Storage.Blobs.Models.PathRenameMode.Posix,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.PathRenameMode value.")
                };
            }
        }
    }
}
#endregion enum PathRenameMode

#region enum PublicAccessType
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Specifies whether data in the container may be accessed publicly and the level of access
    /// </summary>
    public enum PublicAccessType
    {
        /// <summary>
        /// none
        /// </summary>
        None,

        /// <summary>
        /// container
        /// </summary>
        BlobContainer,

        /// <summary>
        /// blob
        /// </summary>
        Blob
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.PublicAccessType value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.PublicAccessType.None => null,
                    Azure.Storage.Blobs.Models.PublicAccessType.BlobContainer => "container",
                    Azure.Storage.Blobs.Models.PublicAccessType.Blob => "blob",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.PublicAccessType value.")
                };
            }

            public static Azure.Storage.Blobs.Models.PublicAccessType ParsePublicAccessType(string value)
            {
                return value switch
                {
                    null => Azure.Storage.Blobs.Models.PublicAccessType.None,
                    "container" => Azure.Storage.Blobs.Models.PublicAccessType.BlobContainer,
                    "blob" => Azure.Storage.Blobs.Models.PublicAccessType.Blob,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.PublicAccessType value.")
                };
            }
        }
    }
}
#endregion enum PublicAccessType

#region class QueryFormat
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// QueryFormat
    /// </summary>
    internal partial class QueryFormat
    {
        /// <summary>
        /// The quick query format type.
        /// </summary>
        public Azure.Storage.Blobs.Models.QueryFormatType? Type { get; set; }

        /// <summary>
        /// delimited text configuration
        /// </summary>
        public Azure.Storage.Blobs.Models.DelimitedTextConfigurationInternal DelimitedTextConfiguration { get; set; }

        /// <summary>
        /// json text configuration
        /// </summary>
        public Azure.Storage.Blobs.Models.JsonTextConfigurationInternal JsonTextConfiguration { get; set; }

        /// <summary>
        /// arrow configuration
        /// </summary>
        public Azure.Storage.Blobs.Models.ArrowTextConfigurationInternal ArrowConfiguration { get; set; }

        /// <summary>
        /// Creates a new QueryFormat instance
        /// </summary>
        public QueryFormat()
        {
            DelimitedTextConfiguration = new Azure.Storage.Blobs.Models.DelimitedTextConfigurationInternal();
            JsonTextConfiguration = new Azure.Storage.Blobs.Models.JsonTextConfigurationInternal();
            ArrowConfiguration = new Azure.Storage.Blobs.Models.ArrowTextConfigurationInternal();
        }

        /// <summary>
        /// Serialize a QueryFormat instance as XML.
        /// </summary>
        /// <param name="value">The QueryFormat instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "QueryFormat".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.QueryFormat value, string name = "QueryFormat", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            if (value.Type != null)
            {
                _element.Add(new System.Xml.Linq.XElement(
                    System.Xml.Linq.XName.Get("Type", ""),
                    Azure.Storage.Blobs.BlobRestClient.Serialization.ToString(value.Type.Value)));
            }
            if (value.DelimitedTextConfiguration != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.DelimitedTextConfigurationInternal.ToXml(value.DelimitedTextConfiguration, "DelimitedTextConfiguration", ""));
            }
            if (value.JsonTextConfiguration != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.JsonTextConfigurationInternal.ToXml(value.JsonTextConfiguration, "JsonTextConfiguration", ""));
            }
            if (value.ArrowConfiguration != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.ArrowTextConfigurationInternal.ToXml(value.ArrowConfiguration, "ArrowConfiguration", ""));
            }
            return _element;
        }
    }
}
#endregion class QueryFormat

#region enum QueryFormatType
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// The quick query format type.
    /// </summary>
    internal enum QueryFormatType
    {
        /// <summary>
        /// delimited
        /// </summary>
        Delimited,

        /// <summary>
        /// json
        /// </summary>
        Json,

        /// <summary>
        /// arrow
        /// </summary>
        Arrow
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.QueryFormatType value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.QueryFormatType.Delimited => "delimited",
                    Azure.Storage.Blobs.Models.QueryFormatType.Json => "json",
                    Azure.Storage.Blobs.Models.QueryFormatType.Arrow => "arrow",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.QueryFormatType value.")
                };
            }

            public static Azure.Storage.Blobs.Models.QueryFormatType ParseQueryFormatType(string value)
            {
                return value switch
                {
                    "delimited" => Azure.Storage.Blobs.Models.QueryFormatType.Delimited,
                    "json" => Azure.Storage.Blobs.Models.QueryFormatType.Json,
                    "arrow" => Azure.Storage.Blobs.Models.QueryFormatType.Arrow,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.QueryFormatType value.")
                };
            }
        }
    }
}
#endregion enum QueryFormatType

#region class QueryRequest
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// the quick query body
    /// </summary>
    internal partial class QueryRequest
    {
        /// <summary>
        /// the query type
        /// </summary>
        public string QueryType { get; set; }

        /// <summary>
        /// a query statement
        /// </summary>
        public string Expression { get; set; }

        /// <summary>
        /// InputSerialization
        /// </summary>
        public Azure.Storage.Blobs.Models.QuerySerialization InputSerialization { get; set; }

        /// <summary>
        /// OutputSerialization
        /// </summary>
        public Azure.Storage.Blobs.Models.QuerySerialization OutputSerialization { get; set; }

        /// <summary>
        /// Creates a new QueryRequest instance
        /// </summary>
        public QueryRequest()
        {
            InputSerialization = new Azure.Storage.Blobs.Models.QuerySerialization();
            OutputSerialization = new Azure.Storage.Blobs.Models.QuerySerialization();
        }

        /// <summary>
        /// Serialize a QueryRequest instance as XML.
        /// </summary>
        /// <param name="value">The QueryRequest instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "QueryRequest".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.QueryRequest value, string name = "QueryRequest", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("QueryType", ""),
                value.QueryType));
            _element.Add(new System.Xml.Linq.XElement(
                System.Xml.Linq.XName.Get("Expression", ""),
                value.Expression));
            if (value.InputSerialization != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.QuerySerialization.ToXml(value.InputSerialization, "InputSerialization", ""));
            }
            if (value.OutputSerialization != null)
            {
                _element.Add(Azure.Storage.Blobs.Models.QuerySerialization.ToXml(value.OutputSerialization, "OutputSerialization", ""));
            }
            return _element;
        }
    }
}
#endregion class QueryRequest

#region class QuerySerialization
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// QuerySerialization
    /// </summary>
    internal partial class QuerySerialization
    {
        /// <summary>
        /// Format
        /// </summary>
        public Azure.Storage.Blobs.Models.QueryFormat Format { get; set; }

        /// <summary>
        /// Creates a new QuerySerialization instance
        /// </summary>
        public QuerySerialization()
        {
            Format = new Azure.Storage.Blobs.Models.QueryFormat();
        }

        /// <summary>
        /// Serialize a QuerySerialization instance as XML.
        /// </summary>
        /// <param name="value">The QuerySerialization instance to serialize.</param>
        /// <param name="name">An optional name to use for the root element instead of "QuerySerialization".</param>
        /// <param name="ns">An optional namespace to use for the root element instead of "".</param>
        /// <returns>The serialized XML element.</returns>
        internal static System.Xml.Linq.XElement ToXml(Azure.Storage.Blobs.Models.QuerySerialization value, string name = "QuerySerialization", string ns = "")
        {
            System.Diagnostics.Debug.Assert(value != null);
            System.Xml.Linq.XElement _element = new System.Xml.Linq.XElement(System.Xml.Linq.XName.Get(name, ns));
            _element.Add(Azure.Storage.Blobs.Models.QueryFormat.ToXml(value.Format, "Format", ""));
            return _element;
        }
    }
}
#endregion class QuerySerialization

#region enum RehydratePriority
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Optional: Indicates the priority with which to rehydrate an archived blob.
    /// </summary>
    public enum RehydratePriority
    {
        /// <summary>
        /// High
        /// </summary>
        High,

        /// <summary>
        /// Standard
        /// </summary>
        Standard
    }
}
#endregion enum RehydratePriority

#region enum SequenceNumberAction
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Required if the x-ms-blob-sequence-number header is set for the request. This property applies to page blobs only. This property indicates how the service should modify the blob's sequence number
    /// </summary>
    public enum SequenceNumberAction
    {
        /// <summary>
        /// max
        /// </summary>
        Max,

        /// <summary>
        /// update
        /// </summary>
        Update,

        /// <summary>
        /// increment
        /// </summary>
        Increment
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.SequenceNumberAction value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.SequenceNumberAction.Max => "max",
                    Azure.Storage.Blobs.Models.SequenceNumberAction.Update => "update",
                    Azure.Storage.Blobs.Models.SequenceNumberAction.Increment => "increment",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.SequenceNumberAction value.")
                };
            }

            public static Azure.Storage.Blobs.Models.SequenceNumberAction ParseSequenceNumberAction(string value)
            {
                return value switch
                {
                    "max" => Azure.Storage.Blobs.Models.SequenceNumberAction.Max,
                    "update" => Azure.Storage.Blobs.Models.SequenceNumberAction.Update,
                    "increment" => Azure.Storage.Blobs.Models.SequenceNumberAction.Increment,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.SequenceNumberAction value.")
                };
            }
        }
    }
}
#endregion enum SequenceNumberAction

#region class SetHttpHeadersOperation
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// SetHttpHeadersOperation
    /// </summary>
    internal partial class SetHttpHeadersOperation
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// The current sequence number for a page blob. This header is not returned for block blobs or append blobs
        /// </summary>
        public long BlobSequenceNumber { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of SetHttpHeadersOperation instances.
        /// You can use BlobsModelFactory.SetHttpHeadersOperation instead.
        /// </summary>
        internal SetHttpHeadersOperation() { }
    }
}
#endregion class SetHttpHeadersOperation

#region class SetMetadataOperation
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// SetMetadataOperation
    /// </summary>
    internal partial class SetMetadataOperation
    {
        /// <summary>
        /// The ETag contains a value that you can use to perform operations conditionally. If the request version is 2011-08-18 or newer, the ETag value will be in quotes.
        /// </summary>
        public Azure.ETag ETag { get; internal set; }

        /// <summary>
        /// Returns the date and time the container was last modified. Any operation that modifies the blob, including an update of the blob's metadata or properties, changes the last-modified time of the blob.
        /// </summary>
        public System.DateTimeOffset LastModified { get; internal set; }

        /// <summary>
        /// A DateTime value returned by the service that uniquely identifies the blob. The value of this header indicates the blob version, and may be used in subsequent requests to access this version of the blob.
        /// </summary>
        public string VersionId { get; internal set; }

        /// <summary>
        /// The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise.
        /// </summary>
        public bool IsServerEncrypted { get; internal set; }

        /// <summary>
        /// The SHA-256 hash of the encryption key used to encrypt the metadata. This header is only returned when the metadata was encrypted with a customer-provided key.
        /// </summary>
        public string EncryptionKeySha256 { get; internal set; }

        /// <summary>
        /// Returns the name of the encryption scope used to encrypt the blob contents and application metadata.  Note that the absence of this header implies use of the default account encryption scope.
        /// </summary>
        public string EncryptionScope { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of SetMetadataOperation instances.
        /// You can use BlobsModelFactory.SetMetadataOperation instead.
        /// </summary>
        internal SetMetadataOperation() { }
    }
}
#endregion class SetMetadataOperation

#region enum SkuName
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// Identifies the sku name of the account
    /// </summary>
    public enum SkuName
    {
        /// <summary>
        /// Standard_LRS
        /// </summary>
        StandardLrs,

        /// <summary>
        /// Standard_GRS
        /// </summary>
        StandardGrs,

        /// <summary>
        /// Standard_RAGRS
        /// </summary>
        StandardRagrs,

        /// <summary>
        /// Standard_ZRS
        /// </summary>
        StandardZrs,

        /// <summary>
        /// Premium_LRS
        /// </summary>
        PremiumLrs
    }
}

namespace Azure.Storage.Blobs
{
    internal static partial class BlobRestClient
    {
        public static partial class Serialization
        {
            public static string ToString(Azure.Storage.Blobs.Models.SkuName value)
            {
                return value switch
                {
                    Azure.Storage.Blobs.Models.SkuName.StandardLrs => "Standard_LRS",
                    Azure.Storage.Blobs.Models.SkuName.StandardGrs => "Standard_GRS",
                    Azure.Storage.Blobs.Models.SkuName.StandardRagrs => "Standard_RAGRS",
                    Azure.Storage.Blobs.Models.SkuName.StandardZrs => "Standard_ZRS",
                    Azure.Storage.Blobs.Models.SkuName.PremiumLrs => "Premium_LRS",
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.SkuName value.")
                };
            }

            public static Azure.Storage.Blobs.Models.SkuName ParseSkuName(string value)
            {
                return value switch
                {
                    "Standard_LRS" => Azure.Storage.Blobs.Models.SkuName.StandardLrs,
                    "Standard_GRS" => Azure.Storage.Blobs.Models.SkuName.StandardGrs,
                    "Standard_RAGRS" => Azure.Storage.Blobs.Models.SkuName.StandardRagrs,
                    "Standard_ZRS" => Azure.Storage.Blobs.Models.SkuName.StandardZrs,
                    "Premium_LRS" => Azure.Storage.Blobs.Models.SkuName.PremiumLrs,
                    _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unknown Azure.Storage.Blobs.Models.SkuName value.")
                };
            }
        }
    }
}
#endregion enum SkuName

#region class StorageError
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// StorageError
    /// </summary>
    internal partial class StorageError
    {
        /// <summary>
        /// Message
        /// </summary>
        public string Message { get; internal set; }

        /// <summary>
        /// Code
        /// </summary>
        public string Code { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of StorageError instances.
        /// You can use BlobsModelFactory.StorageError instead.
        /// </summary>
        internal StorageError() { }

        /// <summary>
        /// Deserializes XML into a new StorageError instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized StorageError instance.</returns>
        internal static Azure.Storage.Blobs.Models.StorageError FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.StorageError _value = new Azure.Storage.Blobs.Models.StorageError();
            _child = element.Element(System.Xml.Linq.XName.Get("Message", ""));
            if (_child != null)
            {
                _value.Message = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Code", ""));
            if (_child != null)
            {
                _value.Code = _child.Value;
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.StorageError value);
    }
}
#endregion class StorageError

#region class UserDelegationKey
namespace Azure.Storage.Blobs.Models
{
    /// <summary>
    /// A user delegation key
    /// </summary>
    public partial class UserDelegationKey
    {
        /// <summary>
        /// The Azure Active Directory object ID in GUID format.
        /// </summary>
        public string SignedObjectId { get; internal set; }

        /// <summary>
        /// The Azure Active Directory tenant ID in GUID format
        /// </summary>
        public string SignedTenantId { get; internal set; }

        /// <summary>
        /// Abbreviation of the Azure Storage service that accepts the key
        /// </summary>
        public string SignedService { get; internal set; }

        /// <summary>
        /// The service version that created the key
        /// </summary>
        public string SignedVersion { get; internal set; }

        /// <summary>
        /// The key as a base64 string
        /// </summary>
        public string Value { get; internal set; }

        /// <summary>
        /// The date-time the key expires
        /// </summary>
        public System.DateTimeOffset SignedExpiresOn { get; internal set; }

        /// <summary>
        /// The date-time the key is active
        /// </summary>
        public System.DateTimeOffset SignedStartsOn { get; internal set; }

        /// <summary>
        /// Prevent direct instantiation of UserDelegationKey instances.
        /// You can use BlobsModelFactory.UserDelegationKey instead.
        /// </summary>
        internal UserDelegationKey() { }

        /// <summary>
        /// Deserializes XML into a new UserDelegationKey instance.
        /// </summary>
        /// <param name="element">The XML element to deserialize.</param>
        /// <returns>A deserialized UserDelegationKey instance.</returns>
        internal static Azure.Storage.Blobs.Models.UserDelegationKey FromXml(System.Xml.Linq.XElement element)
        {
            System.Diagnostics.Debug.Assert(element != null);
            System.Xml.Linq.XElement _child;
            Azure.Storage.Blobs.Models.UserDelegationKey _value = new Azure.Storage.Blobs.Models.UserDelegationKey();
            _child = element.Element(System.Xml.Linq.XName.Get("SignedOid", ""));
            if (_child != null)
            {
                _value.SignedObjectId = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("SignedTid", ""));
            if (_child != null)
            {
                _value.SignedTenantId = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("SignedService", ""));
            if (_child != null)
            {
                _value.SignedService = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("SignedVersion", ""));
            if (_child != null)
            {
                _value.SignedVersion = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("Value", ""));
            if (_child != null)
            {
                _value.Value = _child.Value;
            }
            _child = element.Element(System.Xml.Linq.XName.Get("SignedExpiry", ""));
            if (_child != null)
            {
                _value.SignedExpiresOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            _child = element.Element(System.Xml.Linq.XName.Get("SignedStart", ""));
            if (_child != null)
            {
                _value.SignedStartsOn = System.DateTimeOffset.Parse(_child.Value, System.Globalization.CultureInfo.InvariantCulture);
            }
            CustomizeFromXml(element, _value);
            return _value;
        }

        static partial void CustomizeFromXml(System.Xml.Linq.XElement element, Azure.Storage.Blobs.Models.UserDelegationKey value);
    }

    /// <summary>
    /// BlobsModelFactory provides utilities for mocking.
    /// </summary>
    public static partial class BlobsModelFactory
    {
        /// <summary>
        /// Creates a new UserDelegationKey instance for mocking.
        /// </summary>
        public static UserDelegationKey UserDelegationKey(
            string signedObjectId,
            string signedTenantId,
            string signedService,
            string signedVersion,
            string value,
            System.DateTimeOffset signedExpiresOn,
            System.DateTimeOffset signedStartsOn)
        {
            return new UserDelegationKey()
            {
                SignedObjectId = signedObjectId,
                SignedTenantId = signedTenantId,
                SignedService = signedService,
                SignedVersion = signedVersion,
                Value = value,
                SignedExpiresOn = signedExpiresOn,
                SignedStartsOn = signedStartsOn,
            };
        }
    }
}
#endregion class UserDelegationKey
#endregion Models

