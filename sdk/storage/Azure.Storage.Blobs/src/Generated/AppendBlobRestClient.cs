// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Storage.Blobs.Models;

namespace Azure.Storage.Blobs
{
    internal partial class AppendBlobRestClient
    {
        private string url;
        private string version;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of AppendBlobRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="url"> The URL of the service account, container, or blob that is the targe of the desired operation. </param>
        /// <param name="version"> Specifies the version of the operation to use for this request. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="url"/> or <paramref name="version"/> is null. </exception>
        public AppendBlobRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version = "2020-06-12")
        {
            if (url == null)
            {
                throw new ArgumentNullException(nameof(url));
            }
            if (version == null)
            {
                throw new ArgumentNullException(nameof(version));
            }

            this.url = url;
            this.version = version;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateCreateRequest(string containerName, string blob, long contentLength, int? timeout, IDictionary<string, string> metadata, string blobTagsString, BlobHttpHeaders blobHttpHeaders, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-blob-type", "AppendBlob");
            if (blobHttpHeaders?.BlobContentType != null)
            {
                request.Headers.Add("x-ms-blob-content-type", blobHttpHeaders.BlobContentType);
            }
            if (blobHttpHeaders?.BlobContentEncoding != null)
            {
                request.Headers.Add("x-ms-blob-content-encoding", blobHttpHeaders.BlobContentEncoding);
            }
            if (blobHttpHeaders?.BlobContentLanguage != null)
            {
                request.Headers.Add("x-ms-blob-content-language", blobHttpHeaders.BlobContentLanguage);
            }
            if (blobHttpHeaders?.BlobContentMD5 != null)
            {
                request.Headers.Add("x-ms-blob-content-md5", blobHttpHeaders.BlobContentMD5);
            }
            if (blobHttpHeaders?.BlobCacheControl != null)
            {
                request.Headers.Add("x-ms-blob-cache-control", blobHttpHeaders.BlobCacheControl);
            }
            if (metadata != null)
            {
                request.Headers.Add("x-ms-meta-", metadata);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (blobHttpHeaders?.BlobContentDisposition != null)
            {
                request.Headers.Add("x-ms-blob-content-disposition", blobHttpHeaders.BlobContentDisposition);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            if (blobTagsString != null)
            {
                request.Headers.Add("x-ms-tags", blobTagsString);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Create Append Blob operation creates a new append blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="blobTagsString"> Optional.  Used to set blob tags in various blob operations. </param>
        /// <param name="blobHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<AppendBlobCreateHeaders>> CreateAsync(string containerName, string blob, long contentLength, int? timeout = null, IDictionary<string, string> metadata = null, string blobTagsString = null, BlobHttpHeaders blobHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateCreateRequest(containerName, blob, contentLength, timeout, metadata, blobTagsString, blobHttpHeaders, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new AppendBlobCreateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Create Append Blob operation creates a new append blob. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="blobTagsString"> Optional.  Used to set blob tags in various blob operations. </param>
        /// <param name="blobHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<AppendBlobCreateHeaders> Create(string containerName, string blob, long contentLength, int? timeout = null, IDictionary<string, string> metadata = null, string blobTagsString = null, BlobHttpHeaders blobHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateCreateRequest(containerName, blob, contentLength, timeout, metadata, blobTagsString, blobHttpHeaders, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new AppendBlobCreateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAppendBlockRequest(string containerName, string blob, long contentLength, Stream body, int? timeout, byte[] transactionalContentMD5, byte[] transactionalContentCrc64, LeaseAccessConditions leaseAccessConditions, AppendPositionAccessConditions appendPositionAccessConditions, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "appendblock", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (transactionalContentCrc64 != null)
            {
                request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (appendPositionAccessConditions?.MaxSize != null)
            {
                request.Headers.Add("x-ms-blob-condition-maxsize", appendPositionAccessConditions.MaxSize.Value);
            }
            if (appendPositionAccessConditions?.AppendPosition != null)
            {
                request.Headers.Add("x-ms-blob-condition-appendpos", appendPositionAccessConditions.AppendPosition.Value);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            request.Headers.Add("Content-Length", contentLength);
            if (transactionalContentMD5 != null)
            {
                request.Headers.Add("Content-MD5", transactionalContentMD5);
            }
            request.Headers.Add("Content-Type", "application/octet-stream");
            request.Content = RequestContent.Create(body);
            return message;
        }

        /// <summary> The Append Block operation commits a new block of data to the end of an existing append blob. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="body"> Initial data. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="transactionalContentMD5"> Specify the transactional md5 for the body, to be validated by the service. </param>
        /// <param name="transactionalContentCrc64"> Specify the transactional crc64 for the body, to be validated by the service. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="appendPositionAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="body"/> is null. </exception>
        public async Task<ResponseWithHeaders<AppendBlobAppendBlockHeaders>> AppendBlockAsync(string containerName, string blob, long contentLength, Stream body, int? timeout = null, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, LeaseAccessConditions leaseAccessConditions = null, AppendPositionAccessConditions appendPositionAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateAppendBlockRequest(containerName, blob, contentLength, body, timeout, transactionalContentMD5, transactionalContentCrc64, leaseAccessConditions, appendPositionAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new AppendBlobAppendBlockHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Append Block operation commits a new block of data to the end of an existing append blob. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="body"> Initial data. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="transactionalContentMD5"> Specify the transactional md5 for the body, to be validated by the service. </param>
        /// <param name="transactionalContentCrc64"> Specify the transactional crc64 for the body, to be validated by the service. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="appendPositionAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="body"/> is null. </exception>
        public ResponseWithHeaders<AppendBlobAppendBlockHeaders> AppendBlock(string containerName, string blob, long contentLength, Stream body, int? timeout = null, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, LeaseAccessConditions leaseAccessConditions = null, AppendPositionAccessConditions appendPositionAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateAppendBlockRequest(containerName, blob, contentLength, body, timeout, transactionalContentMD5, transactionalContentCrc64, leaseAccessConditions, appendPositionAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new AppendBlobAppendBlockHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAppendBlockFromUrlRequest(string containerName, string blob, Uri sourceUrl, long contentLength, string sourceRange, byte[] sourceContentMD5, byte[] sourceContentcrc64, int? timeout, byte[] transactionalContentMD5, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, LeaseAccessConditions leaseAccessConditions, AppendPositionAccessConditions appendPositionAccessConditions, ModifiedAccessConditions modifiedAccessConditions, SourceModifiedAccessConditions sourceModifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "appendblock", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-copy-source", sourceUrl);
            if (sourceRange != null)
            {
                request.Headers.Add("x-ms-source-range", sourceRange);
            }
            if (sourceContentMD5 != null)
            {
                request.Headers.Add("x-ms-source-content-md5", sourceContentMD5);
            }
            if (sourceContentcrc64 != null)
            {
                request.Headers.Add("x-ms-source-content-crc64", sourceContentcrc64);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (appendPositionAccessConditions?.MaxSize != null)
            {
                request.Headers.Add("x-ms-blob-condition-maxsize", appendPositionAccessConditions.MaxSize.Value);
            }
            if (appendPositionAccessConditions?.AppendPosition != null)
            {
                request.Headers.Add("x-ms-blob-condition-appendpos", appendPositionAccessConditions.AppendPosition.Value);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            if (sourceModifiedAccessConditions?.SourceIfModifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfUnmodifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfMatch != null)
            {
                request.Headers.Add("x-ms-source-if-match", sourceModifiedAccessConditions.SourceIfMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfNoneMatch != null)
            {
                request.Headers.Add("x-ms-source-if-none-match", sourceModifiedAccessConditions.SourceIfNoneMatch);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Append Block operation commits a new block of data to the end of an existing append blob where the contents are read from a source url. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="sourceUrl"> Specify a URL to the copy source. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="sourceRange"> Bytes of source data in the specified range. </param>
        /// <param name="sourceContentMD5"> Specify the md5 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="sourceContentcrc64"> Specify the crc64 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="transactionalContentMD5"> Specify the transactional md5 for the body, to be validated by the service. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="appendPositionAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="sourceUrl"/> is null. </exception>
        public async Task<ResponseWithHeaders<AppendBlobAppendBlockFromUrlHeaders>> AppendBlockFromUrlAsync(string containerName, string blob, Uri sourceUrl, long contentLength, string sourceRange = null, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, byte[] transactionalContentMD5 = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, LeaseAccessConditions leaseAccessConditions = null, AppendPositionAccessConditions appendPositionAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (sourceUrl == null)
            {
                throw new ArgumentNullException(nameof(sourceUrl));
            }

            using var message = CreateAppendBlockFromUrlRequest(containerName, blob, sourceUrl, contentLength, sourceRange, sourceContentMD5, sourceContentcrc64, timeout, transactionalContentMD5, cpkInfo, cpkScopeInfo, leaseAccessConditions, appendPositionAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new AppendBlobAppendBlockFromUrlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Append Block operation commits a new block of data to the end of an existing append blob where the contents are read from a source url. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="sourceUrl"> Specify a URL to the copy source. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="sourceRange"> Bytes of source data in the specified range. </param>
        /// <param name="sourceContentMD5"> Specify the md5 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="sourceContentcrc64"> Specify the crc64 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="transactionalContentMD5"> Specify the transactional md5 for the body, to be validated by the service. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="appendPositionAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/>, <paramref name="blob"/>, or <paramref name="sourceUrl"/> is null. </exception>
        public ResponseWithHeaders<AppendBlobAppendBlockFromUrlHeaders> AppendBlockFromUrl(string containerName, string blob, Uri sourceUrl, long contentLength, string sourceRange = null, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, byte[] transactionalContentMD5 = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, LeaseAccessConditions leaseAccessConditions = null, AppendPositionAccessConditions appendPositionAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (sourceUrl == null)
            {
                throw new ArgumentNullException(nameof(sourceUrl));
            }

            using var message = CreateAppendBlockFromUrlRequest(containerName, blob, sourceUrl, contentLength, sourceRange, sourceContentMD5, sourceContentcrc64, timeout, transactionalContentMD5, cpkInfo, cpkScopeInfo, leaseAccessConditions, appendPositionAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new AppendBlobAppendBlockFromUrlHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSealRequest(string containerName, string blob, int? timeout, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions, AppendPositionAccessConditions appendPositionAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "seal", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-version", version);
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (appendPositionAccessConditions?.AppendPosition != null)
            {
                request.Headers.Add("x-ms-blob-condition-appendpos", appendPositionAccessConditions.AppendPosition.Value);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version 2019-12-12 version or later. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="appendPositionAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<AppendBlobSealHeaders>> SealAsync(string containerName, string blob, int? timeout = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, AppendPositionAccessConditions appendPositionAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSealRequest(containerName, blob, timeout, leaseAccessConditions, modifiedAccessConditions, appendPositionAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new AppendBlobSealHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version 2019-12-12 version or later. </summary>
        /// <param name="containerName"> The container name. </param>
        /// <param name="blob"> The blob name. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="appendPositionAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerName"/> or <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<AppendBlobSealHeaders> Seal(string containerName, string blob, int? timeout = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, AppendPositionAccessConditions appendPositionAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateSealRequest(containerName, blob, timeout, leaseAccessConditions, modifiedAccessConditions, appendPositionAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new AppendBlobSealHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
