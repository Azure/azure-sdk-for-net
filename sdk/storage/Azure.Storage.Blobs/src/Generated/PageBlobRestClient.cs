// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Storage.Blobs.Models;

namespace Azure.Storage.Blobs
{
    internal partial class PageBlobRestClient
    {
        private string url;
        private string containerName;
        private string version;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of PageBlobRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="url"> The URL of the service account, container, or blob that is the targe of the desired operation. </param>
        /// <param name="containerName"> The container name. </param>
        /// <param name="version"> Specifies the version of the operation to use for this request. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="url"/>, <paramref name="containerName"/>, or <paramref name="version"/> is null. </exception>
        public PageBlobRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string containerName, string version = "2020-06-12")
        {
            if (url == null)
            {
                throw new ArgumentNullException(nameof(url));
            }
            if (containerName == null)
            {
                throw new ArgumentNullException(nameof(containerName));
            }
            if (version == null)
            {
                throw new ArgumentNullException(nameof(version));
            }

            this.url = url;
            this.containerName = containerName;
            this.version = version;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateCreateRequest(string blob, long contentLength, long blobContentLength, int? timeout, PremiumPageBlobAccessTier? tier, IDictionary<string, string> metadata, long? blobSequenceNumber, string blobTagsString, BlobHttpHeaders blobHttpHeaders, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-blob-type", "PageBlob");
            if (tier != null)
            {
                request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
            }
            if (blobHttpHeaders?.BlobContentType != null)
            {
                request.Headers.Add("x-ms-blob-content-type", blobHttpHeaders.BlobContentType);
            }
            if (blobHttpHeaders?.BlobContentEncoding != null)
            {
                request.Headers.Add("x-ms-blob-content-encoding", blobHttpHeaders.BlobContentEncoding);
            }
            if (blobHttpHeaders?.BlobContentLanguage != null)
            {
                request.Headers.Add("x-ms-blob-content-language", blobHttpHeaders.BlobContentLanguage);
            }
            if (blobHttpHeaders?.BlobContentMD5 != null)
            {
                request.Headers.Add("x-ms-blob-content-md5", blobHttpHeaders.BlobContentMD5);
            }
            if (blobHttpHeaders?.BlobCacheControl != null)
            {
                request.Headers.Add("x-ms-blob-cache-control", blobHttpHeaders.BlobCacheControl);
            }
            if (metadata != null)
            {
                request.Headers.Add("x-ms-meta-", metadata);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (blobHttpHeaders?.BlobContentDisposition != null)
            {
                request.Headers.Add("x-ms-blob-content-disposition", blobHttpHeaders.BlobContentDisposition);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-blob-content-length", blobContentLength);
            if (blobSequenceNumber != null)
            {
                request.Headers.Add("x-ms-blob-sequence-number", blobSequenceNumber.Value);
            }
            request.Headers.Add("x-ms-version", version);
            if (blobTagsString != null)
            {
                request.Headers.Add("x-ms-tags", blobTagsString);
            }
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Create operation creates a new page blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="blobContentLength"> This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned to a 512-byte boundary. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="tier"> Optional. Indicates the tier to be set on the page blob. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="blobSequenceNumber"> Set for page blobs only. The sequence number is a user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 2^63 - 1. </param>
        /// <param name="blobTagsString"> Optional.  Used to set blob tags in various blob operations. </param>
        /// <param name="blobHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageBlobCreateHeaders>> CreateAsync(string blob, long contentLength, long blobContentLength, int? timeout = null, PremiumPageBlobAccessTier? tier = null, IDictionary<string, string> metadata = null, long? blobSequenceNumber = null, string blobTagsString = null, BlobHttpHeaders blobHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateCreateRequest(blob, contentLength, blobContentLength, timeout, tier, metadata, blobSequenceNumber, blobTagsString, blobHttpHeaders, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobCreateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Create operation creates a new page blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="blobContentLength"> This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned to a 512-byte boundary. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="tier"> Optional. Indicates the tier to be set on the page blob. </param>
        /// <param name="metadata"> Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value pairs are specified, the operation will copy the metadata from the source blob or file to the destination blob. If one or more name-value pairs are specified, the destination blob is created with the specified metadata, and metadata is not copied from the source blob or file. Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more information. </param>
        /// <param name="blobSequenceNumber"> Set for page blobs only. The sequence number is a user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 2^63 - 1. </param>
        /// <param name="blobTagsString"> Optional.  Used to set blob tags in various blob operations. </param>
        /// <param name="blobHttpHeaders"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<PageBlobCreateHeaders> Create(string blob, long contentLength, long blobContentLength, int? timeout = null, PremiumPageBlobAccessTier? tier = null, IDictionary<string, string> metadata = null, long? blobSequenceNumber = null, string blobTagsString = null, BlobHttpHeaders blobHttpHeaders = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateCreateRequest(blob, contentLength, blobContentLength, timeout, tier, metadata, blobSequenceNumber, blobTagsString, blobHttpHeaders, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobCreateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUploadPagesRequest(string blob, long contentLength, Stream body, byte[] transactionalContentMD5, byte[] transactionalContentCrc64, int? timeout, string range, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, SequenceNumberAccessConditions sequenceNumberAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "page", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-page-write", "update");
            if (transactionalContentCrc64 != null)
            {
                request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64);
            }
            if (range != null)
            {
                request.Headers.Add("x-ms-range", range);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberLessThanOrEqualTo != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-le", sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo.Value);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberLessThan != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-lt", sequenceNumberAccessConditions.IfSequenceNumberLessThan.Value);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberEqualTo != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-eq", sequenceNumberAccessConditions.IfSequenceNumberEqualTo.Value);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            request.Headers.Add("Content-Length", contentLength);
            if (transactionalContentMD5 != null)
            {
                request.Headers.Add("Content-MD5", transactionalContentMD5);
            }
            request.Headers.Add("Content-Type", "application/octet-stream");
            request.Content = RequestContent.Create(body);
            return message;
        }

        /// <summary> The Upload Pages operation writes a range of pages to a page blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="body"> Initial data. </param>
        /// <param name="transactionalContentMD5"> Specify the transactional md5 for the body, to be validated by the service. </param>
        /// <param name="transactionalContentCrc64"> Specify the transactional crc64 for the body, to be validated by the service. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="sequenceNumberAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> or <paramref name="body"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageBlobUploadPagesHeaders>> UploadPagesAsync(string blob, long contentLength, Stream body, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, int? timeout = null, string range = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, SequenceNumberAccessConditions sequenceNumberAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateUploadPagesRequest(blob, contentLength, body, transactionalContentMD5, transactionalContentCrc64, timeout, range, leaseAccessConditions, cpkInfo, cpkScopeInfo, sequenceNumberAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobUploadPagesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Upload Pages operation writes a range of pages to a page blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="body"> Initial data. </param>
        /// <param name="transactionalContentMD5"> Specify the transactional md5 for the body, to be validated by the service. </param>
        /// <param name="transactionalContentCrc64"> Specify the transactional crc64 for the body, to be validated by the service. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="sequenceNumberAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> or <paramref name="body"/> is null. </exception>
        public ResponseWithHeaders<PageBlobUploadPagesHeaders> UploadPages(string blob, long contentLength, Stream body, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, int? timeout = null, string range = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, SequenceNumberAccessConditions sequenceNumberAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateUploadPagesRequest(blob, contentLength, body, transactionalContentMD5, transactionalContentCrc64, timeout, range, leaseAccessConditions, cpkInfo, cpkScopeInfo, sequenceNumberAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobUploadPagesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateClearPagesRequest(string blob, long contentLength, int? timeout, string range, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, SequenceNumberAccessConditions sequenceNumberAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "page", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-page-write", "clear");
            if (range != null)
            {
                request.Headers.Add("x-ms-range", range);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberLessThanOrEqualTo != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-le", sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo.Value);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberLessThan != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-lt", sequenceNumberAccessConditions.IfSequenceNumberLessThan.Value);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberEqualTo != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-eq", sequenceNumberAccessConditions.IfSequenceNumberEqualTo.Value);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Clear Pages operation clears a set of pages from a page blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="sequenceNumberAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageBlobClearPagesHeaders>> ClearPagesAsync(string blob, long contentLength, int? timeout = null, string range = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, SequenceNumberAccessConditions sequenceNumberAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateClearPagesRequest(blob, contentLength, timeout, range, leaseAccessConditions, cpkInfo, cpkScopeInfo, sequenceNumberAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobClearPagesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Clear Pages operation clears a set of pages from a page blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="sequenceNumberAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<PageBlobClearPagesHeaders> ClearPages(string blob, long contentLength, int? timeout = null, string range = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, SequenceNumberAccessConditions sequenceNumberAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateClearPagesRequest(blob, contentLength, timeout, range, leaseAccessConditions, cpkInfo, cpkScopeInfo, sequenceNumberAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobClearPagesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUploadPagesFromURLRequest(string blob, Uri sourceUrl, string sourceRange, long contentLength, string range, byte[] sourceContentMD5, byte[] sourceContentcrc64, int? timeout, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, LeaseAccessConditions leaseAccessConditions, SequenceNumberAccessConditions sequenceNumberAccessConditions, ModifiedAccessConditions modifiedAccessConditions, SourceModifiedAccessConditions sourceModifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "page", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("x-ms-page-write", "update");
            request.Headers.Add("x-ms-copy-source", sourceUrl);
            request.Headers.Add("x-ms-source-range", sourceRange);
            if (sourceContentMD5 != null)
            {
                request.Headers.Add("x-ms-source-content-md5", sourceContentMD5);
            }
            if (sourceContentcrc64 != null)
            {
                request.Headers.Add("x-ms-source-content-crc64", sourceContentcrc64);
            }
            request.Headers.Add("x-ms-range", range);
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberLessThanOrEqualTo != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-le", sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo.Value);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberLessThan != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-lt", sequenceNumberAccessConditions.IfSequenceNumberLessThan.Value);
            }
            if (sequenceNumberAccessConditions?.IfSequenceNumberEqualTo != null)
            {
                request.Headers.Add("x-ms-if-sequence-number-eq", sequenceNumberAccessConditions.IfSequenceNumberEqualTo.Value);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            if (sourceModifiedAccessConditions?.SourceIfModifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfUnmodifiedSince != null)
            {
                request.Headers.Add("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Value, "R");
            }
            if (sourceModifiedAccessConditions?.SourceIfMatch != null)
            {
                request.Headers.Add("x-ms-source-if-match", sourceModifiedAccessConditions.SourceIfMatch);
            }
            if (sourceModifiedAccessConditions?.SourceIfNoneMatch != null)
            {
                request.Headers.Add("x-ms-source-if-none-match", sourceModifiedAccessConditions.SourceIfNoneMatch);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Upload Pages operation writes a range of pages to a page blob where the contents are read from a URL. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="sourceUrl"> Specify a URL to the copy source. </param>
        /// <param name="sourceRange"> Bytes of source data in the specified range. The length of this range should match the ContentLength header and x-ms-range/Range destination range header. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="range"> The range of bytes to which the source range would be written. The range should be 512 aligned and range-end is required. </param>
        /// <param name="sourceContentMD5"> Specify the md5 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="sourceContentcrc64"> Specify the crc64 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="sequenceNumberAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/>, <paramref name="sourceUrl"/>, <paramref name="sourceRange"/>, or <paramref name="range"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageBlobUploadPagesFromURLHeaders>> UploadPagesFromURLAsync(string blob, Uri sourceUrl, string sourceRange, long contentLength, string range, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, LeaseAccessConditions leaseAccessConditions = null, SequenceNumberAccessConditions sequenceNumberAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (sourceUrl == null)
            {
                throw new ArgumentNullException(nameof(sourceUrl));
            }
            if (sourceRange == null)
            {
                throw new ArgumentNullException(nameof(sourceRange));
            }
            if (range == null)
            {
                throw new ArgumentNullException(nameof(range));
            }

            using var message = CreateUploadPagesFromURLRequest(blob, sourceUrl, sourceRange, contentLength, range, sourceContentMD5, sourceContentcrc64, timeout, cpkInfo, cpkScopeInfo, leaseAccessConditions, sequenceNumberAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobUploadPagesFromURLHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Upload Pages operation writes a range of pages to a page blob where the contents are read from a URL. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="sourceUrl"> Specify a URL to the copy source. </param>
        /// <param name="sourceRange"> Bytes of source data in the specified range. The length of this range should match the ContentLength header and x-ms-range/Range destination range header. </param>
        /// <param name="contentLength"> The length of the request. </param>
        /// <param name="range"> The range of bytes to which the source range would be written. The range should be 512 aligned and range-end is required. </param>
        /// <param name="sourceContentMD5"> Specify the md5 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="sourceContentcrc64"> Specify the crc64 calculated for the range of bytes that must be read from the copy source. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="sequenceNumberAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="sourceModifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/>, <paramref name="sourceUrl"/>, <paramref name="sourceRange"/>, or <paramref name="range"/> is null. </exception>
        public ResponseWithHeaders<PageBlobUploadPagesFromURLHeaders> UploadPagesFromURL(string blob, Uri sourceUrl, string sourceRange, long contentLength, string range, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, LeaseAccessConditions leaseAccessConditions = null, SequenceNumberAccessConditions sequenceNumberAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, SourceModifiedAccessConditions sourceModifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (sourceUrl == null)
            {
                throw new ArgumentNullException(nameof(sourceUrl));
            }
            if (sourceRange == null)
            {
                throw new ArgumentNullException(nameof(sourceRange));
            }
            if (range == null)
            {
                throw new ArgumentNullException(nameof(range));
            }

            using var message = CreateUploadPagesFromURLRequest(blob, sourceUrl, sourceRange, contentLength, range, sourceContentMD5, sourceContentcrc64, timeout, cpkInfo, cpkScopeInfo, leaseAccessConditions, sequenceNumberAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobUploadPagesFromURLHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetPageRangesRequest(string blob, string snapshot, int? timeout, string range, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "pagelist", true);
            if (snapshot != null)
            {
                uri.AppendQuery("snapshot", snapshot, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (range != null)
            {
                request.Headers.Add("x-ms-range", range);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot of a page blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders>> GetPageRangesAsync(string blob, string snapshot = null, int? timeout = null, string range = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateGetPageRangesRequest(blob, snapshot, timeout, range, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobGetPageRangesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PageList value = default;
                        var document = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace);
                        if (document.Element("PageList") is XElement pageListElement)
                        {
                            value = PageList.DeserializePageList(pageListElement);
                        }
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot of a page blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders> GetPageRanges(string blob, string snapshot = null, int? timeout = null, string range = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateGetPageRangesRequest(blob, snapshot, timeout, range, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobGetPageRangesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PageList value = default;
                        var document = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace);
                        if (document.Element("PageList") is XElement pageListElement)
                        {
                            value = PageList.DeserializePageList(pageListElement);
                        }
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetPageRangesDiffRequest(string blob, string snapshot, int? timeout, string prevsnapshot, Uri prevSnapshotUrl, string range, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "pagelist", true);
            if (snapshot != null)
            {
                uri.AppendQuery("snapshot", snapshot, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            if (prevsnapshot != null)
            {
                uri.AppendQuery("prevsnapshot", prevsnapshot, true);
            }
            request.Uri = uri;
            if (prevSnapshotUrl != null)
            {
                request.Headers.Add("x-ms-previous-snapshot-url", prevSnapshotUrl);
            }
            if (range != null)
            {
                request.Headers.Add("x-ms-range", range);
            }
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob that were changed between target blob and previous snapshot. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="prevsnapshot"> Optional in version 2015-07-08 and newer. The prevsnapshot parameter is a DateTime value that specifies that the response will contain only pages that were changed between target blob and previous snapshot. Changed pages include both updated and cleared pages. The target blob may be a snapshot, as long as the snapshot specified by prevsnapshot is the older of the two. Note that incremental snapshots are currently supported only for blobs created on or after January 1, 2016. </param>
        /// <param name="prevSnapshotUrl"> Optional. This header is only supported in service versions 2019-04-19 and after and specifies the URL of a previous snapshot of the target blob. The response will only contain pages that were changed between the target blob and its previous snapshot. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders>> GetPageRangesDiffAsync(string blob, string snapshot = null, int? timeout = null, string prevsnapshot = null, Uri prevSnapshotUrl = null, string range = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateGetPageRangesDiffRequest(blob, snapshot, timeout, prevsnapshot, prevSnapshotUrl, range, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobGetPageRangesDiffHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PageList value = default;
                        var document = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace);
                        if (document.Element("PageList") is XElement pageListElement)
                        {
                            value = PageList.DeserializePageList(pageListElement);
                        }
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob that were changed between target blob and previous snapshot. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="snapshot"> The snapshot parameter is an opaque DateTime value that, when present, specifies the blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob&quot;&gt;Creating a Snapshot of a Blob.&lt;/a&gt;. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="prevsnapshot"> Optional in version 2015-07-08 and newer. The prevsnapshot parameter is a DateTime value that specifies that the response will contain only pages that were changed between target blob and previous snapshot. Changed pages include both updated and cleared pages. The target blob may be a snapshot, as long as the snapshot specified by prevsnapshot is the older of the two. Note that incremental snapshots are currently supported only for blobs created on or after January 1, 2016. </param>
        /// <param name="prevSnapshotUrl"> Optional. This header is only supported in service versions 2019-04-19 and after and specifies the URL of a previous snapshot of the target blob. The response will only contain pages that were changed between the target blob and its previous snapshot. </param>
        /// <param name="range"> Return only the bytes of the blob in the specified range. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders> GetPageRangesDiff(string blob, string snapshot = null, int? timeout = null, string prevsnapshot = null, Uri prevSnapshotUrl = null, string range = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateGetPageRangesDiffRequest(blob, snapshot, timeout, prevsnapshot, prevSnapshotUrl, range, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobGetPageRangesDiffHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PageList value = default;
                        var document = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace);
                        if (document.Element("PageList") is XElement pageListElement)
                        {
                            value = PageList.DeserializePageList(pageListElement);
                        }
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateResizeRequest(string blob, long blobContentLength, int? timeout, LeaseAccessConditions leaseAccessConditions, CpkInfo cpkInfo, CpkScopeInfo cpkScopeInfo, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "properties", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (cpkInfo?.EncryptionKey != null)
            {
                request.Headers.Add("x-ms-encryption-key", cpkInfo.EncryptionKey);
            }
            if (cpkInfo?.EncryptionKeySha256 != null)
            {
                request.Headers.Add("x-ms-encryption-key-sha256", cpkInfo.EncryptionKeySha256);
            }
            request.Headers.Add("x-ms-encryption-algorithm", "AES256");
            if (cpkScopeInfo?.EncryptionScope != null)
            {
                request.Headers.Add("x-ms-encryption-scope", cpkScopeInfo.EncryptionScope);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-blob-content-length", blobContentLength);
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Resize the Blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="blobContentLength"> This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned to a 512-byte boundary. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageBlobResizeHeaders>> ResizeAsync(string blob, long blobContentLength, int? timeout = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateResizeRequest(blob, blobContentLength, timeout, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobResizeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Resize the Blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="blobContentLength"> This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned to a 512-byte boundary. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="cpkInfo"> Parameter group. </param>
        /// <param name="cpkScopeInfo"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<PageBlobResizeHeaders> Resize(string blob, long blobContentLength, int? timeout = null, LeaseAccessConditions leaseAccessConditions = null, CpkInfo cpkInfo = null, CpkScopeInfo cpkScopeInfo = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateResizeRequest(blob, blobContentLength, timeout, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobResizeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdateSequenceNumberRequest(string blob, SequenceNumberActionType sequenceNumberAction, int? timeout, long? blobSequenceNumber, LeaseAccessConditions leaseAccessConditions, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "properties", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (leaseAccessConditions?.LeaseId != null)
            {
                request.Headers.Add("x-ms-lease-id", leaseAccessConditions.LeaseId);
            }
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-sequence-number-action", sequenceNumberAction.ToSerialString());
            if (blobSequenceNumber != null)
            {
                request.Headers.Add("x-ms-blob-sequence-number", blobSequenceNumber.Value);
            }
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> Update the sequence number of the blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="sequenceNumberAction"> Required if the x-ms-blob-sequence-number header is set for the request. This property applies to page blobs only. This property indicates how the service should modify the blob&apos;s sequence number. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="blobSequenceNumber"> Set for page blobs only. The sequence number is a user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 2^63 - 1. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageBlobUpdateSequenceNumberHeaders>> UpdateSequenceNumberAsync(string blob, SequenceNumberActionType sequenceNumberAction, int? timeout = null, long? blobSequenceNumber = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateUpdateSequenceNumberRequest(blob, sequenceNumberAction, timeout, blobSequenceNumber, leaseAccessConditions, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobUpdateSequenceNumberHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Update the sequence number of the blob. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="sequenceNumberAction"> Required if the x-ms-blob-sequence-number header is set for the request. This property applies to page blobs only. This property indicates how the service should modify the blob&apos;s sequence number. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="blobSequenceNumber"> Set for page blobs only. The sequence number is a user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 2^63 - 1. </param>
        /// <param name="leaseAccessConditions"> Parameter group. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> is null. </exception>
        public ResponseWithHeaders<PageBlobUpdateSequenceNumberHeaders> UpdateSequenceNumber(string blob, SequenceNumberActionType sequenceNumberAction, int? timeout = null, long? blobSequenceNumber = null, LeaseAccessConditions leaseAccessConditions = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }

            using var message = CreateUpdateSequenceNumberRequest(blob, sequenceNumberAction, timeout, blobSequenceNumber, leaseAccessConditions, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobUpdateSequenceNumberHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCopyIncrementalRequest(string blob, Uri copySource, int? timeout, ModifiedAccessConditions modifiedAccessConditions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(url, false);
            uri.AppendPath("/", false);
            uri.AppendPath(containerName, true);
            uri.AppendPath("/", false);
            uri.AppendPath(blob, true);
            uri.AppendQuery("comp", "incrementalcopy", true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            request.Uri = uri;
            if (modifiedAccessConditions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Value, "R");
            }
            if (modifiedAccessConditions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", modifiedAccessConditions.IfMatch);
            }
            if (modifiedAccessConditions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", modifiedAccessConditions.IfNoneMatch);
            }
            if (modifiedAccessConditions?.IfTags != null)
            {
                request.Headers.Add("x-ms-if-tags", modifiedAccessConditions.IfTags);
            }
            request.Headers.Add("x-ms-copy-source", copySource);
            request.Headers.Add("x-ms-version", version);
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        /// <summary> The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob. The snapshot is copied such that only the differential changes between the previously copied snapshot are transferred to the destination. The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual. This API is supported since REST version 2016-05-31. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="copySource"> Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> or <paramref name="copySource"/> is null. </exception>
        public async Task<ResponseWithHeaders<PageBlobCopyIncrementalHeaders>> CopyIncrementalAsync(string blob, Uri copySource, int? timeout = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (copySource == null)
            {
                throw new ArgumentNullException(nameof(copySource));
            }

            using var message = CreateCopyIncrementalRequest(blob, copySource, timeout, modifiedAccessConditions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PageBlobCopyIncrementalHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob. The snapshot is copied such that only the differential changes between the previously copied snapshot are transferred to the destination. The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual. This API is supported since REST version 2016-05-31. </summary>
        /// <param name="blob"> The blob name. </param>
        /// <param name="copySource"> Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it would appear in a request URI. The source blob must either be public or must be authenticated via a shared access signature. </param>
        /// <param name="timeout"> The timeout parameter is expressed in seconds. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations&quot;&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;. </param>
        /// <param name="modifiedAccessConditions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="blob"/> or <paramref name="copySource"/> is null. </exception>
        public ResponseWithHeaders<PageBlobCopyIncrementalHeaders> CopyIncremental(string blob, Uri copySource, int? timeout = null, ModifiedAccessConditions modifiedAccessConditions = null, CancellationToken cancellationToken = default)
        {
            if (blob == null)
            {
                throw new ArgumentNullException(nameof(blob));
            }
            if (copySource == null)
            {
                throw new ArgumentNullException(nameof(copySource));
            }

            using var message = CreateCopyIncrementalRequest(blob, copySource, timeout, modifiedAccessConditions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PageBlobCopyIncrementalHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
