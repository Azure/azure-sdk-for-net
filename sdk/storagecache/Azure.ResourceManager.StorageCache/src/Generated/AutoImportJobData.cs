// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.StorageCache.Models;

namespace Azure.ResourceManager.StorageCache
{
    /// <summary>
    /// A class representing the AutoImportJob data model.
    /// An auto import job instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md
    /// </summary>
    public partial class AutoImportJobData : TrackedResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="AutoImportJobData"/>. </summary>
        /// <param name="location"> The location. </param>
        public AutoImportJobData(AzureLocation location) : base(location)
        {
            AutoImportPrefixes = new ChangeTrackingList<string>();
        }

        /// <summary> Initializes a new instance of <see cref="AutoImportJobData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="provisioningState"> ARM provisioning state. </param>
        /// <param name="adminStatus"> The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable' will disable the current active auto import job. By default it is set to 'Enable'. </param>
        /// <param name="autoImportPrefixes"> An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number of maximum allowed paths is 100. </param>
        /// <param name="conflictResolutionMode"> How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a thorough explanation of these resolution modes. </param>
        /// <param name="enableDeletions"> Whether or not to enable deletions during auto import. This only affects overwrite-dirty. </param>
        /// <param name="maximumErrors"> Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately on any error. </param>
        /// <param name="state"> The state of the auto import operation. </param>
        /// <param name="statusCode"> Server-defined status code for auto import job. </param>
        /// <param name="statusMessage"> Server-defined status message for auto import job. </param>
        /// <param name="scanStartOn"> Date and time of when the currently running full scan began. </param>
        /// <param name="scanEndOn"> Date and time of when the full scan ended. </param>
        /// <param name="totalBlobsWalked"> Total number of blobs walked during full scan. </param>
        /// <param name="rateOfBlobWalk"> Rate of blobs walked during full scan. </param>
        /// <param name="totalBlobsImported"> Total number of blobs imported during full scan. </param>
        /// <param name="rateOfBlobImport"> Rate of blob import during full scan. </param>
        /// <param name="importedFiles"> Number of files imported during full scan. </param>
        /// <param name="importedDirectories"> Number of directories imported during full scan. </param>
        /// <param name="importedSymlinks"> Number of symlinks imported during full scan. </param>
        /// <param name="preexistingFiles"> Number of preexisting files during full scan. </param>
        /// <param name="preexistingDirectories"> Number of preexisting directories during full scan. </param>
        /// <param name="preexistingSymlinks"> Number of preexisting symlinks during full scan. </param>
        /// <param name="totalErrors"> Total errors encountered during full scan. </param>
        /// <param name="totalConflicts"> Total conflicts encountered during full scan. </param>
        /// <param name="blobSyncEvents"> The storage account blob change feed status of the auto import job. </param>
        /// <param name="lastStartedTimeUTC"> The time (in UTC) the latest auto import job started. </param>
        /// <param name="lastCompletionTimeUTC"> The time (in UTC) of the last completed auto import job. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal AutoImportJobData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, IDictionary<string, string> tags, AzureLocation location, AutoImportJobPropertiesProvisioningState? provisioningState, AutoImportJobPropertiesAdminStatus? adminStatus, IList<string> autoImportPrefixes, ConflictResolutionMode? conflictResolutionMode, bool? enableDeletions, long? maximumErrors, AutoImportJobState? state, string statusCode, string statusMessage, DateTimeOffset? scanStartOn, DateTimeOffset? scanEndOn, long? totalBlobsWalked, long? rateOfBlobWalk, long? totalBlobsImported, long? rateOfBlobImport, long? importedFiles, long? importedDirectories, long? importedSymlinks, long? preexistingFiles, long? preexistingDirectories, long? preexistingSymlinks, long? totalErrors, long? totalConflicts, AutoImportJobPropertiesStatusBlobSyncEvents blobSyncEvents, DateTimeOffset? lastStartedTimeUTC, DateTimeOffset? lastCompletionTimeUTC, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData, tags, location)
        {
            ProvisioningState = provisioningState;
            AdminStatus = adminStatus;
            AutoImportPrefixes = autoImportPrefixes;
            ConflictResolutionMode = conflictResolutionMode;
            EnableDeletions = enableDeletions;
            MaximumErrors = maximumErrors;
            State = state;
            StatusCode = statusCode;
            StatusMessage = statusMessage;
            ScanStartOn = scanStartOn;
            ScanEndOn = scanEndOn;
            TotalBlobsWalked = totalBlobsWalked;
            RateOfBlobWalk = rateOfBlobWalk;
            TotalBlobsImported = totalBlobsImported;
            RateOfBlobImport = rateOfBlobImport;
            ImportedFiles = importedFiles;
            ImportedDirectories = importedDirectories;
            ImportedSymlinks = importedSymlinks;
            PreexistingFiles = preexistingFiles;
            PreexistingDirectories = preexistingDirectories;
            PreexistingSymlinks = preexistingSymlinks;
            TotalErrors = totalErrors;
            TotalConflicts = totalConflicts;
            BlobSyncEvents = blobSyncEvents;
            LastStartedTimeUTC = lastStartedTimeUTC;
            LastCompletionTimeUTC = lastCompletionTimeUTC;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="AutoImportJobData"/> for deserialization. </summary>
        internal AutoImportJobData()
        {
        }

        /// <summary> ARM provisioning state. </summary>
        public AutoImportJobPropertiesProvisioningState? ProvisioningState { get; }
        /// <summary> The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable' will disable the current active auto import job. By default it is set to 'Enable'. </summary>
        public AutoImportJobPropertiesAdminStatus? AdminStatus { get; set; }
        /// <summary> An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number of maximum allowed paths is 100. </summary>
        public IList<string> AutoImportPrefixes { get; }
        /// <summary> How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a thorough explanation of these resolution modes. </summary>
        public ConflictResolutionMode? ConflictResolutionMode { get; set; }
        /// <summary> Whether or not to enable deletions during auto import. This only affects overwrite-dirty. </summary>
        public bool? EnableDeletions { get; set; }
        /// <summary> Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately on any error. </summary>
        public long? MaximumErrors { get; set; }
        /// <summary> The state of the auto import operation. </summary>
        public AutoImportJobState? State { get; }
        /// <summary> Server-defined status code for auto import job. </summary>
        public string StatusCode { get; }
        /// <summary> Server-defined status message for auto import job. </summary>
        public string StatusMessage { get; }
        /// <summary> Date and time of when the currently running full scan began. </summary>
        public DateTimeOffset? ScanStartOn { get; }
        /// <summary> Date and time of when the full scan ended. </summary>
        public DateTimeOffset? ScanEndOn { get; }
        /// <summary> Total number of blobs walked during full scan. </summary>
        public long? TotalBlobsWalked { get; }
        /// <summary> Rate of blobs walked during full scan. </summary>
        public long? RateOfBlobWalk { get; }
        /// <summary> Total number of blobs imported during full scan. </summary>
        public long? TotalBlobsImported { get; }
        /// <summary> Rate of blob import during full scan. </summary>
        public long? RateOfBlobImport { get; }
        /// <summary> Number of files imported during full scan. </summary>
        public long? ImportedFiles { get; }
        /// <summary> Number of directories imported during full scan. </summary>
        public long? ImportedDirectories { get; }
        /// <summary> Number of symlinks imported during full scan. </summary>
        public long? ImportedSymlinks { get; }
        /// <summary> Number of preexisting files during full scan. </summary>
        public long? PreexistingFiles { get; }
        /// <summary> Number of preexisting directories during full scan. </summary>
        public long? PreexistingDirectories { get; }
        /// <summary> Number of preexisting symlinks during full scan. </summary>
        public long? PreexistingSymlinks { get; }
        /// <summary> Total errors encountered during full scan. </summary>
        public long? TotalErrors { get; }
        /// <summary> Total conflicts encountered during full scan. </summary>
        public long? TotalConflicts { get; }
        /// <summary> The storage account blob change feed status of the auto import job. </summary>
        public AutoImportJobPropertiesStatusBlobSyncEvents BlobSyncEvents { get; }
        /// <summary> The time (in UTC) the latest auto import job started. </summary>
        public DateTimeOffset? LastStartedTimeUTC { get; }
        /// <summary> The time (in UTC) of the last completed auto import job. </summary>
        public DateTimeOffset? LastCompletionTimeUTC { get; }
    }
}
