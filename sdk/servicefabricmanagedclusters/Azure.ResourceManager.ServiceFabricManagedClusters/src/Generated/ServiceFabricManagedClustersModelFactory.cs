// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using Azure;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.ServiceFabricManagedClusters;

namespace Azure.ResourceManager.ServiceFabricManagedClusters.Models
{
    /// <summary> Model factory for generated models. </summary>
    public static partial class ServiceFabricManagedClustersModelFactory
    {
        /// <summary> Initializes a new instance of ServiceFabricManagedApplicationTypeData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="provisioningState"> The current deployment or provisioning state, which only appears in the response. </param>
        /// <returns> A new <see cref="ServiceFabricManagedClusters.ServiceFabricManagedApplicationTypeData"/> instance for mocking. </returns>
        public static ServiceFabricManagedApplicationTypeData ServiceFabricManagedApplicationTypeData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string provisioningState = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ServiceFabricManagedApplicationTypeData(id, name, resourceType, systemData, tags, location, provisioningState);
        }

        /// <summary> Initializes a new instance of ServiceFabricManagedApplicationTypeVersionData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="provisioningState"> The current deployment or provisioning state, which only appears in the response. </param>
        /// <param name="appPackageUri"> The URL to the application package. </param>
        /// <returns> A new <see cref="ServiceFabricManagedClusters.ServiceFabricManagedApplicationTypeVersionData"/> instance for mocking. </returns>
        public static ServiceFabricManagedApplicationTypeVersionData ServiceFabricManagedApplicationTypeVersionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string provisioningState = null, Uri appPackageUri = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ServiceFabricManagedApplicationTypeVersionData(id, name, resourceType, systemData, tags, location, provisioningState, appPackageUri);
        }

        /// <summary> Initializes a new instance of ServiceFabricManagedApplicationData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="identity"> Describes the managed identities for an Azure resource. </param>
        /// <param name="provisioningState"> The current deployment or provisioning state, which only appears in the response. </param>
        /// <param name="version">
        /// The version of the application type as defined in the application manifest.
        /// This name must be the full Arm Resource ID for the referenced application type version.
        /// 
        /// </param>
        /// <param name="parameters"> List of application parameters with overridden values from their default values specified in the application manifest. </param>
        /// <param name="upgradePolicy"> Describes the policy for a monitored application upgrade. </param>
        /// <param name="managedIdentities"> List of user assigned identities for the application, each mapped to a friendly name. </param>
        /// <returns> A new <see cref="ServiceFabricManagedClusters.ServiceFabricManagedApplicationData"/> instance for mocking. </returns>
        public static ServiceFabricManagedApplicationData ServiceFabricManagedApplicationData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ManagedServiceIdentity identity = null, string provisioningState = null, string version = null, IDictionary<string, string> parameters = null, ApplicationUpgradePolicy upgradePolicy = null, IEnumerable<ApplicationUserAssignedIdentityInfo> managedIdentities = null)
        {
            tags ??= new Dictionary<string, string>();
            parameters ??= new Dictionary<string, string>();
            managedIdentities ??= new List<ApplicationUserAssignedIdentityInfo>();

            return new ServiceFabricManagedApplicationData(id, name, resourceType, systemData, tags, location, identity, provisioningState, version, parameters, upgradePolicy, managedIdentities?.ToList());
        }

        /// <summary> Initializes a new instance of ApplicationUpgradePolicy. </summary>
        /// <param name="applicationHealthPolicy">
        /// Defines a health policy used to evaluate the health of an application or one of its children entities.
        /// 
        /// </param>
        /// <param name="forceRestart"> If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data). </param>
        /// <param name="rollingUpgradeMonitoringPolicy"> The policy used for monitoring the application upgrade. </param>
        /// <param name="instanceCloseDelayDurationInSeconds"> Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description. </param>
        /// <param name="upgradeMode"> The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto. </param>
        /// <param name="upgradeReplicaSetCheckTimeout"> The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer). </param>
        /// <param name="recreateApplication"> Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed. </param>
        /// <returns> A new <see cref="Models.ApplicationUpgradePolicy"/> instance for mocking. </returns>
        public static ApplicationUpgradePolicy ApplicationUpgradePolicy(ApplicationHealthPolicy applicationHealthPolicy = null, bool? forceRestart = null, RollingUpgradeMonitoringPolicy rollingUpgradeMonitoringPolicy = null, long? instanceCloseDelayDurationInSeconds = null, RollingUpgradeMode? upgradeMode = null, long? upgradeReplicaSetCheckTimeout = null, bool? recreateApplication = null)
        {
            return new ApplicationUpgradePolicy(applicationHealthPolicy, forceRestart, rollingUpgradeMonitoringPolicy, instanceCloseDelayDurationInSeconds, upgradeMode, upgradeReplicaSetCheckTimeout, recreateApplication);
        }

        /// <summary> Initializes a new instance of ApplicationHealthPolicy. </summary>
        /// <param name="considerWarningAsError"> Indicates whether warnings are treated with the same severity as errors. </param>
        /// <param name="maxPercentUnhealthyDeployedApplications">
        /// The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
        /// The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
        /// This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
        /// The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
        /// 
        /// </param>
        /// <param name="defaultServiceTypeHealthPolicy"> The health policy used by default to evaluate the health of a service type. </param>
        /// <param name="serviceTypeHealthPolicyMap"> The map with service type health policy per service type name. The map is empty by default. </param>
        /// <returns> A new <see cref="Models.ApplicationHealthPolicy"/> instance for mocking. </returns>
        public static ApplicationHealthPolicy ApplicationHealthPolicy(bool considerWarningAsError = default, int maxPercentUnhealthyDeployedApplications = default, ServiceTypeHealthPolicy defaultServiceTypeHealthPolicy = null, IDictionary<string, ServiceTypeHealthPolicy> serviceTypeHealthPolicyMap = null)
        {
            serviceTypeHealthPolicyMap ??= new Dictionary<string, ServiceTypeHealthPolicy>();

            return new ApplicationHealthPolicy(considerWarningAsError, maxPercentUnhealthyDeployedApplications, defaultServiceTypeHealthPolicy, serviceTypeHealthPolicyMap);
        }

        /// <summary> Initializes a new instance of ServiceFabricManagedServiceData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties">
        /// The service resource properties.
        /// Please note <see cref="ManagedServiceProperties"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="StatefulServiceProperties"/> and <see cref="StatelessServiceProperties"/>.
        /// </param>
        /// <returns> A new <see cref="ServiceFabricManagedClusters.ServiceFabricManagedServiceData"/> instance for mocking. </returns>
        public static ServiceFabricManagedServiceData ServiceFabricManagedServiceData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ManagedServiceProperties properties = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ServiceFabricManagedServiceData(id, name, resourceType, systemData, tags, location, properties);
        }

        /// <summary> Initializes a new instance of ManagedServiceProperties. </summary>
        /// <param name="placementConstraints"> The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: &quot;NodeColor == blue)&quot;. </param>
        /// <param name="correlationScheme"> A list that describes the correlation of the service with other services. </param>
        /// <param name="serviceLoadMetrics"> The service load metrics is given as an array of ServiceLoadMetric objects. </param>
        /// <param name="servicePlacementPolicies">
        /// A list that describes the correlation of the service with other services.
        /// Please note <see cref="ManagedServicePlacementPolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ServicePlacementInvalidDomainPolicy"/>, <see cref="ServicePlacementNonPartiallyPlaceServicePolicy"/>, <see cref="ServicePlacementPreferPrimaryDomainPolicy"/>, <see cref="ServicePlacementRequiredDomainPolicy"/> and <see cref="ServicePlacementRequireDomainDistributionPolicy"/>.
        /// </param>
        /// <param name="defaultMoveCost"> Specifies the move cost for the service. </param>
        /// <param name="scalingPolicies"> Scaling policies for this service. </param>
        /// <param name="provisioningState"> The current deployment or provisioning state, which only appears in the response. </param>
        /// <param name="serviceKind"> The kind of service (Stateless or Stateful). </param>
        /// <param name="serviceTypeName"> The name of the service type. </param>
        /// <param name="partitionDescription">
        /// Describes how the service is partitioned.
        /// Please note <see cref="ManagedServicePartitionScheme"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="NamedPartitionScheme"/>, <see cref="SingletonPartitionScheme"/> and <see cref="UniformInt64RangePartitionScheme"/>.
        /// </param>
        /// <param name="servicePackageActivationMode"> The activation Mode of the service package. </param>
        /// <returns> A new <see cref="Models.ManagedServiceProperties"/> instance for mocking. </returns>
        public static ManagedServiceProperties ManagedServiceProperties(string placementConstraints = null, IEnumerable<ManagedServiceCorrelation> correlationScheme = null, IEnumerable<ManagedServiceLoadMetric> serviceLoadMetrics = null, IEnumerable<ManagedServicePlacementPolicy> servicePlacementPolicies = null, ServiceFabricManagedServiceMoveCost? defaultMoveCost = null, IEnumerable<ManagedServiceScalingPolicy> scalingPolicies = null, string provisioningState = null, string serviceKind = null, string serviceTypeName = null, ManagedServicePartitionScheme partitionDescription = null, ManagedServicePackageActivationMode? servicePackageActivationMode = null)
        {
            correlationScheme ??= new List<ManagedServiceCorrelation>();
            serviceLoadMetrics ??= new List<ManagedServiceLoadMetric>();
            servicePlacementPolicies ??= new List<ManagedServicePlacementPolicy>();
            scalingPolicies ??= new List<ManagedServiceScalingPolicy>();

            return new Models.UnknownServiceResourceProperties(placementConstraints, correlationScheme?.ToList(), serviceLoadMetrics?.ToList(), servicePlacementPolicies?.ToList(), defaultMoveCost, scalingPolicies?.ToList(), provisioningState, serviceKind, serviceTypeName, partitionDescription, servicePackageActivationMode);
        }

        /// <summary> Initializes a new instance of ManagedServicePartitionScheme. </summary>
        /// <param name="partitionScheme"> Specifies how the service is partitioned. </param>
        /// <returns> A new <see cref="Models.ManagedServicePartitionScheme"/> instance for mocking. </returns>
        public static ManagedServicePartitionScheme ManagedServicePartitionScheme(string partitionScheme = null)
        {
            return new UnknownPartition(partitionScheme);
        }

        /// <summary> Initializes a new instance of ManagedServiceBaseProperties. </summary>
        /// <param name="placementConstraints"> The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: &quot;NodeColor == blue)&quot;. </param>
        /// <param name="correlationScheme"> A list that describes the correlation of the service with other services. </param>
        /// <param name="serviceLoadMetrics"> The service load metrics is given as an array of ServiceLoadMetric objects. </param>
        /// <param name="servicePlacementPolicies">
        /// A list that describes the correlation of the service with other services.
        /// Please note <see cref="ManagedServicePlacementPolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ServicePlacementInvalidDomainPolicy"/>, <see cref="ServicePlacementNonPartiallyPlaceServicePolicy"/>, <see cref="ServicePlacementPreferPrimaryDomainPolicy"/>, <see cref="ServicePlacementRequiredDomainPolicy"/> and <see cref="ServicePlacementRequireDomainDistributionPolicy"/>.
        /// </param>
        /// <param name="defaultMoveCost"> Specifies the move cost for the service. </param>
        /// <param name="scalingPolicies"> Scaling policies for this service. </param>
        /// <returns> A new <see cref="Models.ManagedServiceBaseProperties"/> instance for mocking. </returns>
        public static ManagedServiceBaseProperties ManagedServiceBaseProperties(string placementConstraints = null, IEnumerable<ManagedServiceCorrelation> correlationScheme = null, IEnumerable<ManagedServiceLoadMetric> serviceLoadMetrics = null, IEnumerable<ManagedServicePlacementPolicy> servicePlacementPolicies = null, ServiceFabricManagedServiceMoveCost? defaultMoveCost = null, IEnumerable<ManagedServiceScalingPolicy> scalingPolicies = null)
        {
            correlationScheme ??= new List<ManagedServiceCorrelation>();
            serviceLoadMetrics ??= new List<ManagedServiceLoadMetric>();
            servicePlacementPolicies ??= new List<ManagedServicePlacementPolicy>();
            scalingPolicies ??= new List<ManagedServiceScalingPolicy>();

            return new ManagedServiceBaseProperties(placementConstraints, correlationScheme?.ToList(), serviceLoadMetrics?.ToList(), servicePlacementPolicies?.ToList(), defaultMoveCost, scalingPolicies?.ToList());
        }

        /// <summary> Initializes a new instance of ManagedServiceLoadMetric. </summary>
        /// <param name="name"> The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive. </param>
        /// <param name="weight"> The service load metric relative weight, compared to other metrics configured for this service, as a number. </param>
        /// <param name="primaryDefaultLoad"> Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica. </param>
        /// <param name="secondaryDefaultLoad"> Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica. </param>
        /// <param name="defaultLoad"> Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric. </param>
        /// <returns> A new <see cref="Models.ManagedServiceLoadMetric"/> instance for mocking. </returns>
        public static ManagedServiceLoadMetric ManagedServiceLoadMetric(string name = null, ManagedServiceLoadMetricWeight? weight = null, int? primaryDefaultLoad = null, int? secondaryDefaultLoad = null, int? defaultLoad = null)
        {
            return new ManagedServiceLoadMetric(name, weight, primaryDefaultLoad, secondaryDefaultLoad, defaultLoad);
        }

        /// <summary> Initializes a new instance of ManagedServicePlacementPolicy. </summary>
        /// <param name="servicePlacementPolicyType"> The type of placement policy for a service fabric service. Following are the possible values. </param>
        /// <returns> A new <see cref="Models.ManagedServicePlacementPolicy"/> instance for mocking. </returns>
        public static ManagedServicePlacementPolicy ManagedServicePlacementPolicy(string servicePlacementPolicyType = null)
        {
            return new UnknownServicePlacementPolicy(servicePlacementPolicyType);
        }

        /// <summary> Initializes a new instance of ManagedServiceScalingMechanism. </summary>
        /// <param name="kind"> Specifies the mechanism associated with this scaling policy. </param>
        /// <returns> A new <see cref="Models.ManagedServiceScalingMechanism"/> instance for mocking. </returns>
        public static ManagedServiceScalingMechanism ManagedServiceScalingMechanism(string kind = null)
        {
            return new UnknownScalingMechanism(kind);
        }

        /// <summary> Initializes a new instance of ManagedServiceScalingTrigger. </summary>
        /// <param name="kind"> Specifies the trigger associated with this scaling policy. </param>
        /// <returns> A new <see cref="Models.ManagedServiceScalingTrigger"/> instance for mocking. </returns>
        public static ManagedServiceScalingTrigger ManagedServiceScalingTrigger(string kind = null)
        {
            return new UnknownScalingTrigger(kind);
        }

        /// <summary> Initializes a new instance of ServiceFabricManagedClusterData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="skuName"> The sku of the managed cluster. </param>
        /// <param name="dnsName"> The cluster dns name. </param>
        /// <param name="fqdn"> The fully qualified domain name associated with the public load balancer of the cluster. </param>
        /// <param name="ipv4Address"> The IPv4 address associated with the public load balancer of the cluster. </param>
        /// <param name="clusterId"> A service generated unique identifier for the cluster resource. </param>
        /// <param name="clusterState"> The current state of the cluster. </param>
        /// <param name="clusterCertificateThumbprints"> List of thumbprints of the cluster certificates. </param>
        /// <param name="clientConnectionPort"> The port used for client connections to the cluster. </param>
        /// <param name="httpGatewayConnectionPort"> The port used for HTTP connections to the cluster. </param>
        /// <param name="adminUserName"> VM admin user name. </param>
        /// <param name="adminPassword"> VM admin user password. </param>
        /// <param name="loadBalancingRules"> Load balancing rules that are applied to the public load balancer of the cluster. </param>
        /// <param name="isRdpAccessAllowed"> Setting this to true enables RDP access to the VM. The default NSG rule opens RDP port to Internet which can be overridden with custom Network Security Rules. The default value for this setting is false. </param>
        /// <param name="networkSecurityRules"> Custom Network Security Rules that are applied to the Virtual Network of the cluster. </param>
        /// <param name="clients"> Client certificates that are allowed to manage the cluster. </param>
        /// <param name="azureActiveDirectory"> The AAD authentication settings of the cluster. </param>
        /// <param name="fabricSettings"> The list of custom fabric settings to configure the cluster. </param>
        /// <param name="provisioningState"> The provisioning state of the managed cluster resource. </param>
        /// <param name="clusterCodeVersion"> The Service Fabric runtime version of the cluster. This property is required when **clusterUpgradeMode** is set to &apos;Manual&apos;. To get list of available Service Fabric versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of available version for existing clusters use **availableClusterVersions**. </param>
        /// <param name="clusterUpgradeMode">
        /// The upgrade mode of the cluster when new Service Fabric runtime version is available.
        /// 
        /// </param>
        /// <param name="clusterUpgradeCadence"> Indicates when new cluster runtime version upgrades will be applied after they are released. By default is Wave0. Only applies when **clusterUpgradeMode** is set to &apos;Automatic&apos;. </param>
        /// <param name="addOnFeatures"> List of add-on features to enable on the cluster. </param>
        /// <param name="isAutoOSUpgradeEnabled"> Setting this to true enables automatic OS upgrade for the node types that are created using any platform OS image with version &apos;latest&apos;. The default value for this setting is false. </param>
        /// <param name="hasZoneResiliency"> Indicates if the cluster has zone resiliency. </param>
        /// <param name="maxUnusedVersionsToKeep"> The policy used to clean up unused versions. </param>
        /// <param name="isIPv6Enabled"> Setting this to true creates IPv6 address space for the default VNet used by the cluster. This setting cannot be changed once the cluster is created. The default value for this setting is false. </param>
        /// <param name="subnetId"> If specified, the node types for the cluster are created in this subnet instead of the default VNet. The **networkSecurityRules** specified for the cluster are also applied to this subnet. This setting cannot be changed once the cluster is created. </param>
        /// <param name="ipTags"> The list of IP tags associated with the default public IP address of the cluster. </param>
        /// <param name="ipv6Address"> IPv6 address for the cluster if IPv6 is enabled. </param>
        /// <param name="isServicePublicIPEnabled"> Setting this to true will link the IPv4 address as the ServicePublicIP of the IPv6 address. It can only be set to True if IPv6 is enabled on the cluster. </param>
        /// <param name="auxiliarySubnets"> Auxiliary subnets for the cluster. </param>
        /// <param name="serviceEndpoints"> Service endpoints for subnets in the cluster. </param>
        /// <param name="etag"> Azure resource etag. </param>
        /// <returns> A new <see cref="ServiceFabricManagedClusters.ServiceFabricManagedClusterData"/> instance for mocking. </returns>
        public static ServiceFabricManagedClusterData ServiceFabricManagedClusterData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ServiceFabricManagedClustersSkuName? skuName = null, string dnsName = null, string fqdn = null, IPAddress ipv4Address = null, Guid? clusterId = null, ServiceFabricManagedClusterState? clusterState = null, IEnumerable<BinaryData> clusterCertificateThumbprints = null, int? clientConnectionPort = null, int? httpGatewayConnectionPort = null, string adminUserName = null, string adminPassword = null, IEnumerable<ManagedClusterLoadBalancingRule> loadBalancingRules = null, bool? isRdpAccessAllowed = null, IEnumerable<ServiceFabricManagedNetworkSecurityRule> networkSecurityRules = null, IEnumerable<ManagedClusterClientCertificate> clients = null, ManagedClusterAzureActiveDirectory azureActiveDirectory = null, IEnumerable<ClusterFabricSettingsSection> fabricSettings = null, ServiceFabricManagedResourceProvisioningState? provisioningState = null, string clusterCodeVersion = null, ManagedClusterUpgradeMode? clusterUpgradeMode = null, ManagedClusterUpgradeCadence? clusterUpgradeCadence = null, IEnumerable<ManagedClusterAddOnFeature> addOnFeatures = null, bool? isAutoOSUpgradeEnabled = null, bool? hasZoneResiliency = null, int? maxUnusedVersionsToKeep = null, bool? isIPv6Enabled = null, string subnetId = null, IEnumerable<ManagedClusterIPTag> ipTags = null, IPAddress ipv6Address = null, bool? isServicePublicIPEnabled = null, IEnumerable<ManagedClusterSubnet> auxiliarySubnets = null, IEnumerable<ManagedClusterServiceEndpoint> serviceEndpoints = null, ETag? etag = null)
        {
            tags ??= new Dictionary<string, string>();
            clusterCertificateThumbprints ??= new List<BinaryData>();
            loadBalancingRules ??= new List<ManagedClusterLoadBalancingRule>();
            networkSecurityRules ??= new List<ServiceFabricManagedNetworkSecurityRule>();
            clients ??= new List<ManagedClusterClientCertificate>();
            fabricSettings ??= new List<ClusterFabricSettingsSection>();
            addOnFeatures ??= new List<ManagedClusterAddOnFeature>();
            ipTags ??= new List<ManagedClusterIPTag>();
            auxiliarySubnets ??= new List<ManagedClusterSubnet>();
            serviceEndpoints ??= new List<ManagedClusterServiceEndpoint>();

            return new ServiceFabricManagedClusterData(id, name, resourceType, systemData, tags, location, skuName.HasValue ? new ServiceFabricManagedClustersSku(skuName.Value) : null, dnsName, fqdn, ipv4Address, clusterId, clusterState, clusterCertificateThumbprints?.ToList(), clientConnectionPort, httpGatewayConnectionPort, adminUserName, adminPassword, loadBalancingRules?.ToList(), isRdpAccessAllowed, networkSecurityRules?.ToList(), clients?.ToList(), azureActiveDirectory, fabricSettings?.ToList(), provisioningState, clusterCodeVersion, clusterUpgradeMode, clusterUpgradeCadence, addOnFeatures?.ToList(), isAutoOSUpgradeEnabled, hasZoneResiliency, maxUnusedVersionsToKeep.HasValue ? new ApplicationTypeVersionsCleanupPolicy(maxUnusedVersionsToKeep.Value) : null, isIPv6Enabled, subnetId, ipTags?.ToList(), ipv6Address, isServicePublicIPEnabled, auxiliarySubnets?.ToList(), serviceEndpoints?.ToList(), etag);
        }

        /// <summary> Initializes a new instance of ManagedClusterLoadBalancingRule. </summary>
        /// <param name="frontendPort"> The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534. </param>
        /// <param name="backendPort"> The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535. </param>
        /// <param name="protocol"> The reference to the transport protocol used by the load balancing rule. </param>
        /// <param name="probePort"> The prob port used by the load balancing rule. Acceptable values are between 1 and 65535. </param>
        /// <param name="probeProtocol"> the reference to the load balancer probe used by the load balancing rule. </param>
        /// <param name="probeRequestPath"> The probe request path. Only supported for HTTP/HTTPS probes. </param>
        /// <param name="loadDistribution"> The load distribution policy for this rule. </param>
        /// <returns> A new <see cref="Models.ManagedClusterLoadBalancingRule"/> instance for mocking. </returns>
        public static ManagedClusterLoadBalancingRule ManagedClusterLoadBalancingRule(int frontendPort = default, int backendPort = default, ManagedClusterLoadBalancingRuleTransportProtocol protocol = default, int? probePort = null, ManagedClusterLoadBalanceProbeProtocol probeProtocol = default, string probeRequestPath = null, string loadDistribution = null)
        {
            return new ManagedClusterLoadBalancingRule(frontendPort, backendPort, protocol, probePort, probeProtocol, probeRequestPath, loadDistribution);
        }

        /// <summary> Initializes a new instance of ServiceFabricManagedNetworkSecurityRule. </summary>
        /// <param name="name"> Network security rule name. </param>
        /// <param name="description"> Network security rule description. </param>
        /// <param name="protocol"> Network protocol this rule applies to. </param>
        /// <param name="sourceAddressPrefixes"> The CIDR or source IP ranges. </param>
        /// <param name="destinationAddressPrefixes"> The destination address prefixes. CIDR or destination IP ranges. </param>
        /// <param name="sourcePortRanges"> The source port ranges. </param>
        /// <param name="destinationPortRanges"> The destination port ranges. </param>
        /// <param name="sourceAddressPrefix"> The CIDR or source IP range. Asterisk &apos;*&apos; can also be used to match all source IPs. Default tags such as &apos;VirtualNetwork&apos;, &apos;AzureLoadBalancer&apos; and &apos;Internet&apos; can also be used. If this is an ingress rule, specifies where network traffic originates from. </param>
        /// <param name="destinationAddressPrefix"> The destination address prefix. CIDR or destination IP range. Asterisk &apos;*&apos; can also be used to match all source IPs. Default tags such as &apos;VirtualNetwork&apos;, &apos;AzureLoadBalancer&apos; and &apos;Internet&apos; can also be used. </param>
        /// <param name="sourcePortRange"> The source port or range. Integer or range between 0 and 65535. Asterisk &apos;*&apos; can also be used to match all ports. </param>
        /// <param name="destinationPortRange"> he destination port or range. Integer or range between 0 and 65535. Asterisk &apos;*&apos; can also be used to match all ports. </param>
        /// <param name="access"> The network traffic is allowed or denied. </param>
        /// <param name="priority"> The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule. </param>
        /// <param name="direction"> Network security rule direction. </param>
        /// <returns> A new <see cref="Models.ServiceFabricManagedNetworkSecurityRule"/> instance for mocking. </returns>
        public static ServiceFabricManagedNetworkSecurityRule ServiceFabricManagedNetworkSecurityRule(string name = null, string description = null, ServiceFabricManagedNsgProtocol protocol = default, IEnumerable<string> sourceAddressPrefixes = null, IEnumerable<string> destinationAddressPrefixes = null, IEnumerable<string> sourcePortRanges = null, IEnumerable<string> destinationPortRanges = null, string sourceAddressPrefix = null, string destinationAddressPrefix = null, string sourcePortRange = null, string destinationPortRange = null, ServiceFabricManagedNetworkTrafficAccess access = default, int priority = default, ServiceFabricManagedNetworkSecurityRuleDirection direction = default)
        {
            sourceAddressPrefixes ??= new List<string>();
            destinationAddressPrefixes ??= new List<string>();
            sourcePortRanges ??= new List<string>();
            destinationPortRanges ??= new List<string>();

            return new ServiceFabricManagedNetworkSecurityRule(name, description, protocol, sourceAddressPrefixes?.ToList(), destinationAddressPrefixes?.ToList(), sourcePortRanges?.ToList(), destinationPortRanges?.ToList(), sourceAddressPrefix, destinationAddressPrefix, sourcePortRange, destinationPortRange, access, priority, direction);
        }

        /// <summary> Initializes a new instance of ManagedClusterClientCertificate. </summary>
        /// <param name="isAdmin"> Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster. </param>
        /// <param name="thumbprint"> Certificate thumbprint. </param>
        /// <param name="commonName"> Certificate common name. </param>
        /// <param name="issuerThumbprint"> Issuer thumbprint for the certificate. Only used together with CommonName. </param>
        /// <returns> A new <see cref="Models.ManagedClusterClientCertificate"/> instance for mocking. </returns>
        public static ManagedClusterClientCertificate ManagedClusterClientCertificate(bool isAdmin = default, BinaryData thumbprint = null, string commonName = null, BinaryData issuerThumbprint = null)
        {
            return new ManagedClusterClientCertificate(isAdmin, thumbprint, commonName, issuerThumbprint);
        }

        /// <summary> Initializes a new instance of ManagedClusterAzureActiveDirectory. </summary>
        /// <param name="tenantId"> Azure active directory tenant id. </param>
        /// <param name="clusterApplication"> Azure active directory cluster application id. </param>
        /// <param name="clientApplication"> Azure active directory client application id. </param>
        /// <returns> A new <see cref="Models.ManagedClusterAzureActiveDirectory"/> instance for mocking. </returns>
        public static ManagedClusterAzureActiveDirectory ManagedClusterAzureActiveDirectory(Guid? tenantId = null, string clusterApplication = null, string clientApplication = null)
        {
            return new ManagedClusterAzureActiveDirectory(tenantId, clusterApplication, clientApplication);
        }

        /// <summary> Initializes a new instance of ManagedClusterSubnet. </summary>
        /// <param name="name"> Subnet name. </param>
        /// <param name="isIPv6Enabled"> Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster. </param>
        /// <param name="privateEndpointNetworkPolicies"> Enable or Disable apply network policies on private end point in the subnet. </param>
        /// <param name="privateLinkServiceNetworkPolicies"> Enable or Disable apply network policies on private link service in the subnet. </param>
        /// <param name="networkSecurityGroupId"> Full resource id for the network security group. </param>
        /// <returns> A new <see cref="Models.ManagedClusterSubnet"/> instance for mocking. </returns>
        public static ManagedClusterSubnet ManagedClusterSubnet(string name = null, bool? isIPv6Enabled = null, ManagedClusterSubnetPrivateEndpointNetworkPoliciesState? privateEndpointNetworkPolicies = null, ManagedClusterSubnetPrivateLinkServiceNetworkPoliciesState? privateLinkServiceNetworkPolicies = null, ResourceIdentifier networkSecurityGroupId = null)
        {
            return new ManagedClusterSubnet(name, isIPv6Enabled, privateEndpointNetworkPolicies, privateLinkServiceNetworkPolicies, networkSecurityGroupId);
        }

        /// <summary> Initializes a new instance of ManagedClusterServiceEndpoint. </summary>
        /// <param name="service"> The type of the endpoint service. </param>
        /// <param name="locations"> A list of locations. </param>
        /// <returns> A new <see cref="Models.ManagedClusterServiceEndpoint"/> instance for mocking. </returns>
        public static ManagedClusterServiceEndpoint ManagedClusterServiceEndpoint(string service = null, IEnumerable<AzureLocation> locations = null)
        {
            locations ??= new List<AzureLocation>();

            return new ManagedClusterServiceEndpoint(service, locations?.ToList());
        }

        /// <summary> Initializes a new instance of ServiceFabricManagedClusterVersion. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="clusterCodeVersion"> The Service Fabric runtime version of the cluster. </param>
        /// <param name="versionSupportExpireOn"> The date of expiry of support of the version. </param>
        /// <param name="osType"> Cluster operating system, the default will be Windows. </param>
        /// <returns> A new <see cref="Models.ServiceFabricManagedClusterVersion"/> instance for mocking. </returns>
        public static ServiceFabricManagedClusterVersion ServiceFabricManagedClusterVersion(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string clusterCodeVersion = null, DateTimeOffset? versionSupportExpireOn = null, ServiceFabricManagedClusterOSType? osType = null)
        {
            return new ServiceFabricManagedClusterVersion(id, name, resourceType, systemData, clusterCodeVersion, versionSupportExpireOn, osType);
        }

        /// <summary> Initializes a new instance of ServiceFabricManagedUnsupportedVmSize. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="vmSize"> VM Size properties. </param>
        /// <returns> A new <see cref="Models.ServiceFabricManagedUnsupportedVmSize"/> instance for mocking. </returns>
        public static ServiceFabricManagedUnsupportedVmSize ServiceFabricManagedUnsupportedVmSize(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string vmSize = null)
        {
            return new ServiceFabricManagedUnsupportedVmSize(id, name, resourceType, systemData, vmSize != null ? new VmSize(vmSize) : null);
        }

        /// <summary> Initializes a new instance of ServiceFabricManagedNodeTypeData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="sku"> The node type sku. </param>
        /// <param name="isPrimary"> Indicates the Service Fabric system services for the cluster will run on this node type. This setting cannot be changed once the node type is created. </param>
        /// <param name="vmInstanceCount"> The number of nodes in the node type. &lt;br /&gt;&lt;br /&gt;**Values:** &lt;br /&gt;-1 - Use when auto scale rules are configured or sku.capacity is defined &lt;br /&gt; 0 - Not supported &lt;br /&gt; &gt;0 - Use for manual scale. </param>
        /// <param name="dataDiskSizeInGB"> Disk size for the managed disk attached to the vms on the node type in GBs. </param>
        /// <param name="dataDiskType"> Managed data disk type. Specifies the storage account type for the managed disk. </param>
        /// <param name="dataDiskLetter"> Managed data disk letter. It can not use the reserved letter C or D and it can not change after created. </param>
        /// <param name="placementProperties"> The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run. </param>
        /// <param name="capacities"> The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has. </param>
        /// <param name="applicationPorts"> The range of ports from which cluster assigned port to Service Fabric applications. </param>
        /// <param name="ephemeralPorts"> The range of ephemeral ports that nodes in this node type should be configured with. </param>
        /// <param name="vmSize"> The size of virtual machines in the pool. All virtual machines in a pool are the same size. For example, Standard_D3. </param>
        /// <param name="vmImagePublisher"> The publisher of the Azure Virtual Machines Marketplace image. For example, Canonical or MicrosoftWindowsServer. </param>
        /// <param name="vmImageOffer"> The offer type of the Azure Virtual Machines Marketplace image. For example, UbuntuServer or WindowsServer. </param>
        /// <param name="vmImageSku"> The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or 2012-R2-Datacenter. </param>
        /// <param name="vmImageVersion"> The version of the Azure Virtual Machines Marketplace image. A value of &apos;latest&apos; can be specified to select the latest version of an image. If omitted, the default is &apos;latest&apos;. </param>
        /// <param name="vmSecrets"> The secrets to install in the virtual machines. </param>
        /// <param name="vmExtensions"> Set of extensions that should be installed onto the virtual machines. </param>
        /// <param name="userAssignedIdentities"> Identities to assign to the virtual machine scale set under the node type. </param>
        /// <param name="isStateless"> Indicates if the node type can only host Stateless workloads. </param>
        /// <param name="hasMultiplePlacementGroups"> Indicates if scale set associated with the node type can be composed of multiple placement groups. </param>
        /// <param name="frontendConfigurations"> Indicates the node type uses its own frontend configurations instead of the default one for the cluster. This setting can only be specified for non-primary node types and can not be added or removed after the node type is created. </param>
        /// <param name="networkSecurityRules"> The Network Security Rules for this node type. This setting can only be specified for node types that are configured with frontend configurations. </param>
        /// <param name="additionalDataDisks"> Additional managed data disks. </param>
        /// <param name="isEncryptionAtHostEnabled"> Enable or disable the Host Encryption for the virtual machines on the node type. This will enable the encryption for all the disks including Resource/Temp disk at host itself. Default: The Encryption at host will be disabled unless this property is set to true for the resource. </param>
        /// <param name="provisioningState"> The provisioning state of the node type resource. </param>
        /// <param name="isAcceleratedNetworkingEnabled"> Specifies whether the network interface is accelerated networking-enabled. </param>
        /// <param name="useDefaultPublicLoadBalancer"> Specifies whether the use public load balancer. If not specified and the node type doesn&apos;t have its own frontend configuration, it will be attached to the default load balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is true, then the frontend has to be an Internal Load Balancer. If the node type uses its own Load balancer and useDefaultPublicLoadBalancer is false or not set, then the custom load balancer must include a public load balancer to provide outbound connectivity. </param>
        /// <param name="useTempDataDisk"> Specifies whether to use the temporary disk for the service fabric data root, in which case no managed data disk will be attached and the temporary disk will be used. It is only allowed for stateless node types. </param>
        /// <param name="isOverProvisioningEnabled"> Specifies whether the node type should be overprovisioned. It is only allowed for stateless node types. </param>
        /// <param name="tags"> Azure resource tags. </param>
        /// <returns> A new <see cref="ServiceFabricManagedClusters.ServiceFabricManagedNodeTypeData"/> instance for mocking. </returns>
        public static ServiceFabricManagedNodeTypeData ServiceFabricManagedNodeTypeData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, NodeTypeSku sku = null, bool? isPrimary = null, int? vmInstanceCount = null, int? dataDiskSizeInGB = null, ServiceFabricManagedDataDiskType? dataDiskType = null, string dataDiskLetter = null, IDictionary<string, string> placementProperties = null, IDictionary<string, string> capacities = null, EndpointRangeDescription applicationPorts = null, EndpointRangeDescription ephemeralPorts = null, string vmSize = null, string vmImagePublisher = null, string vmImageOffer = null, string vmImageSku = null, string vmImageVersion = null, IEnumerable<NodeTypeVaultSecretGroup> vmSecrets = null, IEnumerable<NodeTypeVmssExtension> vmExtensions = null, IEnumerable<ResourceIdentifier> userAssignedIdentities = null, bool? isStateless = null, bool? hasMultiplePlacementGroups = null, IEnumerable<NodeTypeFrontendConfiguration> frontendConfigurations = null, IEnumerable<ServiceFabricManagedNetworkSecurityRule> networkSecurityRules = null, IEnumerable<NodeTypeVmssDataDisk> additionalDataDisks = null, bool? isEncryptionAtHostEnabled = null, ServiceFabricManagedResourceProvisioningState? provisioningState = null, bool? isAcceleratedNetworkingEnabled = null, bool? useDefaultPublicLoadBalancer = null, bool? useTempDataDisk = null, bool? isOverProvisioningEnabled = null, IDictionary<string, string> tags = null)
        {
            placementProperties ??= new Dictionary<string, string>();
            capacities ??= new Dictionary<string, string>();
            vmSecrets ??= new List<NodeTypeVaultSecretGroup>();
            vmExtensions ??= new List<NodeTypeVmssExtension>();
            userAssignedIdentities ??= new List<ResourceIdentifier>();
            frontendConfigurations ??= new List<NodeTypeFrontendConfiguration>();
            networkSecurityRules ??= new List<ServiceFabricManagedNetworkSecurityRule>();
            additionalDataDisks ??= new List<NodeTypeVmssDataDisk>();
            tags ??= new Dictionary<string, string>();

            return new ServiceFabricManagedNodeTypeData(id, name, resourceType, systemData, sku, isPrimary, vmInstanceCount, dataDiskSizeInGB, dataDiskType, dataDiskLetter, placementProperties, capacities, applicationPorts, ephemeralPorts, vmSize, vmImagePublisher, vmImageOffer, vmImageSku, vmImageVersion, vmSecrets?.ToList(), vmExtensions?.ToList(), userAssignedIdentities != null ? new VmManagedIdentity(userAssignedIdentities?.ToList()) : null, isStateless, hasMultiplePlacementGroups, frontendConfigurations?.ToList(), networkSecurityRules?.ToList(), additionalDataDisks?.ToList(), isEncryptionAtHostEnabled, provisioningState, isAcceleratedNetworkingEnabled, useDefaultPublicLoadBalancer, useTempDataDisk, isOverProvisioningEnabled, tags);
        }

        /// <summary> Initializes a new instance of NodeTypeVmssExtension. </summary>
        /// <param name="name"> The name of the extension. </param>
        /// <param name="publisher"> The name of the extension handler publisher. </param>
        /// <param name="vmssExtensionPropertiesType"> Specifies the type of the extension; an example is &quot;CustomScriptExtension&quot;. </param>
        /// <param name="typeHandlerVersion"> Specifies the version of the script handler. </param>
        /// <param name="autoUpgradeMinorVersion"> Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true. </param>
        /// <param name="settings"> Json formatted public settings for the extension. </param>
        /// <param name="protectedSettings"> The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all. </param>
        /// <param name="forceUpdateTag"> If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed. </param>
        /// <param name="provisionAfterExtensions"> Collection of extension names after which this extension needs to be provisioned. </param>
        /// <param name="provisioningState"> The provisioning state, which only appears in the response. </param>
        /// <param name="isAutomaticUpgradeEnabled"> Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available. </param>
        /// <returns> A new <see cref="Models.NodeTypeVmssExtension"/> instance for mocking. </returns>
        public static NodeTypeVmssExtension NodeTypeVmssExtension(string name = null, string publisher = null, string vmssExtensionPropertiesType = null, string typeHandlerVersion = null, bool? autoUpgradeMinorVersion = null, BinaryData settings = null, BinaryData protectedSettings = null, string forceUpdateTag = null, IEnumerable<string> provisionAfterExtensions = null, string provisioningState = null, bool? isAutomaticUpgradeEnabled = null)
        {
            provisionAfterExtensions ??= new List<string>();

            return new NodeTypeVmssExtension(name, publisher, vmssExtensionPropertiesType, typeHandlerVersion, autoUpgradeMinorVersion, settings, protectedSettings, forceUpdateTag, provisionAfterExtensions?.ToList(), provisioningState, isAutomaticUpgradeEnabled);
        }

        /// <summary> Initializes a new instance of NodeTypeFrontendConfiguration. </summary>
        /// <param name="ipAddressType"> The IP address type of this frontend configuration. If omitted the default value is IPv4. </param>
        /// <param name="loadBalancerBackendAddressPoolId"> The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is &apos;/subscriptions/&lt;subscriptionId&gt;/resourceGroups/&lt;resourceGroupName&gt;/providers/Microsoft.Network/loadBalancers/&lt;loadBalancerName&gt;/backendAddressPools/&lt;backendAddressPoolName&gt;&apos;. </param>
        /// <param name="loadBalancerInboundNatPoolId"> The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is &apos;/subscriptions/&lt;subscriptionId&gt;/resourceGroups/&lt;resourceGroupName&gt;/providers/Microsoft.Network/loadBalancers/&lt;loadBalancerName&gt;/inboundNatPools/&lt;inboundNatPoolName&gt;&apos;. </param>
        /// <returns> A new <see cref="Models.NodeTypeFrontendConfiguration"/> instance for mocking. </returns>
        public static NodeTypeFrontendConfiguration NodeTypeFrontendConfiguration(NodeTypeFrontendConfigurationIPAddressType? ipAddressType = null, ResourceIdentifier loadBalancerBackendAddressPoolId = null, ResourceIdentifier loadBalancerInboundNatPoolId = null)
        {
            return new NodeTypeFrontendConfiguration(ipAddressType, loadBalancerBackendAddressPoolId, loadBalancerInboundNatPoolId);
        }

        /// <summary> Initializes a new instance of NodeTypeSku. </summary>
        /// <param name="name"> The sku name. &lt;br /&gt;&lt;br /&gt;Name is internally generated and is used in auto-scale scenarios.&lt;br /&gt; Property does not allow to be changed to other values than generated.&lt;br /&gt; To avoid deployment errors please omit the property. </param>
        /// <param name="tier"> Specifies the tier of the node type. &lt;br /&gt;&lt;br /&gt; Possible Values:&lt;br /&gt; **Standard**. </param>
        /// <param name="capacity"> The number of nodes in the node type.&lt;br /&gt;&lt;br /&gt;If present in request it will override properties.vmInstanceCount. </param>
        /// <returns> A new <see cref="Models.NodeTypeSku"/> instance for mocking. </returns>
        public static NodeTypeSku NodeTypeSku(string name = null, string tier = null, int capacity = default)
        {
            return new NodeTypeSku(name, tier, capacity);
        }

        /// <summary> Initializes a new instance of NodeTypeAvailableSku. </summary>
        /// <param name="resourceType"> The type of resource the sku applies to.  &lt;br /&gt;&lt;br /&gt;Value: Microsoft.ServiceFabric/managedClusters/nodeTypes. </param>
        /// <param name="sku"> The supported SKU for a for node type. </param>
        /// <param name="capacity"> Provides information about how the node count can be scaled. </param>
        /// <returns> A new <see cref="Models.NodeTypeAvailableSku"/> instance for mocking. </returns>
        public static NodeTypeAvailableSku NodeTypeAvailableSku(ResourceType? resourceType = null, NodeTypeSupportedSku sku = null, NodeTypeSkuCapacity capacity = null)
        {
            return new NodeTypeAvailableSku(resourceType, sku, capacity);
        }

        /// <summary> Initializes a new instance of NodeTypeSupportedSku. </summary>
        /// <param name="name"> The sku name. </param>
        /// <param name="tier"> Specifies the tier of the node type. &lt;br /&gt;&lt;br /&gt; Possible Values:&lt;br /&gt; **Standard**. </param>
        /// <returns> A new <see cref="Models.NodeTypeSupportedSku"/> instance for mocking. </returns>
        public static NodeTypeSupportedSku NodeTypeSupportedSku(string name = null, string tier = null)
        {
            return new NodeTypeSupportedSku(name, tier);
        }

        /// <summary> Initializes a new instance of NodeTypeSkuCapacity. </summary>
        /// <param name="minimum"> Lowest permitted node count in a node type. </param>
        /// <param name="maximum"> Highest permitted node count in a node type. </param>
        /// <param name="default"> Default node count in a node type. </param>
        /// <param name="scaleType"> Node type capacity scale type. </param>
        /// <returns> A new <see cref="Models.NodeTypeSkuCapacity"/> instance for mocking. </returns>
        public static NodeTypeSkuCapacity NodeTypeSkuCapacity(int? minimum = null, int? maximum = null, int? @default = null, NodeTypeSkuScaleType? scaleType = null)
        {
            return new NodeTypeSkuCapacity(minimum, maximum, @default, scaleType);
        }

        /// <summary> Initializes a new instance of NamedPartitionAddOrRemoveScalingMechanism. </summary>
        /// <param name="minPartitionCount"> Minimum number of named partitions of the service. </param>
        /// <param name="maxPartitionCount"> Maximum number of named partitions of the service. </param>
        /// <param name="scaleIncrement"> The number of instances to add or remove during a scaling operation. </param>
        /// <returns> A new <see cref="Models.NamedPartitionAddOrRemoveScalingMechanism"/> instance for mocking. </returns>
        public static NamedPartitionAddOrRemoveScalingMechanism NamedPartitionAddOrRemoveScalingMechanism(int minPartitionCount = default, int maxPartitionCount = default, int scaleIncrement = default)
        {
            return new NamedPartitionAddOrRemoveScalingMechanism("AddRemoveIncrementalNamedPartition", minPartitionCount, maxPartitionCount, scaleIncrement);
        }

        /// <summary> Initializes a new instance of AveragePartitionLoadScalingTrigger. </summary>
        /// <param name="metricName"> The name of the metric for which usage should be tracked. </param>
        /// <param name="lowerLoadThreshold"> The lower limit of the load below which a scale in operation should be performed. </param>
        /// <param name="upperLoadThreshold"> The upper limit of the load beyond which a scale out operation should be performed. </param>
        /// <param name="scaleInterval"> The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format &quot;hh:mm:ss&quot;. </param>
        /// <returns> A new <see cref="Models.AveragePartitionLoadScalingTrigger"/> instance for mocking. </returns>
        public static AveragePartitionLoadScalingTrigger AveragePartitionLoadScalingTrigger(string metricName = null, double lowerLoadThreshold = default, double upperLoadThreshold = default, string scaleInterval = null)
        {
            return new AveragePartitionLoadScalingTrigger("AveragePartitionLoadTrigger", metricName, lowerLoadThreshold, upperLoadThreshold, scaleInterval);
        }

        /// <summary> Initializes a new instance of AverageServiceLoadScalingTrigger. </summary>
        /// <param name="metricName"> The name of the metric for which usage should be tracked. </param>
        /// <param name="lowerLoadThreshold"> The lower limit of the load below which a scale in operation should be performed. </param>
        /// <param name="upperLoadThreshold"> The upper limit of the load beyond which a scale out operation should be performed. </param>
        /// <param name="scaleInterval"> The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format &quot;hh:mm:ss&quot;. </param>
        /// <param name="useOnlyPrimaryLoad"> Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service. </param>
        /// <returns> A new <see cref="Models.AverageServiceLoadScalingTrigger"/> instance for mocking. </returns>
        public static AverageServiceLoadScalingTrigger AverageServiceLoadScalingTrigger(string metricName = null, double lowerLoadThreshold = default, double upperLoadThreshold = default, string scaleInterval = null, bool useOnlyPrimaryLoad = default)
        {
            return new AverageServiceLoadScalingTrigger("AverageServiceLoadTrigger", metricName, lowerLoadThreshold, upperLoadThreshold, scaleInterval, useOnlyPrimaryLoad);
        }

        /// <summary> Initializes a new instance of NamedPartitionScheme. </summary>
        /// <param name="names"> Array for the names of the partitions. </param>
        /// <returns> A new <see cref="Models.NamedPartitionScheme"/> instance for mocking. </returns>
        public static NamedPartitionScheme NamedPartitionScheme(IEnumerable<string> names = null)
        {
            names ??= new List<string>();

            return new NamedPartitionScheme("Named", names?.ToList());
        }

        /// <summary> Initializes a new instance of PartitionInstanceCountScalingMechanism. </summary>
        /// <param name="minInstanceCount"> Minimum number of instances of the partition. </param>
        /// <param name="maxInstanceCount"> Maximum number of instances of the partition. </param>
        /// <param name="scaleIncrement"> The number of instances to add or remove during a scaling operation. </param>
        /// <returns> A new <see cref="Models.PartitionInstanceCountScalingMechanism"/> instance for mocking. </returns>
        public static PartitionInstanceCountScalingMechanism PartitionInstanceCountScalingMechanism(int minInstanceCount = default, int maxInstanceCount = default, int scaleIncrement = default)
        {
            return new PartitionInstanceCountScalingMechanism("ScalePartitionInstanceCount", minInstanceCount, maxInstanceCount, scaleIncrement);
        }

        /// <summary> Initializes a new instance of ServicePlacementInvalidDomainPolicy. </summary>
        /// <param name="domainName"> The name of the domain that should not be used for placement. </param>
        /// <returns> A new <see cref="Models.ServicePlacementInvalidDomainPolicy"/> instance for mocking. </returns>
        public static ServicePlacementInvalidDomainPolicy ServicePlacementInvalidDomainPolicy(string domainName = null)
        {
            return new ServicePlacementInvalidDomainPolicy("InvalidDomain", domainName);
        }

        /// <summary> Initializes a new instance of ServicePlacementNonPartiallyPlaceServicePolicy. </summary>
        /// <returns> A new <see cref="Models.ServicePlacementNonPartiallyPlaceServicePolicy"/> instance for mocking. </returns>
        public static ServicePlacementNonPartiallyPlaceServicePolicy ServicePlacementNonPartiallyPlaceServicePolicy()
        {
            return new ServicePlacementNonPartiallyPlaceServicePolicy("NonPartiallyPlaceService");
        }

        /// <summary> Initializes a new instance of ServicePlacementPreferPrimaryDomainPolicy. </summary>
        /// <param name="domainName"> The name of the domain that should used for placement as per this policy. </param>
        /// <returns> A new <see cref="Models.ServicePlacementPreferPrimaryDomainPolicy"/> instance for mocking. </returns>
        public static ServicePlacementPreferPrimaryDomainPolicy ServicePlacementPreferPrimaryDomainPolicy(string domainName = null)
        {
            return new ServicePlacementPreferPrimaryDomainPolicy("PreferredPrimaryDomain", domainName);
        }

        /// <summary> Initializes a new instance of ServicePlacementRequiredDomainPolicy. </summary>
        /// <param name="domainName"> The name of the domain that should used for placement as per this policy. </param>
        /// <returns> A new <see cref="Models.ServicePlacementRequiredDomainPolicy"/> instance for mocking. </returns>
        public static ServicePlacementRequiredDomainPolicy ServicePlacementRequiredDomainPolicy(string domainName = null)
        {
            return new ServicePlacementRequiredDomainPolicy("RequiredDomain", domainName);
        }

        /// <summary> Initializes a new instance of ServicePlacementRequireDomainDistributionPolicy. </summary>
        /// <param name="domainName"> The name of the domain that should used for placement as per this policy. </param>
        /// <returns> A new <see cref="Models.ServicePlacementRequireDomainDistributionPolicy"/> instance for mocking. </returns>
        public static ServicePlacementRequireDomainDistributionPolicy ServicePlacementRequireDomainDistributionPolicy(string domainName = null)
        {
            return new ServicePlacementRequireDomainDistributionPolicy("RequiredDomainDistribution", domainName);
        }

        /// <summary> Initializes a new instance of SingletonPartitionScheme. </summary>
        /// <returns> A new <see cref="Models.SingletonPartitionScheme"/> instance for mocking. </returns>
        public static SingletonPartitionScheme SingletonPartitionScheme()
        {
            return new SingletonPartitionScheme("Singleton");
        }

        /// <summary> Initializes a new instance of StatefulServiceProperties. </summary>
        /// <param name="placementConstraints"> The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: &quot;NodeColor == blue)&quot;. </param>
        /// <param name="correlationScheme"> A list that describes the correlation of the service with other services. </param>
        /// <param name="serviceLoadMetrics"> The service load metrics is given as an array of ServiceLoadMetric objects. </param>
        /// <param name="servicePlacementPolicies">
        /// A list that describes the correlation of the service with other services.
        /// Please note <see cref="ManagedServicePlacementPolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ServicePlacementInvalidDomainPolicy"/>, <see cref="ServicePlacementNonPartiallyPlaceServicePolicy"/>, <see cref="ServicePlacementPreferPrimaryDomainPolicy"/>, <see cref="ServicePlacementRequiredDomainPolicy"/> and <see cref="ServicePlacementRequireDomainDistributionPolicy"/>.
        /// </param>
        /// <param name="defaultMoveCost"> Specifies the move cost for the service. </param>
        /// <param name="scalingPolicies"> Scaling policies for this service. </param>
        /// <param name="provisioningState"> The current deployment or provisioning state, which only appears in the response. </param>
        /// <param name="serviceTypeName"> The name of the service type. </param>
        /// <param name="partitionDescription">
        /// Describes how the service is partitioned.
        /// Please note <see cref="ManagedServicePartitionScheme"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="NamedPartitionScheme"/>, <see cref="SingletonPartitionScheme"/> and <see cref="UniformInt64RangePartitionScheme"/>.
        /// </param>
        /// <param name="servicePackageActivationMode"> The activation Mode of the service package. </param>
        /// <param name="hasPersistedState"> A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false. </param>
        /// <param name="targetReplicaSetSize"> The target replica set size as a number. </param>
        /// <param name="minReplicaSetSize"> The minimum replica set size as a number. </param>
        /// <param name="replicaRestartWaitDuration"> The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format &quot;hh:mm:ss&quot;. </param>
        /// <param name="quorumLossWaitDuration"> The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format &quot;hh:mm:ss&quot;. </param>
        /// <param name="standByReplicaKeepDuration"> The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format &quot;hh:mm:ss&quot;. </param>
        /// <param name="servicePlacementTimeLimit"> The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format &quot;hh:mm:ss&quot;. </param>
        /// <returns> A new <see cref="Models.StatefulServiceProperties"/> instance for mocking. </returns>
        public static StatefulServiceProperties StatefulServiceProperties(string placementConstraints = null, IEnumerable<ManagedServiceCorrelation> correlationScheme = null, IEnumerable<ManagedServiceLoadMetric> serviceLoadMetrics = null, IEnumerable<ManagedServicePlacementPolicy> servicePlacementPolicies = null, ServiceFabricManagedServiceMoveCost? defaultMoveCost = null, IEnumerable<ManagedServiceScalingPolicy> scalingPolicies = null, string provisioningState = null, string serviceTypeName = null, ManagedServicePartitionScheme partitionDescription = null, ManagedServicePackageActivationMode? servicePackageActivationMode = null, bool? hasPersistedState = null, int? targetReplicaSetSize = null, int? minReplicaSetSize = null, TimeSpan? replicaRestartWaitDuration = null, TimeSpan? quorumLossWaitDuration = null, TimeSpan? standByReplicaKeepDuration = null, TimeSpan? servicePlacementTimeLimit = null)
        {
            correlationScheme ??= new List<ManagedServiceCorrelation>();
            serviceLoadMetrics ??= new List<ManagedServiceLoadMetric>();
            servicePlacementPolicies ??= new List<ManagedServicePlacementPolicy>();
            scalingPolicies ??= new List<ManagedServiceScalingPolicy>();

            return new StatefulServiceProperties(placementConstraints, correlationScheme?.ToList(), serviceLoadMetrics?.ToList(), servicePlacementPolicies?.ToList(), defaultMoveCost, scalingPolicies?.ToList(), provisioningState, "Stateful", serviceTypeName, partitionDescription, servicePackageActivationMode, hasPersistedState, targetReplicaSetSize, minReplicaSetSize, replicaRestartWaitDuration, quorumLossWaitDuration, standByReplicaKeepDuration, servicePlacementTimeLimit);
        }

        /// <summary> Initializes a new instance of StatelessServiceProperties. </summary>
        /// <param name="placementConstraints"> The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: &quot;NodeColor == blue)&quot;. </param>
        /// <param name="correlationScheme"> A list that describes the correlation of the service with other services. </param>
        /// <param name="serviceLoadMetrics"> The service load metrics is given as an array of ServiceLoadMetric objects. </param>
        /// <param name="servicePlacementPolicies">
        /// A list that describes the correlation of the service with other services.
        /// Please note <see cref="ManagedServicePlacementPolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ServicePlacementInvalidDomainPolicy"/>, <see cref="ServicePlacementNonPartiallyPlaceServicePolicy"/>, <see cref="ServicePlacementPreferPrimaryDomainPolicy"/>, <see cref="ServicePlacementRequiredDomainPolicy"/> and <see cref="ServicePlacementRequireDomainDistributionPolicy"/>.
        /// </param>
        /// <param name="defaultMoveCost"> Specifies the move cost for the service. </param>
        /// <param name="scalingPolicies"> Scaling policies for this service. </param>
        /// <param name="provisioningState"> The current deployment or provisioning state, which only appears in the response. </param>
        /// <param name="serviceTypeName"> The name of the service type. </param>
        /// <param name="partitionDescription">
        /// Describes how the service is partitioned.
        /// Please note <see cref="ManagedServicePartitionScheme"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="NamedPartitionScheme"/>, <see cref="SingletonPartitionScheme"/> and <see cref="UniformInt64RangePartitionScheme"/>.
        /// </param>
        /// <param name="servicePackageActivationMode"> The activation Mode of the service package. </param>
        /// <param name="instanceCount"> The instance count. </param>
        /// <param name="minInstanceCount"> MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service. </param>
        /// <param name="minInstancePercentage"> MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service. </param>
        /// <returns> A new <see cref="Models.StatelessServiceProperties"/> instance for mocking. </returns>
        public static StatelessServiceProperties StatelessServiceProperties(string placementConstraints = null, IEnumerable<ManagedServiceCorrelation> correlationScheme = null, IEnumerable<ManagedServiceLoadMetric> serviceLoadMetrics = null, IEnumerable<ManagedServicePlacementPolicy> servicePlacementPolicies = null, ServiceFabricManagedServiceMoveCost? defaultMoveCost = null, IEnumerable<ManagedServiceScalingPolicy> scalingPolicies = null, string provisioningState = null, string serviceTypeName = null, ManagedServicePartitionScheme partitionDescription = null, ManagedServicePackageActivationMode? servicePackageActivationMode = null, int instanceCount = default, int? minInstanceCount = null, int? minInstancePercentage = null)
        {
            correlationScheme ??= new List<ManagedServiceCorrelation>();
            serviceLoadMetrics ??= new List<ManagedServiceLoadMetric>();
            servicePlacementPolicies ??= new List<ManagedServicePlacementPolicy>();
            scalingPolicies ??= new List<ManagedServiceScalingPolicy>();

            return new StatelessServiceProperties(placementConstraints, correlationScheme?.ToList(), serviceLoadMetrics?.ToList(), servicePlacementPolicies?.ToList(), defaultMoveCost, scalingPolicies?.ToList(), provisioningState, "Stateless", serviceTypeName, partitionDescription, servicePackageActivationMode, instanceCount, minInstanceCount, minInstancePercentage);
        }

        /// <summary> Initializes a new instance of UniformInt64RangePartitionScheme. </summary>
        /// <param name="count"> The number of partitions. </param>
        /// <param name="lowKey">
        /// The lower bound of the partition key range that
        /// should be split between the partition ‘Count’
        /// 
        /// </param>
        /// <param name="highKey">
        /// The upper bound of the partition key range that
        /// should be split between the partition ‘Count’
        /// 
        /// </param>
        /// <returns> A new <see cref="Models.UniformInt64RangePartitionScheme"/> instance for mocking. </returns>
        public static UniformInt64RangePartitionScheme UniformInt64RangePartitionScheme(int count = default, long lowKey = default, long highKey = default)
        {
            return new UniformInt64RangePartitionScheme("UniformInt64Range", count, lowKey, highKey);
        }
    }
}
