// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure;

namespace Azure.AI.ContentUnderstanding
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class ContentUnderstandingModelFactory
    {
        /// <summary> Provides status details for long running operations. </summary>
        /// <param name="id"> The unique ID of the operation. </param>
        /// <param name="status"> The status of the operation. </param>
        /// <param name="error"> Error object that describes the error when status is "Failed". </param>
        /// <param name="result"> The result of the operation. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ResourceOperationStatusContentAnalyzerContentAnalyzerError"/> instance for mocking. </returns>
        public static ResourceOperationStatusContentAnalyzerContentAnalyzerError ResourceOperationStatusContentAnalyzerContentAnalyzerError(string id = default, OperationState status = default, ResponseError error = default, ContentAnalyzer result = default)
        {
            return new ResourceOperationStatusContentAnalyzerContentAnalyzerError(id, status, error, result, additionalBinaryDataProperties: null);
        }

        /// <summary> Analyzer that extracts content and fields from multimodal documents. </summary>
        /// <param name="analyzerId"> The unique identifier of the analyzer. </param>
        /// <param name="description"> A description of the analyzer. </param>
        /// <param name="tags"> Tags associated with the analyzer. </param>
        /// <param name="status"> The status of the analyzer. </param>
        /// <param name="createdAt"> The date and time when the analyzer was created. </param>
        /// <param name="lastModifiedAt"> The date and time when the analyzer was last modified. </param>
        /// <param name="warnings"> Warnings encountered while creating the analyzer. </param>
        /// <param name="baseAnalyzerId"> The analyzer to incrementally train from. </param>
        /// <param name="config"> Analyzer configuration settings. </param>
        /// <param name="fieldSchema"> The schema of fields to extracted. </param>
        /// <param name="trainingData"> The data source containing training data for the analyzer. </param>
        /// <param name="processingLocation"> The location where the data may be processed. </param>
        /// <param name="mode"> The analysis mode: standard, pro.  Default is standard. </param>
        /// <param name="knowledgeSources"> Additional knowledge sources used to enhance the analyzer. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentAnalyzer"/> instance for mocking. </returns>
        public static ContentAnalyzer ContentAnalyzer(string analyzerId = default, string description = default, IDictionary<string, string> tags = default, ResourceStatus status = default, DateTimeOffset createdAt = default, DateTimeOffset lastModifiedAt = default, IEnumerable<ResponseError> warnings = default, string baseAnalyzerId = default, ContentAnalyzerConfig config = default, ContentFieldSchema fieldSchema = default, DataSource trainingData = default, ProcessingLocation? processingLocation = default, AnalysisMode? mode = default, IEnumerable<KnowledgeSource> knowledgeSources = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            warnings ??= new ChangeTrackingList<ResponseError>();
            knowledgeSources ??= new ChangeTrackingList<KnowledgeSource>();

            return new ContentAnalyzer(
                analyzerId,
                description,
                tags,
                status,
                createdAt,
                lastModifiedAt,
                warnings.ToList(),
                baseAnalyzerId,
                config,
                fieldSchema,
                trainingData,
                processingLocation,
                mode,
                knowledgeSources.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Configuration settings for an analyzer. </summary>
        /// <param name="returnDetails"> Return all content details. </param>
        /// <param name="locales"> List of locale hints for speech transcription. </param>
        /// <param name="enableFace"> Enable face detection. </param>
        /// <param name="personDirectoryId"> Specify the person directory used for identifying detected faces. </param>
        /// <param name="enableOcr"> Enable optical character recognition (OCR). </param>
        /// <param name="enableLayout"> Enable layout analysis. </param>
        /// <param name="tableFormat"> Representation format of tables in analyze result markdown. </param>
        /// <param name="enableFormula"> Enable mathematical formula detection. </param>
        /// <param name="disableFaceBlurring"> Disable the default blurring of faces for privacy while processing the content. </param>
        /// <param name="disableContentFiltering"> Disable content filtering that detects and prevents the output of harmful content. </param>
        /// <param name="estimateFieldSourceAndConfidence"> Return grounding source and confidence for extracted fields. </param>
        /// <param name="segmentationMode"> Segmentation mode used to split audio/visual content. </param>
        /// <param name="segmentationDefinition"> Segmentation definition for use with custom segmentation mode. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentAnalyzerConfig"/> instance for mocking. </returns>
        public static ContentAnalyzerConfig ContentAnalyzerConfig(bool? returnDetails = default, IEnumerable<string> locales = default, bool? enableFace = default, string personDirectoryId = default, bool? enableOcr = default, bool? enableLayout = default, TableFormat? tableFormat = default, bool? enableFormula = default, bool? disableFaceBlurring = default, bool? disableContentFiltering = default, bool? estimateFieldSourceAndConfidence = default, SegmentationMode? segmentationMode = default, string segmentationDefinition = default)
        {
            locales ??= new ChangeTrackingList<string>();

            return new ContentAnalyzerConfig(
                returnDetails,
                locales.ToList(),
                enableFace,
                personDirectoryId,
                enableOcr,
                enableLayout,
                tableFormat,
                enableFormula,
                disableFaceBlurring,
                disableContentFiltering,
                estimateFieldSourceAndConfidence,
                segmentationMode,
                segmentationDefinition,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Schema of fields to be extracted from documents. </summary>
        /// <param name="name"> The name of the field schema. </param>
        /// <param name="description"> A description of the field schema. </param>
        /// <param name="fields"> The fields defined in the schema. </param>
        /// <param name="definitions"> Additional definitions referenced by the fields in the schema. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentFieldSchema"/> instance for mocking. </returns>
        public static ContentFieldSchema ContentFieldSchema(string name = default, string description = default, IDictionary<string, ContentFieldDefinition> fields = default, IDictionary<string, ContentFieldDefinition> definitions = default)
        {
            fields ??= new ChangeTrackingDictionary<string, ContentFieldDefinition>();
            definitions ??= new ChangeTrackingDictionary<string, ContentFieldDefinition>();

            return new ContentFieldSchema(name, description, fields, definitions, additionalBinaryDataProperties: null);
        }

        /// <summary> Definition of the field using a JSON Schema like syntax. </summary>
        /// <param name="method"> Generation method. </param>
        /// <param name="type"> Semantic data type of the field value. </param>
        /// <param name="description"> Field description. </param>
        /// <param name="items"> Field type schema of each array element, if type is array. </param>
        /// <param name="properties"> Named sub-fields, if type is object. </param>
        /// <param name="examples"> Examples of field values. </param>
        /// <param name="enum"> Enumeration of possible field values. </param>
        /// <param name="enumDescriptions"> Descriptions for each enumeration value. </param>
        /// <param name="ref"> Reference to another field definition. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentFieldDefinition"/> instance for mocking. </returns>
        public static ContentFieldDefinition ContentFieldDefinition(GenerationMethod? @method = default, ContentFieldType? @type = default, string description = default, ContentFieldDefinition items = default, IDictionary<string, ContentFieldDefinition> properties = default, IEnumerable<string> examples = default, IEnumerable<string> @enum = default, IDictionary<string, string> enumDescriptions = default, string @ref = default)
        {
            properties ??= new ChangeTrackingDictionary<string, ContentFieldDefinition>();
            examples ??= new ChangeTrackingList<string>();
            @enum ??= new ChangeTrackingList<string>();
            enumDescriptions ??= new ChangeTrackingDictionary<string, string>();

            return new ContentFieldDefinition(
                @method,
                @type,
                description,
                items,
                properties,
                examples.ToList(),
                @enum.ToList(),
                enumDescriptions,
                @ref,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Data source specifying a set of documents.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="ContentUnderstanding.BlobDataSource"/>.
        /// </summary>
        /// <param name="kind"> The kind of data source. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DataSource"/> instance for mocking. </returns>
        public static DataSource DataSource(string kind = default)
        {
            return new UnknownDataSource(new DataSourceKind(kind), additionalBinaryDataProperties: null);
        }

        /// <summary> Blob storage data source. </summary>
        /// <param name="containerUrl"> The URL of the blob container. </param>
        /// <param name="prefix"> An optional prefix to filter blobs within the container. </param>
        /// <param name="fileListPath"> An optional path to a file listing specific blobs to include. </param>
        /// <returns> A new <see cref="ContentUnderstanding.BlobDataSource"/> instance for mocking. </returns>
        public static BlobDataSource BlobDataSource(Uri containerUrl = default, string prefix = default, string fileListPath = default)
        {
            return new BlobDataSource(DataSourceKind.Blob, additionalBinaryDataProperties: null, containerUrl, prefix, fileListPath);
        }

        /// <summary>
        /// Knowledge source.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="ContentUnderstanding.ReferenceKnowledgeSource"/>.
        /// </summary>
        /// <param name="kind"> The kind of knowledge source. </param>
        /// <returns> A new <see cref="ContentUnderstanding.KnowledgeSource"/> instance for mocking. </returns>
        public static KnowledgeSource KnowledgeSource(string kind = default)
        {
            return new UnknownKnowledgeSource(new KnowledgeSourceKind(kind), additionalBinaryDataProperties: null);
        }

        /// <summary> File knowledge source. </summary>
        /// <param name="containerUrl"> The URL of the blob container. </param>
        /// <param name="prefix"> An optional prefix to filter blobs within the container. </param>
        /// <param name="fileListPath"> Path to a file listing specific blobs to include. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ReferenceKnowledgeSource"/> instance for mocking. </returns>
        public static ReferenceKnowledgeSource ReferenceKnowledgeSource(Uri containerUrl = default, string prefix = default, string fileListPath = default)
        {
            return new ReferenceKnowledgeSource(KnowledgeSourceKind.Reference, additionalBinaryDataProperties: null, containerUrl, prefix, fileListPath);
        }

        /// <summary> Additional input to analyze. </summary>
        /// <param name="url"> The URL of the input to analyze.  Only one of url or data should be specified. </param>
        /// <param name="data"> Raw image bytes. Provide bytes-like object; do not base64-encode. Only one of url or data should be specified. </param>
        /// <param name="name"> Name of the input. </param>
        /// <returns> A new <see cref="ContentUnderstanding.AnalyzeInput"/> instance for mocking. </returns>
        public static AnalyzeInput AnalyzeInput(Uri url = default, BinaryData data = default, string name = default)
        {
            return new AnalyzeInput(url, data, name, additionalBinaryDataProperties: null);
        }

        /// <summary> Analyze operation result. </summary>
        /// <param name="analyzerId"> The unique identifier of the analyzer. </param>
        /// <param name="apiVersion"> The version of the API used to analyze the document. </param>
        /// <param name="createdAt"> The date and time when the result was created. </param>
        /// <param name="warnings"> Warnings encountered while analyzing the document. </param>
        /// <param name="stringEncoding"> The string encoding used for content spans. </param>
        /// <param name="contents"> The extracted content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.AnalyzeResult"/> instance for mocking. </returns>
        public static AnalyzeResult AnalyzeResult(string analyzerId = default, string apiVersion = default, DateTimeOffset? createdAt = default, IEnumerable<ResponseError> warnings = default, StringEncoding? stringEncoding = default, IEnumerable<MediaContent> contents = default)
        {
            warnings ??= new ChangeTrackingList<ResponseError>();
            contents ??= new ChangeTrackingList<MediaContent>();

            return new AnalyzeResult(
                analyzerId,
                apiVersion,
                createdAt,
                warnings.ToList(),
                stringEncoding,
                contents.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Media content base class.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="ContentUnderstanding.DocumentContent"/> and <see cref="ContentUnderstanding.AudioVisualContent"/>.
        /// </summary>
        /// <param name="kind"> Content kind. </param>
        /// <param name="mimeType"> Detected MIME type of the content.  Ex. application/pdf, image/jpeg, etc. </param>
        /// <param name="category"> Classified content category. </param>
        /// <param name="path"> The path of the content in the input. </param>
        /// <param name="markdown"> Markdown representation of the content. </param>
        /// <param name="fields"> Extracted fields from the content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.MediaContent"/> instance for mocking. </returns>
        public static MediaContent MediaContent(string kind = default, string mimeType = default, string category = default, Uri path = default, string markdown = default, IDictionary<string, ContentField> fields = default)
        {
            fields ??= new ChangeTrackingDictionary<string, ContentField>();

            return new UnknownMediaContent(
                new MediaContentKind(kind),
                mimeType,
                category,
                path,
                markdown,
                fields,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Field extracted from the content.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="ContentUnderstanding.StringField"/>, <see cref="ContentUnderstanding.DateField"/>, <see cref="ContentUnderstanding.TimeField"/>, <see cref="ContentUnderstanding.NumberField"/>, <see cref="ContentUnderstanding.IntegerField"/>, <see cref="ContentUnderstanding.BooleanField"/>, <see cref="ContentUnderstanding.ArrayField"/>, and <see cref="ContentUnderstanding.ObjectField"/>.
        /// </summary>
        /// <param name="type"> Semantic data type of the field value. </param>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentField"/> instance for mocking. </returns>
        public static ContentField ContentField(string @type = default, IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new UnknownContentField(new ContentFieldType(@type), spans.ToList(), confidence, source, additionalBinaryDataProperties: null);
        }

        /// <summary> Position of the element in markdown, specified as a character offset and length. </summary>
        /// <param name="offset"> Starting position (0-indexed) of the element in markdown, specified in characters. </param>
        /// <param name="length"> Length of the element in markdown, specified in characters. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentSpan"/> instance for mocking. </returns>
        public static ContentSpan ContentSpan(int offset = default, int length = default)
        {
            return new ContentSpan(offset, length, additionalBinaryDataProperties: null);
        }

        /// <summary> String field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueString"> String field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.StringField"/> instance for mocking. </returns>
        public static StringField StringField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, string valueString = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new StringField(
                ContentFieldType.String,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueString);
        }

        /// <summary> Date field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueDate"> Date field value, in ISO 8601 (YYYY-MM-DD) format. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DateField"/> instance for mocking. </returns>
        public static DateField DateField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, DateTimeOffset? valueDate = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new DateField(
                ContentFieldType.Date,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueDate);
        }

        /// <summary> Time field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueTime"> Time field value, in ISO 8601 (hh:mm:ss) format. </param>
        /// <returns> A new <see cref="ContentUnderstanding.TimeField"/> instance for mocking. </returns>
        public static TimeField TimeField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, TimeSpan? valueTime = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new TimeField(
                ContentFieldType.Time,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueTime);
        }

        /// <summary> Number field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueNumber"> Number field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.NumberField"/> instance for mocking. </returns>
        public static NumberField NumberField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, double? valueNumber = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new NumberField(
                ContentFieldType.Number,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueNumber);
        }

        /// <summary> Integer field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueInteger"> Integer field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.IntegerField"/> instance for mocking. </returns>
        public static IntegerField IntegerField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, long? valueInteger = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new IntegerField(
                ContentFieldType.Integer,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueInteger);
        }

        /// <summary> Boolean field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueBoolean"> Boolean field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.BooleanField"/> instance for mocking. </returns>
        public static BooleanField BooleanField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, bool? valueBoolean = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new BooleanField(
                ContentFieldType.Boolean,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueBoolean);
        }

        /// <summary> Array field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueArray"> Array field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ArrayField"/> instance for mocking. </returns>
        public static ArrayField ArrayField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, IEnumerable<ContentField> valueArray = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();
            valueArray ??= new ChangeTrackingList<ContentField>();

            return new ArrayField(
                ContentFieldType.Array,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueArray.ToList());
        }

        /// <summary> Object field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueObject"> Object field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ObjectField"/> instance for mocking. </returns>
        public static ObjectField ObjectField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, IDictionary<string, ContentField> valueObject = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();
            valueObject ??= new ChangeTrackingDictionary<string, ContentField>();

            return new ObjectField(
                ContentFieldType.Object,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueObject);
        }

        /// <summary> Document content.  Ex. text/plain, application/pdf, image/jpeg. </summary>
        /// <param name="mimeType"> Detected MIME type of the content.  Ex. application/pdf, image/jpeg, etc. </param>
        /// <param name="category"> Classified content category. </param>
        /// <param name="path"> The path of the content in the input. </param>
        /// <param name="markdown"> Markdown representation of the content. </param>
        /// <param name="fields"> Extracted fields from the content. </param>
        /// <param name="startPageNumber"> Start page number (1-indexed) of the content. </param>
        /// <param name="endPageNumber"> End page number (1-indexed) of the content. </param>
        /// <param name="unit">
        /// Length unit used by the width, height, and source properties.
        /// For images/tiff, the default unit is pixel.  For PDF, the default unit is inch.
        /// </param>
        /// <param name="pages"> List of pages in the document. </param>
        /// <param name="paragraphs"> List of paragraphs in the document.  Only if enableOcr and returnDetails are true. </param>
        /// <param name="sections"> List of sections in the document.  Only if enableLayout and returnDetails are true. </param>
        /// <param name="tables"> List of tables in the document.  Only if enableLayout and returnDetails are true. </param>
        /// <param name="figures"> List of figures in the document.  Only if enableLayout and returnDetails are true. </param>
        /// <param name="persons"> List of detected persons in the document.  Only if enableFace and returnDetails are true. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentContent"/> instance for mocking. </returns>
        public static DocumentContent DocumentContent(string mimeType = default, string category = default, Uri path = default, string markdown = default, IDictionary<string, ContentField> fields = default, int startPageNumber = default, int endPageNumber = default, LengthUnit? unit = default, IEnumerable<DocumentPage> pages = default, IEnumerable<DocumentParagraph> paragraphs = default, IEnumerable<DocumentSection> sections = default, IEnumerable<DocumentTable> tables = default, IEnumerable<DocumentFigure> figures = default, IEnumerable<DetectedPerson> persons = default)
        {
            fields ??= new ChangeTrackingDictionary<string, ContentField>();
            pages ??= new ChangeTrackingList<DocumentPage>();
            paragraphs ??= new ChangeTrackingList<DocumentParagraph>();
            sections ??= new ChangeTrackingList<DocumentSection>();
            tables ??= new ChangeTrackingList<DocumentTable>();
            figures ??= new ChangeTrackingList<DocumentFigure>();
            persons ??= new ChangeTrackingList<DetectedPerson>();

            return new DocumentContent(
                MediaContentKind.Document,
                mimeType,
                category,
                path,
                markdown,
                fields,
                additionalBinaryDataProperties: null,
                startPageNumber,
                endPageNumber,
                unit,
                pages.ToList(),
                paragraphs.ToList(),
                sections.ToList(),
                tables.ToList(),
                figures.ToList(),
                persons.ToList());
        }

        /// <summary> Content from a document page. </summary>
        /// <param name="pageNumber"> Page number (1-based). </param>
        /// <param name="width"> Width of the page. </param>
        /// <param name="height"> Height of the page. </param>
        /// <param name="spans"> Span(s) associated with the page in the markdown content. </param>
        /// <param name="angle">
        /// The general orientation of the content in clockwise direction,
        /// measured in degrees between (-180, 180].
        /// Only if enableOcr is true.
        /// </param>
        /// <param name="words"> List of words in the page.  Only if enableOcr and returnDetails are true. </param>
        /// <param name="lines"> List of lines in the page.  Only if enableOcr and returnDetails are true. </param>
        /// <param name="barcodes"> List of barcodes in the page.  Only if enableBarcode and returnDetails are true. </param>
        /// <param name="formulas"> List of mathematical formulas in the page.  Only if enableFormula and returnDetails are true. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentPage"/> instance for mocking. </returns>
        public static DocumentPage DocumentPage(int pageNumber = default, float? width = default, float? height = default, IEnumerable<ContentSpan> spans = default, float? angle = default, IEnumerable<DocumentWord> words = default, IEnumerable<DocumentLine> lines = default, IEnumerable<DocumentBarcode> barcodes = default, IEnumerable<DocumentFormula> formulas = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();
            words ??= new ChangeTrackingList<DocumentWord>();
            lines ??= new ChangeTrackingList<DocumentLine>();
            barcodes ??= new ChangeTrackingList<DocumentBarcode>();
            formulas ??= new ChangeTrackingList<DocumentFormula>();

            return new DocumentPage(
                pageNumber,
                width,
                height,
                spans.ToList(),
                angle,
                words.ToList(),
                lines.ToList(),
                barcodes.ToList(),
                formulas.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Word in a document, consisting of a contiguous sequence of characters.
        /// For non-space delimited languages, such as Chinese, Japanese, and Korean, 
        /// each character is represented as its own word.
        /// </summary>
        /// <param name="content"> Word text. </param>
        /// <param name="source"> Encoded source that identifies the position of the word in the content. </param>
        /// <param name="span"> Span of the word in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the word. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentWord"/> instance for mocking. </returns>
        public static DocumentWord DocumentWord(string content = default, string source = default, ContentSpan span = default, float? confidence = default)
        {
            return new DocumentWord(content, source, span, confidence, additionalBinaryDataProperties: null);
        }

        /// <summary> Line in a document, consisting of an contiguous sequence of words. </summary>
        /// <param name="content"> Line text. </param>
        /// <param name="source"> Encoded source that identifies the position of the line in the content. </param>
        /// <param name="span"> Span of the line in the markdown content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentLine"/> instance for mocking. </returns>
        public static DocumentLine DocumentLine(string content = default, string source = default, ContentSpan span = default)
        {
            return new DocumentLine(content, source, span, additionalBinaryDataProperties: null);
        }

        /// <summary> Barcode in a document. </summary>
        /// <param name="kind"> Barcode kind. </param>
        /// <param name="value"> Barcode value. </param>
        /// <param name="source"> Encoded source that identifies the position of the barcode in the content. </param>
        /// <param name="span"> Span of the barcode in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the barcode. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentBarcode"/> instance for mocking. </returns>
        public static DocumentBarcode DocumentBarcode(DocumentBarcodeKind kind = default, string value = default, string source = default, ContentSpan span = default, float? confidence = default)
        {
            return new DocumentBarcode(
                kind,
                value,
                source,
                span,
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Mathematical formula in a document. </summary>
        /// <param name="kind"> Formula kind. </param>
        /// <param name="value"> LaTex expression describing the formula. </param>
        /// <param name="source"> Encoded source that identifies the position of the formula in the content. </param>
        /// <param name="span"> Span of the formula in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the formula. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentFormula"/> instance for mocking. </returns>
        public static DocumentFormula DocumentFormula(DocumentFormulaKind kind = default, string value = default, string source = default, ContentSpan span = default, float? confidence = default)
        {
            return new DocumentFormula(
                kind,
                value,
                source,
                span,
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Paragraph in a document, generally consisting of an contiguous sequence of lines
        /// with common alignment and spacing.
        /// </summary>
        /// <param name="role"> Semantic role of the paragraph. </param>
        /// <param name="content"> Paragraph text. </param>
        /// <param name="source"> Encoded source that identifies the position of the paragraph in the content. </param>
        /// <param name="span"> Span of the paragraph in the markdown content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentParagraph"/> instance for mocking. </returns>
        public static DocumentParagraph DocumentParagraph(ParagraphRole? role = default, string content = default, string source = default, ContentSpan span = default)
        {
            return new DocumentParagraph(role, content, source, span, additionalBinaryDataProperties: null);
        }

        /// <summary> Section in a document. </summary>
        /// <param name="span"> Span of the section in the markdown content. </param>
        /// <param name="elements"> Child elements of the section. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentSection"/> instance for mocking. </returns>
        public static DocumentSection DocumentSection(ContentSpan span = default, IEnumerable<string> elements = default)
        {
            elements ??= new ChangeTrackingList<string>();

            return new DocumentSection(span, elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Table in a document, consisting table cells arranged in a rectangular layout. </summary>
        /// <param name="rowCount"> Number of rows in the table. </param>
        /// <param name="columnCount"> Number of columns in the table. </param>
        /// <param name="cells"> Cells contained within the table. </param>
        /// <param name="source"> Encoded source that identifies the position of the table in the content. </param>
        /// <param name="span"> Span of the table in the markdown content. </param>
        /// <param name="caption"> Table caption. </param>
        /// <param name="footnotes"> List of table footnotes. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentTable"/> instance for mocking. </returns>
        public static DocumentTable DocumentTable(int rowCount = default, int columnCount = default, IEnumerable<DocumentTableCell> cells = default, string source = default, ContentSpan span = default, DocumentCaption caption = default, IEnumerable<DocumentFootnote> footnotes = default)
        {
            cells ??= new ChangeTrackingList<DocumentTableCell>();
            footnotes ??= new ChangeTrackingList<DocumentFootnote>();

            return new DocumentTable(
                rowCount,
                columnCount,
                cells.ToList(),
                source,
                span,
                caption,
                footnotes.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Table cell in a document table. </summary>
        /// <param name="kind"> Table cell kind. </param>
        /// <param name="rowIndex"> Row index of the cell. </param>
        /// <param name="columnIndex"> Column index of the cell. </param>
        /// <param name="rowSpan"> Number of rows spanned by this cell. </param>
        /// <param name="columnSpan"> Number of columns spanned by this cell. </param>
        /// <param name="content"> Content of the table cell. </param>
        /// <param name="source"> Encoded source that identifies the position of the table cell in the content. </param>
        /// <param name="span"> Span of the table cell in the markdown content. </param>
        /// <param name="elements"> Child elements of the table cell. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentTableCell"/> instance for mocking. </returns>
        public static DocumentTableCell DocumentTableCell(DocumentTableCellKind? kind = default, int rowIndex = default, int columnIndex = default, int? rowSpan = default, int? columnSpan = default, string content = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default)
        {
            elements ??= new ChangeTrackingList<string>();

            return new DocumentTableCell(
                kind,
                rowIndex,
                columnIndex,
                rowSpan,
                columnSpan,
                content,
                source,
                span,
                elements.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Caption of a table or figure. </summary>
        /// <param name="content"> Content of the caption. </param>
        /// <param name="source"> Encoded source that identifies the position of the caption in the content. </param>
        /// <param name="span"> Span of the caption in the markdown content. </param>
        /// <param name="elements"> Child elements of the caption. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentCaption"/> instance for mocking. </returns>
        public static DocumentCaption DocumentCaption(string content = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default)
        {
            elements ??= new ChangeTrackingList<string>();

            return new DocumentCaption(content, source, span, elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Footnote of a table or figure. </summary>
        /// <param name="content"> Content of the footnote. </param>
        /// <param name="source"> Encoded source that identifies the position of the footnote in the content. </param>
        /// <param name="span"> Span of the footnote in the markdown content. </param>
        /// <param name="elements"> Child elements of the footnote. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentFootnote"/> instance for mocking. </returns>
        public static DocumentFootnote DocumentFootnote(string content = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default)
        {
            elements ??= new ChangeTrackingList<string>();

            return new DocumentFootnote(content, source, span, elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Figure in a document. </summary>
        /// <param name="id"> Figure identifier. </param>
        /// <param name="source"> Encoded source that identifies the position of the figure in the content. </param>
        /// <param name="span"> Span of the figure in the markdown content. </param>
        /// <param name="elements"> Child elements of the figure, excluding any caption or footnotes. </param>
        /// <param name="caption"> Figure caption. </param>
        /// <param name="footnotes"> List of figure footnotes. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentFigure"/> instance for mocking. </returns>
        public static DocumentFigure DocumentFigure(string id = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default, DocumentCaption caption = default, IEnumerable<DocumentFootnote> footnotes = default)
        {
            elements ??= new ChangeTrackingList<string>();
            footnotes ??= new ChangeTrackingList<DocumentFootnote>();

            return new DocumentFigure(
                id,
                source,
                span,
                elements.ToList(),
                caption,
                footnotes.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Detected person. </summary>
        /// <param name="personId"> Person identifier in the optional person directory if found.  Otherwise, each unknown person is assigned a unique `Person-{Number}`. </param>
        /// <param name="confidence"> Confidence of the person identification, if a person directory is provided. </param>
        /// <param name="source"> Encoded source that identifies the position of the person in the input content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DetectedPerson"/> instance for mocking. </returns>
        public static DetectedPerson DetectedPerson(string personId = default, float? confidence = default, string source = default)
        {
            return new DetectedPerson(personId, confidence, source, additionalBinaryDataProperties: null);
        }

        /// <summary> Audio visual content.  Ex. audio/wav, video/mp4. </summary>
        /// <param name="mimeType"> Detected MIME type of the content.  Ex. application/pdf, image/jpeg, etc. </param>
        /// <param name="category"> Classified content category. </param>
        /// <param name="path"> The path of the content in the input. </param>
        /// <param name="markdown"> Markdown representation of the content. </param>
        /// <param name="fields"> Extracted fields from the content. </param>
        /// <param name="startTimeMs"> Start time of the content in milliseconds. </param>
        /// <param name="endTimeMs"> End time of the content in milliseconds. </param>
        /// <param name="width"> Width of each video frame in pixels, if applicable. </param>
        /// <param name="height"> Height of each video frame in pixels, if applicable. </param>
        /// <param name="cameraShotTimesMs"> List of camera shot changes in the video, represented by its timestamp in milliseconds.  Only if returnDetails is true. </param>
        /// <param name="keyFrameTimesMs"> List of key frames in the video, represented by its timestamp in milliseconds.  Only if returnDetails is true. </param>
        /// <param name="transcriptPhrases"> List of transcript phrases.  Only if returnDetails is true. </param>
        /// <param name="persons"> List of detected persons in the video.  Only if enableFace and returnDetails are true. </param>
        /// <param name="segments"> List of audio visual segments.  Only if enableSegmentation and returnDetails are true. </param>
        /// <returns> A new <see cref="ContentUnderstanding.AudioVisualContent"/> instance for mocking. </returns>
        public static AudioVisualContent AudioVisualContent(string mimeType = default, string category = default, Uri path = default, string markdown = default, IDictionary<string, ContentField> fields = default, long startTimeMs = default, long endTimeMs = default, int? width = default, int? height = default, IEnumerable<long> cameraShotTimesMs = default, IEnumerable<long> keyFrameTimesMs = default, IEnumerable<TranscriptPhrase> transcriptPhrases = default, IEnumerable<DetectedPerson> persons = default, IEnumerable<AudioVisualSegment> segments = default)
        {
            fields ??= new ChangeTrackingDictionary<string, ContentField>();
            cameraShotTimesMs ??= new ChangeTrackingList<long>();
            keyFrameTimesMs ??= new ChangeTrackingList<long>();
            transcriptPhrases ??= new ChangeTrackingList<TranscriptPhrase>();
            persons ??= new ChangeTrackingList<DetectedPerson>();
            segments ??= new ChangeTrackingList<AudioVisualSegment>();

            return new AudioVisualContent(
                MediaContentKind.AudioVisual,
                mimeType,
                category,
                path,
                markdown,
                fields,
                additionalBinaryDataProperties: null,
                startTimeMs,
                endTimeMs,
                width,
                height,
                cameraShotTimesMs.ToList(),
                keyFrameTimesMs.ToList(),
                transcriptPhrases.ToList(),
                persons.ToList(),
                segments.ToList());
        }

        /// <summary> Transcript phrase. </summary>
        /// <param name="speaker"> Speaker index or name. </param>
        /// <param name="startTimeMs"> Start time of the phrase in milliseconds. </param>
        /// <param name="endTimeMs"> End time of the phrase in milliseconds. </param>
        /// <param name="locale"> Detected locale of the phrase.  Ex. en-US. </param>
        /// <param name="text"> Transcript text. </param>
        /// <param name="confidence"> Confidence of predicting the phrase. </param>
        /// <param name="span"> Span of the phrase in the markdown content. </param>
        /// <param name="words"> List of words in the phrase. </param>
        /// <returns> A new <see cref="ContentUnderstanding.TranscriptPhrase"/> instance for mocking. </returns>
        public static TranscriptPhrase TranscriptPhrase(string speaker = default, long startTimeMs = default, long endTimeMs = default, string locale = default, string text = default, float? confidence = default, ContentSpan span = default, IEnumerable<TranscriptWord> words = default)
        {
            words ??= new ChangeTrackingList<TranscriptWord>();

            return new TranscriptPhrase(
                speaker,
                startTimeMs,
                endTimeMs,
                locale,
                text,
                confidence,
                span,
                words.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Transcript word. </summary>
        /// <param name="startTimeMs"> Start time of the word in milliseconds. </param>
        /// <param name="endTimeMs"> End time of the word in milliseconds. </param>
        /// <param name="text"> Transcript text. </param>
        /// <param name="span"> Span of the word in the markdown content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.TranscriptWord"/> instance for mocking. </returns>
        public static TranscriptWord TranscriptWord(long startTimeMs = default, long endTimeMs = default, string text = default, ContentSpan span = default)
        {
            return new TranscriptWord(startTimeMs, endTimeMs, text, span, additionalBinaryDataProperties: null);
        }

        /// <summary> Audio visual segment, such as a scene, chapter, etc. </summary>
        /// <param name="segmentId"> Segment ID. </param>
        /// <param name="startTimeMs"> Start time of the segment in milliseconds. </param>
        /// <param name="endTimeMs"> End time of the segment in milliseconds. </param>
        /// <param name="description"> Short description of the segment. </param>
        /// <param name="span"> Span of the segment in the markdown content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.AudioVisualSegment"/> instance for mocking. </returns>
        public static AudioVisualSegment AudioVisualSegment(string segmentId = default, long startTimeMs = default, long endTimeMs = default, string description = default, ContentSpan span = default)
        {
            return new AudioVisualSegment(
                segmentId,
                startTimeMs,
                endTimeMs,
                description,
                span,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Directory of people and their faces. </summary>
        /// <param name="personDirectoryId"> The unique identifier of the person directory. </param>
        /// <param name="description"> A description of the person directory. </param>
        /// <param name="tags"> Tags associated with the person directory. </param>
        /// <param name="createdAt"> The date and time when the person directory was created. </param>
        /// <param name="lastModifiedAt"> The date and time when the person directory was last modified. </param>
        /// <param name="personCount"> Number of people in the person directory. </param>
        /// <param name="faceCount"> Number of faces in the person directory. </param>
        /// <returns> A new <see cref="ContentUnderstanding.PersonDirectory"/> instance for mocking. </returns>
        public static PersonDirectory PersonDirectory(string personDirectoryId = default, string description = default, IDictionary<string, string> tags = default, DateTimeOffset createdAt = default, DateTimeOffset lastModifiedAt = default, int personCount = default, int faceCount = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new PersonDirectory(
                personDirectoryId,
                description,
                tags,
                createdAt,
                lastModifiedAt,
                personCount,
                faceCount,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Person in a person directory. </summary>
        /// <param name="personId"> The unique identifier of the person. </param>
        /// <param name="tags"> Tags associated with the person. </param>
        /// <param name="faceIds"> List of faces associated with the person. </param>
        /// <returns> A new <see cref="ContentUnderstanding.PersonDirectoryPerson"/> instance for mocking. </returns>
        public static PersonDirectoryPerson PersonDirectoryPerson(string personId = default, IDictionary<string, string> tags = default, IEnumerable<string> faceIds = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            faceIds ??= new ChangeTrackingList<string>();

            return new PersonDirectoryPerson(personId, tags, faceIds.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Input face source with an optional target bounding box.  If not specified, the largest face will be used. </summary>
        /// <param name="url"> Image URL.  Only one of url or data should be specified. </param>
        /// <param name="data"> Raw image bytes. Provide bytes-like object; do not base64-encode. Only one of url or data should be specified. </param>
        /// <param name="imageReferenceId"> User provided identifier for the source image. </param>
        /// <param name="targetBoundingBox"> Bounding box specifying the region of interest. </param>
        /// <returns> A new <see cref="ContentUnderstanding.FaceSource"/> instance for mocking. </returns>
        public static FaceSource FaceSource(Uri url = default, BinaryData data = default, string imageReferenceId = default, BoundingBox targetBoundingBox = default)
        {
            return new FaceSource(url, data, imageReferenceId, targetBoundingBox, additionalBinaryDataProperties: null);
        }

        /// <summary> Bounding box in an image. </summary>
        /// <param name="left"> Left coordinate of the bounding box. </param>
        /// <param name="top"> Top coordinate of the bounding box. </param>
        /// <param name="width"> Width of the bounding box. </param>
        /// <param name="height"> Height of the bounding box. </param>
        /// <returns> A new <see cref="ContentUnderstanding.BoundingBox"/> instance for mocking. </returns>
        public static BoundingBox BoundingBox(int left = default, int top = default, int width = default, int height = default)
        {
            return new BoundingBox(left, top, width, height, additionalBinaryDataProperties: null);
        }

        /// <summary> Face in a person directory. </summary>
        /// <param name="faceId"> The unique identifier of the face. </param>
        /// <param name="personId"> Person associated with the face, if any. </param>
        /// <param name="imageReferenceId"> User provided identifier for the source image. </param>
        /// <param name="boundingBox"> Bounding box of the face in the source image. </param>
        /// <returns> A new <see cref="ContentUnderstanding.PersonDirectoryFace"/> instance for mocking. </returns>
        public static PersonDirectoryFace PersonDirectoryFace(string faceId = default, string personId = default, string imageReferenceId = default, BoundingBox boundingBox = default)
        {
            return new PersonDirectoryFace(faceId, personId, imageReferenceId, boundingBox, additionalBinaryDataProperties: null);
        }

        /// <summary> Identify person response. </summary>
        /// <param name="detectedFace"> Details of the detected face. </param>
        /// <param name="personCandidates"> List of person candidates matching the input face. </param>
        /// <returns> A new <see cref="ContentUnderstanding.IdentifyPersonResult"/> instance for mocking. </returns>
        public static IdentifyPersonResult IdentifyPersonResult(DetectedBoundingBox detectedFace = default, IEnumerable<PersonCandidate> personCandidates = default)
        {
            personCandidates ??= new ChangeTrackingList<PersonCandidate>();

            return new IdentifyPersonResult(detectedFace, personCandidates.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Detected bounding box of an object. </summary>
        /// <param name="boundingBox"> Bounding box of the detected face. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DetectedBoundingBox"/> instance for mocking. </returns>
        public static DetectedBoundingBox DetectedBoundingBox(BoundingBox boundingBox = default)
        {
            return new DetectedBoundingBox(boundingBox, additionalBinaryDataProperties: null);
        }

        /// <summary> Identified person candidate. </summary>
        /// <param name="personId"> The unique identifier of the person. </param>
        /// <param name="tags"> Tags associated with the person. </param>
        /// <param name="confidence"> Confidence score of the person matching the input face. </param>
        /// <returns> A new <see cref="ContentUnderstanding.PersonCandidate"/> instance for mocking. </returns>
        public static PersonCandidate PersonCandidate(string personId = default, IDictionary<string, string> tags = default, float confidence = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new PersonCandidate(personId, tags, confidence, additionalBinaryDataProperties: null);
        }

        /// <summary> Find similar faces response. </summary>
        /// <param name="detectedFace"> Details of the detected face. </param>
        /// <param name="similarFaces"> List of similar faces. </param>
        /// <returns> A new <see cref="ContentUnderstanding.FindSimilarFacesResult"/> instance for mocking. </returns>
        public static FindSimilarFacesResult FindSimilarFacesResult(DetectedBoundingBox detectedFace = default, IEnumerable<SimilarFace> similarFaces = default)
        {
            similarFaces ??= new ChangeTrackingList<SimilarFace>();

            return new FindSimilarFacesResult(detectedFace, similarFaces.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Similar face found in the person directory. </summary>
        /// <param name="faceId"> The unique identifier of the face. </param>
        /// <param name="personId"> Person associated with the face, if any. </param>
        /// <param name="imageReferenceId"> User provided identifier for the source image. </param>
        /// <param name="boundingBox"> Bounding box of the face in the source image. </param>
        /// <param name="confidence"> Confidence that this face matches the input face. </param>
        /// <returns> A new <see cref="ContentUnderstanding.SimilarFace"/> instance for mocking. </returns>
        public static SimilarFace SimilarFace(string faceId = default, string personId = default, string imageReferenceId = default, BoundingBox boundingBox = default, float confidence = default)
        {
            return new SimilarFace(
                faceId,
                personId,
                imageReferenceId,
                boundingBox,
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Verify person response. </summary>
        /// <param name="detectedFace"> Details of the detected face. </param>
        /// <param name="confidence"> Confidence score of the person verification. </param>
        /// <returns> A new <see cref="ContentUnderstanding.VerifyPersonResult"/> instance for mocking. </returns>
        public static VerifyPersonResult VerifyPersonResult(DetectedBoundingBox detectedFace = default, float confidence = default)
        {
            return new VerifyPersonResult(detectedFace, confidence, additionalBinaryDataProperties: null);
        }

        /// <summary> Detect faces response. </summary>
        /// <param name="detectedFaces"> List of detected faces. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DetectFacesResult"/> instance for mocking. </returns>
        public static DetectFacesResult DetectFacesResult(IEnumerable<DetectedBoundingBox> detectedFaces = default)
        {
            detectedFaces ??= new ChangeTrackingList<DetectedBoundingBox>();

            return new DetectFacesResult(detectedFaces.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Compare faces response. </summary>
        /// <param name="detectedFace1"> Details of the first detected face. </param>
        /// <param name="detectedFace2"> Details of the second detected face. </param>
        /// <param name="confidence"> Confidence score of the face comparison. </param>
        /// <returns> A new <see cref="ContentUnderstanding.CompareFacesResult"/> instance for mocking. </returns>
        public static CompareFacesResult CompareFacesResult(DetectedBoundingBox detectedFace1 = default, DetectedBoundingBox detectedFace2 = default, float confidence = default)
        {
            return new CompareFacesResult(detectedFace1, detectedFace2, confidence, additionalBinaryDataProperties: null);
        }

        /// <summary> Provides status details for long running operations. </summary>
        /// <param name="id"> The unique ID of the operation. </param>
        /// <param name="status"> The status of the operation. </param>
        /// <param name="error"> Error object that describes the error when status is "Failed". </param>
        /// <param name="result"> The result of the operation. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ResourceOperationStatusContentClassifierContentClassifierError"/> instance for mocking. </returns>
        public static ResourceOperationStatusContentClassifierContentClassifierError ResourceOperationStatusContentClassifierContentClassifierError(string id = default, OperationState status = default, ResponseError error = default, ContentClassifier result = default)
        {
            return new ResourceOperationStatusContentClassifierContentClassifierError(id, status, error, result, additionalBinaryDataProperties: null);
        }

        /// <summary> Classifier that classifies content into categories with optional splitting. </summary>
        /// <param name="classifierId"> The unique identifier of the classifier. </param>
        /// <param name="description"> A description of the classifier. </param>
        /// <param name="tags"> Tags associated with the classifier. </param>
        /// <param name="status"> The status of the classifier. </param>
        /// <param name="createdAt"> The date and time when the classifier was created. </param>
        /// <param name="lastModifiedAt"> The date and time when the classifier was last modified. </param>
        /// <param name="warnings"> Warnings encountered while creating the classifier. </param>
        /// <param name="categories"> The categories to classify against. </param>
        /// <param name="splitMode"> Mode used to split input into content objects. </param>
        /// <param name="processingLocation"> The location where the data may be processed. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentClassifier"/> instance for mocking. </returns>
        public static ContentClassifier ContentClassifier(string classifierId = default, string description = default, IDictionary<string, string> tags = default, ResourceStatus status = default, DateTimeOffset createdAt = default, DateTimeOffset lastModifiedAt = default, IEnumerable<ResponseError> warnings = default, IDictionary<string, ClassifierCategoryDefinition> categories = default, ClassifierSplitMode? splitMode = default, ProcessingLocation? processingLocation = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            warnings ??= new ChangeTrackingList<ResponseError>();
            categories ??= new ChangeTrackingDictionary<string, ClassifierCategoryDefinition>();

            return new ContentClassifier(
                classifierId,
                description,
                tags,
                status,
                createdAt,
                lastModifiedAt,
                warnings.ToList(),
                categories,
                splitMode,
                processingLocation,
                additionalBinaryDataProperties: null);
        }

        /// <summary> A classifier category. </summary>
        /// <param name="description"> The description of the category. </param>
        /// <param name="analyzerId"> Optional analyzer used to process the content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ClassifierCategoryDefinition"/> instance for mocking. </returns>
        public static ClassifierCategoryDefinition ClassifierCategoryDefinition(string description = default, string analyzerId = default)
        {
            return new ClassifierCategoryDefinition(description, analyzerId, additionalBinaryDataProperties: null);
        }

        /// <summary> Classify operation result. </summary>
        /// <param name="classifierId"> The unique identifier of the classifier. </param>
        /// <param name="apiVersion"> The version of the API used to classify the document. </param>
        /// <param name="createdAt"> The date and time when the result was created. </param>
        /// <param name="warnings"> Warnings encountered while classifying the document. </param>
        /// <param name="stringEncoding"> The string encoding used for content spans. </param>
        /// <param name="contents"> The classified content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ClassifyResult"/> instance for mocking. </returns>
        public static ClassifyResult ClassifyResult(string classifierId = default, string apiVersion = default, DateTimeOffset? createdAt = default, IEnumerable<ResponseError> warnings = default, StringEncoding? stringEncoding = default, IEnumerable<MediaContent> contents = default)
        {
            warnings ??= new ChangeTrackingList<ResponseError>();
            contents ??= new ChangeTrackingList<MediaContent>();

            return new ClassifyResult(
                classifierId,
                apiVersion,
                createdAt,
                warnings.ToList(),
                stringEncoding,
                contents.ToList(),
                additionalBinaryDataProperties: null);
        }
    }
}
