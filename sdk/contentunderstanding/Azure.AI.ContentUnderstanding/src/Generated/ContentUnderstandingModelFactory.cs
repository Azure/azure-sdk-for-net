// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure;

namespace Azure.AI.ContentUnderstanding
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class ContentUnderstandingModelFactory
    {
        /// <summary> Additional input to analyze. </summary>
        /// <param name="url"> The URL of the input to analyze.  Only one of url or data should be specified. </param>
        /// <param name="data"> Raw image bytes. Provide bytes-like object; do not base64-encode. Only one of url or data should be specified. </param>
        /// <param name="name"> Name of the input. </param>
        /// <param name="mimeType"> The MIME type of the input content.  Ex. application/pdf, image/jpeg, etc. </param>
        /// <param name="inputRange"> Range of the input to analyze (ex. `1-3,5,9-`).  Document content uses 1-based page numbers, while audio visual content uses integer milliseconds. </param>
        /// <returns> A new <see cref="ContentUnderstanding.AnalyzeInput"/> instance for mocking. </returns>
        public static AnalyzeInput AnalyzeInput(Uri url = default, BinaryData data = default, string name = default, string mimeType = default, string inputRange = default)
        {
            return new AnalyzeInput(
                url,
                data,
                name,
                mimeType,
                inputRange,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Analyze operation result. </summary>
        /// <param name="analyzerId"> The unique identifier of the analyzer. </param>
        /// <param name="apiVersion"> The version of the API used to analyze the document. </param>
        /// <param name="createdAt"> The date and time when the result was created. </param>
        /// <param name="warnings"> Warnings encountered while analyzing the document. </param>
        /// <param name="stringEncoding">
        ///   The string encoding format for content spans in the response.
        ///   Possible values are 'codePoint', 'utf16', and `utf8`.  Default is `codePoint`.")
        /// </param>
        /// <param name="contents"> The extracted content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.AnalyzeResult"/> instance for mocking. </returns>
        public static AnalyzeResult AnalyzeResult(string analyzerId = default, string apiVersion = default, DateTimeOffset? createdAt = default, IEnumerable<ResponseError> warnings = default, string stringEncoding = default, IEnumerable<MediaContent> contents = default)
        {
            warnings ??= new ChangeTrackingList<ResponseError>();
            contents ??= new ChangeTrackingList<MediaContent>();

            return new AnalyzeResult(
                analyzerId,
                apiVersion,
                createdAt,
                warnings.ToList(),
                stringEncoding,
                contents.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Media content base class.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="ContentUnderstanding.DocumentContent"/> and <see cref="ContentUnderstanding.AudioVisualContent"/>.
        /// </summary>
        /// <param name="kind"> Content kind. </param>
        /// <param name="mimeType"> Detected MIME type of the content.  Ex. application/pdf, image/jpeg, etc. </param>
        /// <param name="analyzerId"> The analyzer that generated this content. </param>
        /// <param name="category"> Classified content category. </param>
        /// <param name="path"> The path of the content in the input. </param>
        /// <param name="markdown"> Markdown representation of the content. </param>
        /// <param name="fields"> Extracted fields from the content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.MediaContent"/> instance for mocking. </returns>
        public static MediaContent MediaContent(string kind = default, string mimeType = default, string analyzerId = default, string category = default, string path = default, string markdown = default, IDictionary<string, ContentField> fields = default)
        {
            fields ??= new ChangeTrackingDictionary<string, ContentField>();

            return new UnknownMediaContent(
                new MediaContentKind(kind),
                mimeType,
                analyzerId,
                category,
                path,
                markdown,
                fields,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Field extracted from the content.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="ContentUnderstanding.StringField"/>, <see cref="ContentUnderstanding.DateField"/>, <see cref="ContentUnderstanding.TimeField"/>, <see cref="ContentUnderstanding.NumberField"/>, <see cref="ContentUnderstanding.IntegerField"/>, <see cref="ContentUnderstanding.BooleanField"/>, <see cref="ContentUnderstanding.ArrayField"/>, <see cref="ContentUnderstanding.ObjectField"/>, and <see cref="ContentUnderstanding.JsonField"/>.
        /// </summary>
        /// <param name="type"> Semantic data type of the field value. </param>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentField"/> instance for mocking. </returns>
        public static ContentField ContentField(string @type = default, IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new UnknownContentField(new ContentFieldType(@type), spans.ToList(), confidence, source, additionalBinaryDataProperties: null);
        }

        /// <summary> Position of the element in markdown, specified as a character offset and length. </summary>
        /// <param name="offset"> Starting position (0-indexed) of the element in markdown, specified in characters. </param>
        /// <param name="length"> Length of the element in markdown, specified in characters. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentSpan"/> instance for mocking. </returns>
        public static ContentSpan ContentSpan(int offset = default, int length = default)
        {
            return new ContentSpan(offset, length, additionalBinaryDataProperties: null);
        }

        /// <summary> String field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueString"> String field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.StringField"/> instance for mocking. </returns>
        public static StringField StringField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, string valueString = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new StringField(
                ContentFieldType.String,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueString);
        }

        /// <summary> Date field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueDate"> Date field value, in ISO 8601 (YYYY-MM-DD) format. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DateField"/> instance for mocking. </returns>
        public static DateField DateField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, DateTimeOffset? valueDate = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new DateField(
                ContentFieldType.Date,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueDate);
        }

        /// <summary> Time field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueTime"> Time field value, in ISO 8601 (hh:mm:ss) format. </param>
        /// <returns> A new <see cref="ContentUnderstanding.TimeField"/> instance for mocking. </returns>
        public static TimeField TimeField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, TimeSpan? valueTime = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new TimeField(
                ContentFieldType.Time,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueTime);
        }

        /// <summary> Number field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueNumber"> Number field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.NumberField"/> instance for mocking. </returns>
        public static NumberField NumberField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, double? valueNumber = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new NumberField(
                ContentFieldType.Number,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueNumber);
        }

        /// <summary> Integer field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueInteger"> Integer field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.IntegerField"/> instance for mocking. </returns>
        public static IntegerField IntegerField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, long? valueInteger = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new IntegerField(
                ContentFieldType.Integer,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueInteger);
        }

        /// <summary> Boolean field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueBoolean"> Boolean field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.BooleanField"/> instance for mocking. </returns>
        public static BooleanField BooleanField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, bool? valueBoolean = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new BooleanField(
                ContentFieldType.Boolean,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueBoolean);
        }

        /// <summary> Array field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueArray"> Array field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ArrayField"/> instance for mocking. </returns>
        public static ArrayField ArrayField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, IEnumerable<ContentField> valueArray = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();
            valueArray ??= new ChangeTrackingList<ContentField>();

            return new ArrayField(
                ContentFieldType.Array,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueArray.ToList());
        }

        /// <summary> Object field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueObject"> Object field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ObjectField"/> instance for mocking. </returns>
        public static ObjectField ObjectField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, IDictionary<string, ContentField> valueObject = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();
            valueObject ??= new ChangeTrackingDictionary<string, ContentField>();

            return new ObjectField(
                ContentFieldType.Object,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueObject);
        }

        /// <summary> JSON field extracted from the content. </summary>
        /// <param name="spans"> Span(s) associated with the field value in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the field value. </param>
        /// <param name="source"> Encoded source that identifies the position of the field value in the content. </param>
        /// <param name="valueJson"> JSON field value. </param>
        /// <returns> A new <see cref="ContentUnderstanding.JsonField"/> instance for mocking. </returns>
        public static JsonField JsonField(IEnumerable<ContentSpan> spans = default, float? confidence = default, string source = default, BinaryData valueJson = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();

            return new JsonField(
                ContentFieldType.Json,
                spans.ToList(),
                confidence,
                source,
                additionalBinaryDataProperties: null,
                valueJson);
        }

        /// <summary> Document content.  Ex. text/plain, application/pdf, image/jpeg. </summary>
        /// <param name="mimeType"> Detected MIME type of the content.  Ex. application/pdf, image/jpeg, etc. </param>
        /// <param name="analyzerId"> The analyzer that generated this content. </param>
        /// <param name="category"> Classified content category. </param>
        /// <param name="path"> The path of the content in the input. </param>
        /// <param name="markdown"> Markdown representation of the content. </param>
        /// <param name="fields"> Extracted fields from the content. </param>
        /// <param name="startPageNumber"> Start page number (1-indexed) of the content. </param>
        /// <param name="endPageNumber"> End page number (1-indexed) of the content. </param>
        /// <param name="unit">
        /// Length unit used by the width, height, and source properties.
        /// For images/tiff, the default unit is pixel.  For PDF, the default unit is inch.
        /// </param>
        /// <param name="pages"> List of pages in the document. </param>
        /// <param name="paragraphs"> List of paragraphs in the document.  Only if enableOcr and returnDetails are true. </param>
        /// <param name="sections"> List of sections in the document.  Only if enableLayout and returnDetails are true. </param>
        /// <param name="tables"> List of tables in the document.  Only if enableLayout and returnDetails are true. </param>
        /// <param name="figures"> List of figures in the document.  Only if enableLayout and returnDetails are true. </param>
        /// <param name="annotations"> List of annotations in the document.  Only if enableAnnotations and returnDetails are true. </param>
        /// <param name="hyperlinks"> List of hyperlinks in the document.  Only if returnDetails are true. </param>
        /// <param name="segments"> List of detected content segments.  Only if enableSegment is true. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentContent"/> instance for mocking. </returns>
        public static DocumentContent DocumentContent(string mimeType = default, string analyzerId = default, string category = default, string path = default, string markdown = default, IDictionary<string, ContentField> fields = default, int startPageNumber = default, int endPageNumber = default, LengthUnit? unit = default, IEnumerable<DocumentPage> pages = default, IEnumerable<DocumentParagraph> paragraphs = default, IEnumerable<DocumentSection> sections = default, IEnumerable<DocumentTable> tables = default, IEnumerable<DocumentFigure> figures = default, IEnumerable<DocumentAnnotation> annotations = default, IEnumerable<DocumentHyperlink> hyperlinks = default, IEnumerable<DocumentContentSegment> segments = default)
        {
            fields ??= new ChangeTrackingDictionary<string, ContentField>();
            pages ??= new ChangeTrackingList<DocumentPage>();
            paragraphs ??= new ChangeTrackingList<DocumentParagraph>();
            sections ??= new ChangeTrackingList<DocumentSection>();
            tables ??= new ChangeTrackingList<DocumentTable>();
            figures ??= new ChangeTrackingList<DocumentFigure>();
            annotations ??= new ChangeTrackingList<DocumentAnnotation>();
            hyperlinks ??= new ChangeTrackingList<DocumentHyperlink>();
            segments ??= new ChangeTrackingList<DocumentContentSegment>();

            return new DocumentContent(
                MediaContentKind.Document,
                mimeType,
                analyzerId,
                category,
                path,
                markdown,
                fields,
                additionalBinaryDataProperties: null,
                startPageNumber,
                endPageNumber,
                unit,
                pages.ToList(),
                paragraphs.ToList(),
                sections.ToList(),
                tables.ToList(),
                figures.ToList(),
                annotations.ToList(),
                hyperlinks.ToList(),
                segments.ToList());
        }

        /// <summary> Content from a document page. </summary>
        /// <param name="pageNumber"> Page number (1-based). </param>
        /// <param name="width"> Width of the page. </param>
        /// <param name="height"> Height of the page. </param>
        /// <param name="spans"> Span(s) associated with the page in the markdown content. </param>
        /// <param name="angle">
        /// The general orientation of the content in clockwise direction,
        /// measured in degrees between (-180, 180].
        /// Only if enableOcr is true.
        /// </param>
        /// <param name="words"> List of words in the page.  Only if enableOcr and returnDetails are true. </param>
        /// <param name="lines"> List of lines in the page.  Only if enableOcr and returnDetails are true. </param>
        /// <param name="barcodes"> List of barcodes in the page.  Only if enableBarcode and returnDetails are true. </param>
        /// <param name="formulas"> List of mathematical formulas in the page.  Only if enableFormula and returnDetails are true. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentPage"/> instance for mocking. </returns>
        public static DocumentPage DocumentPage(int pageNumber = default, float? width = default, float? height = default, IEnumerable<ContentSpan> spans = default, float? angle = default, IEnumerable<DocumentWord> words = default, IEnumerable<DocumentLine> lines = default, IEnumerable<DocumentBarcode> barcodes = default, IEnumerable<DocumentFormula> formulas = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();
            words ??= new ChangeTrackingList<DocumentWord>();
            lines ??= new ChangeTrackingList<DocumentLine>();
            barcodes ??= new ChangeTrackingList<DocumentBarcode>();
            formulas ??= new ChangeTrackingList<DocumentFormula>();

            return new DocumentPage(
                pageNumber,
                width,
                height,
                spans.ToList(),
                angle,
                words.ToList(),
                lines.ToList(),
                barcodes.ToList(),
                formulas.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Word in a document, consisting of a contiguous sequence of characters.
        /// For non-space delimited languages, such as Chinese, Japanese, and Korean, 
        /// each character is represented as its own word.
        /// </summary>
        /// <param name="content"> Word text. </param>
        /// <param name="source"> Encoded source that identifies the position of the word in the content. </param>
        /// <param name="span"> Span of the word in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the word. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentWord"/> instance for mocking. </returns>
        public static DocumentWord DocumentWord(string content = default, string source = default, ContentSpan span = default, float? confidence = default)
        {
            return new DocumentWord(content, source, span, confidence, additionalBinaryDataProperties: null);
        }

        /// <summary> Line in a document, consisting of an contiguous sequence of words. </summary>
        /// <param name="content"> Line text. </param>
        /// <param name="source"> Encoded source that identifies the position of the line in the content. </param>
        /// <param name="span"> Span of the line in the markdown content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentLine"/> instance for mocking. </returns>
        public static DocumentLine DocumentLine(string content = default, string source = default, ContentSpan span = default)
        {
            return new DocumentLine(content, source, span, additionalBinaryDataProperties: null);
        }

        /// <summary> Barcode in a document. </summary>
        /// <param name="kind"> Barcode kind. </param>
        /// <param name="value"> Barcode value. </param>
        /// <param name="source"> Encoded source that identifies the position of the barcode in the content. </param>
        /// <param name="span"> Span of the barcode in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the barcode. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentBarcode"/> instance for mocking. </returns>
        public static DocumentBarcode DocumentBarcode(DocumentBarcodeKind kind = default, string value = default, string source = default, ContentSpan span = default, float? confidence = default)
        {
            return new DocumentBarcode(
                kind,
                value,
                source,
                span,
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Mathematical formula in a document. </summary>
        /// <param name="kind"> Formula kind. </param>
        /// <param name="value"> LaTex expression describing the formula. </param>
        /// <param name="source"> Encoded source that identifies the position of the formula in the content. </param>
        /// <param name="span"> Span of the formula in the markdown content. </param>
        /// <param name="confidence"> Confidence of predicting the formula. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentFormula"/> instance for mocking. </returns>
        public static DocumentFormula DocumentFormula(DocumentFormulaKind kind = default, string value = default, string source = default, ContentSpan span = default, float? confidence = default)
        {
            return new DocumentFormula(
                kind,
                value,
                source,
                span,
                confidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Paragraph in a document, generally consisting of an contiguous sequence of lines
        /// with common alignment and spacing.
        /// </summary>
        /// <param name="role"> Semantic role of the paragraph. </param>
        /// <param name="content"> Paragraph text. </param>
        /// <param name="source"> Encoded source that identifies the position of the paragraph in the content. </param>
        /// <param name="span"> Span of the paragraph in the markdown content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentParagraph"/> instance for mocking. </returns>
        public static DocumentParagraph DocumentParagraph(SemanticRole? role = default, string content = default, string source = default, ContentSpan span = default)
        {
            return new DocumentParagraph(role, content, source, span, additionalBinaryDataProperties: null);
        }

        /// <summary> Section in a document. </summary>
        /// <param name="span"> Span of the section in the markdown content. </param>
        /// <param name="elements"> Child elements of the section. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentSection"/> instance for mocking. </returns>
        public static DocumentSection DocumentSection(ContentSpan span = default, IEnumerable<string> elements = default)
        {
            elements ??= new ChangeTrackingList<string>();

            return new DocumentSection(span, elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Table in a document, consisting table cells arranged in a rectangular layout. </summary>
        /// <param name="rowCount"> Number of rows in the table. </param>
        /// <param name="columnCount"> Number of columns in the table. </param>
        /// <param name="cells"> Cells contained within the table. </param>
        /// <param name="source"> Encoded source that identifies the position of the table in the content. </param>
        /// <param name="span"> Span of the table in the markdown content. </param>
        /// <param name="caption"> Table caption. </param>
        /// <param name="footnotes"> List of table footnotes. </param>
        /// <param name="role"> Semantic role of the table. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentTable"/> instance for mocking. </returns>
        public static DocumentTable DocumentTable(int rowCount = default, int columnCount = default, IEnumerable<DocumentTableCell> cells = default, string source = default, ContentSpan span = default, DocumentCaption caption = default, IEnumerable<DocumentFootnote> footnotes = default, SemanticRole? role = default)
        {
            cells ??= new ChangeTrackingList<DocumentTableCell>();
            footnotes ??= new ChangeTrackingList<DocumentFootnote>();

            return new DocumentTable(
                rowCount,
                columnCount,
                cells.ToList(),
                source,
                span,
                caption,
                footnotes.ToList(),
                role,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Table cell in a document table. </summary>
        /// <param name="kind"> Table cell kind. </param>
        /// <param name="rowIndex"> Row index of the cell. </param>
        /// <param name="columnIndex"> Column index of the cell. </param>
        /// <param name="rowSpan"> Number of rows spanned by this cell. </param>
        /// <param name="columnSpan"> Number of columns spanned by this cell. </param>
        /// <param name="content"> Content of the table cell. </param>
        /// <param name="source"> Encoded source that identifies the position of the table cell in the content. </param>
        /// <param name="span"> Span of the table cell in the markdown content. </param>
        /// <param name="elements"> Child elements of the table cell. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentTableCell"/> instance for mocking. </returns>
        public static DocumentTableCell DocumentTableCell(DocumentTableCellKind? kind = default, int rowIndex = default, int columnIndex = default, int? rowSpan = default, int? columnSpan = default, string content = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default)
        {
            elements ??= new ChangeTrackingList<string>();

            return new DocumentTableCell(
                kind,
                rowIndex,
                columnIndex,
                rowSpan,
                columnSpan,
                content,
                source,
                span,
                elements.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Caption of a table or figure. </summary>
        /// <param name="content"> Content of the caption. </param>
        /// <param name="source"> Encoded source that identifies the position of the caption in the content. </param>
        /// <param name="span"> Span of the caption in the markdown content. </param>
        /// <param name="elements"> Child elements of the caption. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentCaption"/> instance for mocking. </returns>
        public static DocumentCaption DocumentCaption(string content = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default)
        {
            elements ??= new ChangeTrackingList<string>();

            return new DocumentCaption(content, source, span, elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Footnote of a table or figure. </summary>
        /// <param name="content"> Content of the footnote. </param>
        /// <param name="source"> Encoded source that identifies the position of the footnote in the content. </param>
        /// <param name="span"> Span of the footnote in the markdown content. </param>
        /// <param name="elements"> Child elements of the footnote. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentFootnote"/> instance for mocking. </returns>
        public static DocumentFootnote DocumentFootnote(string content = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default)
        {
            elements ??= new ChangeTrackingList<string>();

            return new DocumentFootnote(content, source, span, elements.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Figure in a document.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="ContentUnderstanding.DocumentChartFigure"/> and <see cref="ContentUnderstanding.DocumentMermaidFigure"/>.
        /// </summary>
        /// <param name="kind"> Figure kind. </param>
        /// <param name="id"> Figure identifier. </param>
        /// <param name="source"> Encoded source that identifies the position of the figure in the content. </param>
        /// <param name="span"> Span of the figure in the markdown content. </param>
        /// <param name="elements"> Child elements of the figure, excluding any caption or footnotes. </param>
        /// <param name="caption"> Figure caption. </param>
        /// <param name="footnotes"> List of figure footnotes. </param>
        /// <param name="description"> Description of the figure. </param>
        /// <param name="role"> Semantic role of the figure. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentFigure"/> instance for mocking. </returns>
        public static DocumentFigure DocumentFigure(string kind = default, string id = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default, DocumentCaption caption = default, IEnumerable<DocumentFootnote> footnotes = default, string description = default, SemanticRole? role = default)
        {
            elements ??= new ChangeTrackingList<string>();
            footnotes ??= new ChangeTrackingList<DocumentFootnote>();

            return new UnknownDocumentFigure(
                new DocumentFigureKind(kind),
                id,
                source,
                span,
                elements.ToList(),
                caption,
                footnotes.ToList(),
                description,
                role,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Figure containing a chart, such as a bar chart, line chart, or pie chart. </summary>
        /// <param name="id"> Figure identifier. </param>
        /// <param name="source"> Encoded source that identifies the position of the figure in the content. </param>
        /// <param name="span"> Span of the figure in the markdown content. </param>
        /// <param name="elements"> Child elements of the figure, excluding any caption or footnotes. </param>
        /// <param name="caption"> Figure caption. </param>
        /// <param name="footnotes"> List of figure footnotes. </param>
        /// <param name="description"> Description of the figure. </param>
        /// <param name="role"> Semantic role of the figure. </param>
        /// <param name="content"> Chart content represented using [Chart.js config](https://www.chartjs.org/docs/latest/configuration/). </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentChartFigure"/> instance for mocking. </returns>
        public static DocumentChartFigure DocumentChartFigure(string id = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default, DocumentCaption caption = default, IEnumerable<DocumentFootnote> footnotes = default, string description = default, SemanticRole? role = default, IDictionary<string, BinaryData> content = default)
        {
            elements ??= new ChangeTrackingList<string>();
            footnotes ??= new ChangeTrackingList<DocumentFootnote>();
            content ??= new ChangeTrackingDictionary<string, BinaryData>();

            return new DocumentChartFigure(
                DocumentFigureKind.Chart,
                id,
                source,
                span,
                elements.ToList(),
                caption,
                footnotes.ToList(),
                description,
                role,
                additionalBinaryDataProperties: null,
                content);
        }

        /// <summary> Figure containing a diagram, such as a flowchart or network diagram. </summary>
        /// <param name="id"> Figure identifier. </param>
        /// <param name="source"> Encoded source that identifies the position of the figure in the content. </param>
        /// <param name="span"> Span of the figure in the markdown content. </param>
        /// <param name="elements"> Child elements of the figure, excluding any caption or footnotes. </param>
        /// <param name="caption"> Figure caption. </param>
        /// <param name="footnotes"> List of figure footnotes. </param>
        /// <param name="description"> Description of the figure. </param>
        /// <param name="role"> Semantic role of the figure. </param>
        /// <param name="content"> Diagram content represented using [Mermaid syntax](https://mermaid.js.org/intro/). </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentMermaidFigure"/> instance for mocking. </returns>
        public static DocumentMermaidFigure DocumentMermaidFigure(string id = default, string source = default, ContentSpan span = default, IEnumerable<string> elements = default, DocumentCaption caption = default, IEnumerable<DocumentFootnote> footnotes = default, string description = default, SemanticRole? role = default, string content = default)
        {
            elements ??= new ChangeTrackingList<string>();
            footnotes ??= new ChangeTrackingList<DocumentFootnote>();

            return new DocumentMermaidFigure(
                DocumentFigureKind.Mermaid,
                id,
                source,
                span,
                elements.ToList(),
                caption,
                footnotes.ToList(),
                description,
                role,
                additionalBinaryDataProperties: null,
                content);
        }

        /// <summary> Annotation in a document, such as a strikethrough or a comment. </summary>
        /// <param name="id"> Annotation identifier. </param>
        /// <param name="kind"> Annotation kind. </param>
        /// <param name="spans"> Spans of the content associated with the annotation. </param>
        /// <param name="source"> Position of the annotation. </param>
        /// <param name="comments"> Comments associated with the annotation. </param>
        /// <param name="author"> Annotation author. </param>
        /// <param name="createdAt"> Date and time when the annotation was created. </param>
        /// <param name="lastModifiedAt"> Date and time when the annotation was last modified. </param>
        /// <param name="tags"> Tags associated with the annotation. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentAnnotation"/> instance for mocking. </returns>
        public static DocumentAnnotation DocumentAnnotation(string id = default, DocumentAnnotationKind kind = default, IEnumerable<ContentSpan> spans = default, string source = default, IEnumerable<DocumentAnnotationComment> comments = default, string author = default, DateTimeOffset? createdAt = default, DateTimeOffset? lastModifiedAt = default, IEnumerable<string> tags = default)
        {
            spans ??= new ChangeTrackingList<ContentSpan>();
            comments ??= new ChangeTrackingList<DocumentAnnotationComment>();
            tags ??= new ChangeTrackingList<string>();

            return new DocumentAnnotation(
                id,
                kind,
                spans.ToList(),
                source,
                comments.ToList(),
                author,
                createdAt,
                lastModifiedAt,
                tags.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Comment associated with a document annotation. </summary>
        /// <param name="message"> Comment message in Markdown. </param>
        /// <param name="author"> Author of the comment. </param>
        /// <param name="createdAt"> Date and time when the comment was created. </param>
        /// <param name="lastModifiedAt"> Date and time when the comment was last modified. </param>
        /// <param name="tags"> Tags associated with the comment. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentAnnotationComment"/> instance for mocking. </returns>
        public static DocumentAnnotationComment DocumentAnnotationComment(string message = default, string author = default, DateTimeOffset? createdAt = default, DateTimeOffset? lastModifiedAt = default, IEnumerable<string> tags = default)
        {
            tags ??= new ChangeTrackingList<string>();

            return new DocumentAnnotationComment(
                message,
                author,
                createdAt,
                lastModifiedAt,
                tags.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Hyperlink in a document, such as a link to a web page or an email address. </summary>
        /// <param name="content"> Hyperlinked content. </param>
        /// <param name="url"> URL of the hyperlink. </param>
        /// <param name="span"> Span of the hyperlink in the markdown content. </param>
        /// <param name="source"> Position of the hyperlink. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentHyperlink"/> instance for mocking. </returns>
        public static DocumentHyperlink DocumentHyperlink(string content = default, string url = default, ContentSpan span = default, string source = default)
        {
            return new DocumentHyperlink(content, url, span, source, additionalBinaryDataProperties: null);
        }

        /// <summary> Detected document content segment. </summary>
        /// <param name="segmentId"> Segment identifier. </param>
        /// <param name="category"> Classified content category. </param>
        /// <param name="span"> Span of the segment in the markdown content. </param>
        /// <param name="startPageNumber"> Start page number (1-indexed) of the segment. </param>
        /// <param name="endPageNumber"> End page number (1-indexed) of the segment. </param>
        /// <returns> A new <see cref="ContentUnderstanding.DocumentContentSegment"/> instance for mocking. </returns>
        public static DocumentContentSegment DocumentContentSegment(string segmentId = default, string category = default, ContentSpan span = default, int startPageNumber = default, int endPageNumber = default)
        {
            return new DocumentContentSegment(
                segmentId,
                category,
                span,
                startPageNumber,
                endPageNumber,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Audio visual content.  Ex. audio/wav, video/mp4. </summary>
        /// <param name="mimeType"> Detected MIME type of the content.  Ex. application/pdf, image/jpeg, etc. </param>
        /// <param name="analyzerId"> The analyzer that generated this content. </param>
        /// <param name="category"> Classified content category. </param>
        /// <param name="path"> The path of the content in the input. </param>
        /// <param name="markdown"> Markdown representation of the content. </param>
        /// <param name="fields"> Extracted fields from the content. </param>
        /// <param name="startTimeMs"> Start time of the content in milliseconds. </param>
        /// <param name="endTimeMs"> End time of the content in milliseconds. </param>
        /// <param name="width"> Width of each video frame in pixels, if applicable. </param>
        /// <param name="height"> Height of each video frame in pixels, if applicable. </param>
        /// <param name="cameraShotTimesMs"> List of camera shot changes in the video, represented by its timestamp in milliseconds.  Only if returnDetails is true. </param>
        /// <param name="keyFrameTimesMs"> List of key frames in the video, represented by its timestamp in milliseconds.  Only if returnDetails is true. </param>
        /// <param name="transcriptPhrases"> List of transcript phrases.  Only if returnDetails is true. </param>
        /// <param name="segments"> List of detected content segments.  Only if enableSegment is true. </param>
        /// <returns> A new <see cref="ContentUnderstanding.AudioVisualContent"/> instance for mocking. </returns>
        public static AudioVisualContent AudioVisualContent(string mimeType = default, string analyzerId = default, string category = default, string path = default, string markdown = default, IDictionary<string, ContentField> fields = default, long startTimeMs = default, long endTimeMs = default, int? width = default, int? height = default, IEnumerable<long> cameraShotTimesMs = default, IEnumerable<long> keyFrameTimesMs = default, IEnumerable<TranscriptPhrase> transcriptPhrases = default, IEnumerable<AudioVisualContentSegment> segments = default)
        {
            fields ??= new ChangeTrackingDictionary<string, ContentField>();
            cameraShotTimesMs ??= new ChangeTrackingList<long>();
            keyFrameTimesMs ??= new ChangeTrackingList<long>();
            transcriptPhrases ??= new ChangeTrackingList<TranscriptPhrase>();
            segments ??= new ChangeTrackingList<AudioVisualContentSegment>();

            return new AudioVisualContent(
                MediaContentKind.AudioVisual,
                mimeType,
                analyzerId,
                category,
                path,
                markdown,
                fields,
                additionalBinaryDataProperties: null,
                startTimeMs,
                endTimeMs,
                width,
                height,
                cameraShotTimesMs.ToList(),
                keyFrameTimesMs.ToList(),
                transcriptPhrases.ToList(),
                segments.ToList());
        }

        /// <summary> Transcript phrase. </summary>
        /// <param name="speaker"> Speaker index or name. </param>
        /// <param name="startTimeMs"> Start time of the phrase in milliseconds. </param>
        /// <param name="endTimeMs"> End time of the phrase in milliseconds. </param>
        /// <param name="locale"> Detected locale of the phrase.  Ex. en-US. </param>
        /// <param name="text"> Transcript text. </param>
        /// <param name="confidence"> Confidence of predicting the phrase. </param>
        /// <param name="span"> Span of the phrase in the markdown content. </param>
        /// <param name="words"> List of words in the phrase. </param>
        /// <returns> A new <see cref="ContentUnderstanding.TranscriptPhrase"/> instance for mocking. </returns>
        public static TranscriptPhrase TranscriptPhrase(string speaker = default, long startTimeMs = default, long endTimeMs = default, string locale = default, string text = default, float? confidence = default, ContentSpan span = default, IEnumerable<TranscriptWord> words = default)
        {
            words ??= new ChangeTrackingList<TranscriptWord>();

            return new TranscriptPhrase(
                speaker,
                startTimeMs,
                endTimeMs,
                locale,
                text,
                confidence,
                span,
                words.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Transcript word. </summary>
        /// <param name="startTimeMs"> Start time of the word in milliseconds. </param>
        /// <param name="endTimeMs"> End time of the word in milliseconds. </param>
        /// <param name="text"> Transcript text. </param>
        /// <param name="span"> Span of the word in the markdown content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.TranscriptWord"/> instance for mocking. </returns>
        public static TranscriptWord TranscriptWord(long startTimeMs = default, long endTimeMs = default, string text = default, ContentSpan span = default)
        {
            return new TranscriptWord(startTimeMs, endTimeMs, text, span, additionalBinaryDataProperties: null);
        }

        /// <summary> Detected audio/visual content segment. </summary>
        /// <param name="segmentId"> Segment identifier. </param>
        /// <param name="category"> Classified content category. </param>
        /// <param name="span"> Span of the segment in the markdown content. </param>
        /// <param name="startTimeMs"> Start time of the segment in milliseconds. </param>
        /// <param name="endTimeMs"> End time of the segment in milliseconds. </param>
        /// <returns> A new <see cref="ContentUnderstanding.AudioVisualContentSegment"/> instance for mocking. </returns>
        public static AudioVisualContentSegment AudioVisualContentSegment(string segmentId = default, string category = default, ContentSpan span = default, long startTimeMs = default, long endTimeMs = default)
        {
            return new AudioVisualContentSegment(
                segmentId,
                category,
                span,
                startTimeMs,
                endTimeMs,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Analyzer that extracts content and fields from multimodal documents. </summary>
        /// <param name="analyzerId"> The unique identifier of the analyzer. </param>
        /// <param name="description"> A description of the analyzer. </param>
        /// <param name="tags"> Tags associated with the analyzer. </param>
        /// <param name="status"> The status of the analyzer. </param>
        /// <param name="createdAt"> The date and time when the analyzer was created. </param>
        /// <param name="lastModifiedAt"> The date and time when the analyzer was last modified. </param>
        /// <param name="warnings"> Warnings encountered while creating the analyzer. </param>
        /// <param name="baseAnalyzerId"> The analyzer to incrementally train from. </param>
        /// <param name="config"> Analyzer configuration settings. </param>
        /// <param name="fieldSchema"> The schema of fields to extracted. </param>
        /// <param name="dynamicFieldSchema"> Indicates whether the result may contain additional fields outside of the defined schema. </param>
        /// <param name="processingLocation"> The location where the data may be processed.  Defaults to global. </param>
        /// <param name="knowledgeSources"> Additional knowledge sources used to enhance the analyzer. </param>
        /// <param name="models">
        /// Mapping of model roles to specific model names.
        /// Ex. { "completion": "gpt-4.1", "embedding": "text-embedding-3-large" }.
        /// </param>
        /// <param name="supportedModels"> Chat completion and embedding models supported by the analyzer. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentAnalyzer"/> instance for mocking. </returns>
        public static ContentAnalyzer ContentAnalyzer(string analyzerId = default, string description = default, IDictionary<string, string> tags = default, ContentAnalyzerStatus status = default, DateTimeOffset createdAt = default, DateTimeOffset lastModifiedAt = default, IEnumerable<ResponseError> warnings = default, string baseAnalyzerId = default, ContentAnalyzerConfig config = default, ContentFieldSchema fieldSchema = default, bool? dynamicFieldSchema = default, ProcessingLocation? processingLocation = default, IEnumerable<KnowledgeSource> knowledgeSources = default, IDictionary<string, string> models = default, SupportedModels supportedModels = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            warnings ??= new ChangeTrackingList<ResponseError>();
            knowledgeSources ??= new ChangeTrackingList<KnowledgeSource>();
            models ??= new ChangeTrackingDictionary<string, string>();

            return new ContentAnalyzer(
                analyzerId,
                description,
                tags,
                status,
                createdAt,
                lastModifiedAt,
                warnings.ToList(),
                baseAnalyzerId,
                config,
                fieldSchema,
                dynamicFieldSchema,
                processingLocation,
                knowledgeSources.ToList(),
                models,
                supportedModels,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Configuration settings for an analyzer. </summary>
        /// <param name="returnDetails"> Return all content details. </param>
        /// <param name="locales"> List of locale hints for speech transcription. </param>
        /// <param name="enableOcr"> Enable optical character recognition (OCR). </param>
        /// <param name="enableLayout"> Enable layout analysis. </param>
        /// <param name="enableFigureDescription"> Enable generation of figure description. </param>
        /// <param name="enableFigureAnalysis"> Enable analysis of figures, such as charts and diagrams. </param>
        /// <param name="enableFormula"> Enable mathematical formula detection. </param>
        /// <param name="tableFormat"> Representation format of tables in analyze result markdown. </param>
        /// <param name="chartFormat"> Representation format of charts in analyze result markdown. </param>
        /// <param name="annotationFormat"> Representation format of annotations in analyze result markdown. </param>
        /// <param name="disableFaceBlurring"> Disable the default blurring of faces for privacy while processing the content. </param>
        /// <param name="estimateFieldSourceAndConfidence"> Return field grounding source and confidence. </param>
        /// <param name="contentCategories"> Map of categories to classify the input content(s) against. </param>
        /// <param name="enableSegment"> Enable segmentation of the input by contentCategories. </param>
        /// <param name="segmentPerPage"> Force segmentation of document content by page. </param>
        /// <param name="omitContent">
        /// Omit the content for this analyzer from analyze result.
        /// Only return content(s) from additional analyzers specified in contentCategories, if any.
        /// </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentAnalyzerConfig"/> instance for mocking. </returns>
        public static ContentAnalyzerConfig ContentAnalyzerConfig(bool? returnDetails = default, IEnumerable<string> locales = default, bool? enableOcr = default, bool? enableLayout = default, bool? enableFigureDescription = default, bool? enableFigureAnalysis = default, bool? enableFormula = default, TableFormat? tableFormat = default, ChartFormat? chartFormat = default, AnnotationFormat? annotationFormat = default, bool? disableFaceBlurring = default, bool? estimateFieldSourceAndConfidence = default, IDictionary<string, ContentCategoryDefinition> contentCategories = default, bool? enableSegment = default, bool? segmentPerPage = default, bool? omitContent = default)
        {
            locales ??= new ChangeTrackingList<string>();
            contentCategories ??= new ChangeTrackingDictionary<string, ContentCategoryDefinition>();

            return new ContentAnalyzerConfig(
                returnDetails,
                locales.ToList(),
                enableOcr,
                enableLayout,
                enableFigureDescription,
                enableFigureAnalysis,
                enableFormula,
                tableFormat,
                chartFormat,
                annotationFormat,
                disableFaceBlurring,
                estimateFieldSourceAndConfidence,
                contentCategories,
                enableSegment,
                segmentPerPage,
                omitContent,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Content category definition. </summary>
        /// <param name="description"> The description of the category. </param>
        /// <param name="analyzerId"> Optional analyzer used to process the content. </param>
        /// <param name="analyzer"> Optional inline definition of analyzer used to process the content. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentCategoryDefinition"/> instance for mocking. </returns>
        public static ContentCategoryDefinition ContentCategoryDefinition(string description = default, string analyzerId = default, ContentAnalyzer analyzer = default)
        {
            return new ContentCategoryDefinition(description, analyzerId, analyzer, additionalBinaryDataProperties: null);
        }

        /// <summary> Schema of fields to be extracted from documents. </summary>
        /// <param name="name"> The name of the field schema. </param>
        /// <param name="description"> A description of the field schema. </param>
        /// <param name="fields"> The fields defined in the schema. </param>
        /// <param name="definitions"> Additional definitions referenced by the fields in the schema. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentFieldSchema"/> instance for mocking. </returns>
        public static ContentFieldSchema ContentFieldSchema(string name = default, string description = default, IDictionary<string, ContentFieldDefinition> fields = default, IDictionary<string, ContentFieldDefinition> definitions = default)
        {
            fields ??= new ChangeTrackingDictionary<string, ContentFieldDefinition>();
            definitions ??= new ChangeTrackingDictionary<string, ContentFieldDefinition>();

            return new ContentFieldSchema(name, description, fields, definitions, additionalBinaryDataProperties: null);
        }

        /// <summary> Definition of the field using a JSON Schema like syntax. </summary>
        /// <param name="method"> Generation method. </param>
        /// <param name="type"> Semantic data type of the field value. </param>
        /// <param name="description"> Field description. </param>
        /// <param name="itemDefinition"> Field type schema of each array element, if type is array. </param>
        /// <param name="properties"> Named sub-fields, if type is object. </param>
        /// <param name="examples"> Examples of field values. </param>
        /// <param name="enum"> Enumeration of possible field values. </param>
        /// <param name="enumDescriptions"> Descriptions for each enumeration value. </param>
        /// <param name="ref"> Reference to another field definition. </param>
        /// <param name="estimateSourceAndConfidence"> Return grounding source and confidence. </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentFieldDefinition"/> instance for mocking. </returns>
        public static ContentFieldDefinition ContentFieldDefinition(GenerationMethod? @method = default, ContentFieldType? @type = default, string description = default, ContentFieldDefinition itemDefinition = default, IDictionary<string, ContentFieldDefinition> properties = default, IEnumerable<string> examples = default, IEnumerable<string> @enum = default, IDictionary<string, string> enumDescriptions = default, string @ref = default, bool? estimateSourceAndConfidence = default)
        {
            properties ??= new ChangeTrackingDictionary<string, ContentFieldDefinition>();
            examples ??= new ChangeTrackingList<string>();
            @enum ??= new ChangeTrackingList<string>();
            enumDescriptions ??= new ChangeTrackingDictionary<string, string>();

            return new ContentFieldDefinition(
                @method,
                @type,
                description,
                itemDefinition,
                properties,
                examples.ToList(),
                @enum.ToList(),
                enumDescriptions,
                @ref,
                estimateSourceAndConfidence,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Knowledge source.
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="ContentUnderstanding.LabeledDataKnowledgeSource"/>.
        /// </summary>
        /// <param name="kind"> The kind of knowledge source. </param>
        /// <returns> A new <see cref="ContentUnderstanding.KnowledgeSource"/> instance for mocking. </returns>
        public static KnowledgeSource KnowledgeSource(string kind = default)
        {
            return new UnknownKnowledgeSource(new KnowledgeSourceKind(kind), additionalBinaryDataProperties: null);
        }

        /// <summary> Labeled data knowledge source. </summary>
        /// <param name="containerUrl"> The URL of the blob container containing labeled data. </param>
        /// <param name="prefix"> An optional prefix to filter blobs within the container. </param>
        /// <param name="fileListPath"> An optional path to a file listing specific blobs to include. </param>
        /// <returns> A new <see cref="ContentUnderstanding.LabeledDataKnowledgeSource"/> instance for mocking. </returns>
        public static LabeledDataKnowledgeSource LabeledDataKnowledgeSource(Uri containerUrl = default, string prefix = default, string fileListPath = default)
        {
            return new LabeledDataKnowledgeSource(KnowledgeSourceKind.LabeledData, additionalBinaryDataProperties: null, containerUrl, prefix, fileListPath);
        }

        /// <summary> Chat completion and embedding models supported by the analyzer. </summary>
        /// <param name="completion"> Chat completion models supported by the analyzer. </param>
        /// <param name="embedding"> Embedding models supported by the analyzer. </param>
        /// <returns> A new <see cref="ContentUnderstanding.SupportedModels"/> instance for mocking. </returns>
        public static SupportedModels SupportedModels(IEnumerable<string> completion = default, IEnumerable<string> embedding = default)
        {
            completion ??= new ChangeTrackingList<string>();
            embedding ??= new ChangeTrackingList<string>();

            return new SupportedModels(completion.ToList(), embedding.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> default settings for this Content Understanding resource. </summary>
        /// <param name="modelDeployments">
        /// Mapping of model names to deployments.
        /// Ex. { "gpt-4.1": "myGpt41Deployment", "text-embedding-3-large": "myTextEmbedding3LargeDeployment" }.
        /// </param>
        /// <returns> A new <see cref="ContentUnderstanding.ContentUnderstandingDefaults"/> instance for mocking. </returns>
        public static ContentUnderstandingDefaults ContentUnderstandingDefaults(IDictionary<string, string> modelDeployments = default)
        {
            modelDeployments ??= new ChangeTrackingDictionary<string, string>();

            return new ContentUnderstandingDefaults(modelDeployments, additionalBinaryDataProperties: null);
        }

        /// <summary> Copy authorization details for cross-resource copy. </summary>
        /// <param name="source"> Full path of the source analyzer. </param>
        /// <param name="targetAzureResourceId"> Azure resource ID of the target location to copy to. </param>
        /// <param name="expiresAt"> Date/time when the copy authorization expires. </param>
        /// <returns> A new <see cref="ContentUnderstanding.CopyAuthorization"/> instance for mocking. </returns>
        public static CopyAuthorization CopyAuthorization(string source = default, string targetAzureResourceId = default, DateTimeOffset expiresAt = default)
        {
            return new CopyAuthorization(source, targetAzureResourceId, expiresAt, additionalBinaryDataProperties: null);
        }
    }
}
