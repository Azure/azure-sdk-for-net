// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.Language.Conversations;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Language.Conversations.Authoring
{
    // Data plane generated client. The ConversationAuthoring service client.
    /// <summary> The ConversationAuthoring service client. </summary>
    public partial class ConversationAuthoringClient
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of ConversationAuthoringClient for mocking. </summary>
        protected ConversationAuthoringClient()
        {
        }

        /// <summary> Creates a new project or updates an existing one. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateProjectAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectKind = "Conversation",
        ///     projectName = "<projectName>",
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = await client.CreateProjectAsync("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// This sample shows how to call CreateProjectAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectKind = "Conversation",
        ///     settings = new {
        ///         confidenceThreshold = 123.45f,
        ///     },
        ///     projectName = "<projectName>",
        ///     multilingual = true,
        ///     description = "<description>",
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = await client.CreateProjectAsync("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("settings").GetProperty("confidenceThreshold").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("multilingual").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/create-project
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateProjectOptions</c>:
        /// <code>{
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateProjectAsync(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.CreateProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateProjectRequest(projectName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new project or updates an existing one. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateProject with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectKind = "Conversation",
        ///     projectName = "<projectName>",
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = client.CreateProject("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// This sample shows how to call CreateProject with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectKind = "Conversation",
        ///     settings = new {
        ///         confidenceThreshold = 123.45f,
        ///     },
        ///     projectName = "<projectName>",
        ///     multilingual = true,
        ///     description = "<description>",
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = client.CreateProject("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("settings").GetProperty("confidenceThreshold").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("multilingual").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/create-project
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateProjectOptions</c>:
        /// <code>{
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateProject(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.CreateProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateProjectRequest(projectName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetProjectAsync("<projectName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("settings").GetProperty("confidenceThreshold").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("multilingual").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-project
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetProjectAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectRequest(projectName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProject with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetProject("<projectName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("settings").GetProperty("confidenceThreshold").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("multilingual").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-project
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetProject(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectRequest(projectName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a deployment. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetDeploymentAsync("<projectName>", "<deploymentName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentName").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-deployment
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentAsync(string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(projectName, deploymentName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a deployment. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeployment with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetDeployment("<projectName>", "<deploymentName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentName").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-deployment
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeployment(string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(projectName, deploymentName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetDeploymentJobStatusAsync("<projectName>", "<deploymentName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-deployment-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentJobStatusAsync(string projectName, string deploymentName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetDeploymentJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentJobStatusRequest(projectName, deploymentName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetDeploymentJobStatus("<projectName>", "<deploymentName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-deployment-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentJobStatus(string projectName, string deploymentName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetDeploymentJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentJobStatusRequest(projectName, deploymentName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing swap deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSwapDeploymentsJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetSwapDeploymentsJobStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-swap-deployments-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSwapDeploymentsJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetSwapDeploymentsJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSwapDeploymentsJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing swap deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSwapDeploymentsJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetSwapDeploymentsJobStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-swap-deployments-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSwapDeploymentsJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetSwapDeploymentsJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSwapDeploymentsJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an export job. Once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetExportProjectJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetExportProjectJobStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("resultUrl").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-export-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetExportProjectJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetExportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetExportProjectJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an export job. Once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetExportProjectJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetExportProjectJobStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("resultUrl").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-export-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetExportProjectJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetExportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetExportProjectJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for an import. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetImportProjectJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetImportProjectJobStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-import-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetImportProjectJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetImportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetImportProjectJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for an import. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetImportProjectJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetImportProjectJobStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-import-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetImportProjectJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetImportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetImportProjectJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainedModelAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetTrainedModelAsync("<projectName>", "<trainedModelLabel>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        /// Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-trained-model
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectTrainedModel</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: string (date), # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTrainedModelAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainedModelRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainedModel with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetTrainedModel("<projectName>", "<trainedModelLabel>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        /// Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-trained-model
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectTrainedModel</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: string (date), # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTrainedModel(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainedModelRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an existing trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTrainedModelAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.DeleteTrainedModelAsync("<projectName>", "<trainedModelLabel>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteTrainedModelAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTrainedModelRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an existing trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTrainedModel with required parameters.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.DeleteTrainedModel("<projectName>", "<trainedModelLabel>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteTrainedModel(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTrainedModelRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the evaluation summary of a trained model. The summary includes high level performance measurements of the model e.g., F1, Precision, Recall, etc. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetModelEvaluationSummaryAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetModelEvaluationSummaryAsync("<projectName>", "<trainedModelLabel>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("confusionMatrix").GetProperty("<test>").GetProperty("<test>").GetProperty("normalizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("confusionMatrix").GetProperty("<test>").GetProperty("<test>").GetProperty("rawValue").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("f1").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("precision").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("recall").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("truePositiveCount").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("trueNegativeCount").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("falsePositiveCount").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("falseNegativeCount").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("microF1").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("microPrecision").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("microRecall").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("macroF1").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("macroPrecision").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("macroRecall").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("confusionMatrix").GetProperty("<test>").GetProperty("<test>").GetProperty("normalizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("confusionMatrix").GetProperty("<test>").GetProperty("<test>").GetProperty("rawValue").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("f1").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("precision").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("recall").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("truePositiveCount").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("trueNegativeCount").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("falsePositiveCount").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("falseNegativeCount").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("microF1").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("microPrecision").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("microRecall").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("macroF1").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("macroPrecision").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("macroRecall").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("kind").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("trainingSplitPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("testingSplitPercentage").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-model-evaluation-summary
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EvaluationSummary</c>:
        /// <code>{
        ///   entitiesEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two entities (the two entities can be the same). The matrix is between the entity that was labelled and the entity that was predicted.
        ///     entities: Dictionary&lt;string, EntityEvaluationSummary&gt;, # Required. Represents the entities evaluation summary.
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to entities evaluation.
        ///   intentsEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two intents (the two intents can be the same). The matrix is between the intent that was labelled and the intent that was predicted.
        ///     intents: Dictionary&lt;string, IntentEvaluationSummary&gt;, # Required. Represents the intents evaluation summary.
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to intents evaluation.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. The options that were used while running the evaluation.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetModelEvaluationSummaryAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetModelEvaluationSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetModelEvaluationSummaryRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the evaluation summary of a trained model. The summary includes high level performance measurements of the model e.g., F1, Precision, Recall, etc. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetModelEvaluationSummary with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetModelEvaluationSummary("<projectName>", "<trainedModelLabel>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("confusionMatrix").GetProperty("<test>").GetProperty("<test>").GetProperty("normalizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("confusionMatrix").GetProperty("<test>").GetProperty("<test>").GetProperty("rawValue").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("f1").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("precision").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("recall").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("truePositiveCount").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("trueNegativeCount").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("falsePositiveCount").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("entities").GetProperty("<test>").GetProperty("falseNegativeCount").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("microF1").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("microPrecision").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("microRecall").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("macroF1").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("macroPrecision").ToString());
        /// Console.WriteLine(result.GetProperty("entitiesEvaluation").GetProperty("macroRecall").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("confusionMatrix").GetProperty("<test>").GetProperty("<test>").GetProperty("normalizedValue").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("confusionMatrix").GetProperty("<test>").GetProperty("<test>").GetProperty("rawValue").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("f1").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("precision").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("recall").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("truePositiveCount").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("trueNegativeCount").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("falsePositiveCount").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("intents").GetProperty("<test>").GetProperty("falseNegativeCount").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("microF1").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("microPrecision").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("microRecall").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("macroF1").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("macroPrecision").ToString());
        /// Console.WriteLine(result.GetProperty("intentsEvaluation").GetProperty("macroRecall").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("kind").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("trainingSplitPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("testingSplitPercentage").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-model-evaluation-summary
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EvaluationSummary</c>:
        /// <code>{
        ///   entitiesEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two entities (the two entities can be the same). The matrix is between the entity that was labelled and the entity that was predicted.
        ///     entities: Dictionary&lt;string, EntityEvaluationSummary&gt;, # Required. Represents the entities evaluation summary.
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to entities evaluation.
        ///   intentsEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two intents (the two intents can be the same). The matrix is between the intent that was labelled and the intent that was predicted.
        ///     intents: Dictionary&lt;string, IntentEvaluationSummary&gt;, # Required. Represents the intents evaluation summary.
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to intents evaluation.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. The options that were used while running the evaluation.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetModelEvaluationSummary(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetModelEvaluationSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetModelEvaluationSummaryRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a training job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetTrainingJobStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingMode").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-training-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTrainingJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetTrainingJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainingJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a training job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetTrainingJobStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingMode").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-training-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTrainingJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetTrainingJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainingJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a project deletion job. </summary>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectDeletionJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetProjectDeletionJobStatusAsync("<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-project-deletion-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetProjectDeletionJobStatusAsync(string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetProjectDeletionJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectDeletionJobStatusRequest(jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a project deletion job. </summary>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectDeletionJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetProjectDeletionJobStatus("<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-project-deletion-status
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetProjectDeletionJobStatus(string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetProjectDeletionJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectDeletionJobStatusRequest(jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the existing projects. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetProjectsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        ///     Console.WriteLine(result.GetProperty("settings").GetProperty("confidenceThreshold").ToString());
        ///     Console.WriteLine(result.GetProperty("projectName").ToString());
        ///     Console.WriteLine(result.GetProperty("multilingual").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-projects
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectsMetadataValue</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetProjectsAsync(RequestContext context = null)
        {
            return GetProjectsImplementationAsync("ConversationAuthoringClient.GetProjects", context);
        }

        private AsyncPageable<BinaryData> GetProjectsImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetProjectsRequest(context)
                        : CreateGetProjectsNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the existing projects. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjects and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetProjects())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        ///     Console.WriteLine(result.GetProperty("settings").GetProperty("confidenceThreshold").ToString());
        ///     Console.WriteLine(result.GetProperty("projectName").ToString());
        ///     Console.WriteLine(result.GetProperty("multilingual").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-projects
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectsMetadataValue</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetProjects(RequestContext context = null)
        {
            return GetProjectsImplementation("ConversationAuthoringClient.GetProjects", context);
        }

        private Pageable<BinaryData> GetProjectsImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetProjectsRequest(context)
                        : CreateGetProjectsNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the deployments belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentName").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-deployments
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectDeploymentsValue</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetDeploymentsImplementationAsync("ConversationAuthoringClient.GetDeployments", projectName, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsImplementationAsync(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsRequest(projectName, context)
                        : CreateGetDeploymentsNextPageRequest(nextLink, projectName, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the deployments belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeployments with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetDeployments("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentName").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-deployments
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectDeploymentsValue</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeployments(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetDeploymentsImplementation("ConversationAuthoringClient.GetDeployments", projectName, context);
        }

        private Pageable<BinaryData> GetDeploymentsImplementation(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsRequest(projectName, context)
                        : CreateGetDeploymentsNextPageRequest(nextLink, projectName, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the trained models belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainedModelsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainedModelsAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("label").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-trained-models
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectTrainedModelsValue</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: string (date), # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainedModelsAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainedModelsImplementationAsync("ConversationAuthoringClient.GetTrainedModels", projectName, context);
        }

        private AsyncPageable<BinaryData> GetTrainedModelsImplementationAsync(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainedModelsRequest(projectName, context)
                        : CreateGetTrainedModelsNextPageRequest(nextLink, projectName, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the trained models belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainedModels with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainedModels("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("label").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-trained-models
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectTrainedModelsValue</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: string (date), # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainedModels(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainedModelsImplementation("ConversationAuthoringClient.GetTrainedModels", projectName, context);
        }

        private Pageable<BinaryData> GetTrainedModelsImplementation(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainedModelsRequest(projectName, context)
                        : CreateGetTrainedModelsNextPageRequest(nextLink, projectName, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets the detailed results of the evaluation for a trained model. This includes the raw inference results for the data included in the evaluation process. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. Set this to &quot;Utf16CodeUnit&quot; for .NET strings, which are encoded as UTF-16. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="trainedModelLabel"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetModelEvaluationResultsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetModelEvaluationResultsAsync("<projectName>", "<trainedModelLabel>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("text").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("offset").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("length").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("offset").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("length").ToString());
        ///     Console.WriteLine(result.GetProperty("intentsResult").GetProperty("expectedIntent").ToString());
        ///     Console.WriteLine(result.GetProperty("intentsResult").GetProperty("predictedIntent").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetModelEvaluationResultsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetModelEvaluationResultsAsync("<projectName>", "<trainedModelLabel>", <Utf16CodeUnit>))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("text").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("offset").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("length").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("offset").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("length").ToString());
        ///     Console.WriteLine(result.GetProperty("intentsResult").GetProperty("expectedIntent").ToString());
        ///     Console.WriteLine(result.GetProperty("intentsResult").GetProperty("predictedIntent").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-model-evaluation-results
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringEvaluationResultsValue</c>:
        /// <code>{
        ///   text: string, # Required. Represents the utterance text.
        ///   language: string, # Required. Represents the utterance language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   entitiesResult: {
        ///     expectedEntities: [
        ///       {
        ///         category: string, # Required. Represents the entity category.
        ///         offset: number, # Required. Represents the entity offset index relative to the original text.
        ///         length: number, # Required. Represents the entity length.
        ///       }
        ///     ], # Required. Represents the expected entity labels.
        ///     predictedEntities: [UtteranceEntityEvaluationResult], # Required. Represents the predicted entity labels.
        ///   }, # Required. Represents the entities results for the utterance.
        ///   intentsResult: {
        ///     expectedIntent: string, # Required. Represents the utterance&apos;s expected intent.
        ///     predictedIntent: string, # Required. Represents the utterance&apos;s predicted intent.
        ///   }, # Required. Represents the intents results for the utterance.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetModelEvaluationResultsAsync(string projectName, string trainedModelLabel, string stringIndexType = "Utf16CodeUnit", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            return GetModelEvaluationResultsImplementationAsync("ConversationAuthoringClient.GetModelEvaluationResults", projectName, trainedModelLabel, stringIndexType, context);
        }

        private AsyncPageable<BinaryData> GetModelEvaluationResultsImplementationAsync(string diagnosticsScopeName, string projectName, string trainedModelLabel, string stringIndexType, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetModelEvaluationResultsRequest(projectName, trainedModelLabel, stringIndexType, context)
                        : CreateGetModelEvaluationResultsNextPageRequest(nextLink, projectName, trainedModelLabel, stringIndexType, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets the detailed results of the evaluation for a trained model. This includes the raw inference results for the data included in the evaluation process. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. Set this to &quot;Utf16CodeUnit&quot; for .NET strings, which are encoded as UTF-16. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="trainedModelLabel"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetModelEvaluationResults with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetModelEvaluationResults("<projectName>", "<trainedModelLabel>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("text").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("offset").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("length").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("offset").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("length").ToString());
        ///     Console.WriteLine(result.GetProperty("intentsResult").GetProperty("expectedIntent").ToString());
        ///     Console.WriteLine(result.GetProperty("intentsResult").GetProperty("predictedIntent").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetModelEvaluationResults with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetModelEvaluationResults("<projectName>", "<trainedModelLabel>", <Utf16CodeUnit>))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("text").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("offset").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("expectedEntities")[0].GetProperty("length").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("offset").ToString());
        ///     Console.WriteLine(result.GetProperty("entitiesResult").GetProperty("predictedEntities")[0].GetProperty("length").ToString());
        ///     Console.WriteLine(result.GetProperty("intentsResult").GetProperty("expectedIntent").ToString());
        ///     Console.WriteLine(result.GetProperty("intentsResult").GetProperty("predictedIntent").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-model-evaluation-results
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringEvaluationResultsValue</c>:
        /// <code>{
        ///   text: string, # Required. Represents the utterance text.
        ///   language: string, # Required. Represents the utterance language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   entitiesResult: {
        ///     expectedEntities: [
        ///       {
        ///         category: string, # Required. Represents the entity category.
        ///         offset: number, # Required. Represents the entity offset index relative to the original text.
        ///         length: number, # Required. Represents the entity length.
        ///       }
        ///     ], # Required. Represents the expected entity labels.
        ///     predictedEntities: [UtteranceEntityEvaluationResult], # Required. Represents the predicted entity labels.
        ///   }, # Required. Represents the entities results for the utterance.
        ///   intentsResult: {
        ///     expectedIntent: string, # Required. Represents the utterance&apos;s expected intent.
        ///     predictedIntent: string, # Required. Represents the utterance&apos;s predicted intent.
        ///   }, # Required. Represents the intents results for the utterance.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetModelEvaluationResults(string projectName, string trainedModelLabel, string stringIndexType = "Utf16CodeUnit", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            return GetModelEvaluationResultsImplementation("ConversationAuthoringClient.GetModelEvaluationResults", projectName, trainedModelLabel, stringIndexType, context);
        }

        private Pageable<BinaryData> GetModelEvaluationResultsImplementation(string diagnosticsScopeName, string projectName, string trainedModelLabel, string stringIndexType, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetModelEvaluationResultsRequest(projectName, trainedModelLabel, stringIndexType, context)
                        : CreateGetModelEvaluationResultsNextPageRequest(nextLink, projectName, trainedModelLabel, stringIndexType, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the non-expired training jobs created for a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingJobsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainingJobsAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingMode").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("jobId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-training-jobs
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringTrainingJobsValue</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainingJobsAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainingJobsImplementationAsync("ConversationAuthoringClient.GetTrainingJobs", projectName, context);
        }

        private AsyncPageable<BinaryData> GetTrainingJobsImplementationAsync(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingJobsRequest(projectName, context)
                        : CreateGetTrainingJobsNextPageRequest(nextLink, projectName, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the non-expired training jobs created for a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingJobs with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainingJobs("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingMode").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("jobId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-training-jobs
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringTrainingJobsValue</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainingJobs(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainingJobsImplementation("ConversationAuthoringClient.GetTrainingJobs", projectName, context);
        }

        private Pageable<BinaryData> GetTrainingJobsImplementation(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingJobsRequest(projectName, context)
                        : CreateGetTrainingJobsNextPageRequest(nextLink, projectName, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported languages for the given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;Conversation&quot; | &quot;Orchestration&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedLanguagesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSupportedLanguagesAsync("<projectKind>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("languageName").ToString());
        ///     Console.WriteLine(result.GetProperty("languageCode").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-supported-languages
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringSupportedLanguagesValue</c>:
        /// <code>{
        ///   languageName: string, # Required. The language name.
        ///   languageCode: string, # Required. The language code. This is BCP-47 representation of a language. For example, &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetSupportedLanguagesAsync(string projectKind, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetSupportedLanguagesImplementationAsync("ConversationAuthoringClient.GetSupportedLanguages", projectKind, context);
        }

        private AsyncPageable<BinaryData> GetSupportedLanguagesImplementationAsync(string diagnosticsScopeName, string projectKind, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedLanguagesRequest(projectKind, context)
                        : CreateGetSupportedLanguagesNextPageRequest(nextLink, projectKind, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported languages for the given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;Conversation&quot; | &quot;Orchestration&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedLanguages with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSupportedLanguages("<projectKind>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("languageName").ToString());
        ///     Console.WriteLine(result.GetProperty("languageCode").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-supported-languages
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringSupportedLanguagesValue</c>:
        /// <code>{
        ///   languageName: string, # Required. The language name.
        ///   languageCode: string, # Required. The language code. This is BCP-47 representation of a language. For example, &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetSupportedLanguages(string projectKind, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetSupportedLanguagesImplementation("ConversationAuthoringClient.GetSupportedLanguages", projectKind, context);
        }

        private Pageable<BinaryData> GetSupportedLanguagesImplementation(string diagnosticsScopeName, string projectKind, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedLanguagesRequest(projectKind, context)
                        : CreateGetSupportedLanguagesNextPageRequest(nextLink, projectKind, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported prebuilt entities that can be used while creating composed entities. </summary>
        /// <param name="language"> The language to get supported prebuilt entities for. Required if multilingual is false. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc. </param>
        /// <param name="multilingual"> Whether to get the support prebuilt entities for multilingual or monolingual projects. If true, the language parameter is ignored. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedPrebuiltEntitiesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSupportedPrebuiltEntitiesAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("examples").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetSupportedPrebuiltEntitiesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSupportedPrebuiltEntitiesAsync("<language>", true))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("examples").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-supported-prebuilt-entities
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringPrebuiltEntitiesValue</c>:
        /// <code>{
        ///   category: string, # Required. The prebuilt entity category.
        ///   description: string, # Required. The description.
        ///   examples: string, # Required. English examples for the entity.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetSupportedPrebuiltEntitiesAsync(string language = null, bool? multilingual = null, RequestContext context = null)
        {
            return GetSupportedPrebuiltEntitiesImplementationAsync("ConversationAuthoringClient.GetSupportedPrebuiltEntities", language, multilingual, context);
        }

        private AsyncPageable<BinaryData> GetSupportedPrebuiltEntitiesImplementationAsync(string diagnosticsScopeName, string language, bool? multilingual, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedPrebuiltEntitiesRequest(language, multilingual, context)
                        : CreateGetSupportedPrebuiltEntitiesNextPageRequest(nextLink, language, multilingual, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported prebuilt entities that can be used while creating composed entities. </summary>
        /// <param name="language"> The language to get supported prebuilt entities for. Required if multilingual is false. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc. </param>
        /// <param name="multilingual"> Whether to get the support prebuilt entities for multilingual or monolingual projects. If true, the language parameter is ignored. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedPrebuiltEntities and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSupportedPrebuiltEntities())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("examples").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetSupportedPrebuiltEntities with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSupportedPrebuiltEntities("<language>", true))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("category").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("examples").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/get-supported-prebuilt-entities
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringPrebuiltEntitiesValue</c>:
        /// <code>{
        ///   category: string, # Required. The prebuilt entity category.
        ///   description: string, # Required. The description.
        ///   examples: string, # Required. English examples for the entity.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetSupportedPrebuiltEntities(string language = null, bool? multilingual = null, RequestContext context = null)
        {
            return GetSupportedPrebuiltEntitiesImplementation("ConversationAuthoringClient.GetSupportedPrebuiltEntities", language, multilingual, context);
        }

        private Pageable<BinaryData> GetSupportedPrebuiltEntitiesImplementation(string diagnosticsScopeName, string language, bool? multilingual, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedPrebuiltEntitiesRequest(language, multilingual, context)
                        : CreateGetSupportedPrebuiltEntitiesNextPageRequest(nextLink, language, multilingual, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the support training config version for a given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;Conversation&quot; | &quot;Orchestration&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingConfigVersionsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainingConfigVersionsAsync("<projectKind>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-training-config-versions
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringTrainingConfigVersionsValue</c>:
        /// <code>{
        ///   trainingConfigVersion: string, # Required. Represents the version of the config.
        ///   modelExpirationDate: string (date), # Required. Represents the training config version expiration date.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainingConfigVersionsAsync(string projectKind, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetTrainingConfigVersionsImplementationAsync("ConversationAuthoringClient.GetTrainingConfigVersions", projectKind, context);
        }

        private AsyncPageable<BinaryData> GetTrainingConfigVersionsImplementationAsync(string diagnosticsScopeName, string projectKind, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingConfigVersionsRequest(projectKind, context)
                        : CreateGetTrainingConfigVersionsNextPageRequest(nextLink, projectKind, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the support training config version for a given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;Conversation&quot; | &quot;Orchestration&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingConfigVersions with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainingConfigVersions("<projectKind>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/list-training-config-versions
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringTrainingConfigVersionsValue</c>:
        /// <code>{
        ///   trainingConfigVersion: string, # Required. Represents the version of the config.
        ///   modelExpirationDate: string (date), # Required. Represents the training config version expiration date.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainingConfigVersions(string projectKind, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetTrainingConfigVersionsImplementation("ConversationAuthoringClient.GetTrainingConfigVersions", projectKind, context);
        }

        private Pageable<BinaryData> GetTrainingConfigVersionsImplementation(string diagnosticsScopeName, string projectKind, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingConfigVersionsRequest(projectKind, context)
                        : CreateGetTrainingConfigVersionsNextPageRequest(nextLink, projectKind, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Deletes a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteProjectAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.DeleteProjectAsync(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/delete-project
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeleteProjectAsync(WaitUntil waitUntil, string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteProjectRequest(projectName, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeleteProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteProject with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.DeleteProject(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/delete-project
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeleteProject(WaitUntil waitUntil, string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteProjectRequest(projectName, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeleteProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to export a project&apos;s data. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="exportedProjectFormat"> The format of the exported project file to use. Allowed values: &quot;Conversation&quot; | &quot;Luis&quot;. </param>
        /// <param name="assetKind"> Kind of asset to export. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. Set this to &quot;Utf16CodeUnit&quot; for .NET strings, which are encoded as UTF-16. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ExportProjectAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.ExportProjectAsync(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call ExportProjectAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.ExportProjectAsync(WaitUntil.Completed, "<projectName>", "<exportedProjectFormat>", "<assetKind>", <Utf16CodeUnit>);
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("resultUrl").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/export
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ExportProjectAsync(WaitUntil waitUntil, string projectName, string exportedProjectFormat = null, string assetKind = null, string stringIndexType = "Utf16CodeUnit", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.ExportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExportProjectRequest(projectName, exportedProjectFormat, assetKind, stringIndexType, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.ExportProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to export a project&apos;s data. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="exportedProjectFormat"> The format of the exported project file to use. Allowed values: &quot;Conversation&quot; | &quot;Luis&quot;. </param>
        /// <param name="assetKind"> Kind of asset to export. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. Set this to &quot;Utf16CodeUnit&quot; for .NET strings, which are encoded as UTF-16. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ExportProject with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.ExportProject(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call ExportProject with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.ExportProject(WaitUntil.Completed, "<projectName>", "<exportedProjectFormat>", "<assetKind>", <Utf16CodeUnit>);
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("resultUrl").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/export
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> ExportProject(WaitUntil waitUntil, string projectName, string exportedProjectFormat = null, string assetKind = null, string stringIndexType = "Utf16CodeUnit", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.ExportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExportProjectRequest(projectName, exportedProjectFormat, assetKind, stringIndexType, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.ExportProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to import a project. If a project with the same name already exists, the data of that project is replaced. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="exportedProjectFormat"> The format of the exported project file to use. Allowed values: &quot;Conversation&quot; | &quot;Luis&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ImportProjectAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectFileVersion = "<projectFileVersion>",
        ///     stringIndexType = "Utf16CodeUnit",
        ///     metadata = new {
        ///         projectKind = "Conversation",
        ///         projectName = "<projectName>",
        ///         language = "<language>",
        ///     },
        /// };
        /// 
        /// var operation = await client.ImportProjectAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call ImportProjectAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectFileVersion = "<projectFileVersion>",
        ///     stringIndexType = "Utf16CodeUnit",
        ///     metadata = new {
        ///         projectKind = "Conversation",
        ///         settings = new {
        ///             confidenceThreshold = 123.45f,
        ///         },
        ///         projectName = "<projectName>",
        ///         multilingual = true,
        ///         description = "<description>",
        ///         language = "<language>",
        ///     },
        ///     assets = new {
        ///         intents = new[] {
        ///             new {
        ///                 category = "<category>",
        ///             }
        ///         },
        ///         entities = new[] {
        ///             new {
        ///                 category = "<category>",
        ///                 compositionSetting = "returnLongestOverlap",
        ///                 list = new {
        ///                     sublists = new[] {
        ///                         new {
        ///                             listKey = "<listKey>",
        ///                             synonyms = new[] {
        ///                                 new {
        ///                                     language = "<language>",
        ///                                     values = new[] {
        ///                                         "<String>"
        ///                                     },
        ///                                 }
        ///                             },
        ///                         }
        ///                     },
        ///                 },
        ///                 prebuilts = new[] {
        ///                     new {
        ///                         category = "<category>",
        ///                     }
        ///                 },
        ///             }
        ///         },
        ///         utterances = new[] {
        ///             new {
        ///                 entities = new[] {
        ///                     new {
        ///                         category = "<category>",
        ///                         offset = 1234,
        ///                         length = 1234,
        ///                     }
        ///                 },
        ///                 text = "<text>",
        ///                 language = "<language>",
        ///                 intent = "<intent>",
        ///                 dataset = "<dataset>",
        ///             }
        ///         },
        ///         projectKind = "Conversation",
        ///     },
        /// };
        /// 
        /// var operation = await client.ImportProjectAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data), "<exportedProjectFormat>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/import
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ExportedProject</c>:
        /// <code>{
        ///   projectFileVersion: string, # Required. The version of the exported file.
        ///   stringIndexType: &quot;Utf16CodeUnit&quot;, # Required. Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets.
        ///   metadata: {
        ///     projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///     settings: {
        ///       confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///     }, # Optional. The project settings.
        ///     projectName: string, # Required. The new project name.
        ///     multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///     description: string, # Optional. The project description.
        ///     language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   }, # Required. Represents the project metadata.
        ///   assets: {
        ///     projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. The type of project containing the assets.
        ///   }, # Optional. Represents the project assets.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ImportProjectAsync(WaitUntil waitUntil, string projectName, RequestContent content, string exportedProjectFormat = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.ImportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportProjectRequest(projectName, content, exportedProjectFormat, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.ImportProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to import a project. If a project with the same name already exists, the data of that project is replaced. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="exportedProjectFormat"> The format of the exported project file to use. Allowed values: &quot;Conversation&quot; | &quot;Luis&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ImportProject with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectFileVersion = "<projectFileVersion>",
        ///     stringIndexType = "Utf16CodeUnit",
        ///     metadata = new {
        ///         projectKind = "Conversation",
        ///         projectName = "<projectName>",
        ///         language = "<language>",
        ///     },
        /// };
        /// 
        /// var operation = client.ImportProject(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call ImportProject with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectFileVersion = "<projectFileVersion>",
        ///     stringIndexType = "Utf16CodeUnit",
        ///     metadata = new {
        ///         projectKind = "Conversation",
        ///         settings = new {
        ///             confidenceThreshold = 123.45f,
        ///         },
        ///         projectName = "<projectName>",
        ///         multilingual = true,
        ///         description = "<description>",
        ///         language = "<language>",
        ///     },
        ///     assets = new {
        ///         intents = new[] {
        ///             new {
        ///                 category = "<category>",
        ///             }
        ///         },
        ///         entities = new[] {
        ///             new {
        ///                 category = "<category>",
        ///                 compositionSetting = "returnLongestOverlap",
        ///                 list = new {
        ///                     sublists = new[] {
        ///                         new {
        ///                             listKey = "<listKey>",
        ///                             synonyms = new[] {
        ///                                 new {
        ///                                     language = "<language>",
        ///                                     values = new[] {
        ///                                         "<String>"
        ///                                     },
        ///                                 }
        ///                             },
        ///                         }
        ///                     },
        ///                 },
        ///                 prebuilts = new[] {
        ///                     new {
        ///                         category = "<category>",
        ///                     }
        ///                 },
        ///             }
        ///         },
        ///         utterances = new[] {
        ///             new {
        ///                 entities = new[] {
        ///                     new {
        ///                         category = "<category>",
        ///                         offset = 1234,
        ///                         length = 1234,
        ///                     }
        ///                 },
        ///                 text = "<text>",
        ///                 language = "<language>",
        ///                 intent = "<intent>",
        ///                 dataset = "<dataset>",
        ///             }
        ///         },
        ///         projectKind = "Conversation",
        ///     },
        /// };
        /// 
        /// var operation = client.ImportProject(WaitUntil.Completed, "<projectName>", RequestContent.Create(data), "<exportedProjectFormat>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/import
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ExportedProject</c>:
        /// <code>{
        ///   projectFileVersion: string, # Required. The version of the exported file.
        ///   stringIndexType: &quot;Utf16CodeUnit&quot;, # Required. Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets.
        ///   metadata: {
        ///     projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///     settings: {
        ///       confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///     }, # Optional. The project settings.
        ///     projectName: string, # Required. The new project name.
        ///     multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///     description: string, # Optional. The project description.
        ///     language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   }, # Required. Represents the project metadata.
        ///   assets: {
        ///     projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. The type of project containing the assets.
        ///   }, # Optional. Represents the project assets.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> ImportProject(WaitUntil waitUntil, string projectName, RequestContent content, string exportedProjectFormat = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.ImportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportProjectRequest(projectName, content, exportedProjectFormat, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.ImportProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a training job for a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call TrainAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     modelLabel = "<modelLabel>",
        ///     trainingMode = "advanced",
        /// };
        /// 
        /// var operation = await client.TrainAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call TrainAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     modelLabel = "<modelLabel>",
        ///     trainingConfigVersion = "<trainingConfigVersion>",
        ///     trainingMode = "advanced",
        ///     evaluationOptions = new {
        ///         kind = "percentage",
        ///         trainingSplitPercentage = 1234,
        ///         testingSplitPercentage = 1234,
        ///     },
        /// };
        /// 
        /// var operation = await client.TrainAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingMode").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/train
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TrainingJobOptions</c>:
        /// <code>{
        ///   modelLabel: string, # Required. Represents the output model label.
        ///   trainingConfigVersion: string, # Optional. Represents training config version. By default, &quot;latest&quot; value is used which uses the latest released training config version.
        ///   trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Required. Represents the mode of the training operation.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. Represents the evaluation options. By default, the evaluation kind is percentage, with training split percentage as 80, and testing split percentage as 20.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> TrainAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.Train");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.Train", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a training job for a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call Train with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     modelLabel = "<modelLabel>",
        ///     trainingMode = "advanced",
        /// };
        /// 
        /// var operation = client.Train(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call Train with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     modelLabel = "<modelLabel>",
        ///     trainingConfigVersion = "<trainingConfigVersion>",
        ///     trainingMode = "advanced",
        ///     evaluationOptions = new {
        ///         kind = "percentage",
        ///         trainingSplitPercentage = 1234,
        ///         testingSplitPercentage = 1234,
        ///     },
        /// };
        /// 
        /// var operation = client.Train(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingMode").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/train
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TrainingJobOptions</c>:
        /// <code>{
        ///   modelLabel: string, # Required. Represents the output model label.
        ///   trainingConfigVersion: string, # Optional. Represents training config version. By default, &quot;latest&quot; value is used which uses the latest released training config version.
        ///   trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Required. Represents the mode of the training operation.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. Represents the evaluation options. By default, the evaluation kind is percentage, with training split percentage as 80, and testing split percentage as 20.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> Train(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.Train");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.Train", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Swaps two existing deployments with each other. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call SwapDeploymentsAsync with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     firstDeploymentName = "<firstDeploymentName>",
        ///     secondDeploymentName = "<secondDeploymentName>",
        /// };
        /// 
        /// var operation = await client.SwapDeploymentsAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/swap-deployments
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SwapDeploymentsOptions</c>:
        /// <code>{
        ///   firstDeploymentName: string, # Required. Represents the first deployment name.
        ///   secondDeploymentName: string, # Required. Represents the second deployment name.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> SwapDeploymentsAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.SwapDeployments");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSwapDeploymentsRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.SwapDeployments", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Swaps two existing deployments with each other. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call SwapDeployments with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     firstDeploymentName = "<firstDeploymentName>",
        ///     secondDeploymentName = "<secondDeploymentName>",
        /// };
        /// 
        /// var operation = client.SwapDeployments(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/swap-deployments
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SwapDeploymentsOptions</c>:
        /// <code>{
        ///   firstDeploymentName: string, # Required. Represents the first deployment name.
        ///   secondDeploymentName: string, # Required. Represents the second deployment name.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> SwapDeployments(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.SwapDeployments");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSwapDeploymentsRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.SwapDeployments", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new deployment or replaces an existing one. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeployProjectAsync with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     trainedModelLabel = "<trainedModelLabel>",
        /// };
        /// 
        /// var operation = await client.DeployProjectAsync(WaitUntil.Completed, "<projectName>", "<deploymentName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentName").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/deploy-project
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateDeploymentOptions</c>:
        /// <code>{
        ///   trainedModelLabel: string, # Required. Represents the trained model label.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeployProjectAsync(WaitUntil waitUntil, string projectName, string deploymentName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeployProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeployProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new deployment or replaces an existing one. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeployProject with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     trainedModelLabel = "<trainedModelLabel>",
        /// };
        /// 
        /// var operation = client.DeployProject(WaitUntil.Completed, "<projectName>", "<deploymentName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentName").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/deploy-project
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateDeploymentOptions</c>:
        /// <code>{
        ///   trainedModelLabel: string, # Required. Represents the trained model label.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeployProject(WaitUntil waitUntil, string projectName, string deploymentName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeployProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeployProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project deployment. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeploymentAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.DeleteDeploymentAsync(WaitUntil.Completed, "<projectName>", "<deploymentName>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/delete-deployment
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeleteDeploymentAsync(WaitUntil waitUntil, string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(projectName, deploymentName, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeleteDeployment", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project deployment. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeployment with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.DeleteDeployment(WaitUntil.Completed, "<projectName>", "<deploymentName>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/delete-deployment
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeleteDeployment(WaitUntil waitUntil, string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(projectName, deploymentName, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeleteDeployment", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a cancellation for a running training job. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CancelTrainingJobAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.CancelTrainingJobAsync(WaitUntil.Completed, "<projectName>", "<jobId>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingMode").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/cancel-training-job
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> CancelTrainingJobAsync(WaitUntil waitUntil, string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.CancelTrainingJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelTrainingJobRequest(projectName, jobId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.CancelTrainingJob", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a cancellation for a running training job. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CancelTrainingJob with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new ConversationAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.CancelTrainingJob(WaitUntil.Completed, "<projectName>", "<jobId>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingMode").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// Additional information can be found in the service REST API documentation:
        /// https://docs.microsoft.com/rest/api/language/conversational-analysis-authoring/cancel-training-job
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> CancelTrainingJob(WaitUntil waitUntil, string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.CancelTrainingJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelTrainingJobRequest(projectName, jobId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.CancelTrainingJob", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetProjectsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateProjectRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetProjectRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteProjectRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateExportProjectRequest(string projectName, string exportedProjectFormat, string assetKind, string stringIndexType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:export", false);
            if (exportedProjectFormat != null)
            {
                uri.AppendQuery("format", exportedProjectFormat, true);
            }
            if (assetKind != null)
            {
                uri.AppendQuery("assetKind", assetKind, true);
            }
            uri.AppendQuery("stringIndexType", stringIndexType, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportProjectRequest(string projectName, RequestContent content, string exportedProjectFormat, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:import", false);
            if (exportedProjectFormat != null)
            {
                uri.AppendQuery("format", exportedProjectFormat, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateTrainRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:train", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeploymentsRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSwapDeploymentsRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/:swap", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeploymentRequest(string projectName, string deploymentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeployProjectRequest(string projectName, string deploymentName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentRequest(string projectName, string deploymentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentJobStatusRequest(string projectName, string deploymentName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSwapDeploymentsJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/swap/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetExportProjectJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/export/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetImportProjectJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/import/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelsRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteTrainedModelRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationResultsRequest(string projectName, string trainedModelLabel, string stringIndexType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendPath("/evaluation/result", false);
            uri.AppendQuery("stringIndexType", stringIndexType, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationSummaryRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendPath("/evaluation/summary-result", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobsRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCancelTrainingJobRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/:cancel", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetProjectDeletionJobStatusRequest(string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/global/deletion-jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedLanguagesRequest(string projectKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/global/languages", false);
            uri.AppendQuery("projectKind", projectKind, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedPrebuiltEntitiesRequest(string language, bool? multilingual, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/global/prebuilt-entities", false);
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (multilingual != null)
            {
                uri.AppendQuery("multilingual", multilingual.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingConfigVersionsRequest(string projectKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/global/training-config-versions", false);
            uri.AppendQuery("projectKind", projectKind, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetProjectsNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsNextPageRequest(string nextLink, string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelsNextPageRequest(string nextLink, string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationResultsNextPageRequest(string nextLink, string projectName, string trainedModelLabel, string stringIndexType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobsNextPageRequest(string nextLink, string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedLanguagesNextPageRequest(string nextLink, string projectKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedPrebuiltEntitiesNextPageRequest(string nextLink, string language, bool? multilingual, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingConfigVersionsNextPageRequest(string nextLink, string projectKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
