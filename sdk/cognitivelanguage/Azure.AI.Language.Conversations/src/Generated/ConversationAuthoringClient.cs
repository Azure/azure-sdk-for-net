// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.Language.Conversations;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Language.Conversations.Authoring
{
    /// <summary> The ConversationAuthoring service client. </summary>
    public partial class ConversationAuthoringClient
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of ConversationAuthoringClient for mocking. </summary>
        protected ConversationAuthoringClient()
        {
        }

        /// <summary> Creates a new project or updates an existing one. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateProjectOptions</c>:
        /// <code>{
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateProjectAsync(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.CreateProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateProjectRequest(projectName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new project or updates an existing one. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateProjectOptions</c>:
        /// <code>{
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateProject(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.CreateProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateProjectRequest(projectName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetProjectAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectRequest(projectName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetProject(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectRequest(projectName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a deployment. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: ConversationalAnalysisAuthoringProjectDeploymentExpirationDate, # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentAsync(string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(projectName, deploymentName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a deployment. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: ConversationalAnalysisAuthoringProjectDeploymentExpirationDate, # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeployment(string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(projectName, deploymentName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentJobStatusAsync(string projectName, string deploymentName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetDeploymentJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentJobStatusRequest(projectName, deploymentName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentJobStatus(string projectName, string deploymentName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetDeploymentJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentJobStatusRequest(projectName, deploymentName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing swap deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSwapDeploymentsJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetSwapDeploymentsJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSwapDeploymentsJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing swap deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSwapDeploymentsJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetSwapDeploymentsJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSwapDeploymentsJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an export job. Once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetExportProjectJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetExportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetExportProjectJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an export job. Once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetExportProjectJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetExportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetExportProjectJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for an import. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetImportProjectJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetImportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetImportProjectJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for an import. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetImportProjectJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetImportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetImportProjectJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectTrainedModel</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: ConversationalAnalysisAuthoringProjectTrainedModelExpirationDate, # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTrainedModelAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainedModelRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectTrainedModel</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: ConversationalAnalysisAuthoringProjectTrainedModelExpirationDate, # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTrainedModel(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainedModelRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an existing trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response> DeleteTrainedModelAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTrainedModelRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an existing trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response DeleteTrainedModel(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTrainedModelRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the evaluation summary of a trained model. The summary includes high level performance measurements of the model e.g., F1, Precision, Recall, etc. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EvaluationSummary</c>:
        /// <code>{
        ///   entitiesEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two entities (the two entities can be the same). The matrix is between the entity that was labelled and the entity that was predicted.
        ///     entities: Dictionary&lt;string, EntityEvaluationSummary&gt;, # Required. Represents the entities evaluation summary.
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to entities evaluation.
        ///   intentsEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two intents (the two intents can be the same). The matrix is between the intent that was labelled and the intent that was predicted.
        ///     intents: Dictionary&lt;string, IntentEvaluationSummary&gt;, # Required. Represents the intents evaluation summary.
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to intents evaluation.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. The options that were used while running the evaluation.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetModelEvaluationSummaryAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetModelEvaluationSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetModelEvaluationSummaryRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the evaluation summary of a trained model. The summary includes high level performance measurements of the model e.g., F1, Precision, Recall, etc. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>EvaluationSummary</c>:
        /// <code>{
        ///   entitiesEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two entities (the two entities can be the same). The matrix is between the entity that was labelled and the entity that was predicted.
        ///     entities: Dictionary&lt;string, EntityEvaluationSummary&gt;, # Required. Represents the entities evaluation summary.
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to entities evaluation.
        ///   intentsEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two intents (the two intents can be the same). The matrix is between the intent that was labelled and the intent that was predicted.
        ///     intents: Dictionary&lt;string, IntentEvaluationSummary&gt;, # Required. Represents the intents evaluation summary.
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to intents evaluation.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. The options that were used while running the evaluation.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetModelEvaluationSummary(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetModelEvaluationSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetModelEvaluationSummaryRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a training job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTrainingJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetTrainingJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainingJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a training job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTrainingJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetTrainingJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainingJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a project deletion job. </summary>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetProjectDeletionJobStatusAsync(string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetProjectDeletionJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectDeletionJobStatusRequest(jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a project deletion job. </summary>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetProjectDeletionJobStatus(string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.GetProjectDeletionJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectDeletionJobStatusRequest(jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the existing projects. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectsMetadataValue</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetProjectsAsync(RequestContext context = null)
        {
            return GetProjectsImplementationAsync("ConversationAuthoringClient.GetProjects", context);
        }

        private AsyncPageable<BinaryData> GetProjectsImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetProjectsRequest(context)
                        : CreateGetProjectsNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the existing projects. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectsMetadataValue</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last trained datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployed datetime.
        ///   projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///   settings: {
        ///     confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///   }, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetProjects(RequestContext context = null)
        {
            return GetProjectsImplementation("ConversationAuthoringClient.GetProjects", context);
        }

        private Pageable<BinaryData> GetProjectsImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetProjectsRequest(context)
                        : CreateGetProjectsNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the deployments belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectDeploymentsValue</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: ConversationalAnalysisAuthoringProjectDeploymentExpirationDate, # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetDeploymentsImplementationAsync("ConversationAuthoringClient.GetDeployments", projectName, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsImplementationAsync(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsRequest(projectName, context)
                        : CreateGetDeploymentsNextPageRequest(nextLink, projectName, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the deployments belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectDeploymentsValue</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: ConversationalAnalysisAuthoringProjectDeploymentExpirationDate, # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeployments(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetDeploymentsImplementation("ConversationAuthoringClient.GetDeployments", projectName, context);
        }

        private Pageable<BinaryData> GetDeploymentsImplementation(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsRequest(projectName, context)
                        : CreateGetDeploymentsNextPageRequest(nextLink, projectName, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the trained models belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectTrainedModelsValue</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: ConversationalAnalysisAuthoringProjectTrainedModelExpirationDate, # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainedModelsAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainedModelsImplementationAsync("ConversationAuthoringClient.GetTrainedModels", projectName, context);
        }

        private AsyncPageable<BinaryData> GetTrainedModelsImplementationAsync(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainedModelsRequest(projectName, context)
                        : CreateGetTrainedModelsNextPageRequest(nextLink, projectName, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the trained models belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringProjectTrainedModelsValue</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: ConversationalAnalysisAuthoringProjectTrainedModelExpirationDate, # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainedModels(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainedModelsImplementation("ConversationAuthoringClient.GetTrainedModels", projectName, context);
        }

        private Pageable<BinaryData> GetTrainedModelsImplementation(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainedModelsRequest(projectName, context)
                        : CreateGetTrainedModelsNextPageRequest(nextLink, projectName, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets the detailed results of the evaluation for a trained model. This includes the raw inference results for the data included in the evaluation process. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. Set this to &quot;Utf16CodeUnit&quot; for .NET strings, which are encoded as UTF-16. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="trainedModelLabel"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringEvaluationResultsValue</c>:
        /// <code>{
        ///   text: string, # Required. Represents the utterance text.
        ///   language: string, # Required. Represents the utterance language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   entitiesResult: {
        ///     expectedEntities: [
        ///       {
        ///         category: string, # Required. Represents the entity category.
        ///         offset: number, # Required. Represents the entity offset index relative to the original text.
        ///         length: number, # Required. Represents the entity length.
        ///       }
        ///     ], # Required. Represents the expected entity labels.
        ///     predictedEntities: [UtteranceEntityEvaluationResult], # Required. Represents the predicted entity labels.
        ///   }, # Required. Represents the entities results for the utterance.
        ///   intentsResult: {
        ///     expectedIntent: string, # Required. Represents the utterance&apos;s expected intent.
        ///     predictedIntent: string, # Required. Represents the utterance&apos;s predicted intent.
        ///   }, # Required. Represents the intents results for the utterance.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetModelEvaluationResultsAsync(string projectName, string trainedModelLabel, string stringIndexType = "Utf16CodeUnit", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            return GetModelEvaluationResultsImplementationAsync("ConversationAuthoringClient.GetModelEvaluationResults", projectName, trainedModelLabel, stringIndexType, context);
        }

        private AsyncPageable<BinaryData> GetModelEvaluationResultsImplementationAsync(string diagnosticsScopeName, string projectName, string trainedModelLabel, string stringIndexType, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetModelEvaluationResultsRequest(projectName, trainedModelLabel, stringIndexType, context)
                        : CreateGetModelEvaluationResultsNextPageRequest(nextLink, projectName, trainedModelLabel, stringIndexType, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets the detailed results of the evaluation for a trained model. This includes the raw inference results for the data included in the evaluation process. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. Set this to &quot;Utf16CodeUnit&quot; for .NET strings, which are encoded as UTF-16. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="trainedModelLabel"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringEvaluationResultsValue</c>:
        /// <code>{
        ///   text: string, # Required. Represents the utterance text.
        ///   language: string, # Required. Represents the utterance language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   entitiesResult: {
        ///     expectedEntities: [
        ///       {
        ///         category: string, # Required. Represents the entity category.
        ///         offset: number, # Required. Represents the entity offset index relative to the original text.
        ///         length: number, # Required. Represents the entity length.
        ///       }
        ///     ], # Required. Represents the expected entity labels.
        ///     predictedEntities: [UtteranceEntityEvaluationResult], # Required. Represents the predicted entity labels.
        ///   }, # Required. Represents the entities results for the utterance.
        ///   intentsResult: {
        ///     expectedIntent: string, # Required. Represents the utterance&apos;s expected intent.
        ///     predictedIntent: string, # Required. Represents the utterance&apos;s predicted intent.
        ///   }, # Required. Represents the intents results for the utterance.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetModelEvaluationResults(string projectName, string trainedModelLabel, string stringIndexType = "Utf16CodeUnit", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            return GetModelEvaluationResultsImplementation("ConversationAuthoringClient.GetModelEvaluationResults", projectName, trainedModelLabel, stringIndexType, context);
        }

        private Pageable<BinaryData> GetModelEvaluationResultsImplementation(string diagnosticsScopeName, string projectName, string trainedModelLabel, string stringIndexType, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetModelEvaluationResultsRequest(projectName, trainedModelLabel, stringIndexType, context)
                        : CreateGetModelEvaluationResultsNextPageRequest(nextLink, projectName, trainedModelLabel, stringIndexType, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the non-expired training jobs created for a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringTrainingJobsValue</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainingJobsAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainingJobsImplementationAsync("ConversationAuthoringClient.GetTrainingJobs", projectName, context);
        }

        private AsyncPageable<BinaryData> GetTrainingJobsImplementationAsync(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingJobsRequest(projectName, context)
                        : CreateGetTrainingJobsNextPageRequest(nextLink, projectName, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the non-expired training jobs created for a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringTrainingJobsValue</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainingJobs(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainingJobsImplementation("ConversationAuthoringClient.GetTrainingJobs", projectName, context);
        }

        private Pageable<BinaryData> GetTrainingJobsImplementation(string diagnosticsScopeName, string projectName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingJobsRequest(projectName, context)
                        : CreateGetTrainingJobsNextPageRequest(nextLink, projectName, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported languages for the given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;Conversation&quot; | &quot;Orchestration&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringSupportedLanguagesValue</c>:
        /// <code>{
        ///   languageName: string, # Required. The language name.
        ///   languageCode: string, # Required. The language code. This is BCP-47 representation of a language. For example, &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetSupportedLanguagesAsync(string projectKind, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetSupportedLanguagesImplementationAsync("ConversationAuthoringClient.GetSupportedLanguages", projectKind, context);
        }

        private AsyncPageable<BinaryData> GetSupportedLanguagesImplementationAsync(string diagnosticsScopeName, string projectKind, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedLanguagesRequest(projectKind, context)
                        : CreateGetSupportedLanguagesNextPageRequest(nextLink, projectKind, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported languages for the given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;Conversation&quot; | &quot;Orchestration&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringSupportedLanguagesValue</c>:
        /// <code>{
        ///   languageName: string, # Required. The language name.
        ///   languageCode: string, # Required. The language code. This is BCP-47 representation of a language. For example, &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetSupportedLanguages(string projectKind, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetSupportedLanguagesImplementation("ConversationAuthoringClient.GetSupportedLanguages", projectKind, context);
        }

        private Pageable<BinaryData> GetSupportedLanguagesImplementation(string diagnosticsScopeName, string projectKind, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedLanguagesRequest(projectKind, context)
                        : CreateGetSupportedLanguagesNextPageRequest(nextLink, projectKind, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported prebuilt entities that can be used while creating composed entities. </summary>
        /// <param name="language"> The language to get supported prebuilt entities for. Required if multilingual is false. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc. </param>
        /// <param name="multilingual"> Whether to get the support prebuilt entities for multilingual or monolingual projects. If true, the language parameter is ignored. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringPrebuiltEntitiesValue</c>:
        /// <code>{
        ///   category: string, # Required. The prebuilt entity category.
        ///   description: string, # Required. The description.
        ///   examples: string, # Required. English examples for the entity.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetSupportedPrebuiltEntitiesAsync(string language = null, bool? multilingual = null, RequestContext context = null)
        {
            return GetSupportedPrebuiltEntitiesImplementationAsync("ConversationAuthoringClient.GetSupportedPrebuiltEntities", language, multilingual, context);
        }

        private AsyncPageable<BinaryData> GetSupportedPrebuiltEntitiesImplementationAsync(string diagnosticsScopeName, string language, bool? multilingual, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedPrebuiltEntitiesRequest(language, multilingual, context)
                        : CreateGetSupportedPrebuiltEntitiesNextPageRequest(nextLink, language, multilingual, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported prebuilt entities that can be used while creating composed entities. </summary>
        /// <param name="language"> The language to get supported prebuilt entities for. Required if multilingual is false. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc. </param>
        /// <param name="multilingual"> Whether to get the support prebuilt entities for multilingual or monolingual projects. If true, the language parameter is ignored. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringPrebuiltEntitiesValue</c>:
        /// <code>{
        ///   category: string, # Required. The prebuilt entity category.
        ///   description: string, # Required. The description.
        ///   examples: string, # Required. English examples for the entity.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetSupportedPrebuiltEntities(string language = null, bool? multilingual = null, RequestContext context = null)
        {
            return GetSupportedPrebuiltEntitiesImplementation("ConversationAuthoringClient.GetSupportedPrebuiltEntities", language, multilingual, context);
        }

        private Pageable<BinaryData> GetSupportedPrebuiltEntitiesImplementation(string diagnosticsScopeName, string language, bool? multilingual, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedPrebuiltEntitiesRequest(language, multilingual, context)
                        : CreateGetSupportedPrebuiltEntitiesNextPageRequest(nextLink, language, multilingual, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the support training config version for a given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;Conversation&quot; | &quot;Orchestration&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringTrainingConfigVersionsValue</c>:
        /// <code>{
        ///   trainingConfigVersion: string, # Required. Represents the version of the config.
        ///   modelExpirationDate: ConversationalAnalysisAuthoringTrainingConfigVersionModelExpirationDate, # Required. Represents the training config version expiration date.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainingConfigVersionsAsync(string projectKind, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetTrainingConfigVersionsImplementationAsync("ConversationAuthoringClient.GetTrainingConfigVersions", projectKind, context);
        }

        private AsyncPageable<BinaryData> GetTrainingConfigVersionsImplementationAsync(string diagnosticsScopeName, string projectKind, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingConfigVersionsRequest(projectKind, context)
                        : CreateGetTrainingConfigVersionsNextPageRequest(nextLink, projectKind, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the support training config version for a given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;Conversation&quot; | &quot;Orchestration&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ConversationalAnalysisAuthoringTrainingConfigVersionsValue</c>:
        /// <code>{
        ///   trainingConfigVersion: string, # Required. Represents the version of the config.
        ///   modelExpirationDate: ConversationalAnalysisAuthoringTrainingConfigVersionModelExpirationDate, # Required. Represents the training config version expiration date.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainingConfigVersions(string projectKind, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetTrainingConfigVersionsImplementation("ConversationAuthoringClient.GetTrainingConfigVersions", projectKind, context);
        }

        private Pageable<BinaryData> GetTrainingConfigVersionsImplementation(string diagnosticsScopeName, string projectKind, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingConfigVersionsRequest(projectKind, context)
                        : CreateGetTrainingConfigVersionsNextPageRequest(nextLink, projectKind, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Deletes a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeleteProjectAsync(WaitUntil waitUntil, string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteProjectRequest(projectName, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeleteProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeleteProject(WaitUntil waitUntil, string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteProjectRequest(projectName, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeleteProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to export a project&apos;s data. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="exportedProjectFormat"> The format of the exported project file to use. Allowed values: &quot;Conversation&quot; | &quot;Luis&quot;. </param>
        /// <param name="assetKind"> Kind of asset to export. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. Set this to &quot;Utf16CodeUnit&quot; for .NET strings, which are encoded as UTF-16. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ExportProjectAsync(WaitUntil waitUntil, string projectName, string exportedProjectFormat = null, string assetKind = null, string stringIndexType = "Utf16CodeUnit", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.ExportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExportProjectRequest(projectName, exportedProjectFormat, assetKind, stringIndexType, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.ExportProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to export a project&apos;s data. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="exportedProjectFormat"> The format of the exported project file to use. Allowed values: &quot;Conversation&quot; | &quot;Luis&quot;. </param>
        /// <param name="assetKind"> Kind of asset to export. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. Set this to &quot;Utf16CodeUnit&quot; for .NET strings, which are encoded as UTF-16. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> ExportProject(WaitUntil waitUntil, string projectName, string exportedProjectFormat = null, string assetKind = null, string stringIndexType = "Utf16CodeUnit", RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.ExportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExportProjectRequest(projectName, exportedProjectFormat, assetKind, stringIndexType, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.ExportProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to import a project. If a project with the same name already exists, the data of that project is replaced. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="exportedProjectFormat"> The format of the exported project file to use. Allowed values: &quot;Conversation&quot; | &quot;Luis&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ExportedProject</c>:
        /// <code>{
        ///   projectFileVersion: string, # Required. The version of the exported file.
        ///   stringIndexType: &quot;Utf16CodeUnit&quot;, # Required. Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets.
        ///   metadata: {
        ///     projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///     settings: {
        ///       confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///     }, # Optional. The project settings.
        ///     projectName: string, # Required. The new project name.
        ///     multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///     description: string, # Optional. The project description.
        ///     language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   }, # Required. Represents the project metadata.
        ///   assets: {
        ///     projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. The type of project containing the assets.
        ///   }, # Optional. Represents the project assets.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ImportProjectAsync(WaitUntil waitUntil, string projectName, RequestContent content, string exportedProjectFormat = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.ImportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportProjectRequest(projectName, content, exportedProjectFormat, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.ImportProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to import a project. If a project with the same name already exists, the data of that project is replaced. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="exportedProjectFormat"> The format of the exported project file to use. Allowed values: &quot;Conversation&quot; | &quot;Luis&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ExportedProject</c>:
        /// <code>{
        ///   projectFileVersion: string, # Required. The version of the exported file.
        ///   stringIndexType: &quot;Utf16CodeUnit&quot;, # Required. Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets.
        ///   metadata: {
        ///     projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. Represents the project kind.
        ///     settings: {
        ///       confidenceThreshold: number, # Required. The threshold of the intent with the highest confidence, at which the prediction will automatically be changed to &quot;None&quot;.
        ///     }, # Optional. The project settings.
        ///     projectName: string, # Required. The new project name.
        ///     multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///     description: string, # Optional. The project description.
        ///     language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   }, # Required. Represents the project metadata.
        ///   assets: {
        ///     projectKind: &quot;Conversation&quot; | &quot;Orchestration&quot;, # Required. The type of project containing the assets.
        ///   }, # Optional. Represents the project assets.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> ImportProject(WaitUntil waitUntil, string projectName, RequestContent content, string exportedProjectFormat = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.ImportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportProjectRequest(projectName, content, exportedProjectFormat, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.ImportProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a training job for a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TrainingJobOptions</c>:
        /// <code>{
        ///   modelLabel: string, # Required. Represents the output model label.
        ///   trainingConfigVersion: string, # Optional. Represents training config version. By default, &quot;latest&quot; value is used which uses the latest released training config version.
        ///   trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Required. Represents the mode of the training operation.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. Represents the evaluation options. By default, the evaluation kind is percentage, with training split percentage as 80, and testing split percentage as 20.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> TrainAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.Train");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.Train", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a training job for a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TrainingJobOptions</c>:
        /// <code>{
        ///   modelLabel: string, # Required. Represents the output model label.
        ///   trainingConfigVersion: string, # Optional. Represents training config version. By default, &quot;latest&quot; value is used which uses the latest released training config version.
        ///   trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Required. Represents the mode of the training operation.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. Represents the evaluation options. By default, the evaluation kind is percentage, with training split percentage as 80, and testing split percentage as 20.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> Train(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.Train");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.Train", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Swaps two existing deployments with each other. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SwapDeploymentsOptions</c>:
        /// <code>{
        ///   firstDeploymentName: string, # Required. Represents the first deployment name.
        ///   secondDeploymentName: string, # Required. Represents the second deployment name.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> SwapDeploymentsAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.SwapDeployments");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSwapDeploymentsRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.SwapDeployments", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Swaps two existing deployments with each other. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SwapDeploymentsOptions</c>:
        /// <code>{
        ///   firstDeploymentName: string, # Required. Represents the first deployment name.
        ///   secondDeploymentName: string, # Required. Represents the second deployment name.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> SwapDeployments(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.SwapDeployments");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSwapDeploymentsRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.SwapDeployments", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new deployment or replaces an existing one. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateDeploymentOptions</c>:
        /// <code>{
        ///   trainedModelLabel: string, # Required. Represents the trained model label.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: ConversationalAnalysisAuthoringProjectDeploymentExpirationDate, # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeployProjectAsync(WaitUntil waitUntil, string projectName, string deploymentName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeployProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeployProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new deployment or replaces an existing one. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateDeploymentOptions</c>:
        /// <code>{
        ///   trainedModelLabel: string, # Required. Represents the trained model label.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: ConversationalAnalysisAuthoringProjectDeploymentExpirationDate, # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeployProject(WaitUntil waitUntil, string projectName, string deploymentName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeployProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeployProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project deployment. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeleteDeploymentAsync(WaitUntil waitUntil, string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(projectName, deploymentName, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeleteDeployment", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project deployment. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeleteDeployment(WaitUntil waitUntil, string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(projectName, deploymentName, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.DeleteDeployment", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a cancellation for a running training job. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> CancelTrainingJobAsync(WaitUntil waitUntil, string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.CancelTrainingJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelTrainingJobRequest(projectName, jobId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.CancelTrainingJob", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a cancellation for a running training job. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingMode: &quot;advanced&quot; | &quot;standard&quot;, # Optional. Represents the mode of the training operation.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents the model training status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimated end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> CancelTrainingJob(WaitUntil waitUntil, string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("ConversationAuthoringClient.CancelTrainingJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelTrainingJobRequest(projectName, jobId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "ConversationAuthoringClient.CancelTrainingJob", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetProjectsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateProjectRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetProjectRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteProjectRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateExportProjectRequest(string projectName, string exportedProjectFormat, string assetKind, string stringIndexType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:export", false);
            if (exportedProjectFormat != null)
            {
                uri.AppendQuery("format", exportedProjectFormat, true);
            }
            if (assetKind != null)
            {
                uri.AppendQuery("assetKind", assetKind, true);
            }
            uri.AppendQuery("stringIndexType", stringIndexType, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportProjectRequest(string projectName, RequestContent content, string exportedProjectFormat, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:import", false);
            if (exportedProjectFormat != null)
            {
                uri.AppendQuery("format", exportedProjectFormat, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateTrainRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:train", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeploymentsRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSwapDeploymentsRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/:swap", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeploymentRequest(string projectName, string deploymentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeployProjectRequest(string projectName, string deploymentName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentRequest(string projectName, string deploymentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentJobStatusRequest(string projectName, string deploymentName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSwapDeploymentsJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/swap/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetExportProjectJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/export/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetImportProjectJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/import/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelsRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteTrainedModelRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationResultsRequest(string projectName, string trainedModelLabel, string stringIndexType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendPath("/evaluation/result", false);
            uri.AppendQuery("stringIndexType", stringIndexType, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationSummaryRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendPath("/evaluation/summary-result", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobsRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCancelTrainingJobRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/:cancel", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetProjectDeletionJobStatusRequest(string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/global/deletion-jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedLanguagesRequest(string projectKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/global/languages", false);
            uri.AppendQuery("projectKind", projectKind, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedPrebuiltEntitiesRequest(string language, bool? multilingual, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/global/prebuilt-entities", false);
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (multilingual != null)
            {
                uri.AppendQuery("multilingual", multilingual.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingConfigVersionsRequest(string projectKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-conversations/projects/global/training-config-versions", false);
            uri.AppendQuery("projectKind", projectKind, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetProjectsNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsNextPageRequest(string nextLink, string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelsNextPageRequest(string nextLink, string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationResultsNextPageRequest(string nextLink, string projectName, string trainedModelLabel, string stringIndexType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobsNextPageRequest(string nextLink, string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedLanguagesNextPageRequest(string nextLink, string projectKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedPrebuiltEntitiesNextPageRequest(string nextLink, string language, bool? multilingual, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingConfigVersionsNextPageRequest(string nextLink, string projectKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(Endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
