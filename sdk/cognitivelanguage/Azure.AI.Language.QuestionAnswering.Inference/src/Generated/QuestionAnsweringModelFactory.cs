// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Collections.Generic;
using System.Linq;

namespace Azure.AI.Language.QuestionAnswering.Inference
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class QuestionAnsweringModelFactory
    {
        /// <summary> Parameters to query a knowledge base. </summary>
        /// <param name="qnaId">
        /// Exact QnA ID to fetch from the knowledge base, this field takes priority over
        /// question.
        /// </param>
        /// <param name="question"> User question to query against the knowledge base. </param>
        /// <param name="size"> Max number of answers to be returned for the question. </param>
        /// <param name="userId"> Unique identifier for the user. </param>
        /// <param name="confidenceThreshold"> Minimum threshold score for answers, value ranges from 0 to 1. </param>
        /// <param name="answerContext"> Context object with previous QnA's information. </param>
        /// <param name="rankerKind"> Type of ranker to be used. </param>
        /// <param name="filters"> Filter QnAs based on given metadata list and knowledge base sources. </param>
        /// <param name="shortAnswerOptions"> To configure Answer span prediction feature. </param>
        /// <param name="includeUnstructuredSources"> (Optional) Flag to enable Query over Unstructured Sources. </param>
        /// <param name="queryPreferences"> To fine tune query results. </param>
        /// <returns> A new <see cref="Inference.AnswersOptions"/> instance for mocking. </returns>
        public static AnswersOptions AnswersOptions(int? qnaId = default, string question = default, int? size = default, string userId = default, double? confidenceThreshold = default, KnowledgeBaseAnswerContext answerContext = default, RankerKind? rankerKind = default, QueryFilters filters = default, ShortAnswerOptions shortAnswerOptions = default, bool? includeUnstructuredSources = default, QueryPreferences queryPreferences = default)
        {
            return new AnswersOptions(
                qnaId,
                question,
                size,
                userId,
                confidenceThreshold,
                answerContext,
                rankerKind,
                filters,
                shortAnswerOptions,
                includeUnstructuredSources,
                queryPreferences,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Context object with previous QnA's information. </summary>
        /// <param name="previousQnaId"> Previous turn top answer result QnA ID. </param>
        /// <param name="previousQuestion"> Previous user query. </param>
        /// <returns> A new <see cref="Inference.KnowledgeBaseAnswerContext"/> instance for mocking. </returns>
        public static KnowledgeBaseAnswerContext KnowledgeBaseAnswerContext(int previousQnaId = default, string previousQuestion = default)
        {
            return new KnowledgeBaseAnswerContext(previousQnaId, previousQuestion, additionalBinaryDataProperties: null);
        }

        /// <summary> filters over knowledge base. </summary>
        /// <param name="metadataFilter"> Find QnAs that are associated with the given list of metadata. </param>
        /// <param name="sourceFilter">
        /// Find QnAs that are associated with any of the given list of sources in
        /// knowledge base.
        /// </param>
        /// <param name="logicalOperation"> Logical operation used to join metadata filter with source filter. </param>
        /// <returns> A new <see cref="Inference.QueryFilters"/> instance for mocking. </returns>
        public static QueryFilters QueryFilters(MetadataFilter metadataFilter = default, IEnumerable<string> sourceFilter = default, LogicalOperationKind? logicalOperation = default)
        {
            sourceFilter ??= new ChangeTrackingList<string>();

            return new QueryFilters(metadataFilter, sourceFilter.ToList(), logicalOperation, additionalBinaryDataProperties: null);
        }

        /// <summary> Find QnAs that are associated with the given list of metadata. </summary>
        /// <param name="metadata"> Dictionary of string. </param>
        /// <param name="logicalOperation"> Operation used to join metadata filters. </param>
        /// <returns> A new <see cref="Inference.MetadataFilter"/> instance for mocking. </returns>
        public static MetadataFilter MetadataFilter(IEnumerable<MetadataRecord> metadata = default, LogicalOperationKind? logicalOperation = default)
        {
            metadata ??= new ChangeTrackingList<MetadataRecord>();

            return new MetadataFilter(metadata.ToList(), logicalOperation, additionalBinaryDataProperties: null);
        }

        /// <summary> Object to provide the key value pair for each metadata. </summary>
        /// <param name="key"> Metadata Key from Metadata dictionary used in the QnA. </param>
        /// <param name="value"> Metadata Value from Metadata dictionary used in the QnA. </param>
        /// <returns> A new <see cref="Inference.MetadataRecord"/> instance for mocking. </returns>
        public static MetadataRecord MetadataRecord(string key = default, string value = default)
        {
            return new MetadataRecord(key, value, additionalBinaryDataProperties: null);
        }

        /// <summary> To configure Answer span prediction feature. </summary>
        /// <param name="enable"> Enable or disable Answer Span prediction. </param>
        /// <param name="confidenceThreshold">
        /// Minimum threshold score required to include an answer span, value ranges from 0
        /// to 1.
        /// </param>
        /// <param name="size"> Number of Top answers to be considered for span prediction from 1 to 10. </param>
        /// <returns> A new <see cref="Inference.ShortAnswerOptions"/> instance for mocking. </returns>
        public static ShortAnswerOptions ShortAnswerOptions(bool enable = default, double? confidenceThreshold = default, int? size = default)
        {
            return new ShortAnswerOptions(enable, confidenceThreshold, size, additionalBinaryDataProperties: null);
        }

        /// <summary> Additional properties to fine tune query results. </summary>
        /// <param name="scorer"> To specify what scoring algorithm is preferred. </param>
        /// <param name="matchingPolicy"> Policy for controling exact query match behavior. </param>
        /// <returns> A new <see cref="Inference.QueryPreferences"/> instance for mocking. </returns>
        public static QueryPreferences QueryPreferences(Scorer? scorer = default, MatchingPolicy matchingPolicy = default)
        {
            return new QueryPreferences(scorer, matchingPolicy, additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Specify parameters for query matching
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="Inference.PrebuiltQueryMatchingPolicy"/>.
        /// </summary>
        /// <param name="kind"> Kind of matching policy to be applied. </param>
        /// <returns> A new <see cref="Inference.MatchingPolicy"/> instance for mocking. </returns>
        public static MatchingPolicy MatchingPolicy(string kind = default)
        {
            return new UnknownMatchingPolicy(new MatchingPolicyKind(kind), additionalBinaryDataProperties: null);
        }

        /// <summary> Represents fields for Prebuilt query matching. Prebuilt weights will be used for giving preference to question and answer columns when quering AI search. </summary>
        /// <param name="fields"> List of fields to filter during query. For ex if only "questions" is used then query will be filtered on that column. </param>
        /// <param name="disableFullMatch"> Disabling full match on query. Enabling this will give preference to qna pairs that have exact match. </param>
        /// <returns> A new <see cref="Inference.PrebuiltQueryMatchingPolicy"/> instance for mocking. </returns>
        public static PrebuiltQueryMatchingPolicy PrebuiltQueryMatchingPolicy(IEnumerable<MatchingPolicyFieldsType> fields = default, bool? disableFullMatch = default)
        {
            fields ??= new ChangeTrackingList<MatchingPolicyFieldsType>();

            return new PrebuiltQueryMatchingPolicy(MatchingPolicyKind.Prebuilt, additionalBinaryDataProperties: null, fields.ToList(), disableFullMatch);
        }

        /// <summary> The question and text record parameters to answer. </summary>
        /// <param name="question"> User question to query against the given text records. </param>
        /// <param name="textDocuments"> Text records to be searched for given question. </param>
        /// <param name="language">
        /// Language of the text records. This is BCP-47 representation of a language. For
        /// example, use "en" for English; "es" for Spanish etc. If not set, use "en" for
        /// English as default.
        /// </param>
        /// <param name="stringIndexType">
        /// Specifies the method used to interpret string offsets.  Defaults to Text
        /// Elements (Graphemes) according to Unicode v8.0.0. For additional information
        /// see https://aka.ms/text-analytics-offsets.
        /// </param>
        /// <returns> A new <see cref="Inference.AnswersFromTextOptions"/> instance for mocking. </returns>
        public static AnswersFromTextOptions AnswersFromTextOptions(string question = default, IEnumerable<TextDocument> textDocuments = default, string language = default, StringIndexType? stringIndexType = default)
        {
            textDocuments ??= new ChangeTrackingList<TextDocument>();

            return new AnswersFromTextOptions(question, textDocuments.ToList(), language, stringIndexType, additionalBinaryDataProperties: null);
        }

        /// <summary> Represent input text record to be queried. </summary>
        /// <param name="id"> Unique identifier for the text record. </param>
        /// <param name="text"> Text contents of the record. </param>
        /// <returns> A new <see cref="Inference.TextDocument"/> instance for mocking. </returns>
        public static TextDocument TextDocument(string id = default, string text = default)
        {
            return new TextDocument(id, text, additionalBinaryDataProperties: null);
        }
    }
}
