// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Language.QuestionAnswering
{
    /// <summary> The QuestionAnsweringProjects service client. </summary>
    public partial class QuestionAnsweringProjectsClient
    {
        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline { get; }
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private Uri endpoint;
        private readonly string apiVersion;
        private readonly ClientDiagnostics _clientDiagnostics;

        /// <summary> Initializes a new instance of QuestionAnsweringProjectsClient for mocking. </summary>
        protected QuestionAnsweringProjectsClient()
        {
        }

        /// <summary> Initializes a new instance of QuestionAnsweringProjectsClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoint (e.g., https://&lt;resource-name&gt;.api.cognitiveservices.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        public QuestionAnsweringProjectsClient(Uri endpoint, AzureKeyCredential credential, QuestionAnsweringClientOptions options = null)
        {
            if (endpoint == null)
            {
                throw new ArgumentNullException(nameof(endpoint));
            }
            if (credential == null)
            {
                throw new ArgumentNullException(nameof(credential));
            }

            options ??= new QuestionAnsweringClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _keyCredential = credential;
            var authPolicy = new AzureKeyCredentialPolicy(_keyCredential, AuthorizationHeader);
            Pipeline = HttpPipelineBuilder.Build(options, new HttpPipelinePolicy[] { new LowLevelCallbackPolicy() }, new HttpPipelinePolicy[] { authPolicy }, new ResponseClassifier());
            this.endpoint = endpoint;
            apiVersion = options.Version;
        }

        /// <summary> Gets all projects for a user. </summary>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> ListProjectsAsync(RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateListProjectsRequest(requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.ListProjects");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets all projects for a user. </summary>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response ListProjects(RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateListProjectsRequest(requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.ListProjects");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="ListProjects"/> and <see cref="ListProjectsAsync"/> operations. </summary>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateListProjectsRequest(RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Get the requested project metadata. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetProjectDetailsAsync(string projectName, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateGetProjectDetailsRequest(projectName, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetProjectDetails");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the requested project metadata. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetProjectDetails(string projectName, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateGetProjectDetailsRequest(projectName, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetProjectDetails");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetProjectDetails"/> and <see cref="GetProjectDetailsAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateGetProjectDetailsRequest(string projectName, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Create or update a project. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>projectName</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term> Friendly name for the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>description</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Description of the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>language</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term> Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default. </term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Default Answer response when no good match is found in the Knowledgebase. </term>
        ///   </item>
        ///   <item>
        ///     <term>multilingualResource</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term> Set to true to enable creating knowledgebases in different languages for the same resource. </term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> CreateProjectAsync(string projectName, RequestContent requestBody, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateCreateProjectRequest(projectName, requestBody, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.CreateProject");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                        case 201:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or update a project. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>projectName</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term> Friendly name for the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>description</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Description of the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>language</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term> Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default. </term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Default Answer response when no good match is found in the Knowledgebase. </term>
        ///   </item>
        ///   <item>
        ///     <term>multilingualResource</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term> Set to true to enable creating knowledgebases in different languages for the same resource. </term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response CreateProject(string projectName, RequestContent requestBody, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateCreateProjectRequest(projectName, requestBody, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.CreateProject");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                        case 201:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="CreateProject"/> and <see cref="CreateProjectAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateCreateProjectRequest(string projectName, RequestContent requestBody, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = requestBody;
            return message;
        }

        /// <summary> Delete the project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> DeleteProjectAsync(string projectName, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateDeleteProjectRequest(projectName, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeleteProject");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 204:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete the project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response DeleteProject(string projectName, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateDeleteProjectRequest(projectName, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeleteProject");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 204:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="DeleteProject"/> and <see cref="DeleteProjectAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateDeleteProjectRequest(string projectName, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Export project metadata and assets. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>exportAssetTypes</term>
        ///     <term>&quot;synonyms&quot; | &quot;qnas&quot;[]</term>
        ///     <term></term>
        ///     <term> Collection of asset types. </term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="format"> Knowledgebase Import or Export format. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> ExportAsync(string projectName, RequestContent requestBody, string format = null, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateExportRequest(projectName, requestBody, format, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Export");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Export project metadata and assets. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>exportAssetTypes</term>
        ///     <term>&quot;synonyms&quot; | &quot;qnas&quot;[]</term>
        ///     <term></term>
        ///     <term> Collection of asset types. </term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="format"> Knowledgebase Import or Export format. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response Export(string projectName, RequestContent requestBody, string format = null, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateExportRequest(projectName, requestBody, format, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Export");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="Export"/> and <see cref="ExportAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="format"> Knowledgebase Import or Export format. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateExportRequest(string projectName, RequestContent requestBody, string format = null, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:export", false);
            uri.AppendQuery("api-version", apiVersion, true);
            if (format != null)
            {
                uri.AppendQuery("format", format, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = requestBody;
            return message;
        }

        /// <summary> Gets the status of an Export job, once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetExportStatusAsync(string projectName, string jobId, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateGetExportStatusRequest(projectName, jobId, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetExportStatus");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an Export job, once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetExportStatus(string projectName, string jobId, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateGetExportStatusRequest(projectName, jobId, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetExportStatus");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetExportStatus"/> and <see cref="GetExportStatusAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateGetExportStatusRequest(string projectName, string jobId, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/export/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Import project assets. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>importAssetTypes</term>
        ///     <term>&quot;synonyms&quot; | &quot;qnas&quot;[]</term>
        ///     <term></term>
        ///     <term> Collection of asset types. </term>
        ///   </item>
        ///   <item>
        ///     <term>projectMetadata</term>
        ///     <term>ProjectMetadata</term>
        ///     <term></term>
        ///     <term> Represents the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>assets</term>
        ///     <term>Assets</term>
        ///     <term></term>
        ///     <term> All assets for this project. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>ProjectMetadata</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>projectName</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Name of the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>description</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Description of the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>language</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default. </term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Default Answer response when no good match is found in the Knowledgebase. </term>
        ///   </item>
        ///   <item>
        ///     <term>multilingualResource</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term> Resource enabled for multiple languages across projects or not. </term>
        ///   </item>
        ///   <item>
        ///     <term>createdDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term> Project creation date-time. </term>
        ///   </item>
        ///   <item>
        ///     <term>lastModifiedDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term> Represents the project last modified date-time. </term>
        ///   </item>
        ///   <item>
        ///     <term>lastDeployedDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term> Represents the project last deployment date-time. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>Assets</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>synonyms</term>
        ///     <term>WordAlterations[]</term>
        ///     <term></term>
        ///     <term> Collection of synonyms. </term>
        ///   </item>
        ///   <item>
        ///     <term>qnas</term>
        ///     <term>RetrieveQnaRecord[]</term>
        ///     <term></term>
        ///     <term> List of QnA records. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>WordAlterations</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>alterations</term>
        ///     <term>string[]</term>
        ///     <term>Yes</term>
        ///     <term> Collection of word alterations. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>RetrieveQnaRecord</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term> Unique ID for the QnA. </term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Answer text. </term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs . </term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term> List of questions associated with the answer. </term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term> Metadata associated with the answer, useful to categorize or filter question answers. </term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term> Context of a QnA. </term>
        ///   </item>
        ///   <item>
        ///     <term>lastUpdatedDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term> Date-time when the QnA was last updated. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaDialog</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>isContextOnly</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term> To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as search result for queries without context; otherwise, ignores context and includes this QnA in search result. </term>
        ///   </item>
        ///   <item>
        ///     <term>prompts</term>
        ///     <term>QnaPrompt[]</term>
        ///     <term></term>
        ///     <term> List of prompts associated with the answer. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaPrompt</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>displayOrder</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term> Index of the prompt. It is used for ordering of the prompts. </term>
        ///   </item>
        ///   <item>
        ///     <term>qnaId</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term> ID of the QnA corresponding to the prompt. </term>
        ///   </item>
        ///   <item>
        ///     <term>qna</term>
        ///     <term>QnaRecord</term>
        ///     <term></term>
        ///     <term> QnA record. Either QnAId or QnA record needs to be present in a Prompt. </term>
        ///   </item>
        ///   <item>
        ///     <term>displayText</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Text displayed to represent a follow up question prompt. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaRecord</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term> Unique ID for the QnA. </term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Answer text. </term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs . </term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term> List of questions associated with the answer. </term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term> Metadata associated with the answer, useful to categorize or filter question answers. </term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term> Context of a QnA. </term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="format"> Knowledgebase Import or Export format. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> ImportAsync(string projectName, RequestContent requestBody, string format = null, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateImportRequest(projectName, requestBody, format, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Import");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Import project assets. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>importAssetTypes</term>
        ///     <term>&quot;synonyms&quot; | &quot;qnas&quot;[]</term>
        ///     <term></term>
        ///     <term> Collection of asset types. </term>
        ///   </item>
        ///   <item>
        ///     <term>projectMetadata</term>
        ///     <term>ProjectMetadata</term>
        ///     <term></term>
        ///     <term> Represents the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>assets</term>
        ///     <term>Assets</term>
        ///     <term></term>
        ///     <term> All assets for this project. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>ProjectMetadata</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>projectName</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Name of the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>description</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Description of the project. </term>
        ///   </item>
        ///   <item>
        ///     <term>language</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default. </term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Default Answer response when no good match is found in the Knowledgebase. </term>
        ///   </item>
        ///   <item>
        ///     <term>multilingualResource</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term> Resource enabled for multiple languages across projects or not. </term>
        ///   </item>
        ///   <item>
        ///     <term>createdDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term> Project creation date-time. </term>
        ///   </item>
        ///   <item>
        ///     <term>lastModifiedDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term> Represents the project last modified date-time. </term>
        ///   </item>
        ///   <item>
        ///     <term>lastDeployedDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term> Represents the project last deployment date-time. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>Assets</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>synonyms</term>
        ///     <term>WordAlterations[]</term>
        ///     <term></term>
        ///     <term> Collection of synonyms. </term>
        ///   </item>
        ///   <item>
        ///     <term>qnas</term>
        ///     <term>RetrieveQnaRecord[]</term>
        ///     <term></term>
        ///     <term> List of QnA records. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>WordAlterations</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>alterations</term>
        ///     <term>string[]</term>
        ///     <term>Yes</term>
        ///     <term> Collection of word alterations. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>RetrieveQnaRecord</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term> Unique ID for the QnA. </term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Answer text. </term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs . </term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term> List of questions associated with the answer. </term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term> Metadata associated with the answer, useful to categorize or filter question answers. </term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term> Context of a QnA. </term>
        ///   </item>
        ///   <item>
        ///     <term>lastUpdatedDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term> Date-time when the QnA was last updated. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaDialog</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>isContextOnly</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term> To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as search result for queries without context; otherwise, ignores context and includes this QnA in search result. </term>
        ///   </item>
        ///   <item>
        ///     <term>prompts</term>
        ///     <term>QnaPrompt[]</term>
        ///     <term></term>
        ///     <term> List of prompts associated with the answer. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaPrompt</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>displayOrder</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term> Index of the prompt. It is used for ordering of the prompts. </term>
        ///   </item>
        ///   <item>
        ///     <term>qnaId</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term> ID of the QnA corresponding to the prompt. </term>
        ///   </item>
        ///   <item>
        ///     <term>qna</term>
        ///     <term>QnaRecord</term>
        ///     <term></term>
        ///     <term> QnA record. Either QnAId or QnA record needs to be present in a Prompt. </term>
        ///   </item>
        ///   <item>
        ///     <term>displayText</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Text displayed to represent a follow up question prompt. </term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaRecord</c>:
        /// <list type="table">
        ///   <listeader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listeader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term> Unique ID for the QnA. </term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Answer text. </term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term> Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs . </term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term> List of questions associated with the answer. </term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term> Metadata associated with the answer, useful to categorize or filter question answers. </term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term> Context of a QnA. </term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="format"> Knowledgebase Import or Export format. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response Import(string projectName, RequestContent requestBody, string format = null, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateImportRequest(projectName, requestBody, format, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Import");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="Import"/> and <see cref="ImportAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="requestBody"> The request body. </param>
        /// <param name="format"> Knowledgebase Import or Export format. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateImportRequest(string projectName, RequestContent requestBody, string format = null, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:import", false);
            uri.AppendQuery("api-version", apiVersion, true);
            if (format != null)
            {
                uri.AppendQuery("format", format, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = requestBody;
            return message;
        }

        /// <summary> Gets the status of an Import job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetImportStatusAsync(string projectName, string jobId, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateGetImportStatusRequest(projectName, jobId, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetImportStatus");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an Import job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetImportStatus(string projectName, string jobId, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateGetImportStatusRequest(projectName, jobId, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetImportStatus");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetImportStatus"/> and <see cref="GetImportStatusAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateGetImportStatusRequest(string projectName, string jobId, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/import/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Deploy project to production. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> DeployProjectAsync(string projectName, string deploymentName, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeployProject");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deploy project to production. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response DeployProject(string projectName, string deploymentName, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeployProject");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="DeployProject"/> and <see cref="DeployProjectAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateDeployProjectRequest(string projectName, string deploymentName, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets the status of a Deploy job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetDeployStatusAsync(string projectName, string deploymentName, string jobId, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateGetDeployStatusRequest(projectName, deploymentName, jobId, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetDeployStatus");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, requestOptions.CancellationToken).ConfigureAwait(false);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a Deploy job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetDeployStatus(string projectName, string deploymentName, string jobId, RequestOptions requestOptions = null)
#pragma warning restore AZC0002
        {
            requestOptions ??= new RequestOptions();
            HttpMessage message = CreateGetDeployStatusRequest(projectName, deploymentName, jobId, requestOptions);
            if (requestOptions.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", requestOptions.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetDeployStatus");
            scope.Start();
            try
            {
                Pipeline.Send(message, requestOptions.CancellationToken);
                if (requestOptions.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetDeployStatus"/> and <see cref="GetDeployStatusAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="requestOptions"> The request options. </param>
        private HttpMessage CreateGetDeployStatusRequest(string projectName, string deploymentName, string jobId, RequestOptions requestOptions = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }
    }
}
