// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Language.QuestionAnswering
{
    /// <summary> The QuestionAnsweringProjects service client. </summary>
    public partial class QuestionAnsweringProjectsClient
    {
        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline { get; }
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private Uri endpoint;
        private readonly string apiVersion;
        private readonly ClientDiagnostics _clientDiagnostics;

        /// <summary> Initializes a new instance of QuestionAnsweringProjectsClient for mocking. </summary>
        protected QuestionAnsweringProjectsClient()
        {
        }

        /// <summary> Initializes a new instance of QuestionAnsweringProjectsClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoint (e.g., https://&lt;resource-name&gt;.api.cognitiveservices.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        public QuestionAnsweringProjectsClient(Uri endpoint, AzureKeyCredential credential, QuestionAnsweringClientOptions options = null)
        {
            if (endpoint == null)
            {
                throw new ArgumentNullException(nameof(endpoint));
            }
            if (credential == null)
            {
                throw new ArgumentNullException(nameof(credential));
            }

            options ??= new QuestionAnsweringClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _keyCredential = credential;
            var authPolicy = new AzureKeyCredentialPolicy(_keyCredential, AuthorizationHeader);
            Pipeline = HttpPipelineBuilder.Build(options, new HttpPipelinePolicy[] { new LowLevelCallbackPolicy() }, new HttpPipelinePolicy[] { authPolicy }, new ResponseClassifier());
            this.endpoint = endpoint;
            apiVersion = options.Version;
        }

        /// <summary> Gets all projects for a user. </summary>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> ListProjectsAsync(RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateListProjectsRequest(options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.ListProjects");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets all projects for a user. </summary>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response ListProjects(RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateListProjectsRequest(options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.ListProjects");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="ListProjects"/> and <see cref="ListProjectsAsync"/> operations. </summary>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateListProjectsRequest(RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Get the requested project metadata. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetProjectDetailsAsync(string projectName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetProjectDetailsRequest(projectName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetProjectDetails");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the requested project metadata. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetProjectDetails(string projectName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetProjectDetailsRequest(projectName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetProjectDetails");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetProjectDetails"/> and <see cref="GetProjectDetailsAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetProjectDetailsRequest(string projectName, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Create or update a project. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>projectName</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>Friendly name for the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>description</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Description of the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>language</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.</term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Default Answer response when no good match is found in the knowledge base.</term>
        ///   </item>
        ///   <item>
        ///     <term>multilingualResource</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>Set to true to enable creating knowledgebases in different languages for the same resource.</term>
        ///   </item>
        ///   <item>
        ///     <term>enableHierarchicalExtraction</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>Resource enabled for hierarchical QnA extraction from sources.</term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswerUsedForExtraction</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Default answer to be used during QnA extraction from sources.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> CreateProjectAsync(string projectName, RequestContent content, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateCreateProjectRequest(projectName, content, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.CreateProject");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                        case 201:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or update a project. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>projectName</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>Friendly name for the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>description</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Description of the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>language</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.</term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Default Answer response when no good match is found in the knowledge base.</term>
        ///   </item>
        ///   <item>
        ///     <term>multilingualResource</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>Set to true to enable creating knowledgebases in different languages for the same resource.</term>
        ///   </item>
        ///   <item>
        ///     <term>enableHierarchicalExtraction</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>Resource enabled for hierarchical QnA extraction from sources.</term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswerUsedForExtraction</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Default answer to be used during QnA extraction from sources.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response CreateProject(string projectName, RequestContent content, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateCreateProjectRequest(projectName, content, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.CreateProject");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                        case 201:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="CreateProject"/> and <see cref="CreateProjectAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateCreateProjectRequest(string projectName, RequestContent content, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        /// <summary> Delete the project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> DeleteProjectAsync(string projectName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateDeleteProjectRequest(projectName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeleteProject");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 204:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete the project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response DeleteProject(string projectName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateDeleteProjectRequest(projectName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeleteProject");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 204:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="DeleteProject"/> and <see cref="DeleteProjectAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateDeleteProjectRequest(string projectName, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Export project metadata and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="format"> Knowledge base Import or Export format. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Operation<BinaryData>> ExportAsync(string projectName, string format = null, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateExportRequest(projectName, format, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Export");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.Export");
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.Export");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Export project metadata and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="format"> Knowledge base Import or Export format. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Operation<BinaryData> Export(string projectName, string format = null, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateExportRequest(projectName, format, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Export");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.Export");
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.Export");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="Export"/> and <see cref="ExportAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="format"> Knowledge base Import or Export format. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateExportRequest(string projectName, string format = null, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:export", false);
            uri.AppendQuery("api-version", apiVersion, true);
            if (format != null)
            {
                uri.AppendQuery("format", format, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets the status of an Export job, once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetExportStatusAsync(string projectName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetExportStatusRequest(projectName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetExportStatus");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an Export job, once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetExportStatus(string projectName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetExportStatusRequest(projectName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetExportStatus");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetExportStatus"/> and <see cref="GetExportStatusAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetExportStatusRequest(string projectName, string jobId, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/export/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Import project assets. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>projectMetadata</term>
        ///     <term>CreateProjectOptions</term>
        ///     <term></term>
        ///     <term>Parameters needed to create the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>assets</term>
        ///     <term>Assets</term>
        ///     <term></term>
        ///     <term>All assets for this project.</term>
        ///   </item>
        ///   <item>
        ///     <term>fileUri</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Import data File URI.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>CreateProjectOptions</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>projectName</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>Friendly name for the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>description</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Description of the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>language</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.</term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Default Answer response when no good match is found in the knowledge base.</term>
        ///   </item>
        ///   <item>
        ///     <term>multilingualResource</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>Set to true to enable creating knowledgebases in different languages for the same resource.</term>
        ///   </item>
        ///   <item>
        ///     <term>enableHierarchicalExtraction</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>Resource enabled for hierarchical QnA extraction from sources.</term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswerUsedForExtraction</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Default answer to be used during QnA extraction from sources.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>Assets</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>synonyms</term>
        ///     <term>WordAlterations[]</term>
        ///     <term></term>
        ///     <term>Collection of synonyms.</term>
        ///   </item>
        ///   <item>
        ///     <term>qnas</term>
        ///     <term>RetrieveQnaRecord[]</term>
        ///     <term></term>
        ///     <term>List of QnA records.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>WordAlterations</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>alterations</term>
        ///     <term>string[]</term>
        ///     <term>Yes</term>
        ///     <term>Collection of word alterations.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>RetrieveQnaRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Unique ID for the QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Answer text.</term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .</term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term>List of questions associated with the answer.</term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term>Metadata associated with the answer, useful to categorize or filter question answers.</term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term>Context of a QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>activeLearningSuggestions</term>
        ///     <term>SuggestedQuestionsCluster[]</term>
        ///     <term></term>
        ///     <term>List of Active Learning suggestions for the QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>lastUpdatedDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term>Date-time when the QnA was last updated.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaDialog</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>isContextOnly</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as search result for queries without context; otherwise, ignores context and includes this QnA in search result.</term>
        ///   </item>
        ///   <item>
        ///     <term>prompts</term>
        ///     <term>QnaPrompt[]</term>
        ///     <term></term>
        ///     <term>List of prompts associated with the answer.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>SuggestedQuestionsCluster</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>clusterHead</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.</term>
        ///   </item>
        ///   <item>
        ///     <term>suggestedQuestions</term>
        ///     <term>SuggestedQuestion[]</term>
        ///     <term></term>
        ///     <term>List of all suggested questions for the QnA.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaPrompt</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>displayOrder</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Index of the prompt. It is used for ordering of the prompts.</term>
        ///   </item>
        ///   <item>
        ///     <term>qnaId</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>ID of the QnA corresponding to the prompt.</term>
        ///   </item>
        ///   <item>
        ///     <term>qna</term>
        ///     <term>QnaRecord</term>
        ///     <term></term>
        ///     <term>QnA record. Either QnAId or QnA record needs to be present in a Prompt.</term>
        ///   </item>
        ///   <item>
        ///     <term>displayText</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Text displayed to represent a follow up question prompt.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Unique ID for the QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Answer text.</term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .</term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term>List of questions associated with the answer.</term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term>Metadata associated with the answer, useful to categorize or filter question answers.</term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term>Context of a QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>activeLearningSuggestions</term>
        ///     <term>SuggestedQuestionsCluster[]</term>
        ///     <term></term>
        ///     <term>List of Active Learning suggestions for the QnA.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>SuggestedQuestion</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>question</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Question suggested by the Active Learning feature.</term>
        ///   </item>
        ///   <item>
        ///     <term>userSuggestedCount</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>The number of times the question was suggested explicitly by the user.</term>
        ///   </item>
        ///   <item>
        ///     <term>autoSuggestedCount</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>The number of times the question was suggested automatically by the Active Learning algorithm.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="format"> Knowledge base Import or Export format. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Operation<BinaryData>> ImportAsync(string projectName, RequestContent content, string format = null, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateImportRequest(projectName, content, format, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Import");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.Import");
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.Import");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Import project assets. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>projectMetadata</term>
        ///     <term>CreateProjectOptions</term>
        ///     <term></term>
        ///     <term>Parameters needed to create the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>assets</term>
        ///     <term>Assets</term>
        ///     <term></term>
        ///     <term>All assets for this project.</term>
        ///   </item>
        ///   <item>
        ///     <term>fileUri</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Import data File URI.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>CreateProjectOptions</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>projectName</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>Friendly name for the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>description</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Description of the project.</term>
        ///   </item>
        ///   <item>
        ///     <term>language</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.</term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Default Answer response when no good match is found in the knowledge base.</term>
        ///   </item>
        ///   <item>
        ///     <term>multilingualResource</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>Set to true to enable creating knowledgebases in different languages for the same resource.</term>
        ///   </item>
        ///   <item>
        ///     <term>enableHierarchicalExtraction</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>Resource enabled for hierarchical QnA extraction from sources.</term>
        ///   </item>
        ///   <item>
        ///     <term>defaultAnswerUsedForExtraction</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Default answer to be used during QnA extraction from sources.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>Assets</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>synonyms</term>
        ///     <term>WordAlterations[]</term>
        ///     <term></term>
        ///     <term>Collection of synonyms.</term>
        ///   </item>
        ///   <item>
        ///     <term>qnas</term>
        ///     <term>RetrieveQnaRecord[]</term>
        ///     <term></term>
        ///     <term>List of QnA records.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>WordAlterations</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>alterations</term>
        ///     <term>string[]</term>
        ///     <term>Yes</term>
        ///     <term>Collection of word alterations.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>RetrieveQnaRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Unique ID for the QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Answer text.</term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .</term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term>List of questions associated with the answer.</term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term>Metadata associated with the answer, useful to categorize or filter question answers.</term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term>Context of a QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>activeLearningSuggestions</term>
        ///     <term>SuggestedQuestionsCluster[]</term>
        ///     <term></term>
        ///     <term>List of Active Learning suggestions for the QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>lastUpdatedDateTime</term>
        ///     <term>string (ISO 8601 Format)</term>
        ///     <term></term>
        ///     <term>Date-time when the QnA was last updated.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaDialog</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>isContextOnly</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as search result for queries without context; otherwise, ignores context and includes this QnA in search result.</term>
        ///   </item>
        ///   <item>
        ///     <term>prompts</term>
        ///     <term>QnaPrompt[]</term>
        ///     <term></term>
        ///     <term>List of prompts associated with the answer.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>SuggestedQuestionsCluster</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>clusterHead</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.</term>
        ///   </item>
        ///   <item>
        ///     <term>suggestedQuestions</term>
        ///     <term>SuggestedQuestion[]</term>
        ///     <term></term>
        ///     <term>List of all suggested questions for the QnA.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaPrompt</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>displayOrder</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Index of the prompt. It is used for ordering of the prompts.</term>
        ///   </item>
        ///   <item>
        ///     <term>qnaId</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>ID of the QnA corresponding to the prompt.</term>
        ///   </item>
        ///   <item>
        ///     <term>qna</term>
        ///     <term>QnaRecord</term>
        ///     <term></term>
        ///     <term>QnA record. Either QnAId or QnA record needs to be present in a Prompt.</term>
        ///   </item>
        ///   <item>
        ///     <term>displayText</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Text displayed to represent a follow up question prompt.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Unique ID for the QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Answer text.</term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .</term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term>List of questions associated with the answer.</term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term>Metadata associated with the answer, useful to categorize or filter question answers.</term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term>Context of a QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>activeLearningSuggestions</term>
        ///     <term>SuggestedQuestionsCluster[]</term>
        ///     <term></term>
        ///     <term>List of Active Learning suggestions for the QnA.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>SuggestedQuestion</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>question</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Question suggested by the Active Learning feature.</term>
        ///   </item>
        ///   <item>
        ///     <term>userSuggestedCount</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>The number of times the question was suggested explicitly by the user.</term>
        ///   </item>
        ///   <item>
        ///     <term>autoSuggestedCount</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>The number of times the question was suggested automatically by the Active Learning algorithm.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="format"> Knowledge base Import or Export format. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Operation<BinaryData> Import(string projectName, RequestContent content, string format = null, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateImportRequest(projectName, content, format, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Import");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.Import");
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.Import");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="Import"/> and <see cref="ImportAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="format"> Knowledge base Import or Export format. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateImportRequest(string projectName, RequestContent content, string format = null, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:import", false);
            uri.AppendQuery("api-version", apiVersion, true);
            if (format != null)
            {
                uri.AppendQuery("format", format, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        /// <summary> Gets the status of an Import job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetImportStatusAsync(string projectName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetImportStatusRequest(projectName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetImportStatus");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an Import job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetImportStatus(string projectName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetImportStatusRequest(projectName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetImportStatus");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetImportStatus"/> and <see cref="GetImportStatusAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetImportStatusRequest(string projectName, string jobId, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/import/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Deploy project to production. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Operation<BinaryData>> DeployProjectAsync(string projectName, string deploymentName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeployProject");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.DeployProject");
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.DeployProject");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deploy project to production. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Operation<BinaryData> DeployProject(string projectName, string deploymentName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeployProject");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.DeployProject");
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.DeployProject");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="DeployProject"/> and <see cref="DeployProjectAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateDeployProjectRequest(string projectName, string deploymentName, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets the status of a Deploy job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetDeployStatusAsync(string projectName, string deploymentName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetDeployStatusRequest(projectName, deploymentName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetDeployStatus");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a Deploy job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetDeployStatus(string projectName, string deploymentName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetDeployStatusRequest(projectName, deploymentName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetDeployStatus");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetDeployStatus"/> and <see cref="GetDeployStatusAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetDeployStatusRequest(string projectName, string deploymentName, string jobId, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets all the synonyms of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetSynonymsAsync(string projectName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetSynonymsRequest(projectName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetSynonyms");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets all the synonyms of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetSynonyms(string projectName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetSynonymsRequest(projectName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetSynonyms");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetSynonyms"/> and <see cref="GetSynonymsAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetSynonymsRequest(string projectName, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/synonyms", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Updates all the synonyms of a project. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>synonyms</term>
        ///     <term>WordAlterations[]</term>
        ///     <term></term>
        ///     <term>Collection of synonyms.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>WordAlterations</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>alterations</term>
        ///     <term>string[]</term>
        ///     <term>Yes</term>
        ///     <term>Collection of word alterations.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> UpdateSynonymsAsync(string projectName, RequestContent content, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateUpdateSynonymsRequest(projectName, content, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateSynonyms");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 204:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates all the synonyms of a project. </summary>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>synonyms</term>
        ///     <term>WordAlterations[]</term>
        ///     <term></term>
        ///     <term>Collection of synonyms.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>WordAlterations</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>alterations</term>
        ///     <term>string[]</term>
        ///     <term>Yes</term>
        ///     <term>Collection of word alterations.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response UpdateSynonyms(string projectName, RequestContent content, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateUpdateSynonymsRequest(projectName, content, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateSynonyms");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 204:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="UpdateSynonyms"/> and <see cref="UpdateSynonymsAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateUpdateSynonymsRequest(string projectName, RequestContent content, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/synonyms", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        /// <summary> Gets all the sources of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetSourcesAsync(string projectName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetSourcesRequest(projectName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetSources");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets all the sources of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetSources(string projectName, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetSourcesRequest(projectName, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetSources");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetSources"/> and <see cref="GetSourcesAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetSourcesRequest(string projectName, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/sources", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Updates the sources of a project. </summary>
        /// <remarks>
        /// Schema for <c>UpdateSourceRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>op</term>
        ///     <term>&quot;add&quot; | &quot;delete&quot; | &quot;replace&quot;</term>
        ///     <term>Yes</term>
        ///     <term>Update operation type for assets.</term>
        ///   </item>
        ///   <item>
        ///     <term>value</term>
        ///     <term>QnaSourceMetadata</term>
        ///     <term>Yes</term>
        ///     <term>Input source file or url details.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaSourceMetadata</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>sourceName</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Friendly name of the Source.</term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Unique source identifier.</term>
        ///   </item>
        ///   <item>
        ///     <term>sourceUri</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>URI location for the file or url.</term>
        ///   </item>
        ///   <item>
        ///     <term>sourceKind</term>
        ///     <term>&quot;file&quot; | &quot;url&quot;</term>
        ///     <term>Yes</term>
        ///     <term>Supported source types.</term>
        ///   </item>
        ///   <item>
        ///     <term>contentStructureKind</term>
        ///     <term>&quot;unstructured&quot;</term>
        ///     <term></term>
        ///     <term>Content structure type for sources.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Operation<BinaryData>> UpdateSourcesAsync(string projectName, RequestContent content, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateUpdateSourcesRequest(projectName, content, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateSources");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.UpdateSources");
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.UpdateSources");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the sources of a project. </summary>
        /// <remarks>
        /// Schema for <c>UpdateSourceRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>op</term>
        ///     <term>&quot;add&quot; | &quot;delete&quot; | &quot;replace&quot;</term>
        ///     <term>Yes</term>
        ///     <term>Update operation type for assets.</term>
        ///   </item>
        ///   <item>
        ///     <term>value</term>
        ///     <term>QnaSourceMetadata</term>
        ///     <term>Yes</term>
        ///     <term>Input source file or url details.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaSourceMetadata</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>sourceName</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Friendly name of the Source.</term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Unique source identifier.</term>
        ///   </item>
        ///   <item>
        ///     <term>sourceUri</term>
        ///     <term>string</term>
        ///     <term>Yes</term>
        ///     <term>URI location for the file or url.</term>
        ///   </item>
        ///   <item>
        ///     <term>sourceKind</term>
        ///     <term>&quot;file&quot; | &quot;url&quot;</term>
        ///     <term>Yes</term>
        ///     <term>Supported source types.</term>
        ///   </item>
        ///   <item>
        ///     <term>contentStructureKind</term>
        ///     <term>&quot;unstructured&quot;</term>
        ///     <term></term>
        ///     <term>Content structure type for sources.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Operation<BinaryData> UpdateSources(string projectName, RequestContent content, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateUpdateSourcesRequest(projectName, content, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateSources");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.UpdateSources");
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.UpdateSources");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="UpdateSources"/> and <see cref="UpdateSourcesAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateUpdateSourcesRequest(string projectName, RequestContent content, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/sources", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        /// <summary> Gets the status of update sources job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetUpdateSourcesStatusAsync(string projectName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetUpdateSourcesStatusRequest(projectName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetUpdateSourcesStatus");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of update sources job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetUpdateSourcesStatus(string projectName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetUpdateSourcesStatusRequest(projectName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetUpdateSourcesStatus");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetUpdateSourcesStatus"/> and <see cref="GetUpdateSourcesStatusAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetUpdateSourcesStatusRequest(string projectName, string jobId, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/sources/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets all the QnAs of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="source"> Source of the QnA. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetQnasAsync(string projectName, string source = null, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetQnasRequest(projectName, source, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetQnas");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets all the QnAs of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="source"> Source of the QnA. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetQnas(string projectName, string source = null, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetQnasRequest(projectName, source, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetQnas");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetQnas"/> and <see cref="GetQnasAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="source"> Source of the QnA. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetQnasRequest(string projectName, string source = null, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/qnas", false);
            uri.AppendQuery("api-version", apiVersion, true);
            if (source != null)
            {
                uri.AppendQuery("source", source, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Updates the QnAs of a project. </summary>
        /// <remarks>
        /// Schema for <c>UpdateQnaRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>op</term>
        ///     <term>&quot;add&quot; | &quot;delete&quot; | &quot;replace&quot;</term>
        ///     <term>Yes</term>
        ///     <term>Update operation type for assets.</term>
        ///   </item>
        ///   <item>
        ///     <term>value</term>
        ///     <term>QnaRecord</term>
        ///     <term>Yes</term>
        ///     <term>QnA record.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Unique ID for the QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Answer text.</term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .</term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term>List of questions associated with the answer.</term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term>Metadata associated with the answer, useful to categorize or filter question answers.</term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term>Context of a QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>activeLearningSuggestions</term>
        ///     <term>SuggestedQuestionsCluster[]</term>
        ///     <term></term>
        ///     <term>List of Active Learning suggestions for the QnA.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaDialog</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>isContextOnly</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as search result for queries without context; otherwise, ignores context and includes this QnA in search result.</term>
        ///   </item>
        ///   <item>
        ///     <term>prompts</term>
        ///     <term>QnaPrompt[]</term>
        ///     <term></term>
        ///     <term>List of prompts associated with the answer.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>SuggestedQuestionsCluster</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>clusterHead</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.</term>
        ///   </item>
        ///   <item>
        ///     <term>suggestedQuestions</term>
        ///     <term>SuggestedQuestion[]</term>
        ///     <term></term>
        ///     <term>List of all suggested questions for the QnA.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaPrompt</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>displayOrder</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Index of the prompt. It is used for ordering of the prompts.</term>
        ///   </item>
        ///   <item>
        ///     <term>qnaId</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>ID of the QnA corresponding to the prompt.</term>
        ///   </item>
        ///   <item>
        ///     <term>qna</term>
        ///     <term>QnaRecord</term>
        ///     <term></term>
        ///     <term>QnA record. Either QnAId or QnA record needs to be present in a Prompt.</term>
        ///   </item>
        ///   <item>
        ///     <term>displayText</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Text displayed to represent a follow up question prompt.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>SuggestedQuestion</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>question</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Question suggested by the Active Learning feature.</term>
        ///   </item>
        ///   <item>
        ///     <term>userSuggestedCount</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>The number of times the question was suggested explicitly by the user.</term>
        ///   </item>
        ///   <item>
        ///     <term>autoSuggestedCount</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>The number of times the question was suggested automatically by the Active Learning algorithm.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Operation<BinaryData>> UpdateQnasAsync(string projectName, RequestContent content, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateUpdateQnasRequest(projectName, content, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateQnas");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.UpdateQnas");
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.UpdateQnas");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the QnAs of a project. </summary>
        /// <remarks>
        /// Schema for <c>UpdateQnaRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>op</term>
        ///     <term>&quot;add&quot; | &quot;delete&quot; | &quot;replace&quot;</term>
        ///     <term>Yes</term>
        ///     <term>Update operation type for assets.</term>
        ///   </item>
        ///   <item>
        ///     <term>value</term>
        ///     <term>QnaRecord</term>
        ///     <term>Yes</term>
        ///     <term>QnA record.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaRecord</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>id</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Unique ID for the QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>answer</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Answer text.</term>
        ///   </item>
        ///   <item>
        ///     <term>source</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .</term>
        ///   </item>
        ///   <item>
        ///     <term>questions</term>
        ///     <term>string[]</term>
        ///     <term></term>
        ///     <term>List of questions associated with the answer.</term>
        ///   </item>
        ///   <item>
        ///     <term>metadata</term>
        ///     <term>Dictionary&lt;string, string&gt;</term>
        ///     <term></term>
        ///     <term>Metadata associated with the answer, useful to categorize or filter question answers.</term>
        ///   </item>
        ///   <item>
        ///     <term>dialog</term>
        ///     <term>QnaDialog</term>
        ///     <term></term>
        ///     <term>Context of a QnA.</term>
        ///   </item>
        ///   <item>
        ///     <term>activeLearningSuggestions</term>
        ///     <term>SuggestedQuestionsCluster[]</term>
        ///     <term></term>
        ///     <term>List of Active Learning suggestions for the QnA.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaDialog</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>isContextOnly</term>
        ///     <term>boolean</term>
        ///     <term></term>
        ///     <term>To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as search result for queries without context; otherwise, ignores context and includes this QnA in search result.</term>
        ///   </item>
        ///   <item>
        ///     <term>prompts</term>
        ///     <term>QnaPrompt[]</term>
        ///     <term></term>
        ///     <term>List of prompts associated with the answer.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>SuggestedQuestionsCluster</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>clusterHead</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.</term>
        ///   </item>
        ///   <item>
        ///     <term>suggestedQuestions</term>
        ///     <term>SuggestedQuestion[]</term>
        ///     <term></term>
        ///     <term>List of all suggested questions for the QnA.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>QnaPrompt</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>displayOrder</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>Index of the prompt. It is used for ordering of the prompts.</term>
        ///   </item>
        ///   <item>
        ///     <term>qnaId</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>ID of the QnA corresponding to the prompt.</term>
        ///   </item>
        ///   <item>
        ///     <term>qna</term>
        ///     <term>QnaRecord</term>
        ///     <term></term>
        ///     <term>QnA record. Either QnAId or QnA record needs to be present in a Prompt.</term>
        ///   </item>
        ///   <item>
        ///     <term>displayText</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Text displayed to represent a follow up question prompt.</term>
        ///   </item>
        /// </list>
        /// Schema for <c>SuggestedQuestion</c>:
        /// <list type="table">
        ///   <listheader>
        ///     <term>Name</term>
        ///     <term>Type</term>
        ///     <term>Required</term>
        ///     <term>Description</term>
        ///   </listheader>
        ///   <item>
        ///     <term>question</term>
        ///     <term>string</term>
        ///     <term></term>
        ///     <term>Question suggested by the Active Learning feature.</term>
        ///   </item>
        ///   <item>
        ///     <term>userSuggestedCount</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>The number of times the question was suggested explicitly by the user.</term>
        ///   </item>
        ///   <item>
        ///     <term>autoSuggestedCount</term>
        ///     <term>number</term>
        ///     <term></term>
        ///     <term>The number of times the question was suggested automatically by the Active Learning algorithm.</term>
        ///   </item>
        /// </list>
        /// </remarks>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Operation<BinaryData> UpdateQnas(string projectName, RequestContent content, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateUpdateQnasRequest(projectName, content, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateQnas");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 202:
                            return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.UpdateQnas");
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return new LowLevelBinaryDataOperation(_clientDiagnostics, Pipeline, message.Request, message.Response, OperationFinalStateVia.Location, "QuestionAnsweringProjectsClient.UpdateQnas");
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="UpdateQnas"/> and <see cref="UpdateQnasAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateUpdateQnasRequest(string projectName, RequestContent content, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/qnas", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        /// <summary> Gets the status of update QnAs job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual async Task<Response> GetUpdateQnasStatusAsync(string projectName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetUpdateQnasStatusRequest(projectName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetUpdateQnasStatus");
            scope.Start();
            try
            {
                await Pipeline.SendAsync(message, options.CancellationToken).ConfigureAwait(false);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of update QnAs job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
#pragma warning disable AZC0002
        public virtual Response GetUpdateQnasStatus(string projectName, string jobId, RequestOptions options = null)
#pragma warning restore AZC0002
        {
            options ??= new RequestOptions();
            HttpMessage message = CreateGetUpdateQnasStatusRequest(projectName, jobId, options);
            if (options.PerCallPolicy != null)
            {
                message.SetProperty("RequestOptionsPerCallPolicyCallback", options.PerCallPolicy);
            }
            using var scope = _clientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetUpdateQnasStatus");
            scope.Start();
            try
            {
                Pipeline.Send(message, options.CancellationToken);
                if (options.StatusOption == ResponseStatusOption.Default)
                {
                    switch (message.Response.Status)
                    {
                        case 200:
                            return message.Response;
                        default:
                            throw _clientDiagnostics.CreateRequestFailedException(message.Response);
                    }
                }
                else
                {
                    return message.Response;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create Request for <see cref="GetUpdateQnasStatus"/> and <see cref="GetUpdateQnasStatusAsync"/> operations. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="options"> The request options. </param>
        private HttpMessage CreateGetUpdateQnasStatusRequest(string projectName, string jobId, RequestOptions options = null)
        {
            var message = Pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/qnas/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }
    }
}
