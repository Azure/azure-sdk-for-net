// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.Language.QuestionAnswering;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Language.QuestionAnswering.Projects
{
    // Data plane generated client. The QuestionAnsweringProjects service client.
    /// <summary> The QuestionAnsweringProjects service client. </summary>
    public partial class QuestionAnsweringProjectsClient
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of QuestionAnsweringProjectsClient for mocking. </summary>
        protected QuestionAnsweringProjectsClient()
        {
        }

        /// <summary> Initializes a new instance of QuestionAnsweringProjectsClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoint (e.g., https://&lt;resource-name&gt;.api.cognitiveservices.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public QuestionAnsweringProjectsClient(Uri endpoint, AzureKeyCredential credential) : this(endpoint, credential, new QuestionAnsweringClientOptions())
        {
        }

        /// <summary> Initializes a new instance of QuestionAnsweringProjectsClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoint (e.g., https://&lt;resource-name&gt;.api.cognitiveservices.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public QuestionAnsweringProjectsClient(Uri endpoint, AzureKeyCredential credential, QuestionAnsweringClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new QuestionAnsweringClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _keyCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new AzureKeyCredentialPolicy(_keyCredential, AuthorizationHeader) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Get the requested project metadata. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectDetailsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = await client.GetProjectDetailsAsync("<projectName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// Console.WriteLine(result.GetProperty("multilingualResource").ToString());
        /// Console.WriteLine(result.GetProperty("settings").GetProperty("defaultAnswer").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   projectName: string, # Optional. Name of the project.
        ///   description: string, # Optional. Description of the project.
        ///   language: string, # Optional. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///   multilingualResource: boolean, # Optional. Resource enabled for multiple languages across projects or not.
        ///   settings: {
        ///     defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///   }, # Optional. Configurable settings of the Project.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. Project creation date-time.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. Represents the project last modified date-time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment date-time.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetProjectDetailsAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetProjectDetails");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectDetailsRequest(projectName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the requested project metadata. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectDetails with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = client.GetProjectDetails("<projectName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// Console.WriteLine(result.GetProperty("multilingualResource").ToString());
        /// Console.WriteLine(result.GetProperty("settings").GetProperty("defaultAnswer").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   projectName: string, # Optional. Name of the project.
        ///   description: string, # Optional. Description of the project.
        ///   language: string, # Optional. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///   multilingualResource: boolean, # Optional. Resource enabled for multiple languages across projects or not.
        ///   settings: {
        ///     defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///   }, # Optional. Configurable settings of the Project.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. Project creation date-time.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. Represents the project last modified date-time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment date-time.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetProjectDetails(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetProjectDetails");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectDetailsRequest(projectName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or update a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateProjectAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = await client.CreateProjectAsync("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateProjectAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     description = "<description>",
        ///     language = "<language>",
        ///     multilingualResource = true,
        ///     settings = new {
        ///         defaultAnswer = "<defaultAnswer>",
        ///     },
        /// };
        /// 
        /// Response response = await client.CreateProjectAsync("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// Console.WriteLine(result.GetProperty("multilingualResource").ToString());
        /// Console.WriteLine(result.GetProperty("settings").GetProperty("defaultAnswer").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateProjectOptions</c>:
        /// <code>{
        ///   description: string, # Optional. Description of the project.
        ///   language: string, # Required. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///   multilingualResource: boolean, # Optional. Set to true to enable creating knowledgebases in different languages for the same resource.
        ///   settings: {
        ///     defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///   }, # Optional. Configurable settings of the Project.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   projectName: string, # Optional. Name of the project.
        ///   description: string, # Optional. Description of the project.
        ///   language: string, # Optional. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///   multilingualResource: boolean, # Optional. Resource enabled for multiple languages across projects or not.
        ///   settings: {
        ///     defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///   }, # Optional. Configurable settings of the Project.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. Project creation date-time.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. Represents the project last modified date-time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment date-time.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateProjectAsync(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.CreateProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateProjectRequest(projectName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or update a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateProject with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = client.CreateProject("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateProject with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     description = "<description>",
        ///     language = "<language>",
        ///     multilingualResource = true,
        ///     settings = new {
        ///         defaultAnswer = "<defaultAnswer>",
        ///     },
        /// };
        /// 
        /// Response response = client.CreateProject("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// Console.WriteLine(result.GetProperty("multilingualResource").ToString());
        /// Console.WriteLine(result.GetProperty("settings").GetProperty("defaultAnswer").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateProjectOptions</c>:
        /// <code>{
        ///   description: string, # Optional. Description of the project.
        ///   language: string, # Required. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///   multilingualResource: boolean, # Optional. Set to true to enable creating knowledgebases in different languages for the same resource.
        ///   settings: {
        ///     defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///   }, # Optional. Configurable settings of the Project.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   projectName: string, # Optional. Name of the project.
        ///   description: string, # Optional. Description of the project.
        ///   language: string, # Optional. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///   multilingualResource: boolean, # Optional. Resource enabled for multiple languages across projects or not.
        ///   settings: {
        ///     defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///   }, # Optional. Configurable settings of the Project.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. Project creation date-time.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. Represents the project last modified date-time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment date-time.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateProject(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.CreateProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateProjectRequest(projectName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a Project delete job. </summary>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeleteStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = await client.GetDeleteStatusAsync("<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeleteStatusAsync(string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetDeleteStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeleteStatusRequest(jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a Project delete job. </summary>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeleteStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = client.GetDeleteStatus("<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetDeleteStatus(string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetDeleteStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeleteStatusRequest(jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an Export job, once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetExportStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = await client.GetExportStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetExportStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetExportStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetExportStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an Export job, once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetExportStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = client.GetExportStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetExportStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetExportStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetExportStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an Import job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetImportStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = await client.GetImportStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetImportStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetImportStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetImportStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an Import job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetImportStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = client.GetImportStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetImportStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetImportStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetImportStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a Deploy job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeployStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = await client.GetDeployStatusAsync("<projectName>", "<deploymentName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeployStatusAsync(string projectName, string deploymentName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetDeployStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeployStatusRequest(projectName, deploymentName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a Deploy job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeployStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = client.GetDeployStatus("<projectName>", "<deploymentName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetDeployStatus(string projectName, string deploymentName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetDeployStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeployStatusRequest(projectName, deploymentName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates all the synonyms of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call UpdateSynonymsAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.UpdateSynonymsAsync("<projectName>", RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call UpdateSynonymsAsync with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     value = new[] {
        ///         new {
        ///             alterations = new[] {
        ///                 "<String>"
        ///             },
        ///         }
        ///     },
        ///     nextLink = "<nextLink>",
        /// };
        /// 
        /// Response response = await client.UpdateSynonymsAsync("<projectName>", RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SynonymAssets</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       alterations: [string], # Required. Collection of word alterations.
        ///     }
        ///   ], # Optional. Collection of synonyms.
        ///   nextLink: string, # Optional.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateSynonymsAsync(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateSynonyms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateSynonymsRequest(projectName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates all the synonyms of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call UpdateSynonyms with required parameters.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.UpdateSynonyms("<projectName>", RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call UpdateSynonyms with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     value = new[] {
        ///         new {
        ///             alterations = new[] {
        ///                 "<String>"
        ///             },
        ///         }
        ///     },
        ///     nextLink = "<nextLink>",
        /// };
        /// 
        /// Response response = client.UpdateSynonyms("<projectName>", RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SynonymAssets</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       alterations: [string], # Required. Collection of word alterations.
        ///     }
        ///   ], # Optional. Collection of synonyms.
        ///   nextLink: string, # Optional.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateSynonyms(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateSynonyms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateSynonymsRequest(projectName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of update sources job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetUpdateSourcesStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = await client.GetUpdateSourcesStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetUpdateSourcesStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetUpdateSourcesStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateSourcesStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of update sources job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetUpdateSourcesStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = client.GetUpdateSourcesStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetUpdateSourcesStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetUpdateSourcesStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateSourcesStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of update QnAs job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetUpdateQnasStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = await client.GetUpdateQnasStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetUpdateQnasStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetUpdateQnasStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateQnasStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of update QnAs job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> Job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetUpdateQnasStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// Response response = client.GetUpdateQnasStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetUpdateQnasStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.GetUpdateQnasStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateQnasStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add Active Learning feedback. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call AddFeedbackAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.AddFeedbackAsync("<projectName>", RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call AddFeedbackAsync with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     records = new[] {
        ///         new {
        ///             userId = "<userId>",
        ///             userQuestion = "<userQuestion>",
        ///             qnaId = 1234,
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = await client.AddFeedbackAsync("<projectName>", RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ActiveLearningFeedback</c>:
        /// <code>{
        ///   records: [
        ///     {
        ///       userId: string, # Optional. Unique identifier of the user.
        ///       userQuestion: string, # Optional. User suggested question for the QnA.
        ///       qnaId: number, # Optional. Unique ID of the QnA.
        ///     }
        ///   ], # Optional. A list of Feedback Records for Active Learning.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AddFeedbackAsync(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.AddFeedback");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFeedbackRequest(projectName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add Active Learning feedback. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call AddFeedback with required parameters.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.AddFeedback("<projectName>", RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call AddFeedback with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     records = new[] {
        ///         new {
        ///             userId = "<userId>",
        ///             userQuestion = "<userQuestion>",
        ///             qnaId = 1234,
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = client.AddFeedback("<projectName>", RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ActiveLearningFeedback</c>:
        /// <code>{
        ///   records: [
        ///     {
        ///       userId: string, # Optional. Unique identifier of the user.
        ///       userQuestion: string, # Optional. User suggested question for the QnA.
        ///       qnaId: number, # Optional. Unique ID of the QnA.
        ///     }
        ///   ], # Optional. A list of Feedback Records for Active Learning.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AddFeedback(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.AddFeedback");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFeedbackRequest(projectName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets all projects for a user. </summary>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetProjectsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetProjectsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetProjectsAsync(1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("projectName").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("multilingualResource").ToString());
        ///     Console.WriteLine(result.GetProperty("settings").GetProperty("defaultAnswer").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectsMetadataValue</c>:
        /// <code>{
        ///   projectName: string, # Optional. Name of the project.
        ///   description: string, # Optional. Description of the project.
        ///   language: string, # Optional. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///   multilingualResource: boolean, # Optional. Resource enabled for multiple languages across projects or not.
        ///   settings: {
        ///     defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///   }, # Optional. Configurable settings of the Project.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. Project creation date-time.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. Represents the project last modified date-time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment date-time.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetProjectsAsync(int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            return GetProjectsImplementationAsync("QuestionAnsweringProjectsClient.GetProjects", top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetProjectsImplementationAsync(string diagnosticsScopeName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetProjectsRequest(top, skip, maxpagesize, context)
                        : CreateGetProjectsNextPageRequest(nextLink, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets all projects for a user. </summary>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjects and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetProjects())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetProjects with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetProjects(1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("projectName").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("multilingualResource").ToString());
        ///     Console.WriteLine(result.GetProperty("settings").GetProperty("defaultAnswer").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectsMetadataValue</c>:
        /// <code>{
        ///   projectName: string, # Optional. Name of the project.
        ///   description: string, # Optional. Description of the project.
        ///   language: string, # Optional. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///   multilingualResource: boolean, # Optional. Resource enabled for multiple languages across projects or not.
        ///   settings: {
        ///     defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///   }, # Optional. Configurable settings of the Project.
        ///   createdDateTime: string (ISO 8601 Format), # Optional. Project creation date-time.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Optional. Represents the project last modified date-time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment date-time.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetProjects(int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            return GetProjectsImplementation("QuestionAnsweringProjectsClient.GetProjects", top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetProjectsImplementation(string diagnosticsScopeName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetProjectsRequest(top, skip, maxpagesize, context)
                        : CreateGetProjectsNextPageRequest(nextLink, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List all deployments of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeploymentsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsAsync("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentName").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeploymentsList</c>:
        /// <code>{
        ///   deploymentName: string, # Optional. Name of the deployment.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment date-time.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsAsync(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetDeploymentsImplementationAsync("QuestionAnsweringProjectsClient.GetDeployments", projectName, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsImplementationAsync(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetDeploymentsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List all deployments of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeployments with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetDeployments("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeployments with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetDeployments("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentName").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeploymentsList</c>:
        /// <code>{
        ///   deploymentName: string, # Optional. Name of the deployment.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment date-time.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeployments(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetDeploymentsImplementation("QuestionAnsweringProjectsClient.GetDeployments", projectName, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetDeploymentsImplementation(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetDeploymentsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets all the synonyms of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSynonymsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSynonymsAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("alterations")[0].ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetSynonymsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSynonymsAsync("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("alterations")[0].ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SynonymAsset</c>:
        /// <code>{
        ///   alterations: [string], # Required. Collection of word alterations.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetSynonymsAsync(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetSynonymsImplementationAsync("QuestionAnsweringProjectsClient.GetSynonyms", projectName, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetSynonymsImplementationAsync(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSynonymsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetSynonymsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets all the synonyms of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSynonyms with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSynonyms("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("alterations")[0].ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetSynonyms with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSynonyms("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("alterations")[0].ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>SynonymAsset</c>:
        /// <code>{
        ///   alterations: [string], # Required. Collection of word alterations.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetSynonyms(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetSynonymsImplementation("QuestionAnsweringProjectsClient.GetSynonyms", projectName, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetSynonymsImplementation(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSynonymsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetSynonymsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets all the sources of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSourcesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSourcesAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("sourceUri").ToString());
        ///     Console.WriteLine(result.GetProperty("sourceKind").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetSourcesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSourcesAsync("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("displayName").ToString());
        ///     Console.WriteLine(result.GetProperty("source").ToString());
        ///     Console.WriteLine(result.GetProperty("sourceUri").ToString());
        ///     Console.WriteLine(result.GetProperty("sourceKind").ToString());
        ///     Console.WriteLine(result.GetProperty("contentStructureKind").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>QnaSourcesMetadata</c>:
        /// <code>{
        ///   displayName: string, # Optional. Friendly name of the Source.
        ///   source: string, # Optional. Unique source identifier. Name of the file if it&apos;s a &apos;file&apos; source; otherwise, the complete URL if it&apos;s a &apos;url&apos; source.
        ///   sourceUri: string, # Required. URI location for the file or url.
        ///   sourceKind: &quot;file&quot; | &quot;url&quot;, # Required. Supported source types.
        ///   contentStructureKind: &quot;unstructured&quot;, # Optional. Content structure type for sources.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetSourcesAsync(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetSourcesImplementationAsync("QuestionAnsweringProjectsClient.GetSources", projectName, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetSourcesImplementationAsync(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSourcesRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetSourcesNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets all the sources of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSources with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSources("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("sourceUri").ToString());
        ///     Console.WriteLine(result.GetProperty("sourceKind").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetSources with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSources("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("displayName").ToString());
        ///     Console.WriteLine(result.GetProperty("source").ToString());
        ///     Console.WriteLine(result.GetProperty("sourceUri").ToString());
        ///     Console.WriteLine(result.GetProperty("sourceKind").ToString());
        ///     Console.WriteLine(result.GetProperty("contentStructureKind").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>QnaSourcesMetadata</c>:
        /// <code>{
        ///   displayName: string, # Optional. Friendly name of the Source.
        ///   source: string, # Optional. Unique source identifier. Name of the file if it&apos;s a &apos;file&apos; source; otherwise, the complete URL if it&apos;s a &apos;url&apos; source.
        ///   sourceUri: string, # Required. URI location for the file or url.
        ///   sourceKind: &quot;file&quot; | &quot;url&quot;, # Required. Supported source types.
        ///   contentStructureKind: &quot;unstructured&quot;, # Optional. Content structure type for sources.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetSources(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetSourcesImplementation("QuestionAnsweringProjectsClient.GetSources", projectName, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetSourcesImplementation(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSourcesRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetSourcesNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets all the QnAs of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="source"> Source of the QnA. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetQnasAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetQnasAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetQnasAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetQnasAsync("<projectName>", "<source>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("answer").ToString());
        ///     Console.WriteLine(result.GetProperty("source").ToString());
        ///     Console.WriteLine(result.GetProperty("questions")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("metadata").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("isContextOnly").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("displayOrder").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qnaId").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("answer").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("source").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("questions")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("metadata").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("activeLearningSuggestions")[0].GetProperty("clusterHead").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("question").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("userSuggestedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("autoSuggestedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("displayText").ToString());
        ///     Console.WriteLine(result.GetProperty("activeLearningSuggestions")[0].GetProperty("clusterHead").ToString());
        ///     Console.WriteLine(result.GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("question").ToString());
        ///     Console.WriteLine(result.GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("userSuggestedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("autoSuggestedCount").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>QnaAsset</c>:
        /// <code>{
        ///   id: number, # Optional. Unique ID for the QnA.
        ///   answer: string, # Optional. Answer text.
        ///   source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///   questions: [string], # Optional. List of questions associated with the answer.
        ///   metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///   dialog: {
        ///     isContextOnly: boolean, # Optional. To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as answer for queries without context; otherwise, ignores context and includes this QnA in answers.
        ///     prompts: [
        ///       {
        ///         displayOrder: number, # Optional. Index of the prompt. It is used for ordering of the prompts.
        ///         qnaId: number, # Optional. ID of the QnA corresponding to the prompt.
        ///         qna: {
        ///           id: number, # Optional. Unique ID for the QnA.
        ///           answer: string, # Optional. Answer text.
        ///           source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///           questions: [string], # Optional. List of questions associated with the answer.
        ///           metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///           dialog: QnaDialog, # Optional. Context of a QnA.
        ///           activeLearningSuggestions: [
        ///             {
        ///               clusterHead: string, # Optional. Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.
        ///               suggestedQuestions: [
        ///                 {
        ///                   question: string, # Optional. Question suggested by the Active Learning feature.
        ///                   userSuggestedCount: number, # Optional. The number of times the question was suggested explicitly by the user.
        ///                   autoSuggestedCount: number, # Optional. The number of times the question was suggested automatically by the Active Learning algorithm.
        ///                 }
        ///               ], # Optional. List of all suggested questions for the QnA.
        ///             }
        ///           ], # Optional. List of Active Learning suggestions for the QnA.
        ///         }, # Optional. QnA record. Either QnAId or QnA record needs to be present in a Prompt.
        ///         displayText: string, # Optional. Text displayed to represent a follow up question prompt.
        ///       }
        ///     ], # Optional. List of prompts associated with the answer.
        ///   }, # Optional. Context of a QnA.
        ///   activeLearningSuggestions: [SuggestedQuestionsCluster], # Optional. List of Active Learning suggestions for the QnA.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetQnasAsync(string projectName, string source = null, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetQnasImplementationAsync("QuestionAnsweringProjectsClient.GetQnas", projectName, source, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetQnasImplementationAsync(string diagnosticsScopeName, string projectName, string source, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetQnasRequest(projectName, source, top, skip, maxpagesize, context)
                        : CreateGetQnasNextPageRequest(nextLink, projectName, source, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets all the QnAs of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="source"> Source of the QnA. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetQnas with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetQnas("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetQnas with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetQnas("<projectName>", "<source>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("answer").ToString());
        ///     Console.WriteLine(result.GetProperty("source").ToString());
        ///     Console.WriteLine(result.GetProperty("questions")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("metadata").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("isContextOnly").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("displayOrder").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qnaId").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("answer").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("source").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("questions")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("metadata").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("activeLearningSuggestions")[0].GetProperty("clusterHead").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("question").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("userSuggestedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("qna").GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("autoSuggestedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("dialog").GetProperty("prompts")[0].GetProperty("displayText").ToString());
        ///     Console.WriteLine(result.GetProperty("activeLearningSuggestions")[0].GetProperty("clusterHead").ToString());
        ///     Console.WriteLine(result.GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("question").ToString());
        ///     Console.WriteLine(result.GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("userSuggestedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("activeLearningSuggestions")[0].GetProperty("suggestedQuestions")[0].GetProperty("autoSuggestedCount").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>QnaAsset</c>:
        /// <code>{
        ///   id: number, # Optional. Unique ID for the QnA.
        ///   answer: string, # Optional. Answer text.
        ///   source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///   questions: [string], # Optional. List of questions associated with the answer.
        ///   metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///   dialog: {
        ///     isContextOnly: boolean, # Optional. To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as answer for queries without context; otherwise, ignores context and includes this QnA in answers.
        ///     prompts: [
        ///       {
        ///         displayOrder: number, # Optional. Index of the prompt. It is used for ordering of the prompts.
        ///         qnaId: number, # Optional. ID of the QnA corresponding to the prompt.
        ///         qna: {
        ///           id: number, # Optional. Unique ID for the QnA.
        ///           answer: string, # Optional. Answer text.
        ///           source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///           questions: [string], # Optional. List of questions associated with the answer.
        ///           metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///           dialog: QnaDialog, # Optional. Context of a QnA.
        ///           activeLearningSuggestions: [
        ///             {
        ///               clusterHead: string, # Optional. Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.
        ///               suggestedQuestions: [
        ///                 {
        ///                   question: string, # Optional. Question suggested by the Active Learning feature.
        ///                   userSuggestedCount: number, # Optional. The number of times the question was suggested explicitly by the user.
        ///                   autoSuggestedCount: number, # Optional. The number of times the question was suggested automatically by the Active Learning algorithm.
        ///                 }
        ///               ], # Optional. List of all suggested questions for the QnA.
        ///             }
        ///           ], # Optional. List of Active Learning suggestions for the QnA.
        ///         }, # Optional. QnA record. Either QnAId or QnA record needs to be present in a Prompt.
        ///         displayText: string, # Optional. Text displayed to represent a follow up question prompt.
        ///       }
        ///     ], # Optional. List of prompts associated with the answer.
        ///   }, # Optional. Context of a QnA.
        ///   activeLearningSuggestions: [SuggestedQuestionsCluster], # Optional. List of Active Learning suggestions for the QnA.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetQnas(string projectName, string source = null, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetQnasImplementation("QuestionAnsweringProjectsClient.GetQnas", projectName, source, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetQnasImplementation(string diagnosticsScopeName, string projectName, string source, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetQnasRequest(projectName, source, top, skip, maxpagesize, context)
                        : CreateGetQnasNextPageRequest(nextLink, projectName, source, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Delete the project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteProjectAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var operation = await client.DeleteProjectAsync(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeleteProjectAsync(WaitUntil waitUntil, string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeleteProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteProjectRequest(projectName, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.DeleteProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete the project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteProject with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var operation = client.DeleteProject(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeleteProject(WaitUntil waitUntil, string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeleteProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteProjectRequest(projectName, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.DeleteProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Export project metadata and assets. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="format"> Knowledge base Import or Export format. Allowed values: &quot;json&quot; | &quot;tsv&quot; | &quot;excel&quot;. </param>
        /// <param name="assetKind"> Kind of the asset of the project. Allowed values: &quot;qnas&quot; | &quot;synonyms&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ExportAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var operation = await client.ExportAsync(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call ExportAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var operation = await client.ExportAsync(WaitUntil.Completed, "<projectName>", "<format>", "<assetKind>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ExportAsync(WaitUntil waitUntil, string projectName, string format = null, string assetKind = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Export");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExportRequest(projectName, format, assetKind, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.Export", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Export project metadata and assets. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="format"> Knowledge base Import or Export format. Allowed values: &quot;json&quot; | &quot;tsv&quot; | &quot;excel&quot;. </param>
        /// <param name="assetKind"> Kind of the asset of the project. Allowed values: &quot;qnas&quot; | &quot;synonyms&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call Export with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var operation = client.Export(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call Export with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var operation = client.Export(WaitUntil.Completed, "<projectName>", "<format>", "<assetKind>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> Export(WaitUntil waitUntil, string projectName, string format = null, string assetKind = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Export");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExportRequest(projectName, format, assetKind, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.Export", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Import project assets. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="format"> Knowledge base Import or Export format. Allowed values: &quot;json&quot; | &quot;tsv&quot; | &quot;excel&quot;. </param>
        /// <param name="assetKind"> Kind of the asset of the project. Allowed values: &quot;qnas&quot; | &quot;synonyms&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ImportAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {};
        /// 
        /// var operation = await client.ImportAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call ImportAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     metadata = new {
        ///         description = "<description>",
        ///         language = "<language>",
        ///         multilingualResource = true,
        ///         settings = new {
        ///             defaultAnswer = "<defaultAnswer>",
        ///         },
        ///     },
        ///     assets = new {
        ///         synonyms = new[] {
        ///             new {
        ///                 alterations = new[] {
        ///                     "<String>"
        ///                 },
        ///             }
        ///         },
        ///         qnas = new[] {
        ///             new {
        ///                 id = 1234,
        ///                 answer = "<answer>",
        ///                 source = "<source>",
        ///                 questions = new[] {
        ///                     "<String>"
        ///                 },
        ///                 metadata = new {
        ///                     key = "<String>",
        ///                 },
        ///                 dialog = new {
        ///                     isContextOnly = true,
        ///                     prompts = new[] {
        ///                         new {
        ///                             displayOrder = 1234,
        ///                             qnaId = 1234,
        ///                             qna = new {
        ///                                 id = 1234,
        ///                                 answer = "<answer>",
        ///                                 source = "<source>",
        ///                                 questions = new[] {
        ///                                     "<String>"
        ///                                 },
        ///                                 metadata = new {
        ///                                     key = "<String>",
        ///                                 },
        ///                                 activeLearningSuggestions = new[] {
        ///                                     new {
        ///                                         clusterHead = "<clusterHead>",
        ///                                         suggestedQuestions = new[] {
        ///                                             new {
        ///                                                 question = "<question>",
        ///                                                 userSuggestedCount = 1234,
        ///                                                 autoSuggestedCount = 1234,
        ///                                             }
        ///                                         },
        ///                                     }
        ///                                 },
        ///                             },
        ///                             displayText = "<displayText>",
        ///                         }
        ///                     },
        ///                 },
        ///                 activeLearningSuggestions = new[] {
        ///                     new {
        ///                         clusterHead = "<clusterHead>",
        ///                         suggestedQuestions = new[] {
        ///                             new {
        ///                                 question = "<question>",
        ///                                 userSuggestedCount = 1234,
        ///                                 autoSuggestedCount = 1234,
        ///                             }
        ///                         },
        ///                     }
        ///                 },
        ///             }
        ///         },
        ///     },
        ///     fileUri = "<fileUri>",
        /// };
        /// 
        /// var operation = await client.ImportAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data), "<format>", "<assetKind>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ImportJobOptions</c>:
        /// <code>{
        ///   metadata: {
        ///     description: string, # Optional. Description of the project.
        ///     language: string, # Required. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///     multilingualResource: boolean, # Optional. Set to true to enable creating knowledgebases in different languages for the same resource.
        ///     settings: {
        ///       defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///     }, # Optional. Configurable settings of the Project.
        ///   }, # Optional. Parameters needed to create the project.
        ///   assets: {
        ///     synonyms: [
        ///       {
        ///         alterations: [string], # Required. Collection of word alterations.
        ///       }
        ///     ], # Optional. Collection of synonyms.
        ///     qnas: [
        ///       {
        ///         id: number, # Optional. Unique ID for the QnA.
        ///         answer: string, # Optional. Answer text.
        ///         source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///         questions: [string], # Optional. List of questions associated with the answer.
        ///         metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///         dialog: {
        ///           isContextOnly: boolean, # Optional. To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as answer for queries without context; otherwise, ignores context and includes this QnA in answers.
        ///           prompts: [
        ///             {
        ///               displayOrder: number, # Optional. Index of the prompt. It is used for ordering of the prompts.
        ///               qnaId: number, # Optional. ID of the QnA corresponding to the prompt.
        ///               qna: {
        ///                 id: number, # Optional. Unique ID for the QnA.
        ///                 answer: string, # Optional. Answer text.
        ///                 source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///                 questions: [string], # Optional. List of questions associated with the answer.
        ///                 metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///                 dialog: QnaDialog, # Optional. Context of a QnA.
        ///                 activeLearningSuggestions: [
        ///                   {
        ///                     clusterHead: string, # Optional. Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.
        ///                     suggestedQuestions: [
        ///                       {
        ///                         question: string, # Optional. Question suggested by the Active Learning feature.
        ///                         userSuggestedCount: number, # Optional. The number of times the question was suggested explicitly by the user.
        ///                         autoSuggestedCount: number, # Optional. The number of times the question was suggested automatically by the Active Learning algorithm.
        ///                       }
        ///                     ], # Optional. List of all suggested questions for the QnA.
        ///                   }
        ///                 ], # Optional. List of Active Learning suggestions for the QnA.
        ///               }, # Optional. QnA record. Either QnAId or QnA record needs to be present in a Prompt.
        ///               displayText: string, # Optional. Text displayed to represent a follow up question prompt.
        ///             }
        ///           ], # Optional. List of prompts associated with the answer.
        ///         }, # Optional. Context of a QnA.
        ///         activeLearningSuggestions: [SuggestedQuestionsCluster], # Optional. List of Active Learning suggestions for the QnA.
        ///       }
        ///     ], # Optional. List of QnA records to import.
        ///   }, # Optional. All assets for this project.
        ///   fileUri: string, # Optional. Import data File URI.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ImportAsync(WaitUntil waitUntil, string projectName, RequestContent content, string format = null, string assetKind = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Import");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportRequest(projectName, content, format, assetKind, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.Import", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Import project assets. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="format"> Knowledge base Import or Export format. Allowed values: &quot;json&quot; | &quot;tsv&quot; | &quot;excel&quot;. </param>
        /// <param name="assetKind"> Kind of the asset of the project. Allowed values: &quot;qnas&quot; | &quot;synonyms&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call Import with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {};
        /// 
        /// var operation = client.Import(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call Import with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     metadata = new {
        ///         description = "<description>",
        ///         language = "<language>",
        ///         multilingualResource = true,
        ///         settings = new {
        ///             defaultAnswer = "<defaultAnswer>",
        ///         },
        ///     },
        ///     assets = new {
        ///         synonyms = new[] {
        ///             new {
        ///                 alterations = new[] {
        ///                     "<String>"
        ///                 },
        ///             }
        ///         },
        ///         qnas = new[] {
        ///             new {
        ///                 id = 1234,
        ///                 answer = "<answer>",
        ///                 source = "<source>",
        ///                 questions = new[] {
        ///                     "<String>"
        ///                 },
        ///                 metadata = new {
        ///                     key = "<String>",
        ///                 },
        ///                 dialog = new {
        ///                     isContextOnly = true,
        ///                     prompts = new[] {
        ///                         new {
        ///                             displayOrder = 1234,
        ///                             qnaId = 1234,
        ///                             qna = new {
        ///                                 id = 1234,
        ///                                 answer = "<answer>",
        ///                                 source = "<source>",
        ///                                 questions = new[] {
        ///                                     "<String>"
        ///                                 },
        ///                                 metadata = new {
        ///                                     key = "<String>",
        ///                                 },
        ///                                 activeLearningSuggestions = new[] {
        ///                                     new {
        ///                                         clusterHead = "<clusterHead>",
        ///                                         suggestedQuestions = new[] {
        ///                                             new {
        ///                                                 question = "<question>",
        ///                                                 userSuggestedCount = 1234,
        ///                                                 autoSuggestedCount = 1234,
        ///                                             }
        ///                                         },
        ///                                     }
        ///                                 },
        ///                             },
        ///                             displayText = "<displayText>",
        ///                         }
        ///                     },
        ///                 },
        ///                 activeLearningSuggestions = new[] {
        ///                     new {
        ///                         clusterHead = "<clusterHead>",
        ///                         suggestedQuestions = new[] {
        ///                             new {
        ///                                 question = "<question>",
        ///                                 userSuggestedCount = 1234,
        ///                                 autoSuggestedCount = 1234,
        ///                             }
        ///                         },
        ///                     }
        ///                 },
        ///             }
        ///         },
        ///     },
        ///     fileUri = "<fileUri>",
        /// };
        /// 
        /// var operation = client.Import(WaitUntil.Completed, "<projectName>", RequestContent.Create(data), "<format>", "<assetKind>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ImportJobOptions</c>:
        /// <code>{
        ///   metadata: {
        ///     description: string, # Optional. Description of the project.
        ///     language: string, # Required. Language of the text records. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English; &quot;es&quot; for Spanish etc. If not set, use &quot;en&quot; for English as default.
        ///     multilingualResource: boolean, # Optional. Set to true to enable creating knowledgebases in different languages for the same resource.
        ///     settings: {
        ///       defaultAnswer: string, # Optional. Default Answer response when no good match is found in the knowledge base.
        ///     }, # Optional. Configurable settings of the Project.
        ///   }, # Optional. Parameters needed to create the project.
        ///   assets: {
        ///     synonyms: [
        ///       {
        ///         alterations: [string], # Required. Collection of word alterations.
        ///       }
        ///     ], # Optional. Collection of synonyms.
        ///     qnas: [
        ///       {
        ///         id: number, # Optional. Unique ID for the QnA.
        ///         answer: string, # Optional. Answer text.
        ///         source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///         questions: [string], # Optional. List of questions associated with the answer.
        ///         metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///         dialog: {
        ///           isContextOnly: boolean, # Optional. To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as answer for queries without context; otherwise, ignores context and includes this QnA in answers.
        ///           prompts: [
        ///             {
        ///               displayOrder: number, # Optional. Index of the prompt. It is used for ordering of the prompts.
        ///               qnaId: number, # Optional. ID of the QnA corresponding to the prompt.
        ///               qna: {
        ///                 id: number, # Optional. Unique ID for the QnA.
        ///                 answer: string, # Optional. Answer text.
        ///                 source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///                 questions: [string], # Optional. List of questions associated with the answer.
        ///                 metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///                 dialog: QnaDialog, # Optional. Context of a QnA.
        ///                 activeLearningSuggestions: [
        ///                   {
        ///                     clusterHead: string, # Optional. Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.
        ///                     suggestedQuestions: [
        ///                       {
        ///                         question: string, # Optional. Question suggested by the Active Learning feature.
        ///                         userSuggestedCount: number, # Optional. The number of times the question was suggested explicitly by the user.
        ///                         autoSuggestedCount: number, # Optional. The number of times the question was suggested automatically by the Active Learning algorithm.
        ///                       }
        ///                     ], # Optional. List of all suggested questions for the QnA.
        ///                   }
        ///                 ], # Optional. List of Active Learning suggestions for the QnA.
        ///               }, # Optional. QnA record. Either QnAId or QnA record needs to be present in a Prompt.
        ///               displayText: string, # Optional. Text displayed to represent a follow up question prompt.
        ///             }
        ///           ], # Optional. List of prompts associated with the answer.
        ///         }, # Optional. Context of a QnA.
        ///         activeLearningSuggestions: [SuggestedQuestionsCluster], # Optional. List of Active Learning suggestions for the QnA.
        ///       }
        ///     ], # Optional. List of QnA records to import.
        ///   }, # Optional. All assets for this project.
        ///   fileUri: string, # Optional. Import data File URI.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> Import(WaitUntil waitUntil, string projectName, RequestContent content, string format = null, string assetKind = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.Import");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportRequest(projectName, content, format, assetKind, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.Import", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deploy project to production. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeployProjectAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var operation = await client.DeployProjectAsync(WaitUntil.Completed, "<projectName>", "<deploymentName>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeployProjectAsync(WaitUntil waitUntil, string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeployProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.DeployProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deploy project to production. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeployProject with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var operation = client.DeployProject(WaitUntil.Completed, "<projectName>", "<deploymentName>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeployProject(WaitUntil waitUntil, string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.DeployProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.DeployProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the sources of a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateSourcesAsync with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new[] {
        ///     new {
        ///         op = "add",
        ///         value = new {
        ///             displayName = "<displayName>",
        ///             source = "<source>",
        ///             sourceUri = "<sourceUri>",
        ///             sourceKind = "file",
        ///             contentStructureKind = "unstructured",
        ///         },
        ///     }
        /// };
        /// 
        /// var operation = await client.UpdateSourcesAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>UpdateSourceRecord</c>:
        /// <code>{
        ///   op: &quot;add&quot; | &quot;delete&quot; | &quot;replace&quot;, # Required. Update operation type for assets.
        ///   value: {
        ///     displayName: string, # Optional. Friendly name of the Source.
        ///     source: string, # Optional. Unique source identifier. Name of the file if it&apos;s a &apos;file&apos; source; otherwise, the complete URL if it&apos;s a &apos;url&apos; source.
        ///     sourceUri: string, # Required. URI location for the file or url.
        ///     sourceKind: &quot;file&quot; | &quot;url&quot;, # Required. Supported source types.
        ///     contentStructureKind: &quot;unstructured&quot;, # Optional. Content structure type for sources.
        ///   }, # Required. Update source record.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> UpdateSourcesAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateSources");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateSourcesRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.UpdateSources", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the sources of a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateSources with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new[] {
        ///     new {
        ///         op = "add",
        ///         value = new {
        ///             displayName = "<displayName>",
        ///             source = "<source>",
        ///             sourceUri = "<sourceUri>",
        ///             sourceKind = "file",
        ///             contentStructureKind = "unstructured",
        ///         },
        ///     }
        /// };
        /// 
        /// var operation = client.UpdateSources(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>UpdateSourceRecord</c>:
        /// <code>{
        ///   op: &quot;add&quot; | &quot;delete&quot; | &quot;replace&quot;, # Required. Update operation type for assets.
        ///   value: {
        ///     displayName: string, # Optional. Friendly name of the Source.
        ///     source: string, # Optional. Unique source identifier. Name of the file if it&apos;s a &apos;file&apos; source; otherwise, the complete URL if it&apos;s a &apos;url&apos; source.
        ///     sourceUri: string, # Required. URI location for the file or url.
        ///     sourceKind: &quot;file&quot; | &quot;url&quot;, # Required. Supported source types.
        ///     contentStructureKind: &quot;unstructured&quot;, # Optional. Content structure type for sources.
        ///   }, # Required. Update source record.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> UpdateSources(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateSources");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateSourcesRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.UpdateSources", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the QnAs of a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateQnasAsync with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new[] {
        ///     new {
        ///         op = "add",
        ///         value = new {
        ///             id = 1234,
        ///             answer = "<answer>",
        ///             source = "<source>",
        ///             questions = new[] {
        ///                 "<String>"
        ///             },
        ///             metadata = new {
        ///                 key = "<String>",
        ///             },
        ///             dialog = new {
        ///                 isContextOnly = true,
        ///                 prompts = new[] {
        ///                     new {
        ///                         displayOrder = 1234,
        ///                         qnaId = 1234,
        ///                         displayText = "<displayText>",
        ///                     }
        ///                 },
        ///             },
        ///             activeLearningSuggestions = new[] {
        ///                 new {
        ///                     clusterHead = "<clusterHead>",
        ///                     suggestedQuestions = new[] {
        ///                         new {
        ///                             question = "<question>",
        ///                             userSuggestedCount = 1234,
        ///                             autoSuggestedCount = 1234,
        ///                         }
        ///                     },
        ///                 }
        ///             },
        ///         },
        ///     }
        /// };
        /// 
        /// var operation = await client.UpdateQnasAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>UpdateQnaRecord</c>:
        /// <code>{
        ///   op: &quot;add&quot; | &quot;delete&quot; | &quot;replace&quot;, # Required. Update operation type for assets.
        ///   value: {
        ///     id: number, # Optional. Unique ID for the QnA.
        ///     answer: string, # Optional. Answer text.
        ///     source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///     questions: [string], # Optional. List of questions associated with the answer.
        ///     metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///     dialog: {
        ///       isContextOnly: boolean, # Optional. To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as answer for queries without context; otherwise, ignores context and includes this QnA in answers.
        ///       prompts: [
        ///         {
        ///           displayOrder: number, # Optional. Index of the prompt. It is used for ordering of the prompts.
        ///           qnaId: number, # Optional. ID of the QnA corresponding to the prompt.
        ///           qna: QnaRecord, # Optional. QnA record. Either QnAId or QnA record needs to be present in a Prompt.
        ///           displayText: string, # Optional. Text displayed to represent a follow up question prompt.
        ///         }
        ///       ], # Optional. List of prompts associated with the answer.
        ///     }, # Optional. Context of a QnA.
        ///     activeLearningSuggestions: [
        ///       {
        ///         clusterHead: string, # Optional. Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.
        ///         suggestedQuestions: [
        ///           {
        ///             question: string, # Optional. Question suggested by the Active Learning feature.
        ///             userSuggestedCount: number, # Optional. The number of times the question was suggested explicitly by the user.
        ///             autoSuggestedCount: number, # Optional. The number of times the question was suggested automatically by the Active Learning algorithm.
        ///           }
        ///         ], # Optional. List of all suggested questions for the QnA.
        ///       }
        ///     ], # Optional. List of Active Learning suggestions for the QnA.
        ///   }, # Required. QnA record.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> UpdateQnasAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateQnas");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateQnasRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.UpdateQnas", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the QnAs of a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateQnas with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new QuestionAnsweringProjectsClient(endpoint, credential);
        /// 
        /// var data = new[] {
        ///     new {
        ///         op = "add",
        ///         value = new {
        ///             id = 1234,
        ///             answer = "<answer>",
        ///             source = "<source>",
        ///             questions = new[] {
        ///                 "<String>"
        ///             },
        ///             metadata = new {
        ///                 key = "<String>",
        ///             },
        ///             dialog = new {
        ///                 isContextOnly = true,
        ///                 prompts = new[] {
        ///                     new {
        ///                         displayOrder = 1234,
        ///                         qnaId = 1234,
        ///                         displayText = "<displayText>",
        ///                     }
        ///                 },
        ///             },
        ///             activeLearningSuggestions = new[] {
        ///                 new {
        ///                     clusterHead = "<clusterHead>",
        ///                     suggestedQuestions = new[] {
        ///                         new {
        ///                             question = "<question>",
        ///                             userSuggestedCount = 1234,
        ///                             autoSuggestedCount = 1234,
        ///                         }
        ///                     },
        ///                 }
        ///             },
        ///         },
        ///     }
        /// };
        /// 
        /// var operation = client.UpdateQnas(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>UpdateQnaRecord</c>:
        /// <code>{
        ///   op: &quot;add&quot; | &quot;delete&quot; | &quot;replace&quot;, # Required. Update operation type for assets.
        ///   value: {
        ///     id: number, # Optional. Unique ID for the QnA.
        ///     answer: string, # Optional. Answer text.
        ///     source: string, # Optional. Source from which QnA was indexed e.g. https://docs.microsoft.com/en-us/azure/cognitive-services/QnAMaker/FAQs .
        ///     questions: [string], # Optional. List of questions associated with the answer.
        ///     metadata: Dictionary&lt;string, string&gt;, # Optional. Metadata associated with the answer, useful to categorize or filter question answers.
        ///     dialog: {
        ///       isContextOnly: boolean, # Optional. To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as answer for queries without context; otherwise, ignores context and includes this QnA in answers.
        ///       prompts: [
        ///         {
        ///           displayOrder: number, # Optional. Index of the prompt. It is used for ordering of the prompts.
        ///           qnaId: number, # Optional. ID of the QnA corresponding to the prompt.
        ///           qna: QnaRecord, # Optional. QnA record. Either QnAId or QnA record needs to be present in a Prompt.
        ///           displayText: string, # Optional. Text displayed to represent a follow up question prompt.
        ///         }
        ///       ], # Optional. List of prompts associated with the answer.
        ///     }, # Optional. Context of a QnA.
        ///     activeLearningSuggestions: [
        ///       {
        ///         clusterHead: string, # Optional. Question chosen as the head of suggested questions cluster by Active Learning clustering algorithm.
        ///         suggestedQuestions: [
        ///           {
        ///             question: string, # Optional. Question suggested by the Active Learning feature.
        ///             userSuggestedCount: number, # Optional. The number of times the question was suggested explicitly by the user.
        ///             autoSuggestedCount: number, # Optional. The number of times the question was suggested automatically by the Active Learning algorithm.
        ///           }
        ///         ], # Optional. List of all suggested questions for the QnA.
        ///       }
        ///     ], # Optional. List of Active Learning suggestions for the QnA.
        ///   }, # Required. QnA record.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// <details><summary>ExportJobState</summary>Schema for <c>ExportJobState</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional.
        ///   jobId: string, # Required.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Job Status.
        /// }
        /// </code>
        /// </details>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> UpdateQnas(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("QuestionAnsweringProjectsClient.UpdateQnas");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateQnasRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "QuestionAnsweringProjectsClient.UpdateQnas", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetProjectsRequest(int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetProjectDetailsRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateProjectRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteProjectRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeleteStatusRequest(string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/deletion-jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateExportRequest(string projectName, string format, string assetKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:export", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (format != null)
            {
                uri.AppendQuery("format", format, true);
            }
            if (assetKind != null)
            {
                uri.AppendQuery("assetKind", assetKind, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetExportStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/export/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportRequest(string projectName, RequestContent content, string format, string assetKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:import", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (format != null)
            {
                uri.AppendQuery("format", format, true);
            }
            if (assetKind != null)
            {
                uri.AppendQuery("assetKind", assetKind, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetImportStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/import/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeployProjectRequest(string projectName, string deploymentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeployStatusRequest(string projectName, string deploymentName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsRequest(string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSynonymsRequest(string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/synonyms", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateSynonymsRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/synonyms", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSourcesRequest(string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/sources", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateSourcesRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/sources", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetUpdateSourcesStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/sources/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetQnasRequest(string projectName, string source, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/qnas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (source != null)
            {
                uri.AppendQuery("source", source, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateQnasRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/qnas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetUpdateQnasStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/qnas/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddFeedbackRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/query-knowledgebases/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/feedback", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetProjectsNextPageRequest(string nextLink, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsNextPageRequest(string nextLink, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSynonymsNextPageRequest(string nextLink, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSourcesNextPageRequest(string nextLink, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetQnasNextPageRequest(string nextLink, string projectName, string source, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
