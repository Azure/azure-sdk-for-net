// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.IotOperations.Models
{
    /// <summary>
    /// Disk persistence configuration.
    ///
    /// When persistence is enabled, certain items (non-performance-critical data) selected for persistence will reside only on disk. Below are the affected items:
    ///
    /// - Retained messages will be stored on disk only.
    /// - WILL messages will be stored on disk only.
    /// - DSS key/value pairs will be stored on disk only, except for performance-critical items like timed locks, which remain in both disk and memory for improved performance.
    ///
    /// Optional. Everything is in-memory if not set.
    /// Note: if configured, all MQTT session states are written to disk.
    /// </summary>
    public partial class BrokerPersistence
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="BrokerPersistence"/>. </summary>
        /// <param name="maxSize"> The max size of the message buffer on disk. If a PVC template is specified using persistentVolumeClaimSpec Then this size is used as the request and limit sizes of that template. If a PVC template isn't specified Then local-path provisioner is requested with this size limit. Required. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="maxSize"/> is null. </exception>
        public BrokerPersistence(string maxSize)
        {
            Argument.AssertNotNull(maxSize, nameof(maxSize));

            MaxSize = maxSize;
        }

        /// <summary> Initializes a new instance of <see cref="BrokerPersistence"/>. </summary>
        /// <param name="dynamicSettings">
        /// Client sets the specified user property key/value in the CONNECT/SUBSCRIBE/PUBLISH.
        /// Optionally, if the customer specifies a configurable user property, it will work to enable persistence dynamically. The default user property key is 'aio-persistence' and value 'true'.
        /// </param>
        /// <param name="maxSize"> The max size of the message buffer on disk. If a PVC template is specified using persistentVolumeClaimSpec Then this size is used as the request and limit sizes of that template. If a PVC template isn't specified Then local-path provisioner is requested with this size limit. Required. </param>
        /// <param name="persistentVolumeClaimSpec">
        /// Use the specified persistent volume claim template to mount a persistent volume. Same object as in diskBackedMessageBuffer, but with a limitation that access modes field must be set to `ReadWriteOncePod`.
        ///
        /// If unset, a default PVC with default properties will be used. Among other things this PVC will use the cluster default storage class, which may or may not be using a local path provisioner. User is opting in to sub-optimal behavior if they leave this unset or set it without the storage class field, and their cluster default is not a local path class.
        /// </param>
        /// <param name="retain">
        /// Controls which topic's retained messages should be persisted to disk.
        /// Please note <see cref="BrokerRetainMessagesPolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BrokerRetainMessagesCustomPolicy"/>.
        /// </param>
        /// <param name="stateStore">
        /// Controls which keys should be persisted to disk for the state store.
        /// Please note <see cref="BrokerStateStorePolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BrokerStateStoreCustomPolicy"/>.
        /// </param>
        /// <param name="subscriberQueue">
        /// Controls which subscriber message queues should be persisted to disk. Important: to facilitate reconnection, session state metadata are ALWAYS written to disk if any persistence setting is specified, even if this section isn't set.
        /// Please note <see cref="BrokerSubscriberQueuePolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BrokerSubscriberQueueCustomPolicy"/>.
        /// </param>
        /// <param name="encryption"> Controls settings related to encryption of the persistence database. Optional, defaults to enabling encryption. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal BrokerPersistence(BrokerPersistenceDynamicSettings dynamicSettings, string maxSize, VolumeClaimSpec persistentVolumeClaimSpec, BrokerRetainMessagesPolicy retain, BrokerStateStorePolicy stateStore, BrokerSubscriberQueuePolicy subscriberQueue, BrokerPersistenceEncryption encryption, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            DynamicSettings = dynamicSettings;
            MaxSize = maxSize;
            PersistentVolumeClaimSpec = persistentVolumeClaimSpec;
            Retain = retain;
            StateStore = stateStore;
            SubscriberQueue = subscriberQueue;
            Encryption = encryption;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="BrokerPersistence"/> for deserialization. </summary>
        internal BrokerPersistence()
        {
        }

        /// <summary>
        /// Client sets the specified user property key/value in the CONNECT/SUBSCRIBE/PUBLISH.
        /// Optionally, if the customer specifies a configurable user property, it will work to enable persistence dynamically. The default user property key is 'aio-persistence' and value 'true'.
        /// </summary>
        public BrokerPersistenceDynamicSettings DynamicSettings { get; set; }
        /// <summary> The max size of the message buffer on disk. If a PVC template is specified using persistentVolumeClaimSpec Then this size is used as the request and limit sizes of that template. If a PVC template isn't specified Then local-path provisioner is requested with this size limit. Required. </summary>
        public string MaxSize { get; set; }
        /// <summary>
        /// Use the specified persistent volume claim template to mount a persistent volume. Same object as in diskBackedMessageBuffer, but with a limitation that access modes field must be set to `ReadWriteOncePod`.
        ///
        /// If unset, a default PVC with default properties will be used. Among other things this PVC will use the cluster default storage class, which may or may not be using a local path provisioner. User is opting in to sub-optimal behavior if they leave this unset or set it without the storage class field, and their cluster default is not a local path class.
        /// </summary>
        public VolumeClaimSpec PersistentVolumeClaimSpec { get; set; }
        /// <summary>
        /// Controls which topic's retained messages should be persisted to disk.
        /// Please note <see cref="BrokerRetainMessagesPolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BrokerRetainMessagesCustomPolicy"/>.
        /// </summary>
        public BrokerRetainMessagesPolicy Retain { get; set; }
        /// <summary>
        /// Controls which keys should be persisted to disk for the state store.
        /// Please note <see cref="BrokerStateStorePolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BrokerStateStoreCustomPolicy"/>.
        /// </summary>
        public BrokerStateStorePolicy StateStore { get; set; }
        /// <summary>
        /// Controls which subscriber message queues should be persisted to disk. Important: to facilitate reconnection, session state metadata are ALWAYS written to disk if any persistence setting is specified, even if this section isn't set.
        /// Please note <see cref="BrokerSubscriberQueuePolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BrokerSubscriberQueueCustomPolicy"/>.
        /// </summary>
        public BrokerSubscriberQueuePolicy SubscriberQueue { get; set; }
        /// <summary> Controls settings related to encryption of the persistence database. Optional, defaults to enabling encryption. </summary>
        internal BrokerPersistenceEncryption Encryption { get; set; }
        /// <summary> Determines if encryption is enabled. </summary>
        public IotOperationsOperationalMode? EncryptionMode
        {
            get => Encryption is null ? default(IotOperationsOperationalMode?) : Encryption.Mode;
            set
            {
                Encryption = value.HasValue ? new BrokerPersistenceEncryption(value.Value) : null;
            }
        }
    }
}
