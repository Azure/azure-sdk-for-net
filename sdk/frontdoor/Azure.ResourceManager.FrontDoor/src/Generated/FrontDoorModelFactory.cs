// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure;
using Azure.Core;
using Azure.ResourceManager.FrontDoor;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.Resources.Models;

namespace Azure.ResourceManager.FrontDoor.Models
{
    /// <summary> Model factory for generated models. </summary>
    public static partial class FrontDoorModelFactory
    {
        /// <summary> Initializes a new instance of FrontDoorWebApplicationFirewallPolicyData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="etag"> Gets a unique read-only string that changes whenever the resource is updated. </param>
        /// <param name="skuName"> The pricing tier of web application firewall policy. Defaults to Classic_AzureFrontDoor if not specified. </param>
        /// <param name="policySettings"> Describes settings for the policy. </param>
        /// <param name="rules"> Describes custom rules inside the policy. </param>
        /// <param name="managedRuleSets"> Describes managed rules inside the policy. </param>
        /// <param name="frontendEndpointLinks"> Describes Frontend Endpoints associated with this Web Application Firewall policy. </param>
        /// <param name="routingRuleLinks"> Describes Routing Rules associated with this Web Application Firewall policy. </param>
        /// <param name="securityPolicyLinks"> Describes Security Policy associated with this Web Application Firewall policy. </param>
        /// <param name="provisioningState"> Provisioning state of the policy. </param>
        /// <param name="resourceState"> Resource status of the policy. </param>
        /// <returns> A new <see cref="FrontDoor.FrontDoorWebApplicationFirewallPolicyData"/> instance for mocking. </returns>
        public static FrontDoorWebApplicationFirewallPolicyData FrontDoorWebApplicationFirewallPolicyData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ETag? etag = null, FrontDoorSkuName? skuName = null, FrontDoorWebApplicationFirewallPolicySettings policySettings = null, IEnumerable<WebApplicationCustomRule> rules = null, IEnumerable<ManagedRuleSet> managedRuleSets = null, IEnumerable<SubResource> frontendEndpointLinks = null, IEnumerable<SubResource> routingRuleLinks = null, IEnumerable<SubResource> securityPolicyLinks = null, string provisioningState = null, FrontDoorWebApplicationFirewallPolicyResourceState? resourceState = null)
        {
            tags ??= new Dictionary<string, string>();
            rules ??= new List<WebApplicationCustomRule>();
            managedRuleSets ??= new List<ManagedRuleSet>();
            frontendEndpointLinks ??= new List<SubResource>();
            routingRuleLinks ??= new List<SubResource>();
            securityPolicyLinks ??= new List<SubResource>();

            return new FrontDoorWebApplicationFirewallPolicyData(id, name, resourceType, systemData, tags, location, etag, new FrontDoorSku(skuName), policySettings, new CustomRuleList(rules?.ToList()), new ManagedRuleSetList(managedRuleSets?.ToList()), frontendEndpointLinks?.ToList(), routingRuleLinks?.ToList(), securityPolicyLinks?.ToList(), provisioningState, resourceState);
        }

        /// <summary> Initializes a new instance of FrontDoorWebApplicationFirewallPolicySettings. </summary>
        /// <param name="enabledState"> Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified. </param>
        /// <param name="mode"> Describes if it is in detection mode or prevention mode at policy level. </param>
        /// <param name="redirectUri"> If action type is redirect, this field represents redirect URL for the client. </param>
        /// <param name="customBlockResponseStatusCode"> If the action type is block, customer can override the response status code. </param>
        /// <param name="customBlockResponseBody"> If the action type is block, customer can override the response body. The body must be specified in base64 encoding. </param>
        /// <param name="requestBodyCheck"> Describes if policy managed rules will inspect the request body content. </param>
        /// <returns> A new <see cref="Models.FrontDoorWebApplicationFirewallPolicySettings"/> instance for mocking. </returns>
        public static FrontDoorWebApplicationFirewallPolicySettings FrontDoorWebApplicationFirewallPolicySettings(PolicyEnabledState? enabledState = null, FrontDoorWebApplicationFirewallPolicyMode? mode = null, Uri redirectUri = null, int? customBlockResponseStatusCode = null, string customBlockResponseBody = null, PolicyRequestBodyCheck? requestBodyCheck = null)
        {
            return new FrontDoorWebApplicationFirewallPolicySettings(enabledState, mode, redirectUri, customBlockResponseStatusCode, customBlockResponseBody, requestBodyCheck);
        }

        /// <summary> Initializes a new instance of WebApplicationCustomRule. </summary>
        /// <param name="name"> Describes the name of the rule. </param>
        /// <param name="priority"> Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. </param>
        /// <param name="enabledState"> Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified. </param>
        /// <param name="ruleType"> Describes type of rule. </param>
        /// <param name="rateLimitDurationInMinutes"> Time window for resetting the rate limit count. Default is 1 minute. </param>
        /// <param name="rateLimitThreshold"> Number of allowed requests per client within the time window. </param>
        /// <param name="matchConditions"> List of match conditions. </param>
        /// <param name="action"> Describes what action to be applied when rule matches. </param>
        /// <returns> A new <see cref="Models.WebApplicationCustomRule"/> instance for mocking. </returns>
        public static WebApplicationCustomRule WebApplicationCustomRule(string name = null, int priority = default, CustomRuleEnabledState? enabledState = null, WebApplicationRuleType ruleType = default, int? rateLimitDurationInMinutes = null, int? rateLimitThreshold = null, IEnumerable<WebApplicationRuleMatchCondition> matchConditions = null, RuleMatchActionType action = default)
        {
            matchConditions ??= new List<WebApplicationRuleMatchCondition>();

            return new WebApplicationCustomRule(name, priority, enabledState, ruleType, rateLimitDurationInMinutes, rateLimitThreshold, matchConditions?.ToList(), action);
        }

        /// <summary> Initializes a new instance of WebApplicationRuleMatchCondition. </summary>
        /// <param name="matchVariable"> Request variable to compare with. </param>
        /// <param name="selector"> Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null. </param>
        /// <param name="operator"> Comparison type to use for matching with the variable value. </param>
        /// <param name="isNegateCondition"> Describes if the result of this condition should be negated. </param>
        /// <param name="matchValue"> List of possible match values. </param>
        /// <param name="transforms"> List of transforms. </param>
        /// <returns> A new <see cref="Models.WebApplicationRuleMatchCondition"/> instance for mocking. </returns>
        public static WebApplicationRuleMatchCondition WebApplicationRuleMatchCondition(WebApplicationRuleMatchVariable matchVariable = default, string selector = null, WebApplicationRuleMatchOperator @operator = default, bool? isNegateCondition = null, IEnumerable<string> matchValue = null, IEnumerable<WebApplicationRuleMatchTransformType> transforms = null)
        {
            matchValue ??= new List<string>();
            transforms ??= new List<WebApplicationRuleMatchTransformType>();

            return new WebApplicationRuleMatchCondition(matchVariable, selector, @operator, isNegateCondition, matchValue?.ToList(), transforms?.ToList());
        }

        /// <summary> Initializes a new instance of ManagedRuleSet. </summary>
        /// <param name="ruleSetType"> Defines the rule set type to use. </param>
        /// <param name="ruleSetVersion"> Defines the version of the rule set to use. </param>
        /// <param name="ruleSetAction"> Defines the rule set action. </param>
        /// <param name="exclusions"> Describes the exclusions that are applied to all rules in the set. </param>
        /// <param name="ruleGroupOverrides"> Defines the rule group overrides to apply to the rule set. </param>
        /// <returns> A new <see cref="Models.ManagedRuleSet"/> instance for mocking. </returns>
        public static ManagedRuleSet ManagedRuleSet(string ruleSetType = null, string ruleSetVersion = null, ManagedRuleSetActionType? ruleSetAction = null, IEnumerable<ManagedRuleExclusion> exclusions = null, IEnumerable<ManagedRuleGroupOverride> ruleGroupOverrides = null)
        {
            exclusions ??= new List<ManagedRuleExclusion>();
            ruleGroupOverrides ??= new List<ManagedRuleGroupOverride>();

            return new ManagedRuleSet(ruleSetType, ruleSetVersion, ruleSetAction, exclusions?.ToList(), ruleGroupOverrides?.ToList());
        }

        /// <summary> Initializes a new instance of ManagedRuleGroupOverride. </summary>
        /// <param name="ruleGroupName"> Describes the managed rule group to override. </param>
        /// <param name="exclusions"> Describes the exclusions that are applied to all rules in the group. </param>
        /// <param name="rules"> List of rules that will be disabled. If none specified, all rules in the group will be disabled. </param>
        /// <returns> A new <see cref="Models.ManagedRuleGroupOverride"/> instance for mocking. </returns>
        public static ManagedRuleGroupOverride ManagedRuleGroupOverride(string ruleGroupName = null, IEnumerable<ManagedRuleExclusion> exclusions = null, IEnumerable<ManagedRuleOverride> rules = null)
        {
            exclusions ??= new List<ManagedRuleExclusion>();
            rules ??= new List<ManagedRuleOverride>();

            return new ManagedRuleGroupOverride(ruleGroupName, exclusions?.ToList(), rules?.ToList());
        }

        /// <summary> Initializes a new instance of ManagedRuleOverride. </summary>
        /// <param name="ruleId"> Identifier for the managed rule. </param>
        /// <param name="enabledState"> Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified. </param>
        /// <param name="action"> Describes the override action to be applied when rule matches. </param>
        /// <param name="exclusions"> Describes the exclusions that are applied to this specific rule. </param>
        /// <returns> A new <see cref="Models.ManagedRuleOverride"/> instance for mocking. </returns>
        public static ManagedRuleOverride ManagedRuleOverride(string ruleId = null, ManagedRuleEnabledState? enabledState = null, RuleMatchActionType? action = null, IEnumerable<ManagedRuleExclusion> exclusions = null)
        {
            exclusions ??= new List<ManagedRuleExclusion>();

            return new ManagedRuleOverride(ruleId, enabledState, action, exclusions?.ToList());
        }

        /// <summary> Initializes a new instance of ManagedRuleSetDefinition. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="provisioningState"> Provisioning state of the managed rule set. </param>
        /// <param name="ruleSetId"> Id of the managed rule set. </param>
        /// <param name="ruleSetType"> Type of the managed rule set. </param>
        /// <param name="ruleSetVersion"> Version of the managed rule set type. </param>
        /// <param name="ruleGroups"> Rule groups of the managed rule set. </param>
        /// <returns> A new <see cref="Models.ManagedRuleSetDefinition"/> instance for mocking. </returns>
        public static ManagedRuleSetDefinition ManagedRuleSetDefinition(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string provisioningState = null, string ruleSetId = null, string ruleSetType = null, string ruleSetVersion = null, IEnumerable<ManagedRuleGroupDefinition> ruleGroups = null)
        {
            tags ??= new Dictionary<string, string>();
            ruleGroups ??= new List<ManagedRuleGroupDefinition>();

            return new ManagedRuleSetDefinition(id, name, resourceType, systemData, tags, location, provisioningState, ruleSetId, ruleSetType, ruleSetVersion, ruleGroups?.ToList());
        }

        /// <summary> Initializes a new instance of ManagedRuleGroupDefinition. </summary>
        /// <param name="ruleGroupName"> Name of the managed rule group. </param>
        /// <param name="description"> Description of the managed rule group. </param>
        /// <param name="rules"> List of rules within the managed rule group. </param>
        /// <returns> A new <see cref="Models.ManagedRuleGroupDefinition"/> instance for mocking. </returns>
        public static ManagedRuleGroupDefinition ManagedRuleGroupDefinition(string ruleGroupName = null, string description = null, IEnumerable<ManagedRuleDefinition> rules = null)
        {
            rules ??= new List<ManagedRuleDefinition>();

            return new ManagedRuleGroupDefinition(ruleGroupName, description, rules?.ToList());
        }

        /// <summary> Initializes a new instance of ManagedRuleDefinition. </summary>
        /// <param name="ruleId"> Identifier for the managed rule. </param>
        /// <param name="defaultState"> Describes the default state for the managed rule. </param>
        /// <param name="defaultAction"> Describes the default action to be applied when the managed rule matches. </param>
        /// <param name="description"> Describes the functionality of the managed rule. </param>
        /// <returns> A new <see cref="Models.ManagedRuleDefinition"/> instance for mocking. </returns>
        public static ManagedRuleDefinition ManagedRuleDefinition(string ruleId = null, ManagedRuleEnabledState? defaultState = null, RuleMatchActionType? defaultAction = null, string description = null)
        {
            return new ManagedRuleDefinition(ruleId, defaultState, defaultAction, description);
        }

        /// <summary> Initializes a new instance of FrontDoorNameAvailabilityResult. </summary>
        /// <param name="nameAvailability"> Indicates whether the name is available. </param>
        /// <param name="reason"> The reason why the name is not available. </param>
        /// <param name="message"> The detailed error message describing why the name is not available. </param>
        /// <returns> A new <see cref="Models.FrontDoorNameAvailabilityResult"/> instance for mocking. </returns>
        public static FrontDoorNameAvailabilityResult FrontDoorNameAvailabilityResult(FrontDoorNameAvailabilityState? nameAvailability = null, string reason = null, string message = null)
        {
            return new FrontDoorNameAvailabilityResult(nameAvailability, reason, message);
        }

        /// <summary> Initializes a new instance of FrontDoorData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="friendlyName"> A friendly name for the frontDoor. </param>
        /// <param name="routingRules"> Routing rules associated with this Front Door. </param>
        /// <param name="loadBalancingSettings"> Load balancing settings associated with this Front Door instance. </param>
        /// <param name="healthProbeSettings"> Health probe settings associated with this Front Door instance. </param>
        /// <param name="backendPools"> Backend pools available to routing rules. </param>
        /// <param name="frontendEndpoints"> Frontend endpoints available to routing rules. </param>
        /// <param name="backendPoolsSettings"> Settings for all backendPools. </param>
        /// <param name="enabledState"> Operational status of the Front Door load balancer. Permitted values are &apos;Enabled&apos; or &apos;Disabled&apos;. </param>
        /// <param name="resourceState"> Resource status of the Front Door. </param>
        /// <param name="provisioningState"> Provisioning state of the Front Door. </param>
        /// <param name="cname"> The host that each frontendEndpoint must CNAME to. </param>
        /// <param name="frontdoorId"> The Id of the frontdoor. </param>
        /// <param name="rulesEngines"> Rules Engine Configurations available to routing rules. </param>
        /// <param name="extendedProperties"> Key-Value pair representing additional properties for frontdoor. </param>
        /// <returns> A new <see cref="FrontDoor.FrontDoorData"/> instance for mocking. </returns>
        public static FrontDoorData FrontDoorData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string friendlyName = null, IEnumerable<RoutingRuleData> routingRules = null, IEnumerable<FrontDoorLoadBalancingSettingsData> loadBalancingSettings = null, IEnumerable<FrontDoorHealthProbeSettingsData> healthProbeSettings = null, IEnumerable<FrontDoorBackendPool> backendPools = null, IEnumerable<FrontendEndpointData> frontendEndpoints = null, BackendPoolsSettings backendPoolsSettings = null, FrontDoorEnabledState? enabledState = null, FrontDoorResourceState? resourceState = null, string provisioningState = null, string cname = null, string frontdoorId = null, IEnumerable<FrontDoorRulesEngineData> rulesEngines = null, IReadOnlyDictionary<string, string> extendedProperties = null)
        {
            tags ??= new Dictionary<string, string>();
            routingRules ??= new List<RoutingRuleData>();
            loadBalancingSettings ??= new List<FrontDoorLoadBalancingSettingsData>();
            healthProbeSettings ??= new List<FrontDoorHealthProbeSettingsData>();
            backendPools ??= new List<FrontDoorBackendPool>();
            frontendEndpoints ??= new List<FrontendEndpointData>();
            rulesEngines ??= new List<FrontDoorRulesEngineData>();
            extendedProperties ??= new Dictionary<string, string>();

            return new FrontDoorData(id, name, resourceType, systemData, tags, location, friendlyName, routingRules?.ToList(), loadBalancingSettings?.ToList(), healthProbeSettings?.ToList(), backendPools?.ToList(), frontendEndpoints?.ToList(), backendPoolsSettings, enabledState, resourceState, provisioningState, cname, frontdoorId, rulesEngines?.ToList(), extendedProperties);
        }

        /// <summary> Initializes a new instance of FrontDoorRulesEngineData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="rules"> A list of rules that define a particular Rules Engine Configuration. </param>
        /// <param name="resourceState"> Resource status. </param>
        /// <returns> A new <see cref="FrontDoor.FrontDoorRulesEngineData"/> instance for mocking. </returns>
        public static FrontDoorRulesEngineData FrontDoorRulesEngineData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IEnumerable<RulesEngineRule> rules = null, FrontDoorResourceState? resourceState = null)
        {
            rules ??= new List<RulesEngineRule>();

            return new FrontDoorRulesEngineData(id, name, resourceType, systemData, rules?.ToList(), resourceState);
        }

        /// <summary> Initializes a new instance of RulesEngineRule. </summary>
        /// <param name="name"> A name to refer to this specific rule. </param>
        /// <param name="priority"> A priority assigned to this rule. </param>
        /// <param name="action"> Actions to perform on the request and response if all of the match conditions are met. </param>
        /// <param name="matchConditions"> A list of match conditions that must meet in order for the actions of this rule to run. Having no match conditions means the actions will always run. </param>
        /// <param name="matchProcessingBehavior"> If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue. </param>
        /// <returns> A new <see cref="Models.RulesEngineRule"/> instance for mocking. </returns>
        public static RulesEngineRule RulesEngineRule(string name = null, int priority = default, RulesEngineAction action = null, IEnumerable<RulesEngineMatchCondition> matchConditions = null, MatchProcessingBehavior? matchProcessingBehavior = null)
        {
            matchConditions ??= new List<RulesEngineMatchCondition>();

            return new RulesEngineRule(name, priority, action, matchConditions?.ToList(), matchProcessingBehavior);
        }

        /// <summary> Initializes a new instance of RulesEngineAction. </summary>
        /// <param name="requestHeaderActions"> A list of header actions to apply from the request from AFD to the origin. </param>
        /// <param name="responseHeaderActions"> A list of header actions to apply from the response from AFD to the client. </param>
        /// <param name="routeConfigurationOverride">
        /// Override the route configuration.
        /// Please note <see cref="RouteConfiguration"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ForwardingConfiguration"/> and <see cref="RedirectConfiguration"/>.
        /// </param>
        /// <returns> A new <see cref="Models.RulesEngineAction"/> instance for mocking. </returns>
        public static RulesEngineAction RulesEngineAction(IEnumerable<RulesEngineHeaderAction> requestHeaderActions = null, IEnumerable<RulesEngineHeaderAction> responseHeaderActions = null, RouteConfiguration routeConfigurationOverride = null)
        {
            requestHeaderActions ??= new List<RulesEngineHeaderAction>();
            responseHeaderActions ??= new List<RulesEngineHeaderAction>();

            return new RulesEngineAction(requestHeaderActions?.ToList(), responseHeaderActions?.ToList(), routeConfigurationOverride);
        }

        /// <summary> Initializes a new instance of RulesEngineHeaderAction. </summary>
        /// <param name="headerActionType"> Which type of manipulation to apply to the header. </param>
        /// <param name="headerName"> The name of the header this action will apply to. </param>
        /// <param name="value"> The value to update the given header name with. This value is not used if the actionType is Delete. </param>
        /// <returns> A new <see cref="Models.RulesEngineHeaderAction"/> instance for mocking. </returns>
        public static RulesEngineHeaderAction RulesEngineHeaderAction(RulesEngineHeaderActionType headerActionType = default, string headerName = null, string value = null)
        {
            return new RulesEngineHeaderAction(headerActionType, headerName, value);
        }

        /// <summary> Initializes a new instance of RouteConfiguration. </summary>
        /// <param name="odataType"></param>
        /// <returns> A new <see cref="Models.RouteConfiguration"/> instance for mocking. </returns>
        public static RouteConfiguration RouteConfiguration(string odataType = null)
        {
            return new UnknownRouteConfiguration(odataType);
        }

        /// <summary> Initializes a new instance of RulesEngineMatchCondition. </summary>
        /// <param name="rulesEngineMatchVariable"> Match Variable. </param>
        /// <param name="selector"> Name of selector in RequestHeader or RequestBody to be matched. </param>
        /// <param name="rulesEngineOperator"> Describes operator to apply to the match condition. </param>
        /// <param name="isNegateCondition"> Describes if this is negate condition or not. </param>
        /// <param name="rulesEngineMatchValue"> Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match. </param>
        /// <param name="transforms"> List of transforms. </param>
        /// <returns> A new <see cref="Models.RulesEngineMatchCondition"/> instance for mocking. </returns>
        public static RulesEngineMatchCondition RulesEngineMatchCondition(RulesEngineMatchVariable rulesEngineMatchVariable = default, string selector = null, RulesEngineOperator rulesEngineOperator = default, bool? isNegateCondition = null, IEnumerable<string> rulesEngineMatchValue = null, IEnumerable<RulesEngineMatchTransform> transforms = null)
        {
            rulesEngineMatchValue ??= new List<string>();
            transforms ??= new List<RulesEngineMatchTransform>();

            return new RulesEngineMatchCondition(rulesEngineMatchVariable, selector, rulesEngineOperator, isNegateCondition, rulesEngineMatchValue?.ToList(), transforms?.ToList());
        }

        /// <summary> Initializes a new instance of RoutingRuleData. </summary>
        /// <param name="id"> Resource ID. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="resourceType"> Resource type. </param>
        /// <param name="frontendEndpoints"> Frontend endpoints associated with this rule. </param>
        /// <param name="acceptedProtocols"> Protocol schemes to match for this rule. </param>
        /// <param name="patternsToMatch"> The route patterns of the rule. </param>
        /// <param name="enabledState"> Whether to enable use of this rule. Permitted values are &apos;Enabled&apos; or &apos;Disabled&apos;. </param>
        /// <param name="routeConfiguration">
        /// A reference to the routing configuration.
        /// Please note <see cref="RouteConfiguration"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ForwardingConfiguration"/> and <see cref="RedirectConfiguration"/>.
        /// </param>
        /// <param name="rulesEngineId"> A reference to a specific Rules Engine Configuration to apply to this route. </param>
        /// <param name="webApplicationFirewallPolicyLinkId"> Defines the Web Application Firewall policy for each routing rule (if applicable). </param>
        /// <param name="resourceState"> Resource status. </param>
        /// <returns> A new <see cref="Models.RoutingRuleData"/> instance for mocking. </returns>
        public static RoutingRuleData RoutingRuleData(ResourceIdentifier id = null, string name = null, ResourceType? resourceType = null, IEnumerable<WritableSubResource> frontendEndpoints = null, IEnumerable<FrontDoorProtocol> acceptedProtocols = null, IEnumerable<string> patternsToMatch = null, RoutingRuleEnabledState? enabledState = null, RouteConfiguration routeConfiguration = null, ResourceIdentifier rulesEngineId = null, ResourceIdentifier webApplicationFirewallPolicyLinkId = null, FrontDoorResourceState? resourceState = null)
        {
            frontendEndpoints ??= new List<WritableSubResource>();
            acceptedProtocols ??= new List<FrontDoorProtocol>();
            patternsToMatch ??= new List<string>();

            return new RoutingRuleData(id, name, resourceType, frontendEndpoints?.ToList(), acceptedProtocols?.ToList(), patternsToMatch?.ToList(), enabledState, routeConfiguration, ResourceManagerModelFactory.WritableSubResource(rulesEngineId), ResourceManagerModelFactory.WritableSubResource(webApplicationFirewallPolicyLinkId), resourceState);
        }

        /// <summary> Initializes a new instance of FrontDoorResourceData. </summary>
        /// <param name="id"> Resource ID. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="resourceType"> Resource type. </param>
        /// <returns> A new <see cref="Models.FrontDoorResourceData"/> instance for mocking. </returns>
        public static FrontDoorResourceData FrontDoorResourceData(ResourceIdentifier id = null, string name = null, ResourceType? resourceType = null)
        {
            return new FrontDoorResourceData(id, name, resourceType);
        }

        /// <summary> Initializes a new instance of FrontDoorLoadBalancingSettingsData. </summary>
        /// <param name="id"> Resource ID. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="resourceType"> Resource type. </param>
        /// <param name="sampleSize"> The number of samples to consider for load balancing decisions. </param>
        /// <param name="successfulSamplesRequired"> The number of samples within the sample period that must succeed. </param>
        /// <param name="additionalLatencyMilliseconds"> The additional latency in milliseconds for probes to fall into the lowest latency bucket. </param>
        /// <param name="resourceState"> Resource status. </param>
        /// <returns> A new <see cref="Models.FrontDoorLoadBalancingSettingsData"/> instance for mocking. </returns>
        public static FrontDoorLoadBalancingSettingsData FrontDoorLoadBalancingSettingsData(ResourceIdentifier id = null, string name = null, ResourceType? resourceType = null, int? sampleSize = null, int? successfulSamplesRequired = null, int? additionalLatencyMilliseconds = null, FrontDoorResourceState? resourceState = null)
        {
            return new FrontDoorLoadBalancingSettingsData(id, name, resourceType, sampleSize, successfulSamplesRequired, additionalLatencyMilliseconds, resourceState);
        }

        /// <summary> Initializes a new instance of FrontDoorHealthProbeSettingsData. </summary>
        /// <param name="id"> Resource ID. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="resourceType"> Resource type. </param>
        /// <param name="path"> The path to use for the health probe. Default is /. </param>
        /// <param name="protocol"> Protocol scheme to use for this probe. </param>
        /// <param name="intervalInSeconds"> The number of seconds between health probes. </param>
        /// <param name="healthProbeMethod"> Configures which HTTP method to use to probe the backends defined under backendPools. </param>
        /// <param name="enabledState"> Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool. </param>
        /// <param name="resourceState"> Resource status. </param>
        /// <returns> A new <see cref="Models.FrontDoorHealthProbeSettingsData"/> instance for mocking. </returns>
        public static FrontDoorHealthProbeSettingsData FrontDoorHealthProbeSettingsData(ResourceIdentifier id = null, string name = null, ResourceType? resourceType = null, string path = null, FrontDoorProtocol? protocol = null, int? intervalInSeconds = null, FrontDoorHealthProbeMethod? healthProbeMethod = null, HealthProbeEnabled? enabledState = null, FrontDoorResourceState? resourceState = null)
        {
            return new FrontDoorHealthProbeSettingsData(id, name, resourceType, path, protocol, intervalInSeconds, healthProbeMethod, enabledState, resourceState);
        }

        /// <summary> Initializes a new instance of FrontDoorBackendPool. </summary>
        /// <param name="id"> Resource ID. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="resourceType"> Resource type. </param>
        /// <param name="backends"> The set of backends for this pool. </param>
        /// <param name="loadBalancingSettingsId"> Load balancing settings for a backend pool. </param>
        /// <param name="healthProbeSettingsId"> L7 health probe settings for a backend pool. </param>
        /// <param name="resourceState"> Resource status. </param>
        /// <returns> A new <see cref="Models.FrontDoorBackendPool"/> instance for mocking. </returns>
        public static FrontDoorBackendPool FrontDoorBackendPool(ResourceIdentifier id = null, string name = null, ResourceType? resourceType = null, IEnumerable<FrontDoorBackend> backends = null, ResourceIdentifier loadBalancingSettingsId = null, ResourceIdentifier healthProbeSettingsId = null, FrontDoorResourceState? resourceState = null)
        {
            backends ??= new List<FrontDoorBackend>();

            return new FrontDoorBackendPool(id, name, resourceType, backends?.ToList(), ResourceManagerModelFactory.WritableSubResource(loadBalancingSettingsId), ResourceManagerModelFactory.WritableSubResource(healthProbeSettingsId), resourceState);
        }

        /// <summary> Initializes a new instance of FrontDoorBackend. </summary>
        /// <param name="address"> Location of the backend (IP address or FQDN). </param>
        /// <param name="privateLinkAlias"> The Alias of the Private Link resource. Populating this optional field indicates that this backend is &apos;Private&apos;. </param>
        /// <param name="privateLinkResourceId"> The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is &apos;Private&apos;. </param>
        /// <param name="privateLinkLocation"> The location of the Private Link resource. Required only if &apos;privateLinkResourceId&apos; is populated. </param>
        /// <param name="privateEndpointStatus"> The Approval status for the connection to the Private Link. </param>
        /// <param name="privateLinkApprovalMessage"> A custom message to be included in the approval request to connect to the Private Link. </param>
        /// <param name="httpPort"> The HTTP TCP port number. Must be between 1 and 65535. </param>
        /// <param name="httpsPort"> The HTTPS TCP port number. Must be between 1 and 65535. </param>
        /// <param name="enabledState"> Whether to enable use of this backend. Permitted values are &apos;Enabled&apos; or &apos;Disabled&apos;. </param>
        /// <param name="priority"> Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. </param>
        /// <param name="weight"> Weight of this endpoint for load balancing purposes. </param>
        /// <param name="backendHostHeader"> The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host. </param>
        /// <returns> A new <see cref="Models.FrontDoorBackend"/> instance for mocking. </returns>
        public static FrontDoorBackend FrontDoorBackend(string address = null, string privateLinkAlias = null, ResourceIdentifier privateLinkResourceId = null, AzureLocation? privateLinkLocation = null, BackendPrivateEndpointStatus? privateEndpointStatus = null, string privateLinkApprovalMessage = null, int? httpPort = null, int? httpsPort = null, BackendEnabledState? enabledState = null, int? priority = null, int? weight = null, string backendHostHeader = null)
        {
            return new FrontDoorBackend(address, privateLinkAlias, privateLinkResourceId, privateLinkLocation, privateEndpointStatus, privateLinkApprovalMessage, httpPort, httpsPort, enabledState, priority, weight, backendHostHeader);
        }

        /// <summary> Initializes a new instance of FrontendEndpointData. </summary>
        /// <param name="id"> Resource ID. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="resourceType"> Resource type. </param>
        /// <param name="hostName"> The host name of the frontendEndpoint. Must be a domain name. </param>
        /// <param name="sessionAffinityEnabledState"> Whether to allow session affinity on this host. Valid options are &apos;Enabled&apos; or &apos;Disabled&apos;. </param>
        /// <param name="sessionAffinityTtlInSeconds"> UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable. </param>
        /// <param name="webApplicationFirewallPolicyLinkId"> Defines the Web Application Firewall policy for each host (if applicable). </param>
        /// <param name="resourceState"> Resource status. </param>
        /// <param name="customHttpsProvisioningState"> Provisioning status of Custom Https of the frontendEndpoint. </param>
        /// <param name="customHttpsProvisioningSubstate"> Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step. </param>
        /// <param name="customHttpsConfiguration"> The configuration specifying how to enable HTTPS. </param>
        /// <returns> A new <see cref="FrontDoor.FrontendEndpointData"/> instance for mocking. </returns>
        public static FrontendEndpointData FrontendEndpointData(ResourceIdentifier id = null, string name = null, ResourceType? resourceType = null, string hostName = null, SessionAffinityEnabledState? sessionAffinityEnabledState = null, int? sessionAffinityTtlInSeconds = null, ResourceIdentifier webApplicationFirewallPolicyLinkId = null, FrontDoorResourceState? resourceState = null, FrontendEndpointCustomHttpsProvisioningState? customHttpsProvisioningState = null, FrontendEndpointCustomHttpsProvisioningSubstate? customHttpsProvisioningSubstate = null, CustomHttpsConfiguration customHttpsConfiguration = null)
        {
            return new FrontendEndpointData(id, name, resourceType, hostName, sessionAffinityEnabledState, sessionAffinityTtlInSeconds, ResourceManagerModelFactory.WritableSubResource(webApplicationFirewallPolicyLinkId), resourceState, customHttpsProvisioningState, customHttpsProvisioningSubstate, customHttpsConfiguration);
        }

        /// <summary> Initializes a new instance of CustomHttpsConfiguration. </summary>
        /// <param name="certificateSource"> Defines the source of the SSL certificate. </param>
        /// <param name="protocolType"> Defines the TLS extension protocol that is used for secure delivery. </param>
        /// <param name="minimumTlsVersion"> The minimum TLS version required from the clients to establish an SSL handshake with Front Door. </param>
        /// <param name="certificateType"> Defines the type of the certificate used for secure connections to a frontendEndpoint. </param>
        /// <param name="vaultId"> The Key Vault containing the SSL certificate. </param>
        /// <param name="secretName"> The name of the Key Vault secret representing the full certificate PFX. </param>
        /// <param name="secretVersion"> The version of the Key Vault secret representing the full certificate PFX. </param>
        /// <returns> A new <see cref="Models.CustomHttpsConfiguration"/> instance for mocking. </returns>
        public static CustomHttpsConfiguration CustomHttpsConfiguration(FrontDoorCertificateSource certificateSource = default, FrontDoorTlsProtocolType protocolType = default, FrontDoorRequiredMinimumTlsVersion minimumTlsVersion = default, FrontDoorEndpointConnectionCertificateType? certificateType = null, ResourceIdentifier vaultId = null, string secretName = null, string secretVersion = null)
        {
            return new CustomHttpsConfiguration(certificateSource, protocolType, minimumTlsVersion, certificateType, ResourceManagerModelFactory.WritableSubResource(vaultId), secretName, secretVersion);
        }

        /// <summary> Initializes a new instance of BackendPoolsSettings. </summary>
        /// <param name="enforceCertificateNameCheck"> Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests. </param>
        /// <param name="sendRecvTimeoutInSeconds"> Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns. </param>
        /// <returns> A new <see cref="Models.BackendPoolsSettings"/> instance for mocking. </returns>
        public static BackendPoolsSettings BackendPoolsSettings(EnforceCertificateNameCheckEnabledState? enforceCertificateNameCheck = null, int? sendRecvTimeoutInSeconds = null)
        {
            return new BackendPoolsSettings(enforceCertificateNameCheck, sendRecvTimeoutInSeconds);
        }

        /// <summary> Initializes a new instance of FrontDoorValidateCustomDomainResult. </summary>
        /// <param name="isCustomDomainValidated"> Indicates whether the custom domain is valid or not. </param>
        /// <param name="reason"> The reason why the custom domain is not valid. </param>
        /// <param name="message"> Error message describing why the custom domain is not valid. </param>
        /// <returns> A new <see cref="Models.FrontDoorValidateCustomDomainResult"/> instance for mocking. </returns>
        public static FrontDoorValidateCustomDomainResult FrontDoorValidateCustomDomainResult(bool? isCustomDomainValidated = null, string reason = null, string message = null)
        {
            return new FrontDoorValidateCustomDomainResult(isCustomDomainValidated, reason, message);
        }

        /// <summary> Initializes a new instance of FrontDoorNetworkExperimentProfileData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="etag"> Gets a unique read-only string that changes whenever the resource is updated. </param>
        /// <param name="resourceState"> Resource status. </param>
        /// <param name="enabledState"> The state of the Experiment. </param>
        /// <returns> A new <see cref="FrontDoor.FrontDoorNetworkExperimentProfileData"/> instance for mocking. </returns>
        public static FrontDoorNetworkExperimentProfileData FrontDoorNetworkExperimentProfileData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ETag? etag = null, NetworkExperimentResourceState? resourceState = null, FrontDoorExperimentState? enabledState = null)
        {
            tags ??= new Dictionary<string, string>();

            return new FrontDoorNetworkExperimentProfileData(id, name, resourceType, systemData, tags, location, etag, resourceState, enabledState);
        }

        /// <summary> Initializes a new instance of PreconfiguredEndpoint. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="description"> The description of the endpoint. </param>
        /// <param name="endpoint"> The endpoint that is preconfigured. </param>
        /// <param name="endpointType"> The type of endpoint. </param>
        /// <param name="backend"> The preconfigured endpoint backend. </param>
        /// <returns> A new <see cref="Models.PreconfiguredEndpoint"/> instance for mocking. </returns>
        public static PreconfiguredEndpoint PreconfiguredEndpoint(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string description = null, string endpoint = null, FrontDoorEndpointType? endpointType = null, string backend = null)
        {
            tags ??= new Dictionary<string, string>();

            return new PreconfiguredEndpoint(id, name, resourceType, systemData, tags, location, description, endpoint, endpointType, backend);
        }

        /// <summary> Initializes a new instance of FrontDoorExperimentData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="description"> The description of the details or intents of the Experiment. </param>
        /// <param name="experimentEndpointA"> The endpoint A of an experiment. </param>
        /// <param name="experimentEndpointB"> The endpoint B of an experiment. </param>
        /// <param name="enabledState"> The state of the Experiment. </param>
        /// <param name="resourceState"> Resource status. </param>
        /// <param name="status"> The description of Experiment status from the server side. </param>
        /// <param name="scriptFileUri"> The uri to the Script used in the Experiment. </param>
        /// <returns> A new <see cref="FrontDoor.FrontDoorExperimentData"/> instance for mocking. </returns>
        public static FrontDoorExperimentData FrontDoorExperimentData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string description = null, FrontDoorExperimentEndpointProperties experimentEndpointA = null, FrontDoorExperimentEndpointProperties experimentEndpointB = null, FrontDoorExperimentState? enabledState = null, NetworkExperimentResourceState? resourceState = null, string status = null, Uri scriptFileUri = null)
        {
            tags ??= new Dictionary<string, string>();

            return new FrontDoorExperimentData(id, name, resourceType, systemData, tags, location, description, experimentEndpointA, experimentEndpointB, enabledState, resourceState, status, scriptFileUri);
        }

        /// <summary> Initializes a new instance of FrontDoorExperimentEndpointProperties. </summary>
        /// <param name="name"> The name of the endpoint. </param>
        /// <param name="endpoint"> The endpoint URL. </param>
        /// <returns> A new <see cref="Models.FrontDoorExperimentEndpointProperties"/> instance for mocking. </returns>
        public static FrontDoorExperimentEndpointProperties FrontDoorExperimentEndpointProperties(string name = null, string endpoint = null)
        {
            return new FrontDoorExperimentEndpointProperties(name, endpoint);
        }

        /// <summary> Initializes a new instance of LatencyScorecard. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="latencyScorecardId"> The unique identifier of the Latency Scorecard. </param>
        /// <param name="latencyScorecardName"> The name of the Latency Scorecard. </param>
        /// <param name="description"> The description of the Latency Scorecard. </param>
        /// <param name="scorecardEndpointA"> The A endpoint in the scorecard. </param>
        /// <param name="scorecardEndpointB"> The B endpoint in the scorecard. </param>
        /// <param name="startOn"> The start time of the Latency Scorecard in UTC. </param>
        /// <param name="endOn"> The end time of the Latency Scorecard in UTC. </param>
        /// <param name="country"> The country associated with the Latency Scorecard. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html. </param>
        /// <param name="latencyMetrics"> The latency metrics of the Latency Scorecard. </param>
        /// <returns> A new <see cref="Models.LatencyScorecard"/> instance for mocking. </returns>
        public static LatencyScorecard LatencyScorecard(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string latencyScorecardId = null, string latencyScorecardName = null, string description = null, Uri scorecardEndpointA = null, Uri scorecardEndpointB = null, DateTimeOffset? startOn = null, DateTimeOffset? endOn = null, string country = null, IEnumerable<LatencyMetric> latencyMetrics = null)
        {
            tags ??= new Dictionary<string, string>();
            latencyMetrics ??= new List<LatencyMetric>();

            return new LatencyScorecard(id, name, resourceType, systemData, tags, location, latencyScorecardId, latencyScorecardName, description, scorecardEndpointA, scorecardEndpointB, startOn, endOn, country, latencyMetrics?.ToList());
        }

        /// <summary> Initializes a new instance of LatencyMetric. </summary>
        /// <param name="name"> The name of the Latency Metric. </param>
        /// <param name="endOn"> The end time of the Latency Scorecard in UTC. </param>
        /// <param name="aValue"> The metric value of the A endpoint. </param>
        /// <param name="bValue"> The metric value of the B endpoint. </param>
        /// <param name="delta"> The difference in value between endpoint A and B. </param>
        /// <param name="deltaPercent"> The percent difference between endpoint A and B. </param>
        /// <param name="acLower95CI"> The lower end of the 95% confidence interval for endpoint A. </param>
        /// <param name="ahUpper95CI"> The upper end of the 95% confidence interval for endpoint A. </param>
        /// <param name="bcLower95CI"> The lower end of the 95% confidence interval for endpoint B. </param>
        /// <param name="bUpper95CI"> The upper end of the 95% confidence interval for endpoint B. </param>
        /// <returns> A new <see cref="Models.LatencyMetric"/> instance for mocking. </returns>
        public static LatencyMetric LatencyMetric(string name = null, DateTimeOffset? endOn = null, float? aValue = null, float? bValue = null, float? delta = null, float? deltaPercent = null, float? acLower95CI = null, float? ahUpper95CI = null, float? bcLower95CI = null, float? bUpper95CI = null)
        {
            return new LatencyMetric(name, endOn, aValue, bValue, delta, deltaPercent, acLower95CI, ahUpper95CI, bcLower95CI, bUpper95CI);
        }

        /// <summary> Initializes a new instance of FrontDoorTimeSeriesInfo. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="endpoint"> The endpoint associated with the Timeseries data point. </param>
        /// <param name="startOn"> The start DateTime of the Timeseries in UTC. </param>
        /// <param name="endOn"> The end DateTime of the Timeseries in UTC. </param>
        /// <param name="aggregationInterval"> The aggregation interval of the Timeseries. </param>
        /// <param name="timeSeriesType"> The type of Timeseries. </param>
        /// <param name="country"> The country associated with the Timeseries. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html. </param>
        /// <param name="timeSeriesData"> The set of data points for the timeseries. </param>
        /// <returns> A new <see cref="Models.FrontDoorTimeSeriesInfo"/> instance for mocking. </returns>
        public static FrontDoorTimeSeriesInfo FrontDoorTimeSeriesInfo(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, Uri endpoint = null, DateTimeOffset? startOn = null, DateTimeOffset? endOn = null, FrontDoorTimeSeriesInfoAggregationInterval? aggregationInterval = null, FrontDoorTimeSeriesType? timeSeriesType = null, string country = null, IEnumerable<FrontDoorTimeSeriesDataPoint> timeSeriesData = null)
        {
            tags ??= new Dictionary<string, string>();
            timeSeriesData ??= new List<FrontDoorTimeSeriesDataPoint>();

            return new FrontDoorTimeSeriesInfo(id, name, resourceType, systemData, tags, location, endpoint, startOn, endOn, aggregationInterval, timeSeriesType, country, timeSeriesData?.ToList());
        }

        /// <summary> Initializes a new instance of FrontDoorTimeSeriesDataPoint. </summary>
        /// <param name="dateTimeUtc"> The DateTime of the Timeseries data point in UTC. </param>
        /// <param name="value"> The Value of the Timeseries data point. </param>
        /// <returns> A new <see cref="Models.FrontDoorTimeSeriesDataPoint"/> instance for mocking. </returns>
        public static FrontDoorTimeSeriesDataPoint FrontDoorTimeSeriesDataPoint(DateTimeOffset? dateTimeUtc = null, float? value = null)
        {
            return new FrontDoorTimeSeriesDataPoint(dateTimeUtc, value);
        }

        /// <summary> Initializes a new instance of ForwardingConfiguration. </summary>
        /// <param name="customForwardingPath"> A custom path used to rewrite resource paths matched by this rule. Leave empty to use incoming path. </param>
        /// <param name="forwardingProtocol"> Protocol this rule will use when forwarding traffic to backends. </param>
        /// <param name="cacheConfiguration"> The caching configuration associated with this rule. </param>
        /// <param name="backendPoolId"> A reference to the BackendPool which this rule routes to. </param>
        /// <returns> A new <see cref="Models.ForwardingConfiguration"/> instance for mocking. </returns>
        public static ForwardingConfiguration ForwardingConfiguration(string customForwardingPath = null, FrontDoorForwardingProtocol? forwardingProtocol = null, FrontDoorCacheConfiguration cacheConfiguration = null, ResourceIdentifier backendPoolId = null)
        {
            return new ForwardingConfiguration("#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration", customForwardingPath, forwardingProtocol, cacheConfiguration, ResourceManagerModelFactory.WritableSubResource(backendPoolId));
        }

        /// <summary> Initializes a new instance of FrontDoorCacheConfiguration. </summary>
        /// <param name="queryParameterStripDirective"> Treatment of URL query terms when forming the cache key. </param>
        /// <param name="queryParameters"> query parameters to include or exclude (comma separated). </param>
        /// <param name="dynamicCompression"> Whether to use dynamic compression for cached content. </param>
        /// <param name="cacheDuration"> The duration for which the content needs to be cached. Allowed format is in ISO 8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations). HTTP requires the value to be no more than a year. </param>
        /// <returns> A new <see cref="Models.FrontDoorCacheConfiguration"/> instance for mocking. </returns>
        public static FrontDoorCacheConfiguration FrontDoorCacheConfiguration(FrontDoorQuery? queryParameterStripDirective = null, string queryParameters = null, DynamicCompressionEnabled? dynamicCompression = null, TimeSpan? cacheDuration = null)
        {
            return new FrontDoorCacheConfiguration(queryParameterStripDirective, queryParameters, dynamicCompression, cacheDuration);
        }

        /// <summary> Initializes a new instance of RedirectConfiguration. </summary>
        /// <param name="redirectType"> The redirect type the rule will use when redirecting traffic. </param>
        /// <param name="redirectProtocol"> The protocol of the destination to where the traffic is redirected. </param>
        /// <param name="customHost"> Host to redirect. Leave empty to use the incoming host as the destination host. </param>
        /// <param name="customPath"> The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path. </param>
        /// <param name="customFragment"> Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #. </param>
        /// <param name="customQueryString"> The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming query string. Query string must be in &lt;key&gt;=&lt;value&gt; format. The first ? and &amp; will be added automatically so do not include them in the front, but do separate multiple query strings with &amp;. </param>
        /// <returns> A new <see cref="Models.RedirectConfiguration"/> instance for mocking. </returns>
        public static RedirectConfiguration RedirectConfiguration(FrontDoorRedirectType? redirectType = null, FrontDoorRedirectProtocol? redirectProtocol = null, string customHost = null, string customPath = null, string customFragment = null, string customQueryString = null)
        {
            return new RedirectConfiguration("#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration", redirectType, redirectProtocol, customHost, customPath, customFragment, customQueryString);
        }
    }
}
