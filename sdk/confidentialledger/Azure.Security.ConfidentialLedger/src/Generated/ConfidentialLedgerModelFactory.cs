// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Collections.Generic;
using System.Linq;

namespace Azure.Security.ConfidentialLedger.Models
{
    /// <summary> Model factory for read-only models. </summary>
    public static partial class ConfidentialLedgerModelFactory
    {
        /// <summary> Initializes a new instance of Constitution. </summary>
        /// <param name="digest"> SHA256 digest of the constitution script. </param>
        /// <param name="script"> Contents of the constitution. </param>
        /// <returns> A new <see cref="Models.Constitution"/> instance for mocking. </returns>
        public static Constitution Constitution(string digest = null, string script = null)
        {
            return new Constitution(digest, script);
        }

        /// <summary> Initializes a new instance of Consortium. </summary>
        /// <param name="members"></param>
        /// <returns> A new <see cref="Models.Consortium"/> instance for mocking. </returns>
        public static Consortium Consortium(IEnumerable<ConsortiumMember> members = null)
        {
            members ??= new List<ConsortiumMember>();

            return new Consortium(members?.ToList());
        }

        /// <summary> Initializes a new instance of ConsortiumMember. </summary>
        /// <param name="certificate"> PEM-encoded certificate associated with the member. </param>
        /// <param name="id"> Identifier assigned to the member. </param>
        /// <returns> A new <see cref="Models.ConsortiumMember"/> instance for mocking. </returns>
        public static ConsortiumMember ConsortiumMember(string certificate = null, string id = null)
        {
            return new ConsortiumMember(certificate, id);
        }

        /// <summary> Initializes a new instance of ConfidentialLedgerEnclaves. </summary>
        /// <param name="currentNodeId"> Id of the Confidential Ledger node responding to the request. </param>
        /// <param name="enclaveQuotes"> Dictionary of enclave quotes, indexed by node id. </param>
        /// <returns> A new <see cref="Models.ConfidentialLedgerEnclaves"/> instance for mocking. </returns>
        public static ConfidentialLedgerEnclaves ConfidentialLedgerEnclaves(string currentNodeId = null, IReadOnlyDictionary<string, EnclaveQuote> enclaveQuotes = null)
        {
            enclaveQuotes ??= new Dictionary<string, EnclaveQuote>();

            return new ConfidentialLedgerEnclaves(currentNodeId, enclaveQuotes);
        }

        /// <summary> Initializes a new instance of EnclaveQuote. </summary>
        /// <param name="nodeId"> ID assigned to this node. </param>
        /// <param name="mrenclave"> MRENCLAVE value of the code running in the enclave. </param>
        /// <param name="quoteVersion"> Version of the quote presented. </param>
        /// <param name="raw"> Raw SGX quote, parsable by tools like Open Enclave&apos;s oeverify. </param>
        /// <returns> A new <see cref="Models.EnclaveQuote"/> instance for mocking. </returns>
        public static EnclaveQuote EnclaveQuote(string nodeId = null, string mrenclave = null, string quoteVersion = null, string raw = null)
        {
            return new EnclaveQuote(nodeId, mrenclave, quoteVersion, raw);
        }

        /// <summary> Initializes a new instance of LedgerEntry. </summary>
        /// <param name="contents"> Contents of the ledger entry. </param>
        /// <param name="subLedgerId"> Identifier for sub-ledgers. </param>
        /// <param name="transactionId"> A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read. </param>
        /// <returns> A new <see cref="Models.LedgerEntry"/> instance for mocking. </returns>
        public static LedgerEntry LedgerEntry(string contents = null, string subLedgerId = null, string transactionId = null)
        {
            return new LedgerEntry(contents, subLedgerId, transactionId);
        }

        /// <summary> Initializes a new instance of LedgerWriteResult. </summary>
        /// <param name="subLedgerId"> Identifier for sub-ledgers. </param>
        /// <returns> A new <see cref="Models.LedgerWriteResult"/> instance for mocking. </returns>
        public static LedgerWriteResult LedgerWriteResult(string subLedgerId = null)
        {
            return new LedgerWriteResult(subLedgerId);
        }

        /// <summary> Initializes a new instance of LedgerQueryResult. </summary>
        /// <param name="state"> State of a ledger query. </param>
        /// <param name="entry"> The ledger entry found as a result of the query. This is only available if the query is in Ready state. </param>
        /// <returns> A new <see cref="Models.LedgerQueryResult"/> instance for mocking. </returns>
        public static LedgerQueryResult LedgerQueryResult(ConfidentialLedgerQueryState state = default, LedgerEntry entry = null)
        {
            return new LedgerQueryResult(state, entry);
        }

        /// <summary> Initializes a new instance of TransactionReceipt. </summary>
        /// <param name="receipt"> A receipt certifying the transaction at the specified id. </param>
        /// <param name="state"> State of a ledger query. </param>
        /// <param name="transactionId"> A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read. </param>
        /// <returns> A new <see cref="Models.TransactionReceipt"/> instance for mocking. </returns>
        public static TransactionReceipt TransactionReceipt(ReceiptContents receipt = null, ConfidentialLedgerQueryState state = default, string transactionId = null)
        {
            return new TransactionReceipt(receipt, state, transactionId);
        }

        /// <summary> Initializes a new instance of ReceiptContents. </summary>
        /// <param name="leaf"> Merkle tree leaf for this transaction. </param>
        /// <param name="nodeId"> Id of the node returning the receipt. </param>
        /// <param name="proof"> Merkle proof. </param>
        /// <param name="root"> Root of the Merkle tree at the time the transaction was recorded. </param>
        /// <param name="signature"> Signature by the node, with its certificate, over the Merkle root. </param>
        /// <returns> A new <see cref="Models.ReceiptContents"/> instance for mocking. </returns>
        public static ReceiptContents ReceiptContents(string leaf = null, string nodeId = null, IEnumerable<MerkleProofElement> proof = null, string root = null, string signature = null)
        {
            proof ??= new List<MerkleProofElement>();

            return new ReceiptContents(leaf, nodeId, proof?.ToList(), root, signature);
        }

        /// <summary> Initializes a new instance of MerkleProofElement. </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <returns> A new <see cref="Models.MerkleProofElement"/> instance for mocking. </returns>
        public static MerkleProofElement MerkleProofElement(string left = null, string right = null)
        {
            return new MerkleProofElement(left, right);
        }

        /// <summary> Initializes a new instance of TransactionStatus. </summary>
        /// <param name="state"> Represents the state of the transaction. </param>
        /// <param name="transactionId"> A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read. </param>
        /// <returns> A new <see cref="Models.TransactionStatus"/> instance for mocking. </returns>
        public static TransactionStatus TransactionStatus(TransactionState state = default, string transactionId = null)
        {
            return new TransactionStatus(state, transactionId);
        }

        /// <summary> Initializes a new instance of LedgerUser. </summary>
        /// <param name="assignedRole"> Represents an assignable role. </param>
        /// <param name="userId"> Identifier for the user. This must either be an AAD object id or a certificate fingerprint. </param>
        /// <returns> A new <see cref="Models.LedgerUser"/> instance for mocking. </returns>
        public static LedgerUser LedgerUser(ConfidentialLedgerUserRoleName assignedRole = default, string userId = null)
        {
            return new LedgerUser(assignedRole, userId);
        }

        /// <summary> Initializes a new instance of LedgerIdentityInformation. </summary>
        /// <param name="ledgerId"> Id for the ledger. </param>
        /// <param name="ledgerTlsCertificate"> PEM-encoded certificate used for TLS by the Confidential Ledger. </param>
        /// <returns> A new <see cref="Models.LedgerIdentityInformation"/> instance for mocking. </returns>
        public static LedgerIdentityInformation LedgerIdentityInformation(string ledgerId = null, string ledgerTlsCertificate = null)
        {
            return new LedgerIdentityInformation(ledgerId, ledgerTlsCertificate);
        }
    }
}
