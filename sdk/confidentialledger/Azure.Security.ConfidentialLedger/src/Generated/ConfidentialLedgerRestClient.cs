// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Security.ConfidentialLedger.Models;

namespace Azure.Security.ConfidentialLedger
{
    internal partial class ConfidentialLedgerRestClient
    {
        private Uri ledgerUri;
        private string apiVersion;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of ConfidentialLedgerRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="ledgerUri"> The Confidential Ledger URL, for example https://contoso.confidentialledger.azure.com. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="ledgerUri"/> or <paramref name="apiVersion"/> is null. </exception>
        public ConfidentialLedgerRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri ledgerUri, string apiVersion = "0.1-preview")
        {
            this.ledgerUri = ledgerUri ?? throw new ArgumentNullException(nameof(ledgerUri));
            this.apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateGetConstitutionRequest()
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/governance/constitution", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> The constitution is a script that assesses and applies proposals from consortium members. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<Constitution>> GetConstitutionAsync(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetConstitutionRequest();
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Constitution value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Constitution.DeserializeConstitution(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The constitution is a script that assesses and applies proposals from consortium members. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<Constitution> GetConstitution(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetConstitutionRequest();
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Constitution value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Constitution.DeserializeConstitution(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetConsortiumMembersRequest()
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/governance/members", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Consortium members can manage the Confidential Ledger. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<Consortium>> GetConsortiumMembersAsync(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetConsortiumMembersRequest();
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Consortium value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Consortium.DeserializeConsortium(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Consortium members can manage the Confidential Ledger. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<Consortium> GetConsortiumMembers(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetConsortiumMembersRequest();
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Consortium value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Consortium.DeserializeConsortium(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetEnclaveQuotesRequest()
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/enclaveQuotes", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> A quote is an SGX enclave measurement that can be used to verify the validity of a node and its enclave. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<ConfidentialLedgerEnclaves>> GetEnclaveQuotesAsync(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetEnclaveQuotesRequest();
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfidentialLedgerEnclaves value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ConfidentialLedgerEnclaves.DeserializeConfidentialLedgerEnclaves(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> A quote is an SGX enclave measurement that can be used to verify the validity of a node and its enclave. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<ConfidentialLedgerEnclaves> GetEnclaveQuotes(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetEnclaveQuotesRequest();
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfidentialLedgerEnclaves value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ConfidentialLedgerEnclaves.DeserializeConfidentialLedgerEnclaves(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetLedgerEntriesRequest(string subLedgerId, string fromTransactionId, string toTransactionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/transactions", false);
            uri.AppendQuery("api-version", apiVersion, true);
            if (subLedgerId != null)
            {
                uri.AppendQuery("subLedgerId", subLedgerId, true);
            }
            if (fromTransactionId != null)
            {
                uri.AppendQuery("fromTransactionId", fromTransactionId, true);
            }
            if (toTransactionId != null)
            {
                uri.AppendQuery("toTransactionId", toTransactionId, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> A sub-ledger id may optionally be specified. Only entries in the specified (or default) sub-ledger will be returned. </summary>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="fromTransactionId"> Specify the first transaction ID in a range. </param>
        /// <param name="toTransactionId"> Specify the last transaction ID in a range. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<PagedLedgerEntries>> GetLedgerEntriesAsync(string subLedgerId = null, string fromTransactionId = null, string toTransactionId = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetLedgerEntriesRequest(subLedgerId, fromTransactionId, toTransactionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PagedLedgerEntries value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PagedLedgerEntries.DeserializePagedLedgerEntries(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> A sub-ledger id may optionally be specified. Only entries in the specified (or default) sub-ledger will be returned. </summary>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="fromTransactionId"> Specify the first transaction ID in a range. </param>
        /// <param name="toTransactionId"> Specify the last transaction ID in a range. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<PagedLedgerEntries> GetLedgerEntries(string subLedgerId = null, string fromTransactionId = null, string toTransactionId = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetLedgerEntriesRequest(subLedgerId, fromTransactionId, toTransactionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PagedLedgerEntries value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PagedLedgerEntries.DeserializePagedLedgerEntries(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostLedgerEntryRequest(string subLedgerId, LedgerEntry entry)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/transactions", false);
            uri.AppendQuery("api-version", apiVersion, true);
            if (subLedgerId != null)
            {
                uri.AppendQuery("subLedgerId", subLedgerId, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (entry != null)
            {
                request.Headers.Add("Content-Type", "application/json");
                var content = new Utf8JsonRequestContent();
                content.JsonWriter.WriteObjectValue(entry);
                request.Content = content;
            }
            return message;
        }

        /// <summary> A sub-ledger id may optionally be specified. </summary>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="entry"> Ledger entry. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<LedgerWriteResult, ConfidentialLedgerPostLedgerEntryHeaders>> PostLedgerEntryAsync(string subLedgerId = null, LedgerEntry entry = null, CancellationToken cancellationToken = default)
        {
            using var message = CreatePostLedgerEntryRequest(subLedgerId, entry);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ConfidentialLedgerPostLedgerEntryHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerWriteResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = LedgerWriteResult.DeserializeLedgerWriteResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> A sub-ledger id may optionally be specified. </summary>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="entry"> Ledger entry. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<LedgerWriteResult, ConfidentialLedgerPostLedgerEntryHeaders> PostLedgerEntry(string subLedgerId = null, LedgerEntry entry = null, CancellationToken cancellationToken = default)
        {
            using var message = CreatePostLedgerEntryRequest(subLedgerId, entry);
            _pipeline.Send(message, cancellationToken);
            var headers = new ConfidentialLedgerPostLedgerEntryHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerWriteResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = LedgerWriteResult.DeserializeLedgerWriteResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetLedgerEntryRequest(string transactionId, string subLedgerId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/transactions/", false);
            uri.AppendPath(transactionId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            if (subLedgerId != null)
            {
                uri.AppendQuery("subLedgerId", subLedgerId, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> To return older ledger entries, the relevant sections of the ledger must be read from disk and validated. To prevent blocking within the enclave, the response will indicate whether the entry is ready and part of the response, or if the loading is still ongoing. </summary>
        /// <param name="transactionId"> Identifies a write transaction. </param>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="transactionId"/> is null. </exception>
        public async Task<Response<LedgerQueryResult>> GetLedgerEntryAsync(string transactionId, string subLedgerId = null, CancellationToken cancellationToken = default)
        {
            if (transactionId == null)
            {
                throw new ArgumentNullException(nameof(transactionId));
            }

            using var message = CreateGetLedgerEntryRequest(transactionId, subLedgerId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerQueryResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = LedgerQueryResult.DeserializeLedgerQueryResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> To return older ledger entries, the relevant sections of the ledger must be read from disk and validated. To prevent blocking within the enclave, the response will indicate whether the entry is ready and part of the response, or if the loading is still ongoing. </summary>
        /// <param name="transactionId"> Identifies a write transaction. </param>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="transactionId"/> is null. </exception>
        public Response<LedgerQueryResult> GetLedgerEntry(string transactionId, string subLedgerId = null, CancellationToken cancellationToken = default)
        {
            if (transactionId == null)
            {
                throw new ArgumentNullException(nameof(transactionId));
            }

            using var message = CreateGetLedgerEntryRequest(transactionId, subLedgerId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerQueryResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = LedgerQueryResult.DeserializeLedgerQueryResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetReceiptRequest(string transactionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/transactions/", false);
            uri.AppendPath(transactionId, true);
            uri.AppendPath("/receipt", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets a receipt certifying ledger contents at a particular transaction id. </summary>
        /// <param name="transactionId"> Identifies a write transaction. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="transactionId"/> is null. </exception>
        public async Task<Response<TransactionReceipt>> GetReceiptAsync(string transactionId, CancellationToken cancellationToken = default)
        {
            if (transactionId == null)
            {
                throw new ArgumentNullException(nameof(transactionId));
            }

            using var message = CreateGetReceiptRequest(transactionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TransactionReceipt value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TransactionReceipt.DeserializeTransactionReceipt(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Gets a receipt certifying ledger contents at a particular transaction id. </summary>
        /// <param name="transactionId"> Identifies a write transaction. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="transactionId"/> is null. </exception>
        public Response<TransactionReceipt> GetReceipt(string transactionId, CancellationToken cancellationToken = default)
        {
            if (transactionId == null)
            {
                throw new ArgumentNullException(nameof(transactionId));
            }

            using var message = CreateGetReceiptRequest(transactionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TransactionReceipt value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TransactionReceipt.DeserializeTransactionReceipt(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetTransactionStatusRequest(string transactionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/transactions/", false);
            uri.AppendPath(transactionId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets the status of an entry identified by a transaction id. </summary>
        /// <param name="transactionId"> Identifies a write transaction. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="transactionId"/> is null. </exception>
        public async Task<Response<TransactionStatus>> GetTransactionStatusAsync(string transactionId, CancellationToken cancellationToken = default)
        {
            if (transactionId == null)
            {
                throw new ArgumentNullException(nameof(transactionId));
            }

            using var message = CreateGetTransactionStatusRequest(transactionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TransactionStatus value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TransactionStatus.DeserializeTransactionStatus(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Gets the status of an entry identified by a transaction id. </summary>
        /// <param name="transactionId"> Identifies a write transaction. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="transactionId"/> is null. </exception>
        public Response<TransactionStatus> GetTransactionStatus(string transactionId, CancellationToken cancellationToken = default)
        {
            if (transactionId == null)
            {
                throw new ArgumentNullException(nameof(transactionId));
            }

            using var message = CreateGetTransactionStatusRequest(transactionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TransactionStatus value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TransactionStatus.DeserializeTransactionStatus(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetCurrentLedgerEntryRequest(string subLedgerId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/transactions/current", false);
            uri.AppendQuery("api-version", apiVersion, true);
            if (subLedgerId != null)
            {
                uri.AppendQuery("subLedgerId", subLedgerId, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> A sub-ledger id may optionally be specified. </summary>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<LedgerEntry>> GetCurrentLedgerEntryAsync(string subLedgerId = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetCurrentLedgerEntryRequest(subLedgerId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerEntry value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = LedgerEntry.DeserializeLedgerEntry(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> A sub-ledger id may optionally be specified. </summary>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<LedgerEntry> GetCurrentLedgerEntry(string subLedgerId = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetCurrentLedgerEntryRequest(subLedgerId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerEntry value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = LedgerEntry.DeserializeLedgerEntry(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteUserRequest(string userId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Deletes a user from the Confidential Ledger. </summary>
        /// <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userId"/> is null. </exception>
        public async Task<Response> DeleteUserAsync(string userId, CancellationToken cancellationToken = default)
        {
            if (userId == null)
            {
                throw new ArgumentNullException(nameof(userId));
            }

            using var message = CreateDeleteUserRequest(userId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Deletes a user from the Confidential Ledger. </summary>
        /// <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userId"/> is null. </exception>
        public Response DeleteUser(string userId, CancellationToken cancellationToken = default)
        {
            if (userId == null)
            {
                throw new ArgumentNullException(nameof(userId));
            }

            using var message = CreateDeleteUserRequest(userId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetUserRequest(string userId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets a user. </summary>
        /// <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userId"/> is null. </exception>
        public async Task<Response<LedgerUser>> GetUserAsync(string userId, CancellationToken cancellationToken = default)
        {
            if (userId == null)
            {
                throw new ArgumentNullException(nameof(userId));
            }

            using var message = CreateGetUserRequest(userId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerUser value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = LedgerUser.DeserializeLedgerUser(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Gets a user. </summary>
        /// <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userId"/> is null. </exception>
        public Response<LedgerUser> GetUser(string userId, CancellationToken cancellationToken = default)
        {
            if (userId == null)
            {
                throw new ArgumentNullException(nameof(userId));
            }

            using var message = CreateGetUserRequest(userId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerUser value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = LedgerUser.DeserializeLedgerUser(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCreateOrUpdateUserRequest(string userId, LedgerUser userDetails)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendPath("/app/users/", false);
            uri.AppendPath(userId, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(userDetails);
            request.Content = content;
            return message;
        }

        /// <summary> A JSON merge patch is applied for existing users. </summary>
        /// <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        /// <param name="userDetails"> Details about a Confidential Ledger user. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userId"/> or <paramref name="userDetails"/> is null. </exception>
        public async Task<Response<LedgerUser>> CreateOrUpdateUserAsync(string userId, LedgerUser userDetails, CancellationToken cancellationToken = default)
        {
            if (userId == null)
            {
                throw new ArgumentNullException(nameof(userId));
            }
            if (userDetails == null)
            {
                throw new ArgumentNullException(nameof(userDetails));
            }

            using var message = CreateCreateOrUpdateUserRequest(userId, userDetails);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerUser value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = LedgerUser.DeserializeLedgerUser(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> A JSON merge patch is applied for existing users. </summary>
        /// <param name="userId"> The user id, either an AAD object ID or certificate fingerprint. </param>
        /// <param name="userDetails"> Details about a Confidential Ledger user. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userId"/> or <paramref name="userDetails"/> is null. </exception>
        public Response<LedgerUser> CreateOrUpdateUser(string userId, LedgerUser userDetails, CancellationToken cancellationToken = default)
        {
            if (userId == null)
            {
                throw new ArgumentNullException(nameof(userId));
            }
            if (userDetails == null)
            {
                throw new ArgumentNullException(nameof(userDetails));
            }

            using var message = CreateCreateOrUpdateUserRequest(userId, userDetails);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        LedgerUser value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = LedgerUser.DeserializeLedgerUser(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetLedgerEntriesNextPageRequest(string nextLink, string subLedgerId, string fromTransactionId, string toTransactionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(ledgerUri);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> A sub-ledger id may optionally be specified. Only entries in the specified (or default) sub-ledger will be returned. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="fromTransactionId"> Specify the first transaction ID in a range. </param>
        /// <param name="toTransactionId"> Specify the last transaction ID in a range. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public async Task<Response<PagedLedgerEntries>> GetLedgerEntriesNextPageAsync(string nextLink, string subLedgerId = null, string fromTransactionId = null, string toTransactionId = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateGetLedgerEntriesNextPageRequest(nextLink, subLedgerId, fromTransactionId, toTransactionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PagedLedgerEntries value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PagedLedgerEntries.DeserializePagedLedgerEntries(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> A sub-ledger id may optionally be specified. Only entries in the specified (or default) sub-ledger will be returned. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subLedgerId"> The sub-ledger id. </param>
        /// <param name="fromTransactionId"> Specify the first transaction ID in a range. </param>
        /// <param name="toTransactionId"> Specify the last transaction ID in a range. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public Response<PagedLedgerEntries> GetLedgerEntriesNextPage(string nextLink, string subLedgerId = null, string fromTransactionId = null, string toTransactionId = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateGetLedgerEntriesNextPageRequest(nextLink, subLedgerId, fromTransactionId, toTransactionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PagedLedgerEntries value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PagedLedgerEntries.DeserializePagedLedgerEntries(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
