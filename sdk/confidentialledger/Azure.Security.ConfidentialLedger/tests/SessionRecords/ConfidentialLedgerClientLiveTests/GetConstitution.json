{
  "Entries": [
    {
      "RequestUri": "https://chriss-cl2.confidential-ledger.azure.com/app/governance/constitution?api-version=0.1-preview",
      "RequestMethod": "GET",
      "RequestHeaders": {
        "Accept": "application/json",
        "Authorization": "Sanitized",
        "User-Agent": [
          "azsdk-net-Storage.ConfidentialLedger/1.0.0-alpha.20210603.1",
          "(.NET 5.0.6; Microsoft Windows 10.0.19043)"
        ],
        "x-ms-client-request-id": "913db77379850554a627cccba979b3bd",
        "x-ms-return-client-request-id": "true"
      },
      "RequestBody": null,
      "StatusCode": 200,
      "ResponseHeaders": {
        "Content-Length": "31381",
        "Content-Type": "application/json",
        "x-ms-ccf-transaction-id": "2.118"
      },
      "ResponseBody": {
        "digest": "5e3a52df2faa3c42d482f5367c0f2bcddd251f1aaabf07d233ec6f2f5e69b977",
        "script": "class Action {\n  constructor(validate, apply) {\n    this.validate = validate;\n    this.apply = apply;\n  }\n}\n\nfunction parseUrl(url) {\n  // From https://tools.ietf.org/html/rfc3986#appendix-B\n  const re = new RegExp(\n    \u0022^(([^:/?#]\u002B):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\u0022\n  );\n  const groups = url.match(re);\n  if (!groups) {\n    throw new TypeError(\u0060${url} is not a valid URL.\u0060);\n  }\n  return {\n    scheme: groups[2],\n    authority: groups[4],\n    path: groups[5],\n    query: groups[7],\n    fragment: groups[9],\n  };\n}\n\nfunction checkType(value, type, field) {\n  const optional = type.endsWith(\u0022?\u0022);\n  if (optional) {\n    if (value === null || value === undefined) {\n      return;\n    }\n    type = type.slice(0, -1);\n  }\n  if (type === \u0022array\u0022) {\n    if (!Array.isArray(value)) {\n      throw new Error(\u0060${field} must be an array\u0060);\n    }\n  } else if (type === \u0022integer\u0022) {\n    if (!Number.isInteger(value)) {\n      throw new Error(\u0060${field} must be an integer\u0060);\n    }\n  } else if (typeof value !== type) {\n    throw new Error(\u0060${field} must be of type ${type} but is ${typeof value}\u0060);\n  }\n}\n\nfunction checkEnum(value, members, field) {\n  if (!members.includes(value)) {\n    throw new Error(\u0060${field} must be one of ${members}\u0060);\n  }\n}\n\nfunction checkBounds(value, low, high, field) {\n  if (low !== null \u0026\u0026 value \u003C low) {\n    throw new Error(\u0060${field} must be greater than ${low}\u0060);\n  }\n  if (high !== null \u0026\u0026 value \u003E high) {\n    throw new Error(\u0060${field} must be lower than ${high}\u0060);\n  }\n}\n\nfunction checkLength(value, min, max, field) {\n  if (min !== null \u0026\u0026 value.length \u003C min) {\n    throw new Error(\u0060${field} must be an array of minimum ${min} elements\u0060);\n  }\n  if (max !== null \u0026\u0026 value.length \u003E max) {\n    throw new Error(\u0060${field} must be an array of maximum ${max} elements\u0060);\n  }\n}\n\nfunction checkNone(args) {\n  if (args !== null \u0026\u0026 args !== undefined) {\n    throw new Error(\u0060Proposal does not accept any argument, found \u0022${args}\u0022\u0060);\n  }\n}\n\nfunction getSingletonKvKey() {\n  // When a KV map only contains one value, this is the key at which\n  // the value is recorded\n  return new ArrayBuffer(8);\n}\n\nfunction getActiveRecoveryMembersCount() {\n  let activeRecoveryMembersCount = 0;\n  ccf.kv[\u0022public:ccf.gov.members.encryption_public_keys\u0022].forEach((_, k) =\u003E {\n    let rawMemberInfo = ccf.kv[\u0022public:ccf.gov.members.info\u0022].get(k);\n    if (rawMemberInfo === undefined) {\n      throw new Error(\u0060Recovery member ${ccf.bufToStr(k)} has no information\u0060);\n    }\n\n    const memberInfo = ccf.bufToJsonCompatible(rawMemberInfo);\n    if (memberInfo.status === \u0022Active\u0022) {\n      activeRecoveryMembersCount\u002B\u002B;\n    }\n  });\n  return activeRecoveryMembersCount;\n}\n\nfunction checkJwks(value, field) {\n  checkType(value, \u0022object\u0022, field);\n  checkType(value.keys, \u0022array\u0022, \u0060${field}.keys\u0060);\n  for (const [i, jwk] of value.keys.entries()) {\n    checkType(jwk.kid, \u0022string\u0022, \u0060${field}.keys[${i}].kid\u0060);\n    checkType(jwk.kty, \u0022string\u0022, \u0060${field}.keys[${i}].kty\u0060);\n    checkType(jwk.x5c, \u0022array\u0022, \u0060${field}.keys[${i}].x5c\u0060);\n    checkLength(jwk.x5c, 1, null, \u0060${field}.keys[${i}].x5c\u0060);\n    for (const [j, b64der] of jwk.x5c.entries()) {\n      checkType(b64der, \u0022string\u0022, \u0060${field}.keys[${i}].x5c[${j}]\u0060);\n      const pem =\n        \u0022-----BEGIN CERTIFICATE-----\\n\u0022 \u002B\n        b64der \u002B\n        \u0022\\n-----END CERTIFICATE-----\u0022;\n      checkX509CertChain(pem, \u0060${field}.keys[${i}].x5c[${j}]\u0060);\n    }\n  }\n}\n\nfunction checkX509CertChain(value, field) {\n  if (!ccf.isValidX509CertBundle(value)) {\n    throw new Error(\n      \u0060${field} must be a valid X509 certificate (chain) in PEM format\u0060\n    );\n  }\n}\n\nfunction invalidateOtherOpenProposals(proposalIdToRetain) {\n  let proposals = ccf.kv[\u0022public:ccf.gov.proposals_info.js\u0022];\n  const proposalsMap = ccf.kv[\u0022public:ccf.gov.proposals_info.js\u0022];\n  proposalsMap.forEach((v, k) =\u003E {\n    let proposalId = ccf.bufToStr(k);\n    if (proposalId !== proposalIdToRetain) {\n      let info = ccf.bufToJsonCompatible(v);\n      if (info.state === \u0022Open\u0022) {\n        info.state = \u0022Dropped\u0022;\n        proposalsMap.set(k, ccf.jsonCompatibleToBuf(info));\n      }\n    }\n  });\n}\n\nconst actions = new Map([\n  [\n    \u0022set_constitution\u0022,\n    new Action(\n      function (args) {\n        checkType(args.constitution, \u0022string\u0022);\n      },\n      function (args, proposalId) {\n        ccf.kv[\u0022public:ccf.gov.constitution\u0022].set(\n          getSingletonKvKey(),\n          ccf.jsonCompatibleToBuf(args.constitution)\n        );\n\n        // Changing the constitution changes the semantics of any other open proposals, so invalidate them to avoid confusion or malicious vote modification\n        invalidateOtherOpenProposals(proposalId);\n      }\n    ),\n  ],\n  [\n    \u0022set_member\u0022,\n    new Action(\n      function (args) {\n        checkX509CertChain(args.cert, \u0022cert\u0022);\n        checkType(args.member_data, \u0022object?\u0022, \u0022member_data\u0022);\n        // Also check that public encryption key is well formed, if it exists\n      },\n\n      function (args) {\n        const memberId = ccf.pemToId(args.cert);\n        const rawMemberId = ccf.strToBuf(memberId);\n\n        ccf.kv[\u0022public:ccf.gov.members.certs\u0022].set(\n          rawMemberId,\n          ccf.strToBuf(args.cert)\n        );\n\n        if (args.encryption_pub_key == null) {\n          ccf.kv[\u0022public:ccf.gov.members.encryption_public_keys\u0022].delete(\n            rawMemberId\n          );\n        } else {\n          ccf.kv[\u0022public:ccf.gov.members.encryption_public_keys\u0022].set(\n            rawMemberId,\n            ccf.strToBuf(args.encryption_pub_key)\n          );\n        }\n\n        let member_info = {};\n        member_info.member_data = args.member_data;\n        member_info.status = \u0022Accepted\u0022;\n        ccf.kv[\u0022public:ccf.gov.members.info\u0022].set(\n          rawMemberId,\n          ccf.jsonCompatibleToBuf(member_info)\n        );\n\n        const rawSignature = ccf.kv[\u0022public:ccf.internal.signatures\u0022].get(\n          getSingletonKvKey()\n        );\n        if (rawSignature === undefined) {\n          ccf.kv[\u0022public:ccf.gov.members.acks\u0022].set(rawMemberId);\n        } else {\n          const signature = ccf.bufToJsonCompatible(rawSignature);\n          const ack = {};\n          ack.state_digest = signature.root;\n          ccf.kv[\u0022public:ccf.gov.members.acks\u0022].set(\n            rawMemberId,\n            ccf.jsonCompatibleToBuf(ack)\n          );\n        }\n      }\n    ),\n  ],\n  [\n    \u0022remove_member\u0022,\n    new Action(\n      function (args) {\n        checkType(args.member_id, \u0022string\u0022, \u0022member_id\u0022);\n      },\n      function (args) {\n        const rawMemberId = ccf.strToBuf(args.member_id);\n        const rawMemberInfo = ccf.kv[\u0022public:ccf.gov.members.info\u0022].get(\n          rawMemberId\n        );\n        if (rawMemberInfo === undefined) {\n          return; // Idempotent\n        }\n\n        const memberInfo = ccf.bufToJsonCompatible(rawMemberInfo);\n        const isActiveMember = memberInfo.status == \u0022Active\u0022;\n\n        const isRecoveryMember = ccf.kv[\n          \u0022public:ccf.gov.members.encryption_public_keys\u0022\n        ].has(rawMemberId)\n          ? true\n          : false;\n\n        // If the member is an active recovery member, check that there\n        // would still be a sufficient number of recovery members left\n        // to recover the service\n        if (isActiveMember \u0026\u0026 isRecoveryMember) {\n          const rawConfig = ccf.kv[\u0022public:ccf.gov.service.config\u0022].get(\n            getSingletonKvKey()\n          );\n          if (rawConfig === undefined) {\n            throw new Error(\u0022Service configuration could not be found\u0022);\n          }\n\n          const config = ccf.bufToJsonCompatible(rawConfig);\n          const activeRecoveryMembersCountAfter =\n            getActiveRecoveryMembersCount() - 1;\n          if (activeRecoveryMembersCountAfter \u003C config.recovery_threshold) {\n            throw new Error(\n              \u0060Number of active recovery members (${activeRecoveryMembersCountAfter}) would be less than recovery threshold (${config.recovery_threshold})\u0060\n            );\n          }\n        }\n\n        ccf.kv[\u0022public:ccf.gov.members.info\u0022].delete(rawMemberId);\n        ccf.kv[\u0022public:ccf.gov.members.encryption_public_keys\u0022].delete(\n          rawMemberId\n        );\n        ccf.kv[\u0022public:ccf.gov.members.certs\u0022].delete(rawMemberId);\n        ccf.kv[\u0022public:ccf.gov.members.acks\u0022].delete(rawMemberId);\n        ccf.kv[\u0022public:ccf.gov.history\u0022].delete(rawMemberId);\n\n        if (isActiveMember \u0026\u0026 isRecoveryMember) {\n          // A retired recovery member should not have access to the private\n          // ledger going forward so rekey the ledger, issuing new shares to\n          // remaining active recovery members\n          ccf.node.triggerLedgerRekey();\n        }\n      }\n    ),\n  ],\n  [\n    \u0022set_member_data\u0022,\n    new Action(\n      function (args) {\n        checkType(args.member_id, \u0022string\u0022, \u0022member_id\u0022);\n        checkType(args.member_data, \u0022object\u0022, \u0022member_data\u0022);\n      },\n\n      function (args) {\n        let member_id = ccf.strToBuf(args.member_id);\n        let members_info = ccf.kv[\u0022public:ccf.gov.members.info\u0022];\n        let member_info = members_info.get(member_id);\n        if (member_info === undefined) {\n          throw new Error(\u0060Member ${args.member_id} does not exist\u0060);\n        }\n        let mi = ccf.bufToJsonCompatible(member_info);\n        mi.member_data = args.member_data;\n        members_info.set(member_id, ccf.jsonCompatibleToBuf(mi));\n      }\n    ),\n  ],\n  [\n    \u0022set_user\u0022,\n    new Action(\n      function (args) {\n        checkX509CertChain(args.cert, \u0022cert\u0022);\n        checkType(args.user_data, \u0022object?\u0022, \u0022user_data\u0022);\n      },\n      function (args) {\n        let userId = ccf.pemToId(args.cert);\n        let rawUserId = ccf.strToBuf(userId);\n\n        ccf.kv[\u0022public:ccf.gov.users.certs\u0022].set(\n          rawUserId,\n          ccf.strToBuf(args.cert)\n        );\n\n        if (args.user_data !== null \u0026\u0026 args.user_data !== undefined) {\n          ccf.kv[\u0022public:ccf.gov.users.info\u0022].set(\n            rawUserId,\n            ccf.jsonCompatibleToBuf(args.user_data)\n          );\n        } else {\n          ccf.kv[\u0022public:ccf.gov.users.info\u0022].delete(rawUserId);\n        }\n      }\n    ),\n  ],\n  [\n    \u0022remove_user\u0022,\n    new Action(\n      function (args) {\n        checkType(args.user_id, \u0022string\u0022, \u0022user_id\u0022);\n      },\n      function (args) {\n        const user_id = ccf.strToBuf(args.user_id);\n        ccf.kv[\u0022public:ccf.gov.users.certs\u0022].delete(user_id);\n        ccf.kv[\u0022public:ccf.gov.users.info\u0022].delete(user_id);\n      }\n    ),\n  ],\n  [\n    \u0022remove_user_by_cert\u0022,\n    new Action(\n      function (args) {\n        checkX509CertChain(args.cert, \u0022cert\u0022);\n      },\n      function (args) {\n        let userId = ccf.pemToId(args.cert);\n        let rawUserId = ccf.strToBuf(userId);\n\n        ccf.kv[\u0022public:ccf.gov.users.certs\u0022].delete(\n          rawUserId\n        );\n        ccf.kv[\u0022public:ccf.gov.users.info\u0022].delete(rawUserId);\n      }\n    ),\n  ],\n  [\n    \u0022set_user_data\u0022,\n    new Action(\n      function (args) {\n        checkType(args.user_id, \u0022string\u0022, \u0022user_id\u0022);\n        checkType(args.user_data, \u0022object?\u0022, \u0022user_data\u0022);\n      },\n      function (args) {\n        const userId = ccf.strToBuf(args.user_id);\n\n        if (args.user_data !== null \u0026\u0026 args.user_data !== undefined) {\n          let userInfo = {};\n          userInfo.user_data = args.user_data;\n          ccf.kv[\u0022public:ccf.gov.users.info\u0022].set(\n            userId,\n            ccf.jsonCompatibleToBuf(userInfo)\n          );\n        } else {\n          ccf.kv[\u0022public:ccf.gov.users.info\u0022].delete(userId);\n        }\n      }\n    ),\n  ],\n  [\n    \u0022set_recovery_threshold\u0022,\n    new Action(\n      function (args) {\n        checkType(args.recovery_threshold, \u0022integer\u0022, \u0022threshold\u0022);\n        checkBounds(args.recovery_threshold, 1, 254, \u0022threshold\u0022);\n      },\n      function (args) {\n        const rawConfig = ccf.kv[\u0022public:ccf.gov.service.config\u0022].get(\n          getSingletonKvKey()\n        );\n        if (rawConfig === undefined) {\n          throw new Error(\u0022Service configuration could not be found\u0022);\n        }\n\n        let config = ccf.bufToJsonCompatible(rawConfig);\n\n        if (args.recovery_threshold === config.recovery_threshold) {\n          return; // No effect\n        }\n\n        const rawService = ccf.kv[\u0022public:ccf.gov.service.info\u0022].get(\n          getSingletonKvKey()\n        );\n        if (rawService === undefined) {\n          throw new Error(\u0022Service information could not be found\u0022);\n        }\n\n        const service = ccf.bufToJsonCompatible(rawService);\n\n        if (service.status === \u0022WaitingForRecoveryShares\u0022) {\n          throw new Error(\n            \u0060Cannot set recovery threshold if service is ${service.status}\u0060\n          );\n        } else if (service.status === \u0022Open\u0022) {\n          let activeRecoveryMembersCount = getActiveRecoveryMembersCount();\n          if (args.recovery_threshold \u003E activeRecoveryMembersCount) {\n            throw new Error(\n              \u0060Cannot set recovery threshold to ${args.recovery_threshold}: recovery threshold would be greater than the number of recovery members ${activeRecoveryMembersCount}\u0060\n            );\n          }\n        }\n\n        config.recovery_threshold = args.recovery_threshold;\n        ccf.kv[\u0022public:ccf.gov.service.config\u0022].set(\n          getSingletonKvKey(),\n          ccf.jsonCompatibleToBuf(config)\n        );\n\n        ccf.node.triggerRecoverySharesRefresh();\n      }\n    ),\n  ],\n  [\n    \u0022trigger_recovery_shares_refresh\u0022,\n    new Action(\n      function (args) {\n        checkNone(args);\n      },\n      function (args) {\n        ccf.node.triggerRecoverySharesRefresh();\n      }\n    ),\n  ],\n  [\n    \u0022trigger_ledger_rekey\u0022,\n    new Action(\n      function (args) {\n        checkNone(args);\n      },\n\n      function (args) {\n        ccf.node.triggerLedgerRekey();\n      }\n    ),\n  ],\n  [\n    \u0022transition_service_to_open\u0022,\n    new Action(\n      function (args) {\n        checkNone(args);\n      },\n\n      function (args) {\n        ccf.node.transitionServiceToOpen();\n      }\n    ),\n  ],\n  [\n    \u0022set_js_app\u0022,\n    new Action(\n      function (args) {\n        const bundle = args.bundle;\n        checkType(bundle, \u0022object\u0022, \u0022bundle\u0022);\n\n        let prefix = \u0022bundle.modules\u0022;\n        checkType(bundle.modules, \u0022array\u0022, prefix);\n        for (const [i, module] of bundle.modules.entries()) {\n          checkType(module, \u0022object\u0022, \u0060${prefix}[${i}]\u0060);\n          checkType(module.name, \u0022string\u0022, \u0060${prefix}[${i}].name\u0060);\n          checkType(module.module, \u0022string\u0022, \u0060${prefix}[${i}].module\u0060);\n        }\n\n        prefix = \u0022bundle.metadata\u0022;\n        checkType(bundle.metadata, \u0022object\u0022, prefix);\n        checkType(bundle.metadata.endpoints, \u0022object\u0022, \u0060${prefix}.endpoints\u0060);\n        for (const [url, endpoint] of Object.entries(\n          bundle.metadata.endpoints\n        )) {\n          checkType(endpoint, \u0022object\u0022, \u0060${prefix}.endpoints[\u0022${url}\u0022]\u0060);\n          for (const [method, info] of Object.entries(endpoint)) {\n            const prefix2 = \u0060${prefix}.endpoints[\u0022${url}\u0022][\u0022${method}\u0022]\u0060;\n            checkType(info, \u0022object\u0022, prefix2);\n            checkType(info.js_module, \u0022string\u0022, \u0060${prefix2}.js_module\u0060);\n            checkType(info.js_function, \u0022string\u0022, \u0060${prefix2}.js_function\u0060);\n            checkEnum(\n              info.mode,\n              [\u0022readwrite\u0022, \u0022readonly\u0022, \u0022historical\u0022],\n              \u0060${prefix2}.mode\u0060\n            );\n            checkEnum(\n              info.forwarding_required,\n              [\u0022sometimes\u0022, \u0022always\u0022, \u0022never\u0022],\n              \u0060${prefix2}.forwarding_required\u0060\n            );\n            checkType(info.openapi, \u0022object?\u0022, \u0060${prefix2}.openapi\u0060);\n            checkType(\n              info.openapi_hidden,\n              \u0022boolean?\u0022,\n              \u0060${prefix2}.openapi_hidden\u0060\n            );\n            checkType(\n              info.authn_policies,\n              \u0022array\u0022,\n              \u0060${prefix2}.authn_policies\u0060\n            );\n            for (const [i, policy] of info.authn_policies.entries()) {\n              checkType(policy, \u0022string\u0022, \u0060${prefix2}.authn_policies[${i}]\u0060);\n            }\n            if (!bundle.modules.some((m) =\u003E m.name === info.js_module)) {\n              throw new Error(\u0060module \u0027${info.js_module}\u0027 not found in bundle\u0060);\n            }\n          }\n        }\n      },\n      function (args) {\n        const modulesMap = ccf.kv[\u0022public:ccf.gov.modules\u0022];\n        const endpointsMap = ccf.kv[\u0022public:ccf.gov.endpoints\u0022];\n        // kv should expose .clear()\n        modulesMap.forEach((_, k) =\u003E {\n          modulesMap.delete(k);\n        });\n        endpointsMap.forEach((_, k) =\u003E {\n          endpointsMap.delete(k);\n        });\n\n        const bundle = args.bundle;\n        for (const module of bundle.modules) {\n          const path = \u0022/\u0022 \u002B module.name;\n          const pathBuf = ccf.strToBuf(path);\n          const moduleBuf = ccf.strToBuf(module.module);\n          modulesMap.set(pathBuf, moduleBuf);\n        }\n\n        for (const [url, endpoint] of Object.entries(\n          bundle.metadata.endpoints\n        )) {\n          for (const [method, info] of Object.entries(endpoint)) {\n            const key = \u0060${method.toUpperCase()} ${url}\u0060;\n            const keyBuf = ccf.strToBuf(key);\n\n            info.js_module = \u0022/\u0022 \u002B info.js_module;\n            const infoBuf = ccf.jsonCompatibleToBuf(info);\n            endpointsMap.set(keyBuf, infoBuf);\n          }\n        }\n      }\n    ),\n  ],\n  [\n    \u0022remove_js_app\u0022,\n    new Action(\n      function (args) { },\n      function (args) {\n        const modulesMap = ccf.kv[\u0022public:ccf.gov.modules\u0022];\n        const endpointsMap = ccf.kv[\u0022public:ccf.gov.endpoints\u0022];\n        // kv should expose .clear()\n        modulesMap.forEach((_, k) =\u003E {\n          modulesMap.delete(k);\n        });\n        endpointsMap.forEach((_, k) =\u003E {\n          endpointsMap.delete(k);\n        });\n      }\n    ),\n  ],\n  [\n    \u0022set_ca_cert_bundle\u0022,\n    new Action(\n      function (args) {\n        checkType(args.name, \u0022string\u0022, \u0022name\u0022);\n        checkX509CertChain(args.cert_bundle, \u0022cert_bundle\u0022);\n      },\n      function (args) {\n        const name = args.name;\n        const bundle = args.cert_bundle;\n        const nameBuf = ccf.strToBuf(name);\n        const bundleBuf = ccf.jsonCompatibleToBuf(bundle);\n        ccf.kv[\u0022public:ccf.gov.tls.ca_cert_bundles\u0022].set(nameBuf, bundleBuf);\n      }\n    ),\n  ],\n  [\n    \u0022remove_ca_cert_bundle\u0022,\n    new Action(\n      function (args) {\n        checkType(args.name, \u0022string\u0022, \u0022name\u0022);\n      },\n      function (args) {\n        const name = args.name;\n        const nameBuf = ccf.strToBuf(name);\n        ccf.kv[\u0022public:ccf.gov.tls.ca_cert_bundles\u0022].delete(nameBuf);\n      }\n    ),\n  ],\n  [\n    \u0022set_jwt_issuer\u0022,\n    new Action(\n      function (args) {\n        checkType(args.issuer, \u0022string\u0022, \u0022issuer\u0022);\n        checkType(args.auto_refresh, \u0022boolean?\u0022, \u0022auto_refresh\u0022);\n        checkType(args.ca_cert_bundle_name, \u0022string?\u0022, \u0022ca_cert_bundle_name\u0022);\n        checkEnum(args.key_filter, [\u0022all\u0022, \u0022sgx\u0022], \u0022key_filter\u0022);\n        checkType(args.key_policy, \u0022object?\u0022, \u0022key_policy\u0022);\n        if (args.key_policy) {\n          checkType(\n            args.key_policy.sgx_claims,\n            \u0022object?\u0022,\n            \u0022key_policy.sgx_claims\u0022\n          );\n          if (args.key_policy.sgx_claims) {\n            for (const [name, value] of Object.entries(\n              args.key_policy.sgx_claims\n            )) {\n              checkType(value, \u0022string\u0022, \u0060key_policy.sgx_claims[\u0022${name}\u0022]\u0060);\n            }\n          }\n        }\n        checkType(args.jwks, \u0022object?\u0022, \u0022jwks\u0022);\n        if (args.jwks) {\n          checkJwks(args.jwks, \u0022jwks\u0022);\n        }\n        if (args.auto_refresh) {\n          if (!args.ca_cert_bundle_name) {\n            throw new Error(\n              \u0022ca_cert_bundle_name is missing but required if auto_refresh is true\u0022\n            );\n          }\n          let url;\n          try {\n            url = parseUrl(args.issuer);\n          } catch (e) {\n            throw new Error(\u0022issuer must be a URL if auto_refresh is true\u0022);\n          }\n          if (url.scheme != \u0022https\u0022) {\n            throw new Error(\n              \u0022issuer must be a URL starting with https:// if auto_refresh is true\u0022\n            );\n          }\n          if (url.query || url.fragment) {\n            throw new Error(\n              \u0022issuer must be a URL without query/fragment if auto_refresh is true\u0022\n            );\n          }\n        }\n      },\n      function (args) {\n        if (args.auto_refresh) {\n          const caCertBundleName = args.ca_cert_bundle_name;\n          const caCertBundleNameBuf = ccf.strToBuf(args.ca_cert_bundle_name);\n          if (\n            !ccf.kv[\u0022public:ccf.gov.tls.ca_cert_bundles\u0022].has(\n              caCertBundleNameBuf\n            )\n          ) {\n            throw new Error(\n              \u0060No CA cert bundle found with name \u0027${caCertBundleName}\u0027\u0060\n            );\n          }\n        }\n        const issuer = args.issuer;\n        const jwks = args.jwks;\n        delete args.jwks;\n        const metadata = args;\n        if (jwks) {\n          ccf.setJwtPublicSigningKeys(issuer, metadata, jwks);\n        }\n        const issuerBuf = ccf.strToBuf(issuer);\n        const metadataBuf = ccf.jsonCompatibleToBuf(metadata);\n        ccf.kv[\u0022public:ccf.gov.jwt.issuers\u0022].set(issuerBuf, metadataBuf);\n      }\n    ),\n  ],\n  [\n    \u0022set_jwt_public_signing_keys\u0022,\n    new Action(\n      function (args) {\n        checkType(args.issuer, \u0022string\u0022, \u0022issuer\u0022);\n        checkJwks(args.jwks, \u0022jwks\u0022);\n      },\n      function (args) {\n        const issuer = args.issuer;\n        const issuerBuf = ccf.strToBuf(issuer);\n        const metadataBuf = ccf.kv[\u0022public:ccf.gov.jwt.issuers\u0022].get(issuerBuf);\n        if (metadataBuf === undefined) {\n          throw new Error(\u0060issuer ${issuer} not found\u0060);\n        }\n        const metadata = ccf.bufToJsonCompatible(metadataBuf);\n        const jwks = args.jwks;\n        ccf.setJwtPublicSigningKeys(issuer, metadata, jwks);\n      }\n    ),\n  ],\n  [\n    \u0022remove_jwt_issuer\u0022,\n    new Action(\n      function (args) {\n        checkType(args.issuer, \u0022string\u0022, \u0022issuer\u0022);\n      },\n      function (args) {\n        const issuerBuf = ccf.strToBuf(args.issuer);\n        if (!ccf.kv[\u0022public:ccf.gov.jwt.issuers\u0022].delete(issuerBuf)) {\n          return;\n        }\n        ccf.removeJwtPublicSigningKeys(args.issuer);\n      }\n    ),\n  ],\n  [\n    \u0022add_node_code\u0022,\n    new Action(\n      function (args) {\n        checkType(args.new_code_id, \u0022string\u0022, \u0022new_code_id\u0022);\n        checkType(args.existing_code_id, \u0022string\u0022, \u0022existing_code_id\u0022);\n      },\n      function (args, proposalId) {\n        const existingCode = ccf.kv[\u0022public:ccf.gov.nodes.code_ids\u0022].get(\n          ccf.strToBuf(args.existing_code_id)\n        );\n        if (existingCode === undefined) {\n          throw new Error(\u0060Code required to exist is not present: ${args.existing_code_id}\u0060);\n        }\n\n        const newCodeId = ccf.strToBuf(args.new_code_id);\n        const ALLOWED = ccf.jsonCompatibleToBuf(\u0022AllowedToJoin\u0022);\n        ccf.kv[\u0022public:ccf.gov.nodes.code_ids\u0022].set(newCodeId, ALLOWED);\n\n        // Adding a new allowed code ID changes the semantics of any other open proposals, so invalidate them to avoid confusion or malicious vote modification\n        invalidateOtherOpenProposals(proposalId);\n      }\n    ),\n  ],\n\n  [\n    \u0022transition_node_to_trusted\u0022,\n    new Action(\n      function (args) {\n        checkType(args.node_id, \u0022string\u0022, \u0022node_id\u0022);\n      },\n      function (args) {\n        const node = ccf.kv[\u0022public:ccf.gov.nodes.info\u0022].get(\n          ccf.strToBuf(args.node_id)\n        );\n        if (node === undefined) {\n          throw new Error(\u0060No such node: ${args.node_id}\u0060);\n        }\n        const nodeInfo = ccf.bufToJsonCompatible(node);\n        if (nodeInfo.status === \u0022Pending\u0022) {\n          nodeInfo.status = \u0022Trusted\u0022;\n          nodeInfo.ledger_secret_seqno = ccf.network.getLatestLedgerSecretSeqno();\n          ccf.kv[\u0022public:ccf.gov.nodes.info\u0022].set(\n            ccf.strToBuf(args.node_id),\n            ccf.jsonCompatibleToBuf(nodeInfo)\n          );\n        }\n      }\n    ),\n  ],\n  [\n    \u0022remove_node_code\u0022,\n    new Action(\n      function (args) {\n        checkType(args.code_id_to_remove, \u0022string\u0022, \u0022code_id_to_remove\u0022);\n        checkType(args.remaining_code_id, \u0022string\u0022, \u0022remaining_code_id\u0022);\n      },\n      function (args) {\n        const remainingCode = ccf.kv[\u0022public:ccf.gov.nodes.code_ids\u0022].get(\n          ccf.strToBuf(args.remaining_code_id)\n        );\n        if (remainingCode === undefined) {\n          throw new Error(\u0060Code required to remain is not present: ${args.remaining_code_id}\u0060);\n        }\n\n        const codeIdToRemove = ccf.strToBuf(args.code_id_to_remove);\n        ccf.kv[\u0022public:ccf.gov.nodes.code_ids\u0022].delete(codeIdToRemove);\n      }\n    ),\n  ],\n  [\n    \u0022remove_node\u0022,\n    new Action(\n      function (args) {\n        checkType(args.node_id, \u0022string\u0022, \u0022node_id\u0022);\n      },\n      function (args) {\n        const node = ccf.kv[\u0022public:ccf.gov.nodes.info\u0022].get(\n          ccf.strToBuf(args.node_id)\n        );\n        if (node !== undefined) {\n          const node_obj = ccf.bufToJsonCompatible(node);\n          node_obj.status = \u0022Retired\u0022;\n          ccf.kv[\u0022public:ccf.gov.nodes.info\u0022].set(\n            ccf.strToBuf(args.node_id),\n            ccf.jsonCompatibleToBuf(node_obj)\n          );\n        }\n      }\n    ),\n  ],\n  [\n    \u0022set_service_principal\u0022,\n    new Action(\n      function (args) {\n        checkType(args.id, \u0022string\u0022, \u0022id\u0022);\n        checkType(args.data, \u0022object\u0022, \u0022data\u0022);\n      },\n      function (args) {\n        ccf.kv[\u0022public:ccf.gov.service_principals\u0022].set(\n          ccf.strToBuf(args.id),\n          ccf.jsonCompatibleToBuf(args.data)\n        );\n      }\n    ),\n  ],\n  [\n    \u0022remove_service_principal\u0022,\n    new Action(\n      function (args) {\n        checkType(args.id, \u0022string\u0022, \u0022id\u0022);\n      },\n      function (args) {\n        ccf.kv[\u0022public:ccf.gov.service_principals\u0022].delete(\n          ccf.strToBuf(args.id)\n        );\n      }\n    ),\n  ],\n]);\nexport function apply(proposal, proposalId) {\n  const proposed_actions = JSON.parse(proposal)[\u0022actions\u0022];\n  for (const proposed_action of proposed_actions) {\n    const definition = actions.get(proposed_action.name);\n    definition.apply(proposed_action.args, proposalId);\n  }\n}\nfunction getMemberInfo(memberId) {\n  const key = ccf.strToBuf(memberId);\n  const value = ccf.kv[\u0022public:ccf.gov.members.info\u0022].get(key);\n  const info = ccf.bufToJsonCompatible(value);\n  return info;\n}\n\n// Returns true if the member is a recovery member.\nfunction isRecoveryMember(memberId) {\n  const info = getMemberInfo(memberId);\n  if (info.member_data.encryption_pub_key) {\n    return true;\n  }\n  return false;\n}\n\n// Defines which of the members are operators.\nfunction isOperator(memberId) {\n  // // Operators cannot be recovery members.\n  // if (isRecoveryMember(memberId)) {\n  //   return false;\n  // }\n  const info = getMemberInfo(memberId);\n  return info.member_data.is_operator;\n}\n\n// Defines actions that can be passed with sole operator input.\nfunction canOperatorPass(action) {\n  // To enable code upgrades and disaster recovery for Public Preview, we\u0027ve given the\n  // operator member some additional privileges.\n  // 1. add/remove node code are required for code upgrades.\n  // 2. set_constitution to replace this constitution with a \u0022correct\u0022 one easily later on.\n  // 3. set_member to add a new member for privileged operations when we use MHSM keys.\n  const allowedOperatorActions = [\n    \u0022add_node_code\u0022, // Remove\n    \u0022remove_ca_cert_bundle\u0022,\n    \u0022remove_jwt_issuer\u0022,\n    \u0022remove_node\u0022,\n    \u0022remove_node_code\u0022, // Remove\n    \u0022remove_service_principal\u0022,\n    \u0022remove_user\u0022,\n    \u0022remove_user_by_cert\u0022,\n    \u0022set_ca_cert_bundle\u0022,\n    \u0022set_constitution\u0022, // Remove\n    \u0022set_js_app\u0022,\n    \u0022set_jwt_issuer\u0022,\n    \u0022set_jwt_public_signing_keys\u0022,\n    \u0022set_member\u0022, // Remove\n    \u0022set_service_principal\u0022,\n    \u0022set_user\u0022,\n    \u0022set_user_data\u0022,\n    \u0022transition_node_to_trusted\u0022,\n    \u0022transition_service_to_open\u0022\n  ];\n\n  if (allowedOperatorActions.includes(action.name)) {\n    return true;\n  }\n  // Additionally, operators can add or retire other operators.\n  if (action.name === \u0022set_member\u0022) {\n    const memberData = action.args[\u0022member_data\u0022];\n    if (memberData \u0026\u0026 memberData.is_operator) {\n      return true;\n    }\n  } else if (action.name === \u0022remove_member\u0022) {\n    if (isOperator(action.args.member_id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function resolve(proposal, proposerId, votes) {\n  const actions = JSON.parse(proposal)[\u0022actions\u0022];\n\n  // Count member votes.\n  const memberVoteCount = votes.filter(\n    (v) =\u003E v.vote \u0026\u0026 !isOperator(v.member_id)\n  ).length;\n\n  // Count active members, excluding operators.\n  let activeMemberCount = 0;\n  ccf.kv[\u0022public:ccf.gov.members.info\u0022].forEach((value, key) =\u003E {\n    const memberId = ccf.bufToStr(key);\n    const info = ccf.bufToJsonCompatible(value);\n    if (info.status === \u0022Active\u0022 \u0026\u0026 !isOperator(memberId)) {\n      activeMemberCount\u002B\u002B;\n    }\n  });\n\n  // A proposal is an operator change if it\u0027s only applying operator actions.\n  const isOperatorChange = actions.every(canOperatorPass);\n\n  // A majority of members can always accept a proposal.\n  if (memberVoteCount \u003E Math.floor(activeMemberCount / 2)) {\n    return \u0022Accepted\u0022;\n  }\n\n  // Operators proposing operator changes can accept them without a vote.\n  if (isOperatorChange \u0026\u0026 isOperator(proposerId)) {\n    return \u0022Accepted\u0022;\n  }\n\n  return \u0022Open\u0022;\n}\nexport function validate(input) {\n  let proposal = JSON.parse(input);\n  let errors = [];\n  let position = 0;\n  for (const action of proposal[\u0022actions\u0022]) {\n    const definition = actions.get(action.name);\n    if (definition) {\n      try {\n        definition.validate(action.args);\n      } catch (e) {\n        errors.push(\n          \u0060${action.name} at position ${position} failed validation: ${e}\\n${e.stack}\u0060\n        );\n      }\n    } else {\n      errors.push(\u0060${action.name}: no such action\u0060);\n    }\n    position\u002B\u002B;\n  }\n  return { valid: errors.length === 0, description: errors.join(\u0022, \u0022) };\n}\n"
      }
    }
  ],
  "Variables": {
    "CONFIDENTIALLEDGER_IDENTITY_URL": "https://identity.accledger.azure.com/",
    "CONFIDENTIALLEDGER_URL": "https://chriss-CL2.confidential-ledger.azure.com",
    "RandomSeed": "1047716920"
  }
}