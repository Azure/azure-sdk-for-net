// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.PlanetaryComputer
{
    // Data plane generated client.
    /// <summary> The StacItemTiler service client. </summary>
    public partial class StacItemTilerClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://geocatalog.spatio.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of StacItemTilerClient for mocking. </summary>
        protected StacItemTilerClient()
        {
        }

        /// <summary> Initializes a new instance of StacItemTilerClient. </summary>
        /// <param name="endpoint"> Service host. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public StacItemTilerClient(Uri endpoint, TokenCredential credential) : this(endpoint, credential, new AzurePlanetaryComputerClientOptions())
        {
        }

        /// <summary> Initializes a new instance of StacItemTilerClient. </summary>
        /// <param name="endpoint"> Service host. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public StacItemTilerClient(Uri endpoint, TokenCredential credential, AzurePlanetaryComputerClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new AzurePlanetaryComputerClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Bounds. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return all Bounds. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetBoundsAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<BoundsResult>> GetBoundsAsync(string collectionId, string itemId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetBoundsAsync(collectionId, itemId, context).ConfigureAwait(false);
            return Response.FromValue(BoundsResult.FromResponse(response), response);
        }

        /// <summary> Bounds. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return all Bounds. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetBounds(string,string,CancellationToken)']/*" />
        public virtual Response<BoundsResult> GetBounds(string collectionId, string itemId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetBounds(collectionId, itemId, context);
            return Response.FromValue(BoundsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Bounds
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetBoundsAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetBoundsAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetBoundsAsync(string collectionId, string itemId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetBounds");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBoundsRequest(collectionId, itemId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Bounds
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetBounds(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetBounds(string,string,RequestContext)']/*" />
        public virtual Response GetBounds(string collectionId, string itemId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetBounds");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBoundsRequest(collectionId, itemId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Info. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return dataset's basic info. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetInfoAsync(string,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<InfoOperationResult>> GetInfoAsync(string collectionId, string itemId, IEnumerable<string> assets = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetInfoAsync(collectionId, itemId, assets, context).ConfigureAwait(false);
            return Response.FromValue(InfoOperationResult.FromResponse(response), response);
        }

        /// <summary> Info. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return dataset's basic info. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetInfo(string,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<InfoOperationResult> GetInfo(string collectionId, string itemId, IEnumerable<string> assets = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetInfo(collectionId, itemId, assets, context);
            return Response.FromValue(InfoOperationResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Info
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetInfoAsync(string,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetInfoAsync(string,string,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetInfoAsync(string collectionId, string itemId, IEnumerable<string> assets, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetInfo");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetInfoRequest(collectionId, itemId, assets, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Info
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetInfo(string,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetInfo(string,string,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetInfo(string collectionId, string itemId, IEnumerable<string> assets, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetInfo");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetInfoRequest(collectionId, itemId, assets, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Info Geojson. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return Info Geojson. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetInfoGeoJsonAsync(string,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<TilerInfoGeoJsonFeature>> GetInfoGeoJsonAsync(string collectionId, string itemId, IEnumerable<string> assets = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetInfoGeoJsonAsync(collectionId, itemId, assets, context).ConfigureAwait(false);
            return Response.FromValue(TilerInfoGeoJsonFeature.FromResponse(response), response);
        }

        /// <summary> Info Geojson. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return Info Geojson. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetInfoGeoJson(string,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<TilerInfoGeoJsonFeature> GetInfoGeoJson(string collectionId, string itemId, IEnumerable<string> assets = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetInfoGeoJson(collectionId, itemId, assets, context);
            return Response.FromValue(TilerInfoGeoJsonFeature.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Info Geojson
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetInfoGeoJsonAsync(string,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetInfoGeoJsonAsync(string,string,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetInfoGeoJsonAsync(string collectionId, string itemId, IEnumerable<string> assets, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetInfoGeoJson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetInfoGeoJsonRequest(collectionId, itemId, assets, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Info Geojson
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetInfoGeoJson(string,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetInfoGeoJson(string,string,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetInfoGeoJson(string collectionId, string itemId, IEnumerable<string> assets, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetInfoGeoJson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetInfoGeoJsonRequest(collectionId, itemId, assets, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Available Assets. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return a list of supported assets. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetAvailableAssetsAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<string>>> GetAvailableAssetsAsync(string collectionId, string itemId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetAvailableAssetsAsync(collectionId, itemId, context).ConfigureAwait(false);
            IReadOnlyList<string> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
            List<string> array = new List<string>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(item.GetString());
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Available Assets. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return a list of supported assets. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetAvailableAssets(string,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<string>> GetAvailableAssets(string collectionId, string itemId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetAvailableAssets(collectionId, itemId, context);
            IReadOnlyList<string> value = default;
            using var document = JsonDocument.Parse(response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
            List<string> array = new List<string>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(item.GetString());
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Available Assets
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetAvailableAssetsAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetAvailableAssetsAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetAvailableAssetsAsync(string collectionId, string itemId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetAvailableAssets");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAvailableAssetsRequest(collectionId, itemId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Available Assets
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetAvailableAssets(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetAvailableAssets(string,string,RequestContext)']/*" />
        public virtual Response GetAvailableAssets(string collectionId, string itemId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetAvailableAssets");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAvailableAssetsRequest(collectionId, itemId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Asset Statistics. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Per Asset statistics. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetAssetStatisticsAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)']/*" />
        public virtual async Task<Response<AssetStatisticsResult>> GetAssetStatisticsAsync(string collectionId, string itemId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, ResamplingMethod? resampling = null, int? maxSize = null, bool? categorical = null, IEnumerable<string> c = null, IEnumerable<int> p = null, string histogramBins = null, string histogramRange = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetAssetStatisticsAsync(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, resampling?.ToString(), maxSize, categorical, c, p, histogramBins, histogramRange, context).ConfigureAwait(false);
            return Response.FromValue(AssetStatisticsResult.FromResponse(response), response);
        }

        /// <summary> Asset Statistics. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Per Asset statistics. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetAssetStatistics(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)']/*" />
        public virtual Response<AssetStatisticsResult> GetAssetStatistics(string collectionId, string itemId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, ResamplingMethod? resampling = null, int? maxSize = null, bool? categorical = null, IEnumerable<string> c = null, IEnumerable<int> p = null, string histogramBins = null, string histogramRange = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetAssetStatistics(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, resampling?.ToString(), maxSize, categorical, c, p, histogramBins, histogramRange, context);
            return Response.FromValue(AssetStatisticsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Asset Statistics
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetAssetStatisticsAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetAssetStatisticsAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetAssetStatisticsAsync(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string resampling, int? maxSize, bool? categorical, IEnumerable<string> c, IEnumerable<int> p, string histogramBins, string histogramRange, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetAssetStatistics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAssetStatisticsRequest(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, resampling, maxSize, categorical, c, p, histogramBins, histogramRange, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Asset Statistics
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetAssetStatistics(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetAssetStatistics(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response GetAssetStatistics(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string resampling, int? maxSize, bool? categorical, IEnumerable<string> c, IEnumerable<int> p, string histogramBins, string histogramRange, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetAssetStatistics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAssetStatisticsRequest(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, resampling, maxSize, categorical, c, p, histogramBins, histogramRange, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Statistics. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Merged assets statistics. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetStatisticsAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)']/*" />
        public virtual async Task<Response<StatisticsResult>> GetStatisticsAsync(string collectionId, string itemId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, ResamplingMethod? resampling = null, int? maxSize = null, bool? categorical = null, IEnumerable<string> c = null, IEnumerable<int> p = null, string histogramBins = null, string histogramRange = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetStatisticsAsync(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, resampling?.ToString(), maxSize, categorical, c, p, histogramBins, histogramRange, context).ConfigureAwait(false);
            return Response.FromValue(StatisticsResult.FromResponse(response), response);
        }

        /// <summary> Statistics. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Merged assets statistics. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetStatistics(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)']/*" />
        public virtual Response<StatisticsResult> GetStatistics(string collectionId, string itemId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, ResamplingMethod? resampling = null, int? maxSize = null, bool? categorical = null, IEnumerable<string> c = null, IEnumerable<int> p = null, string histogramBins = null, string histogramRange = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetStatistics(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, resampling?.ToString(), maxSize, categorical, c, p, histogramBins, histogramRange, context);
            return Response.FromValue(StatisticsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Statistics
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetStatisticsAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetStatisticsAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetStatisticsAsync(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string resampling, int? maxSize, bool? categorical, IEnumerable<string> c, IEnumerable<int> p, string histogramBins, string histogramRange, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetStatistics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStatisticsRequest(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, resampling, maxSize, categorical, c, p, histogramBins, histogramRange, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Statistics
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetStatistics(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetStatistics(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response GetStatistics(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string resampling, int? maxSize, bool? categorical, IEnumerable<string> c, IEnumerable<int> p, string histogramBins, string histogramRange, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetStatistics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStatisticsRequest(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, resampling, maxSize, categorical, c, p, histogramBins, histogramRange, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Geojson Statistics. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="body"> Request GeoJson body. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get Statistics from a geojson feature or featureCollection. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetGeoJsonStatisticsAsync(string,string,ItemCollectionModel,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)']/*" />
        public virtual async Task<Response<GeoJsonStatisticsItemCollectionResult>> GetGeoJsonStatisticsAsync(string collectionId, string itemId, ItemCollectionModel body, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, bool? categorical = null, IEnumerable<string> c = null, IEnumerable<int> p = null, string histogramBins = null, string histogramRange = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = body.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetGeoJsonStatisticsAsync(collectionId, itemId, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, coordCrs, resampling?.ToString(), maxSize, categorical, c, p, histogramBins, histogramRange, context).ConfigureAwait(false);
            return Response.FromValue(GeoJsonStatisticsItemCollectionResult.FromResponse(response), response);
        }

        /// <summary> Geojson Statistics. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="body"> Request GeoJson body. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get Statistics from a geojson feature or featureCollection. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetGeoJsonStatistics(string,string,ItemCollectionModel,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)']/*" />
        public virtual Response<GeoJsonStatisticsItemCollectionResult> GetGeoJsonStatistics(string collectionId, string itemId, ItemCollectionModel body, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, bool? categorical = null, IEnumerable<string> c = null, IEnumerable<int> p = null, string histogramBins = null, string histogramRange = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = body.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetGeoJsonStatistics(collectionId, itemId, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, coordCrs, resampling?.ToString(), maxSize, categorical, c, p, histogramBins, histogramRange, context);
            return Response.FromValue(GeoJsonStatisticsItemCollectionResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Geojson Statistics
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGeoJsonStatisticsAsync(string,string,ItemCollectionModel,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetGeoJsonStatisticsAsync(string,string,RequestContent,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetGeoJsonStatisticsAsync(string collectionId, string itemId, RequestContent content, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string coordCrs = null, string resampling = null, int? maxSize = null, bool? categorical = null, IEnumerable<string> c = null, IEnumerable<int> p = null, string histogramBins = null, string histogramRange = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetGeoJsonStatistics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGeoJsonStatisticsRequest(collectionId, itemId, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, coordCrs, resampling, maxSize, categorical, c, p, histogramBins, histogramRange, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Geojson Statistics
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGeoJsonStatistics(string,string,ItemCollectionModel,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,ResamplingMethod?,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Maximum dimension in pixels for the source data used to calculate statistics. </param>
        /// <param name="categorical"> Return statistics for categorical dataset. </param>
        /// <param name="c"> List of values for which to report counts. </param>
        /// <param name="p"> List of percentile values (default to [2, 98]). </param>
        /// <param name="histogramBins">
        /// Defines the number of equal-width bins in the given range (10, by default).
        ///
        /// If bins is a sequence (comma `,` delimited values), it defines a monotonically
        /// increasing array of bin edges, including the rightmost edge, allowing for
        /// non-uniform bin widths.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="histogramRange">
        /// Comma `,` delimited range of the bins.
        ///
        /// The lower and upper range of the bins. If not provided, range is simply
        /// (a.min(), a.max()).
        ///
        /// Values outside the range are ignored. The first element of the range must be
        /// less than or equal to the second.
        /// range affects the automatic bin computation as well.
        ///
        /// link: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetGeoJsonStatistics(string,string,RequestContent,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,int?,bool?,IEnumerable{string},IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response GetGeoJsonStatistics(string collectionId, string itemId, RequestContent content, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string coordCrs = null, string resampling = null, int? maxSize = null, bool? categorical = null, IEnumerable<string> c = null, IEnumerable<int> p = null, string histogramBins = null, string histogramRange = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetGeoJsonStatistics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGeoJsonStatisticsRequest(collectionId, itemId, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, coordCrs, resampling, maxSize, categorical, c, p, histogramBins, histogramRange, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Tile. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="z">
        /// Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
        /// representing the scaleDenominator the tile.
        /// </param>
        /// <param name="x">
        /// Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixHeight-1 for the selected TileMatrix.
        /// </param>
        /// <param name="y">
        /// Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixWidth-1 for the selected TileMatrix.
        /// </param>
        /// <param name="scale"> Numeric scale factor for the tile. Higher values produce larger tiles (default: "1"). </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad')
        /// </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="subdatasetName"> The name of a subdataset within the asset. </param>
        /// <param name="subdatasetBands"> The index of a subdataset band within the asset. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create map tile from a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileAsync(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetTileAsync(string collectionId, string itemId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, TileMatrixSetId? tileMatrixSetId = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, string subdatasetName = null, IEnumerable<string> subdatasetBands = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTileAsync(collectionId, itemId, z, x, y, scale, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileMatrixSetId?.ToString(), buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, subdatasetName, subdatasetBands, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Tile. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="z">
        /// Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
        /// representing the scaleDenominator the tile.
        /// </param>
        /// <param name="x">
        /// Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixHeight-1 for the selected TileMatrix.
        /// </param>
        /// <param name="y">
        /// Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixWidth-1 for the selected TileMatrix.
        /// </param>
        /// <param name="scale"> Numeric scale factor for the tile. Higher values produce larger tiles (default: "1"). </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad')
        /// </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="subdatasetName"> The name of a subdataset within the asset. </param>
        /// <param name="subdatasetBands"> The index of a subdataset band within the asset. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create map tile from a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTile(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BinaryData> GetTile(string collectionId, string itemId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, TileMatrixSetId? tileMatrixSetId = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, string subdatasetName = null, IEnumerable<string> subdatasetBands = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTile(collectionId, itemId, z, x, y, scale, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileMatrixSetId?.ToString(), buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, subdatasetName, subdatasetBands, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Tile
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTileAsync(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="z">
        /// Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
        /// representing the scaleDenominator the tile.
        /// </param>
        /// <param name="x">
        /// Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixHeight-1 for the selected TileMatrix.
        /// </param>
        /// <param name="y">
        /// Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixWidth-1 for the selected TileMatrix.
        /// </param>
        /// <param name="scale"> Numeric scale factor for the tile. Higher values produce larger tiles (default: "1"). </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC" | "EuropeanETRS89_LAEAQuad" | "LINZAntarticaMapTilegrid" | "NZTM2000Quad" | "UPSAntarcticWGS84Quad" | "UPSArcticWGS84Quad" | "UTM31WGS84Quad" | "WGS1984Quad" | "WebMercatorQuad" | "WorldCRS84Quad" | "WorldMercatorWGS84Quad"
        /// </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="subdatasetName"> The name of a subdataset within the asset. </param>
        /// <param name="subdatasetBands"> The index of a subdataset band within the asset. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileAsync(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,string,IEnumerable{string},string,string,bool?,string,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetTileAsync(string collectionId, string itemId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, string subdatasetName, IEnumerable<string> subdatasetBands, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetTile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileRequest(collectionId, itemId, z, x, y, scale, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileMatrixSetId, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, subdatasetName, subdatasetBands, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Tile
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTile(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="z">
        /// Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
        /// representing the scaleDenominator the tile.
        /// </param>
        /// <param name="x">
        /// Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixHeight-1 for the selected TileMatrix.
        /// </param>
        /// <param name="y">
        /// Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixWidth-1 for the selected TileMatrix.
        /// </param>
        /// <param name="scale"> Numeric scale factor for the tile. Higher values produce larger tiles (default: "1"). </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC" | "EuropeanETRS89_LAEAQuad" | "LINZAntarticaMapTilegrid" | "NZTM2000Quad" | "UPSAntarcticWGS84Quad" | "UPSArcticWGS84Quad" | "UTM31WGS84Quad" | "WGS1984Quad" | "WebMercatorQuad" | "WorldCRS84Quad" | "WorldMercatorWGS84Quad"
        /// </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="subdatasetName"> The name of a subdataset within the asset. </param>
        /// <param name="subdatasetBands"> The index of a subdataset band within the asset. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTile(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,string,IEnumerable{string},string,string,bool?,string,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetTile(string collectionId, string itemId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, string subdatasetName, IEnumerable<string> subdatasetBands, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetTile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileRequest(collectionId, itemId, z, x, y, scale, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileMatrixSetId, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, subdatasetName, subdatasetBands, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Tile Tilematrixsetid As Path. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="z">
        /// Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
        /// representing the scaleDenominator the tile.
        /// </param>
        /// <param name="x">
        /// Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixHeight-1 for the selected TileMatrix.
        /// </param>
        /// <param name="y">
        /// Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixWidth-1 for the selected TileMatrix.
        /// </param>
        /// <param name="scale"> Numeric scale factor for the tile. Higher values produce larger tiles (default: "1"). </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="subdatasetName"> The name of a subdataset within the asset. </param>
        /// <param name="subdatasetBands"> The index of a subdataset band within the asset. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="tileMatrixSetId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="tileMatrixSetId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create map tile from a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileWithMatrixSetAsync(string,string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetTileWithMatrixSetAsync(string collectionId, string itemId, string tileMatrixSetId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, string subdatasetName = null, IEnumerable<string> subdatasetBands = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTileWithMatrixSetAsync(collectionId, itemId, tileMatrixSetId, z, x, y, scale, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, subdatasetName, subdatasetBands, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Tile Tilematrixsetid As Path. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="z">
        /// Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
        /// representing the scaleDenominator the tile.
        /// </param>
        /// <param name="x">
        /// Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixHeight-1 for the selected TileMatrix.
        /// </param>
        /// <param name="y">
        /// Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixWidth-1 for the selected TileMatrix.
        /// </param>
        /// <param name="scale"> Numeric scale factor for the tile. Higher values produce larger tiles (default: "1"). </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="subdatasetName"> The name of a subdataset within the asset. </param>
        /// <param name="subdatasetBands"> The index of a subdataset band within the asset. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="tileMatrixSetId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="tileMatrixSetId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create map tile from a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileWithMatrixSet(string,string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BinaryData> GetTileWithMatrixSet(string collectionId, string itemId, string tileMatrixSetId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, string subdatasetName = null, IEnumerable<string> subdatasetBands = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTileWithMatrixSet(collectionId, itemId, tileMatrixSetId, z, x, y, scale, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, subdatasetName, subdatasetBands, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Tile Tilematrixsetid As Path
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTileWithMatrixSetAsync(string,string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="z">
        /// Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
        /// representing the scaleDenominator the tile.
        /// </param>
        /// <param name="x">
        /// Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixHeight-1 for the selected TileMatrix.
        /// </param>
        /// <param name="y">
        /// Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixWidth-1 for the selected TileMatrix.
        /// </param>
        /// <param name="scale"> Numeric scale factor for the tile. Higher values produce larger tiles (default: "1"). </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="subdatasetName"> The name of a subdataset within the asset. </param>
        /// <param name="subdatasetBands"> The index of a subdataset band within the asset. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="tileMatrixSetId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="tileMatrixSetId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileWithMatrixSetAsync(string,string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,IEnumerable{string},string,string,bool?,string,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetTileWithMatrixSetAsync(string collectionId, string itemId, string tileMatrixSetId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, string subdatasetName, IEnumerable<string> subdatasetBands, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetTileWithMatrixSet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileWithMatrixSetRequest(collectionId, itemId, tileMatrixSetId, z, x, y, scale, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, subdatasetName, subdatasetBands, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Tile Tilematrixsetid As Path
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTileWithMatrixSet(string,string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="z">
        /// Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
        /// representing the scaleDenominator the tile.
        /// </param>
        /// <param name="x">
        /// Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixHeight-1 for the selected TileMatrix.
        /// </param>
        /// <param name="y">
        /// Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
        /// MatrixWidth-1 for the selected TileMatrix.
        /// </param>
        /// <param name="scale"> Numeric scale factor for the tile. Higher values produce larger tiles (default: "1"). </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="subdatasetName"> The name of a subdataset within the asset. </param>
        /// <param name="subdatasetBands"> The index of a subdataset band within the asset. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="tileMatrixSetId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="tileMatrixSetId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileWithMatrixSet(string,string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,IEnumerable{string},string,string,bool?,string,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetTileWithMatrixSet(string collectionId, string itemId, string tileMatrixSetId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, string subdatasetName, IEnumerable<string> subdatasetBands, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetTileWithMatrixSet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileWithMatrixSetRequest(collectionId, itemId, tileMatrixSetId, z, x, y, scale, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, subdatasetName, subdatasetBands, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Tilejson. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad')
        /// </param>
        /// <param name="tileFormat">
        /// Default will be automatically defined if the output image needs a mask (png) or
        /// not (jpeg).
        /// </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return Tilejson. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileJsonAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<TileJsonResult>> GetTileJsonAsync(string collectionId, string itemId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, TileMatrixSetId? tileMatrixSetId = null, ImageType? tileFormat = null, int? tileScale = null, int? minzoom = null, int? maxzoom = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTileJsonAsync(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileMatrixSetId?.ToString(), tileFormat?.ToString(), tileScale, minzoom, maxzoom, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(TileJsonResult.FromResponse(response), response);
        }

        /// <summary> Tilejson. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad')
        /// </param>
        /// <param name="tileFormat">
        /// Default will be automatically defined if the output image needs a mask (png) or
        /// not (jpeg).
        /// </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return Tilejson. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileJson(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<TileJsonResult> GetTileJson(string collectionId, string itemId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, TileMatrixSetId? tileMatrixSetId = null, ImageType? tileFormat = null, int? tileScale = null, int? minzoom = null, int? maxzoom = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTileJson(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileMatrixSetId?.ToString(), tileFormat?.ToString(), tileScale, minzoom, maxzoom, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(TileJsonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Tilejson
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTileJsonAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC" | "EuropeanETRS89_LAEAQuad" | "LINZAntarticaMapTilegrid" | "NZTM2000Quad" | "UPSAntarcticWGS84Quad" | "UPSArcticWGS84Quad" | "UTM31WGS84Quad" | "WGS1984Quad" | "WebMercatorQuad" | "WorldCRS84Quad" | "WorldMercatorWGS84Quad"
        /// </param>
        /// <param name="tileFormat">
        /// Default will be automatically defined if the output image needs a mask (png) or
        /// not (jpeg). Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw"
        /// </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileJsonAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,int?,int?,int?,string,string,string,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetTileJsonAsync(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetTileJson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileJsonRequest(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileMatrixSetId, tileFormat, tileScale, minzoom, maxzoom, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Tilejson
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTileJson(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC" | "EuropeanETRS89_LAEAQuad" | "LINZAntarticaMapTilegrid" | "NZTM2000Quad" | "UPSAntarcticWGS84Quad" | "UPSArcticWGS84Quad" | "UTM31WGS84Quad" | "WGS1984Quad" | "WebMercatorQuad" | "WorldCRS84Quad" | "WorldMercatorWGS84Quad"
        /// </param>
        /// <param name="tileFormat">
        /// Default will be automatically defined if the output image needs a mask (png) or
        /// not (jpeg). Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw"
        /// </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileJson(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,int?,int?,int?,string,string,string,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response GetTileJson(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetTileJson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileJsonRequest(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileMatrixSetId, tileFormat, tileScale, minzoom, maxzoom, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Tilejson Tilematrixsetid As Path. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileFormat">
        /// Default will be automatically defined if the output image needs a mask (png) or
        /// not (jpeg).
        /// </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return the Tilejson Tilematrixsetid As a path. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileJsonWithMatrixSetAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<TileJsonResult>> GetTileJsonWithMatrixSetAsync(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, ImageType? tileFormat = null, int? tileScale = null, int? minzoom = null, int? maxzoom = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTileJsonWithMatrixSetAsync(collectionId, itemId, tileMatrixSetId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileFormat?.ToString(), tileScale, minzoom, maxzoom, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(TileJsonResult.FromResponse(response), response);
        }

        /// <summary> Tilejson Tilematrixsetid As Path. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileFormat">
        /// Default will be automatically defined if the output image needs a mask (png) or
        /// not (jpeg).
        /// </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Return the Tilejson Tilematrixsetid As a path. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileJsonWithMatrixSet(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<TileJsonResult> GetTileJsonWithMatrixSet(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, ImageType? tileFormat = null, int? tileScale = null, int? minzoom = null, int? maxzoom = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTileJsonWithMatrixSet(collectionId, itemId, tileMatrixSetId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileFormat?.ToString(), tileScale, minzoom, maxzoom, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(TileJsonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Tilejson Tilematrixsetid As Path
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTileJsonWithMatrixSetAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileFormat">
        /// Default will be automatically defined if the output image needs a mask (png) or
        /// not (jpeg). Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw"
        /// </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileJsonWithMatrixSetAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,int?,int?,int?,string,string,string,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetTileJsonWithMatrixSetAsync(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetTileJsonWithMatrixSet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileJsonWithMatrixSetRequest(collectionId, itemId, tileMatrixSetId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileFormat, tileScale, minzoom, maxzoom, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Tilejson Tilematrixsetid As Path
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTileJsonWithMatrixSet(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileFormat">
        /// Default will be automatically defined if the output image needs a mask (png) or
        /// not (jpeg). Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw"
        /// </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetTileJsonWithMatrixSet(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,int?,int?,int?,string,string,string,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response GetTileJsonWithMatrixSet(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetTileJsonWithMatrixSet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileJsonWithMatrixSetRequest(collectionId, itemId, tileMatrixSetId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileFormat, tileScale, minzoom, maxzoom, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Wmts. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad')
        /// </param>
        /// <param name="tileFormat"> Output image type. Default is png. </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> OGC WMTS endpoint. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetWmtsCapabilitiesAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<string>> GetWmtsCapabilitiesAsync(string collectionId, string itemId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, TileMatrixSetId? tileMatrixSetId = null, ImageType? tileFormat = null, int? tileScale = null, int? minzoom = null, int? maxzoom = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetWmtsCapabilitiesAsync(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileMatrixSetId?.ToString(), tileFormat?.ToString(), tileScale, minzoom, maxzoom, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(response.Content.ToObjectFromJson<string>(), response);
        }

        /// <summary> Wmts. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad')
        /// </param>
        /// <param name="tileFormat"> Output image type. Default is png. </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> OGC WMTS endpoint. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetWmtsCapabilities(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<string> GetWmtsCapabilities(string collectionId, string itemId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, TileMatrixSetId? tileMatrixSetId = null, ImageType? tileFormat = null, int? tileScale = null, int? minzoom = null, int? maxzoom = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetWmtsCapabilities(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileMatrixSetId?.ToString(), tileFormat?.ToString(), tileScale, minzoom, maxzoom, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(response.Content.ToObjectFromJson<string>(), response);
        }

        /// <summary>
        /// [Protocol Method] Wmts
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetWmtsCapabilitiesAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC" | "EuropeanETRS89_LAEAQuad" | "LINZAntarticaMapTilegrid" | "NZTM2000Quad" | "UPSAntarcticWGS84Quad" | "UPSArcticWGS84Quad" | "UTM31WGS84Quad" | "WGS1984Quad" | "WebMercatorQuad" | "WorldCRS84Quad" | "WorldMercatorWGS84Quad"
        /// </param>
        /// <param name="tileFormat"> Output image type. Default is png. Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw". </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetWmtsCapabilitiesAsync(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,int?,int?,int?,string,string,string,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetWmtsCapabilitiesAsync(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetWmtsCapabilities");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetWmtsCapabilitiesRequest(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileMatrixSetId, tileFormat, tileScale, minzoom, maxzoom, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Wmts
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetWmtsCapabilities(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,TileMatrixSetId?,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileMatrixSetId">
        /// Identifier selecting one of the TileMatrixSetId supported (default:
        /// 'WebMercatorQuad'). Allowed values: "CanadianNAD83_LCC" | "EuropeanETRS89_LAEAQuad" | "LINZAntarticaMapTilegrid" | "NZTM2000Quad" | "UPSAntarcticWGS84Quad" | "UPSArcticWGS84Quad" | "UTM31WGS84Quad" | "WGS1984Quad" | "WebMercatorQuad" | "WorldCRS84Quad" | "WorldMercatorWGS84Quad"
        /// </param>
        /// <param name="tileFormat"> Output image type. Default is png. Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw". </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetWmtsCapabilities(string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,int?,int?,int?,string,string,string,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response GetWmtsCapabilities(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetWmtsCapabilities");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetWmtsCapabilitiesRequest(collectionId, itemId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileMatrixSetId, tileFormat, tileScale, minzoom, maxzoom, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Wmts Tilematrixsetid As Path. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileFormat"> Output image type. Default is png. </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> OGC WMTS endpoint. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetWmtsCapabilitiesWithMatrixSetAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<string>> GetWmtsCapabilitiesWithMatrixSetAsync(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, ImageType? tileFormat = null, int? tileScale = null, int? minzoom = null, int? maxzoom = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetWmtsCapabilitiesWithMatrixSetAsync(collectionId, itemId, tileMatrixSetId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileFormat?.ToString(), tileScale, minzoom, maxzoom, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(response.Content.ToObjectFromJson<string>(), response);
        }

        /// <summary> Wmts Tilematrixsetid As Path. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileFormat"> Output image type. Default is png. </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> OGC WMTS endpoint. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetWmtsCapabilitiesWithMatrixSet(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<string> GetWmtsCapabilitiesWithMatrixSet(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, ImageType? tileFormat = null, int? tileScale = null, int? minzoom = null, int? maxzoom = null, string buffer = null, string colorFormula = null, ResamplingMethod? resampling = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetWmtsCapabilitiesWithMatrixSet(collectionId, itemId, tileMatrixSetId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, tileFormat?.ToString(), tileScale, minzoom, maxzoom, buffer, colorFormula, resampling?.ToString(), rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(response.Content.ToObjectFromJson<string>(), response);
        }

        /// <summary>
        /// [Protocol Method] Wmts Tilematrixsetid As Path
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetWmtsCapabilitiesWithMatrixSetAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileFormat"> Output image type. Default is png. Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw". </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetWmtsCapabilitiesWithMatrixSetAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,int?,int?,int?,string,string,string,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetWmtsCapabilitiesWithMatrixSetAsync(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetWmtsCapabilitiesWithMatrixSet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetWmtsCapabilitiesWithMatrixSetRequest(collectionId, itemId, tileMatrixSetId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileFormat, tileScale, minzoom, maxzoom, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Wmts Tilematrixsetid As Path
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetWmtsCapabilitiesWithMatrixSet(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,int?,int?,int?,string,string,ResamplingMethod?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="tileMatrixSetId"> Identifier selecting one of the TileMatrixSetId supported. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="tileFormat"> Output image type. Default is png. Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw". </param>
        /// <param name="tileScale"> Tile scale factor affecting output size. Values &gt; 1 produce larger tiles (e.g., 1=256x256, 2=512x512). </param>
        /// <param name="minzoom"> Overwrite default minzoom. </param>
        /// <param name="maxzoom"> Overwrite default maxzoom. </param>
        /// <param name="buffer">
        /// Buffer on each side of the given tile. It must be a multiple of `0.5`. Output
        /// **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257,
        /// 1.0 = 258x258).
        /// </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="tileMatrixSetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetWmtsCapabilitiesWithMatrixSet(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,int?,int?,int?,string,string,string,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response GetWmtsCapabilitiesWithMatrixSet(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(tileMatrixSetId, nameof(tileMatrixSetId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetWmtsCapabilitiesWithMatrixSet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetWmtsCapabilitiesWithMatrixSetRequest(collectionId, itemId, tileMatrixSetId, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, tileFormat, tileScale, minzoom, maxzoom, buffer, colorFormula, resampling, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Point. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="lon"> Longitude. </param>
        /// <param name="lat"> Latitude. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get Point value for a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPointAsync(string,string,double,float,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,ResamplingMethod?,CancellationToken)']/*" />
        public virtual async Task<Response<TitilerCoreModelsResponsesPoint>> GetPointAsync(string collectionId, string itemId, double lon, float lat, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string coordCrs = null, ResamplingMethod? resampling = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPointAsync(collectionId, itemId, lon, lat, assets, expression, assetBidx, assetAsBand, nodata, unscale, coordCrs, resampling?.ToString(), context).ConfigureAwait(false);
            return Response.FromValue(TitilerCoreModelsResponsesPoint.FromResponse(response), response);
        }

        /// <summary> Point. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="lon"> Longitude. </param>
        /// <param name="lat"> Latitude. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get Point value for a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPoint(string,string,double,float,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,ResamplingMethod?,CancellationToken)']/*" />
        public virtual Response<TitilerCoreModelsResponsesPoint> GetPoint(string collectionId, string itemId, double lon, float lat, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string coordCrs = null, ResamplingMethod? resampling = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPoint(collectionId, itemId, lon, lat, assets, expression, assetBidx, assetAsBand, nodata, unscale, coordCrs, resampling?.ToString(), context);
            return Response.FromValue(TitilerCoreModelsResponsesPoint.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Point
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPointAsync(string,string,double,float,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,ResamplingMethod?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="lon"> Longitude. </param>
        /// <param name="lat"> Latitude. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPointAsync(string,string,double,float,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetPointAsync(string collectionId, string itemId, double lon, float lat, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string coordCrs, string resampling, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPoint");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPointRequest(collectionId, itemId, lon, lat, assets, expression, assetBidx, assetAsBand, nodata, unscale, coordCrs, resampling, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Point
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPoint(string,string,double,float,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,ResamplingMethod?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="lon"> Longitude. </param>
        /// <param name="lat"> Latitude. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPoint(string,string,double,float,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,RequestContext)']/*" />
        public virtual Response GetPoint(string collectionId, string itemId, double lon, float lat, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string coordCrs, string resampling, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPoint");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPointRequest(collectionId, itemId, lon, lat, assets, expression, assetBidx, assetAsBand, nodata, unscale, coordCrs, resampling, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Preview. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create preview of a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPreviewAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetPreviewAsync(string collectionId, string itemId, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, ImageType? format = null, string colorFormula = null, string dstCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPreviewAsync(collectionId, itemId, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, format?.ToString(), colorFormula, dstCrs, resampling?.ToString(), maxSize, height, width, rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Preview. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create preview of a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPreview(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<BinaryData> GetPreview(string collectionId, string itemId, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, ImageType? format = null, string colorFormula = null, string dstCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPreview(collectionId, itemId, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, format?.ToString(), colorFormula, dstCrs, resampling?.ToString(), maxSize, height, width, rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Preview
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPreviewAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw". </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPreviewAsync(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,string,int?,int?,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetPreviewAsync(string collectionId, string itemId, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string format, string colorFormula, string dstCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPreview");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPreviewRequest(collectionId, itemId, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, format, colorFormula, dstCrs, resampling, maxSize, height, width, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Preview
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPreview(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,ImageType?,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). Allowed values: "png" | "npy" | "tif" | "jpeg" | "jpg" | "jp2" | "webp" | "pngraw". </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPreview(string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,string,int?,int?,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response GetPreview(string collectionId, string itemId, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string format, string colorFormula, string dstCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPreview");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPreviewRequest(collectionId, itemId, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, format, colorFormula, dstCrs, resampling, maxSize, height, width, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Preview. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create preview of a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPreviewWithFormatAsync(string,string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetPreviewWithFormatAsync(string collectionId, string itemId, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string dstCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPreviewWithFormatAsync(collectionId, itemId, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, dstCrs, resampling?.ToString(), maxSize, height, width, rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Preview. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create preview of a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPreviewWithFormat(string,string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<BinaryData> GetPreviewWithFormat(string collectionId, string itemId, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string dstCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPreviewWithFormat(collectionId, itemId, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, dstCrs, resampling?.ToString(), maxSize, height, width, rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Preview
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPreviewWithFormatAsync(string,string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPreviewWithFormatAsync(string,string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,int?,int?,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetPreviewWithFormatAsync(string collectionId, string itemId, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPreviewWithFormat");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPreviewWithFormatRequest(collectionId, itemId, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, dstCrs, resampling, maxSize, height, width, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Preview
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPreviewWithFormat(string,string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPreviewWithFormat(string,string,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,int?,int?,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response GetPreviewWithFormat(string collectionId, string itemId, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPreviewWithFormat");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPreviewWithFormatRequest(collectionId, itemId, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, dstCrs, resampling, maxSize, height, width, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Part. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="minx"> Bounding box min X. </param>
        /// <param name="miny"> Bounding box min Y. </param>
        /// <param name="maxx"> Bounding box max X. </param>
        /// <param name="maxy"> Bounding box max Y. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create image from part of a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPartAsync(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetPartAsync(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string dstCrs = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPartAsync(collectionId, itemId, minx, miny, maxx, maxy, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, dstCrs, coordCrs, resampling?.ToString(), maxSize, height, width, rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Part. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="minx"> Bounding box min X. </param>
        /// <param name="miny"> Bounding box min Y. </param>
        /// <param name="maxx"> Bounding box max X. </param>
        /// <param name="maxy"> Bounding box max Y. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create image from part of a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPart(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<BinaryData> GetPart(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string dstCrs = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPart(collectionId, itemId, minx, miny, maxx, maxy, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, dstCrs, coordCrs, resampling?.ToString(), maxSize, height, width, rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Part
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPartAsync(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="minx"> Bounding box min X. </param>
        /// <param name="miny"> Bounding box min Y. </param>
        /// <param name="maxx"> Bounding box max X. </param>
        /// <param name="maxy"> Bounding box max Y. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPartAsync(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,string,int?,int?,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetPartAsync(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string coordCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPart");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPartRequest(collectionId, itemId, minx, miny, maxx, maxy, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, dstCrs, coordCrs, resampling, maxSize, height, width, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Part
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPart(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="minx"> Bounding box min X. </param>
        /// <param name="miny"> Bounding box min Y. </param>
        /// <param name="maxx"> Bounding box max X. </param>
        /// <param name="maxy"> Bounding box max Y. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPart(string,string,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,string,int?,int?,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response GetPart(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string coordCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPart");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPartRequest(collectionId, itemId, minx, miny, maxx, maxy, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, dstCrs, coordCrs, resampling, maxSize, height, width, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Part. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="minx"> Bounding box min X. </param>
        /// <param name="miny"> Bounding box min Y. </param>
        /// <param name="maxx"> Bounding box max X. </param>
        /// <param name="maxy"> Bounding box max Y. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create image from part of a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPartWithDimensionsAsync(string,string,float,float,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,string,ResamplingMethod?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetPartWithDimensionsAsync(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, float width, float height, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string dstCrs = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPartWithDimensionsAsync(collectionId, itemId, minx, miny, maxx, maxy, width, height, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, dstCrs, coordCrs, resampling?.ToString(), maxSize, rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Part. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="minx"> Bounding box min X. </param>
        /// <param name="miny"> Bounding box min Y. </param>
        /// <param name="maxx"> Bounding box max X. </param>
        /// <param name="maxy"> Bounding box max Y. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create image from part of a dataset. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPartWithDimensions(string,string,float,float,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,string,ResamplingMethod?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<BinaryData> GetPartWithDimensions(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, float width, float height, string format, string accept, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string dstCrs = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPartWithDimensions(collectionId, itemId, minx, miny, maxx, maxy, width, height, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, dstCrs, coordCrs, resampling?.ToString(), maxSize, rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Part
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPartWithDimensionsAsync(string,string,float,float,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,string,ResamplingMethod?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="minx"> Bounding box min X. </param>
        /// <param name="miny"> Bounding box min Y. </param>
        /// <param name="maxx"> Bounding box max X. </param>
        /// <param name="maxy"> Bounding box max Y. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPartWithDimensionsAsync(string,string,float,float,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,string,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetPartWithDimensionsAsync(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, float width, float height, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string coordCrs, string resampling, int? maxSize, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPartWithDimensions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPartWithDimensionsRequest(collectionId, itemId, minx, miny, maxx, maxy, width, height, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, dstCrs, coordCrs, resampling, maxSize, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Part
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPartWithDimensions(string,string,float,float,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,string,ResamplingMethod?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="minx"> Bounding box min X. </param>
        /// <param name="miny"> Bounding box min Y. </param>
        /// <param name="maxx"> Bounding box max X. </param>
        /// <param name="maxy"> Bounding box max Y. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="dstCrs"> Output Coordinate Reference System. </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/> or <paramref name="accept"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='GetPartWithDimensions(string,string,float,float,float,float,float,float,string,string,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,string,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response GetPartWithDimensions(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, float width, float height, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string coordCrs, string resampling, int? maxSize, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.GetPartWithDimensions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPartWithDimensionsRequest(collectionId, itemId, minx, miny, maxx, maxy, width, height, format, accept, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, dstCrs, coordCrs, resampling, maxSize, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Geojson Crop. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="body"> Request GeoJson body. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/>, <paramref name="accept"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create image from a geojson feature. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='CropGeoJsonAsync(string,string,string,string,GeoJsonGeometry,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> CropGeoJsonAsync(string collectionId, string itemId, string format, string accept, GeoJsonGeometry body, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = body.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CropGeoJsonAsync(collectionId, itemId, format, accept, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, coordCrs, resampling?.ToString(), maxSize, height, width, rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Geojson Crop. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="body"> Request GeoJson body. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/>, <paramref name="accept"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create image from a geojson feature. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='CropGeoJson(string,string,string,string,GeoJsonGeometry,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<BinaryData> CropGeoJson(string collectionId, string itemId, string format, string accept, GeoJsonGeometry body, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = body.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CropGeoJson(collectionId, itemId, format, accept, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, coordCrs, resampling?.ToString(), maxSize, height, width, rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Geojson Crop
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CropGeoJsonAsync(string,string,string,string,GeoJsonGeometry,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/>, <paramref name="accept"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='CropGeoJsonAsync(string,string,string,string,RequestContent,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,int?,int?,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> CropGeoJsonAsync(string collectionId, string itemId, string format, string accept, RequestContent content, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string algorithm = null, string algorithmParams = null, string colorFormula = null, string coordCrs = null, string resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, string colormapName = null, string colormap = null, bool? returnMask = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.CropGeoJson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCropGeoJsonRequest(collectionId, itemId, format, accept, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, coordCrs, resampling, maxSize, height, width, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Geojson Crop
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CropGeoJson(string,string,string,string,GeoJsonGeometry,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,int?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp) (default: "png"). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/>, <paramref name="accept"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='CropGeoJson(string,string,string,string,RequestContent,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,int?,int?,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response CropGeoJson(string collectionId, string itemId, string format, string accept, RequestContent content, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string algorithm = null, string algorithmParams = null, string colorFormula = null, string coordCrs = null, string resampling = null, int? maxSize = null, int? height = null, int? width = null, IEnumerable<string> rescale = null, string colormapName = null, string colormap = null, bool? returnMask = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.CropGeoJson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCropGeoJsonRequest(collectionId, itemId, format, accept, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, coordCrs, resampling, maxSize, height, width, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Geojson Crop. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="body"> Request GeoJson body. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/>, <paramref name="accept"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create image from a geojson feature. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='CropGeoJsonWithDimensionsAsync(string,string,float,float,string,string,StacItemModel,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> CropGeoJsonWithDimensionsAsync(string collectionId, string itemId, float width, float height, string format, string accept, StacItemModel body, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = body.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CropGeoJsonWithDimensionsAsync(collectionId, itemId, width, height, format, accept, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, coordCrs, resampling?.ToString(), maxSize, rescale, colormapName?.ToString(), colormap, returnMask, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Geojson Crop. </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="body"> Request GeoJson body. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/>, <paramref name="accept"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create image from a geojson feature. </remarks>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='CropGeoJsonWithDimensions(string,string,float,float,string,string,StacItemModel,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)']/*" />
        public virtual Response<BinaryData> CropGeoJsonWithDimensions(string collectionId, string itemId, float width, float height, string format, string accept, StacItemModel body, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, AlgorithmInfo? algorithm = null, string algorithmParams = null, string colorFormula = null, string coordCrs = null, ResamplingMethod? resampling = null, int? maxSize = null, IEnumerable<string> rescale = null, ColorMapNames? colormapName = null, string colormap = null, bool? returnMask = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = body.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CropGeoJsonWithDimensions(collectionId, itemId, width, height, format, accept, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm?.ToString(), algorithmParams, colorFormula, coordCrs, resampling?.ToString(), maxSize, rescale, colormapName?.ToString(), colormap, returnMask, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Geojson Crop
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CropGeoJsonWithDimensionsAsync(string,string,float,float,string,string,StacItemModel,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/>, <paramref name="accept"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='CropGeoJsonWithDimensionsAsync(string,string,float,float,string,string,RequestContent,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> CropGeoJsonWithDimensionsAsync(string collectionId, string itemId, float width, float height, string format, string accept, RequestContent content, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string algorithm = null, string algorithmParams = null, string colorFormula = null, string coordCrs = null, string resampling = null, int? maxSize = null, IEnumerable<string> rescale = null, string colormapName = null, string colormap = null, bool? returnMask = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.CropGeoJsonWithDimensions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCropGeoJsonWithDimensionsRequest(collectionId, itemId, width, height, format, accept, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, coordCrs, resampling, maxSize, rescale, colormapName, colormap, returnMask, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Geojson Crop
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CropGeoJsonWithDimensions(string,string,float,float,string,string,StacItemModel,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,AlgorithmInfo?,string,string,string,ResamplingMethod?,int?,IEnumerable{string},ColorMapNames?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection Identifier. </param>
        /// <param name="itemId"> STAC Item Identifier. </param>
        /// <param name="width"> Width in pixels for the output image. </param>
        /// <param name="height"> Height in pixels for the output image. </param>
        /// <param name="format"> Output format for the tile or image (e.g., png, jpeg, webp). </param>
        /// <param name="accept"> The <see cref="string"/> to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="assets"> Asset's names. </param>
        /// <param name="expression"> Band math expression between assets. </param>
        /// <param name="assetBidx"> Per asset band indexes (coma separated indexes). </param>
        /// <param name="assetAsBand"> Asset as Band. </param>
        /// <param name="nodata"> Overwrite internal Nodata value. </param>
        /// <param name="unscale"> Apply internal Scale or Offset. </param>
        /// <param name="algorithm"> Algorithm name. Allowed values: "hillshade" | "contours" | "normalizedIndex" | "terrarium" | "terrainrgb". </param>
        /// <param name="algorithmParams"> Algorithm parameter. </param>
        /// <param name="colorFormula"> rio-color formula (info: https://github.com/mapbox/rio-color). </param>
        /// <param name="coordCrs"> Coordinate Reference System of the input coords. Default to `epsg:4326`. </param>
        /// <param name="resampling"> Resampling method. Allowed values: "nearest" | "bilinear" | "cubic" | "cubic_spline" | "lanczos" | "average" | "mode" | "gauss" | "rms". </param>
        /// <param name="maxSize"> Image output size limit if width and height limits are not set. </param>
        /// <param name="rescale"> comma (',') delimited Min,Max range. Can set multiple time for multiple bands. </param>
        /// <param name="colormapName"> Colormap name. Allowed values: "accent" | "accent_r" | "afmhot" | "afmhot_r" | "ai4g-lulc" | "alos-fnf" | "alos-palsar-mask" | "autumn" | "autumn_r" | "binary" | "binary_r" | "blues" | "blues_r" | "bone" | "bone_r" | "brbg" | "brbg_r" | "brg" | "brg_r" | "bugn" | "bugn_r" | "bupu" | "bupu_r" | "bwr" | "bwr_r" | "c-cap" | "cfastie" | "chesapeake-lc-13" | "chesapeake-lc-7" | "chesapeake-lu" | "chloris-biomass" | "cividis" | "cividis_r" | "cmrmap" | "cmrmap_r" | "cool" | "cool_r" | "coolwarm" | "coolwarm_r" | "copper" | "copper_r" | "cubehelix" | "cubehelix_r" | "dark2" | "dark2_r" | "drcog-lulc" | "esa-cci-lc" | "esa-worldcover" | "flag" | "flag_r" | "gap-lulc" | "gist_earth" | "gist_earth_r" | "gist_gray" | "gist_gray_r" | "gist_heat" | "gist_heat_r" | "gist_ncar" | "gist_ncar_r" | "gist_rainbow" | "gist_rainbow_r" | "gist_stern" | "gist_stern_r" | "gist_yarg" | "gist_yarg_r" | "gnbu" | "gnbu_r" | "gnuplot" | "gnuplot2" | "gnuplot2_r" | "gnuplot_r" | "gray" | "gray_r" | "greens" | "greens_r" | "greys" | "greys_r" | "hot" | "hot_r" | "hsv" | "hsv_r" | "inferno" | "inferno_r" | "io-bii" | "io-lulc" | "io-lulc-9-class" | "jet" | "jet_r" | "jrc-change" | "jrc-extent" | "jrc-occurrence" | "jrc-recurrence" | "jrc-seasonality" | "jrc-transitions" | "lidar-classification" | "lidar-hag" | "lidar-hag-alternative" | "lidar-intensity" | "lidar-returns" | "magma" | "magma_r" | "modis-10A1" | "modis-10A2" | "modis-13A1|Q1" | "modis-14A1|A2" | "modis-15A2H|A3H" | "modis-16A3GF-ET" | "modis-16A3GF-PET" | "modis-17A2H|A2HGF" | "modis-17A3HGF" | "modis-64A1" | "mtbs-severity" | "nipy_spectral" | "nipy_spectral_r" | "nrcan-lulc" | "ocean" | "ocean_r" | "oranges" | "oranges_r" | "orrd" | "orrd_r" | "paired" | "paired_r" | "pastel1" | "pastel1_r" | "pastel2" | "pastel2_r" | "pink" | "pink_r" | "piyg" | "piyg_r" | "plasma" | "plasma_r" | "prgn" | "prgn_r" | "prism" | "prism_r" | "pubu" | "pubu_r" | "pubugn" | "pubugn_r" | "puor" | "puor_r" | "purd" | "purd_r" | "purples" | "purples_r" | "qpe" | "rainbow" | "rainbow_r" | "rdbu" | "rdbu_r" | "rdgy" | "rdgy_r" | "rdpu" | "rdpu_r" | "rdylbu" | "rdylbu_r" | "rdylgn" | "rdylgn_r" | "reds" | "reds_r" | "rplumbo" | "schwarzwald" | "seismic" | "seismic_r" | "set1" | "set1_r" | "set2" | "set2_r" | "set3" | "set3_r" | "spectral" | "spectral_r" | "spring" | "spring_r" | "summer" | "summer_r" | "tab10" | "tab10_r" | "tab20" | "tab20_r" | "tab20b" | "tab20b_r" | "tab20c" | "tab20c_r" | "terrain" | "terrain_r" | "twilight" | "twilight_r" | "twilight_shifted" | "twilight_shifted_r" | "usda-cdl" | "usda-cdl-corn" | "usda-cdl-cotton" | "usda-cdl-soybeans" | "usda-cdl-wheat" | "usgs-lcmap" | "viirs-10a1" | "viirs-13a1" | "viirs-14a1" | "viirs-15a2H" | "viridis" | "viridis_r" | "winter" | "winter_r" | "wistia" | "wistia_r" | "ylgn" | "ylgn_r" | "ylgnbu" | "ylgnbu_r" | "ylorbr" | "ylorbr_r" | "ylorrd" | "ylorrd_r". </param>
        /// <param name="colormap"> JSON encoded custom Colormap. </param>
        /// <param name="returnMask"> Add mask to the output data. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/>, <paramref name="format"/>, <paramref name="accept"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/StacItemTilerClient.xml" path="doc/members/member[@name='CropGeoJsonWithDimensions(string,string,float,float,string,string,RequestContent,IEnumerable{string},string,IEnumerable{string},bool?,float?,bool?,string,string,string,string,string,int?,IEnumerable{string},string,string,bool?,RequestContext)']/*" />
        public virtual Response CropGeoJsonWithDimensions(string collectionId, string itemId, float width, float height, string format, string accept, RequestContent content, IEnumerable<string> assets = null, string expression = null, IEnumerable<string> assetBidx = null, bool? assetAsBand = null, float? nodata = null, bool? unscale = null, string algorithm = null, string algorithmParams = null, string colorFormula = null, string coordCrs = null, string resampling = null, int? maxSize = null, IEnumerable<string> rescale = null, string colormapName = null, string colormap = null, bool? returnMask = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNullOrEmpty(format, nameof(format));
            Argument.AssertNotNull(accept, nameof(accept));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("StacItemTilerClient.CropGeoJsonWithDimensions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCropGeoJsonWithDimensionsRequest(collectionId, itemId, width, height, format, accept, content, assets, expression, assetBidx, assetAsBand, nodata, unscale, algorithm, algorithmParams, colorFormula, coordCrs, resampling, maxSize, rescale, colormapName, colormap, returnMask, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetBoundsRequest(string collectionId, string itemId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/bounds", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInfoRequest(string collectionId, string itemId, IEnumerable<string> assets, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/info", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInfoGeoJsonRequest(string collectionId, string itemId, IEnumerable<string> assets, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/info.geojson", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAvailableAssetsRequest(string collectionId, string itemId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200204);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/assets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAssetStatisticsRequest(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string resampling, int? maxSize, bool? categorical, IEnumerable<string> c, IEnumerable<int> p, string histogramBins, string histogramRange, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/asset_statistics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (categorical != null)
            {
                uri.AppendQuery("categorical", categorical.Value, true);
            }
            if (c != null && !(c is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in c)
                {
                    uri.AppendQuery("c", param, true);
                }
            }
            if (p != null && !(p is ChangeTrackingList<int> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                foreach (var param in p)
                {
                    uri.AppendQuery("p", param, true);
                }
            }
            if (histogramBins != null)
            {
                uri.AppendQuery("histogram_bins", histogramBins, true);
            }
            if (histogramRange != null)
            {
                uri.AppendQuery("histogram_range", histogramRange, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetStatisticsRequest(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string resampling, int? maxSize, bool? categorical, IEnumerable<string> c, IEnumerable<int> p, string histogramBins, string histogramRange, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/statistics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (categorical != null)
            {
                uri.AppendQuery("categorical", categorical.Value, true);
            }
            if (c != null && !(c is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in c)
                {
                    uri.AppendQuery("c", param, true);
                }
            }
            if (p != null && !(p is ChangeTrackingList<int> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                foreach (var param in p)
                {
                    uri.AppendQuery("p", param, true);
                }
            }
            if (histogramBins != null)
            {
                uri.AppendQuery("histogram_bins", histogramBins, true);
            }
            if (histogramRange != null)
            {
                uri.AppendQuery("histogram_range", histogramRange, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGeoJsonStatisticsRequest(string collectionId, string itemId, RequestContent content, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string coordCrs, string resampling, int? maxSize, bool? categorical, IEnumerable<string> c, IEnumerable<int> p, string histogramBins, string histogramRange, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/statistics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (coordCrs != null)
            {
                uri.AppendQuery("coord-crs", coordCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (categorical != null)
            {
                uri.AppendQuery("categorical", categorical.Value, true);
            }
            if (c != null && !(c is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in c)
                {
                    uri.AppendQuery("c", param, true);
                }
            }
            if (p != null && !(p is ChangeTrackingList<int> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                foreach (var param in p)
                {
                    uri.AppendQuery("p", param, true);
                }
            }
            if (histogramBins != null)
            {
                uri.AppendQuery("histogram_bins", histogramBins, true);
            }
            if (histogramRange != null)
            {
                uri.AppendQuery("histogram_range", histogramRange, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTileRequest(string collectionId, string itemId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, string subdatasetName, IEnumerable<string> subdatasetBands, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200204);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(z, true);
            uri.AppendPath("/", false);
            uri.AppendPath(x, true);
            uri.AppendPath("/", false);
            uri.AppendPath(y, true);
            uri.AppendPath("@", false);
            uri.AppendPath(scale, true);
            uri.AppendPath("x.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileMatrixSetId != null)
            {
                uri.AppendQuery("tileMatrixSetId", tileMatrixSetId, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            if (subdatasetName != null)
            {
                uri.AppendQuery("subdataset_name", subdatasetName, true);
            }
            if (subdatasetBands != null && !(subdatasetBands is ChangeTrackingList<string> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                uri.AppendQueryDelimited("subdataset_bands", subdatasetBands, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", accept);
            return message;
        }

        internal HttpMessage CreateGetTileWithMatrixSetRequest(string collectionId, string itemId, string tileMatrixSetId, float z, float x, float y, float scale, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, string subdatasetName, IEnumerable<string> subdatasetBands, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(z, true);
            uri.AppendPath("/", false);
            uri.AppendPath(x, true);
            uri.AppendPath("/", false);
            uri.AppendPath(y, true);
            uri.AppendPath("@", false);
            uri.AppendPath(scale, true);
            uri.AppendPath("x.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            if (subdatasetName != null)
            {
                uri.AppendQuery("subdataset_name", subdatasetName, true);
            }
            if (subdatasetBands != null && !(subdatasetBands is ChangeTrackingList<string> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                uri.AppendQueryDelimited("subdataset_bands", subdatasetBands, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", accept);
            return message;
        }

        internal HttpMessage CreateGetTileJsonRequest(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/tilejson.json", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileMatrixSetId != null)
            {
                uri.AppendQuery("tileMatrixSetId", tileMatrixSetId, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", tileScale.Value, true);
            }
            if (minzoom != null)
            {
                uri.AppendQuery("minzoom", minzoom.Value, true);
            }
            if (maxzoom != null)
            {
                uri.AppendQuery("maxzoom", maxzoom.Value, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTileJsonWithMatrixSetRequest(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/tilejson.json", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", tileScale.Value, true);
            }
            if (minzoom != null)
            {
                uri.AppendQuery("minzoom", minzoom.Value, true);
            }
            if (maxzoom != null)
            {
                uri.AppendQuery("maxzoom", maxzoom.Value, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetWmtsCapabilitiesRequest(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200204);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/WMTSCapabilities.xml", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileMatrixSetId != null)
            {
                uri.AppendQuery("tileMatrixSetId", tileMatrixSetId, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", tileScale.Value, true);
            }
            if (minzoom != null)
            {
                uri.AppendQuery("minzoom", minzoom.Value, true);
            }
            if (maxzoom != null)
            {
                uri.AppendQuery("maxzoom", maxzoom.Value, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        internal HttpMessage CreateGetWmtsCapabilitiesWithMatrixSetRequest(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/WMTSCapabilities.xml", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", tileScale.Value, true);
            }
            if (minzoom != null)
            {
                uri.AppendQuery("minzoom", minzoom.Value, true);
            }
            if (maxzoom != null)
            {
                uri.AppendQuery("maxzoom", maxzoom.Value, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/xml");
            return message;
        }

        internal HttpMessage CreateGetPointRequest(string collectionId, string itemId, double lon, float lat, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string coordCrs, string resampling, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/point/", false);
            uri.AppendPath(lon, true);
            uri.AppendPath(",", false);
            uri.AppendPath(lat, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (coordCrs != null)
            {
                uri.AppendQuery("coord-crs", coordCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPreviewRequest(string collectionId, string itemId, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string format, string colorFormula, string dstCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/preview", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (format != null)
            {
                uri.AppendQuery("format", format, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (dstCrs != null)
            {
                uri.AppendQuery("dst-crs", dstCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (height != null)
            {
                uri.AppendQuery("height", height.Value, true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", width.Value, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", accept);
            return message;
        }

        internal HttpMessage CreateGetPreviewWithFormatRequest(string collectionId, string itemId, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/preview.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (dstCrs != null)
            {
                uri.AppendQuery("dst-crs", dstCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (height != null)
            {
                uri.AppendQuery("height", height.Value, true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", width.Value, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", accept);
            return message;
        }

        internal HttpMessage CreateGetPartRequest(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string coordCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/crop/", false);
            uri.AppendPath(minx, true);
            uri.AppendPath(",", false);
            uri.AppendPath(miny, true);
            uri.AppendPath(",", false);
            uri.AppendPath(maxx, true);
            uri.AppendPath(",", false);
            uri.AppendPath(maxy, true);
            uri.AppendPath(".", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (dstCrs != null)
            {
                uri.AppendQuery("dst-crs", dstCrs, true);
            }
            if (coordCrs != null)
            {
                uri.AppendQuery("coord-crs", coordCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (height != null)
            {
                uri.AppendQuery("height", height.Value, true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", width.Value, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", accept);
            return message;
        }

        internal HttpMessage CreateGetPartWithDimensionsRequest(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, float width, float height, string format, string accept, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string coordCrs, string resampling, int? maxSize, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/crop/", false);
            uri.AppendPath(minx, true);
            uri.AppendPath(",", false);
            uri.AppendPath(miny, true);
            uri.AppendPath(",", false);
            uri.AppendPath(maxx, true);
            uri.AppendPath(",", false);
            uri.AppendPath(maxy, true);
            uri.AppendPath("/", false);
            uri.AppendPath(width, true);
            uri.AppendPath("x", false);
            uri.AppendPath(height, true);
            uri.AppendPath(".", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (dstCrs != null)
            {
                uri.AppendQuery("dst-crs", dstCrs, true);
            }
            if (coordCrs != null)
            {
                uri.AppendQuery("coord-crs", coordCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", accept);
            return message;
        }

        internal HttpMessage CreateCropGeoJsonRequest(string collectionId, string itemId, string format, string accept, RequestContent content, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string coordCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/crop.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (coordCrs != null)
            {
                uri.AppendQuery("coord-crs", coordCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (height != null)
            {
                uri.AppendQuery("height", height.Value, true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", width.Value, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", accept);
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCropGeoJsonWithDimensionsRequest(string collectionId, string itemId, float width, float height, string format, string accept, RequestContent content, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string coordCrs, string resampling, int? maxSize, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/crop/", false);
            uri.AppendPath(width, true);
            uri.AppendPath("x", false);
            uri.AppendPath(height, true);
            uri.AppendPath(".", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var param in assets)
                {
                    uri.AppendQuery("assets", param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", assetAsBand.Value, true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", nodata.Value, true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", unscale.Value, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (coordCrs != null)
            {
                uri.AppendQuery("coord-crs", coordCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", maxSize.Value, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var param in rescale)
                {
                    uri.AppendQuery("rescale", param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", returnMask.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", accept);
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200204;
        private static ResponseClassifier ResponseClassifier200204 => _responseClassifier200204 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 204 });
    }
}
