// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Collections.Generic;
using Azure;
using Azure.Core;
using Microsoft.PlanetaryComputer;

namespace Customizations
{
    /// <summary></summary>
    public partial class StacApiClient
    {
        private static ResponseClassifier _pipelineMessageClassifier200;
        private static ResponseClassifier _pipelineMessageClassifier200204;
        private static ResponseClassifier _pipelineMessageClassifier201204;
        private static ResponseClassifier _pipelineMessageClassifier202;

        private static ResponseClassifier PipelineMessageClassifier200 => _pipelineMessageClassifier200 = new StatusCodeClassifier(stackalloc ushort[] { 200 });

        private static ResponseClassifier PipelineMessageClassifier200204 => _pipelineMessageClassifier200204 = new StatusCodeClassifier(stackalloc ushort[] { 200, 204 });

        private static ResponseClassifier PipelineMessageClassifier201204 => _pipelineMessageClassifier201204 = new StatusCodeClassifier(stackalloc ushort[] { 201, 204 });

        private static ResponseClassifier PipelineMessageClassifier202 => _pipelineMessageClassifier202 = new StatusCodeClassifier(stackalloc ushort[] { 202 });

        internal HttpMessage CreateGetStacLandingPageRequest(RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/stac", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllCollectionsRequest(string sign, int? duration, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/collections", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (sign != null)
            {
                uri.AppendQuery("sign", sign, true);
            }
            if (duration != null)
            {
                uri.AppendQuery("duration", Microsoft.PlanetaryComputer.TypeFormatters.ConvertToString(duration, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateCollectionRequest(RequestContent content, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier202);
            Request request = message.Request;
            request.Method = RequestMethod.Post;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/collections", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetCollectionRequest(string collectionId, string sign, int? duration, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (sign != null)
            {
                uri.AppendQuery("sign", sign, true);
            }
            if (duration != null)
            {
                uri.AppendQuery("duration", Microsoft.PlanetaryComputer.TypeFormatters.ConvertToString(duration, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrReplaceCollectionRequest(string collectionId, RequestContent content, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier202);
            Request request = message.Request;
            request.Method = RequestMethod.Put;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteCollectionRequest(string collectionId, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier202);
            Request request = message.Request;
            request.Method = RequestMethod.Delete;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetItemsAsFeaturesRequest(string collectionId, long? limit, IEnumerable<string> bbox, string datetime, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", Microsoft.PlanetaryComputer.TypeFormatters.ConvertToString(limit, null), true);
            }
            if (bbox != null && !(bbox is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in bbox)
                {
                    uri.AppendQuery("bbox", @param, true);
                }
            }
            if (datetime != null)
            {
                uri.AppendQuery("datetime", datetime, true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateItemRequest(string collectionId, RequestContent content, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier202);
            Request request = message.Request;
            request.Method = RequestMethod.Post;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetItemRequest(string collectionId, string itemId, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(itemId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrReplaceItemRequest(string collectionId, string itemId, RequestContent content, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier202);
            Request request = message.Request;
            request.Method = RequestMethod.Put;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(itemId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateItemRequest(string collectionId, string itemId, RequestContent content, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier202);
            Request request = message.Request;
            request.Method = RequestMethod.Patch;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(itemId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Content-Type", "application/merge-patch+json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteItemRequest(string collectionId, string itemId, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier202);
            Request request = message.Request;
            request.Method = RequestMethod.Delete;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(itemId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllQueryablesRequest(RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/stac/queryables", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllQueryablesByCollectionRequest(string collectionId, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/stac/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/queryables", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateQueryablesRequest(string collectionId, RequestContent content, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier201204);
            Request request = message.Request;
            request.Method = RequestMethod.Post;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/stac/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/queryables", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetConformanceClassRequest(RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/stac/conformance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSearchOperationsRequest(IEnumerable<string> collections, IEnumerable<string> ids, IEnumerable<double> bbox, string intersects, string datetime, int? limit, string sign, int? duration, string query, string sortBy, string fields, string filter, string token, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/stac/search", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (collections != null && !(collections is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("collections", collections, ",", null, true);
            }
            if (ids != null && !(ids is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("ids", ids, ",", null, true);
            }
            if (bbox != null && !(bbox is ChangeTrackingList<double> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                uri.AppendQueryDelimited("bbox", bbox, ",", null, true);
            }
            if (intersects != null)
            {
                uri.AppendQuery("intersects", intersects, true);
            }
            if (datetime != null)
            {
                uri.AppendQuery("datetime", datetime, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", Microsoft.PlanetaryComputer.TypeFormatters.ConvertToString(limit, null), true);
            }
            if (sign != null)
            {
                uri.AppendQuery("sign", sign, true);
            }
            if (duration != null)
            {
                uri.AppendQuery("duration", Microsoft.PlanetaryComputer.TypeFormatters.ConvertToString(duration, null), true);
            }
            if (query != null)
            {
                uri.AppendQuery("query", query, true);
            }
            if (sortBy != null)
            {
                uri.AppendQuery("sortby", sortBy, true);
            }
            if (fields != null)
            {
                uri.AppendQuery("fields", fields, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            if (token != null)
            {
                uri.AppendQuery("token", token, true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateSearchOperationsRequest(RequestContent content, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Post;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/stac/search", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }
    }
}
