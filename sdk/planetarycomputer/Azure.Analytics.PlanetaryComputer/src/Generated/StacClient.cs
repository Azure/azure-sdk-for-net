// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.PlanetaryComputer
{
    /// <summary> The StacClient sub-client. </summary>
    public partial class StacClient
    {
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of StacClient for mocking. </summary>
        protected StacClient()
        {
        }

        /// <summary> Initializes a new instance of StacClient. </summary>
        /// <param name="clientDiagnostics"> The ClientDiagnostics is used to provide tracing support for the client library. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> Service endpoint. </param>
        /// <param name="apiVersion"></param>
        internal StacClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _endpoint = endpoint;
            Pipeline = pipeline;
            _apiVersion = apiVersion;
        }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline { get; }

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary>
        /// [Protocol Method] Create a new asset in the Collection metadata and write the associated
        /// file to managed storage.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> The contentType to use which has the multipart/form-data boundary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateCollectionAsset(string collectionId, RequestContent content, string contentType, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateCollectionAsset");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateCollectionAssetRequest(collectionId, content, contentType, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new asset in the Collection metadata and write the associated
        /// file to managed storage.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> The contentType to use which has the multipart/form-data boundary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateCollectionAssetAsync(string collectionId, RequestContent content, string contentType, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateCollectionAsset");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateCollectionAssetRequest(collectionId, content, contentType, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing asset in a given collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="assetId"> STAC Asset ID. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> The contentType to use which has the multipart/form-data boundary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="assetId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateOrReplaceCollectionAsset(string collectionId, string assetId, RequestContent content, string contentType, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceCollectionAsset");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(assetId, nameof(assetId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceCollectionAssetRequest(collectionId, assetId, content, contentType, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing asset in a given collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="assetId"> STAC Asset ID. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> The contentType to use which has the multipart/form-data boundary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="assetId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateOrReplaceCollectionAssetAsync(string collectionId, string assetId, RequestContent content, string contentType, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceCollectionAsset");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(assetId, nameof(assetId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceCollectionAssetRequest(collectionId, assetId, content, contentType, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete an asset from a given collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="assetId"> STAC Asset ID. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteCollectionAsset(string collectionId, string assetId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteCollectionAsset");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(assetId, nameof(assetId));

                using HttpMessage message = CreateDeleteCollectionAssetRequest(collectionId, assetId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete an asset from a given collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="assetId"> STAC Asset ID. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteCollectionAssetAsync(string collectionId, string assetId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteCollectionAsset");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(assetId, nameof(assetId));

                using HttpMessage message = CreateDeleteCollectionAssetRequest(collectionId, assetId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete an asset from a given collection. </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="assetId"> STAC Asset ID. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response DeleteCollectionAsset(string collectionId, string assetId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(assetId, nameof(assetId));

            return DeleteCollectionAsset(collectionId, assetId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Delete an asset from a given collection. </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="assetId"> STAC Asset ID. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="assetId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> DeleteCollectionAssetAsync(string collectionId, string assetId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(assetId, nameof(assetId));

            return await DeleteCollectionAssetAsync(collectionId, assetId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get the complete user configuration for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCollectionConfiguration(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollectionConfiguration");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetCollectionConfigurationRequest(collectionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the complete user configuration for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCollectionConfigurationAsync(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollectionConfiguration");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetCollectionConfigurationRequest(collectionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the complete user configuration for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<UserCollectionSettings> GetCollectionConfiguration(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetCollectionConfiguration(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((UserCollectionSettings)result, result);
        }

        /// <summary> Get the complete user configuration for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<UserCollectionSettings>> GetCollectionConfigurationAsync(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetCollectionConfigurationAsync(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((UserCollectionSettings)result, result);
        }

        /// <summary>
        /// [Protocol Method] Add a mosaic definition to a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AddMosaic(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.AddMosaic");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddMosaicRequest(collectionId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a mosaic definition to a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AddMosaicAsync(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.AddMosaic");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddMosaicRequest(collectionId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a mosaic definition to a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Mosaic definition to be created or updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacMosaic> AddMosaic(string collectionId, StacMosaic body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = AddMosaic(collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacMosaic)result, result);
        }

        /// <summary> Add a mosaic definition to a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Mosaic definition to be created or updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacMosaic>> AddMosaicAsync(string collectionId, StacMosaic body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await AddMosaicAsync(collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacMosaic)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update a mosaic definition from a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="mosaicId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateOrReplaceMosaic(string collectionId, string mosaicId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceMosaic");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceMosaicRequest(collectionId, mosaicId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a mosaic definition from a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="mosaicId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateOrReplaceMosaicAsync(string collectionId, string mosaicId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceMosaic");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceMosaicRequest(collectionId, mosaicId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update a mosaic definition from a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="body"> Mosaic definition to be created or updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="mosaicId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacMosaic> CreateOrReplaceMosaic(string collectionId, string mosaicId, StacMosaic body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = CreateOrReplaceMosaic(collectionId, mosaicId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacMosaic)result, result);
        }

        /// <summary> Update a mosaic definition from a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="body"> Mosaic definition to be created or updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="mosaicId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacMosaic>> CreateOrReplaceMosaicAsync(string collectionId, string mosaicId, StacMosaic body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await CreateOrReplaceMosaicAsync(collectionId, mosaicId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacMosaic)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete a mosaic definition from a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteMosaic(string collectionId, string mosaicId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteMosaic");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));

                using HttpMessage message = CreateDeleteMosaicRequest(collectionId, mosaicId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a mosaic definition from a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteMosaicAsync(string collectionId, string mosaicId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteMosaic");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));

                using HttpMessage message = CreateDeleteMosaicRequest(collectionId, mosaicId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a mosaic definition from a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response DeleteMosaic(string collectionId, string mosaicId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));

            return DeleteMosaic(collectionId, mosaicId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Delete a mosaic definition from a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> DeleteMosaicAsync(string collectionId, string mosaicId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));

            return await DeleteMosaicAsync(collectionId, mosaicId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get a mosaic definition from a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetMosaic(string collectionId, string mosaicId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetMosaic");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));

                using HttpMessage message = CreateGetMosaicRequest(collectionId, mosaicId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a mosaic definition from a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetMosaicAsync(string collectionId, string mosaicId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetMosaic");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));

                using HttpMessage message = CreateGetMosaicRequest(collectionId, mosaicId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a mosaic definition from a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacMosaic> GetMosaic(string collectionId, string mosaicId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));

            Response result = GetMosaic(collectionId, mosaicId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacMosaic)result, result);
        }

        /// <summary> Get a mosaic definition from a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="mosaicId"> Unique identifier for the mosaic configuration. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="mosaicId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacMosaic>> GetMosaicAsync(string collectionId, string mosaicId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(mosaicId, nameof(mosaicId));

            Response result = await GetMosaicAsync(collectionId, mosaicId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacMosaic)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get the mosaic definitions for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetMosaics(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetMosaics");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetMosaicsRequest(collectionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the mosaic definitions for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetMosaicsAsync(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetMosaics");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetMosaicsRequest(collectionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the mosaic definitions for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<StacMosaic>> GetMosaics(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetMosaics(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            IList<StacMosaic> value = new List<StacMosaic>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(StacMosaic.DeserializeStacMosaic(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<StacMosaic>)value, result);
        }

        /// <summary> Get the mosaic definitions for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<StacMosaic>>> GetMosaicsAsync(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetMosaicsAsync(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            IList<StacMosaic> value = new List<StacMosaic>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(StacMosaic.DeserializeStacMosaic(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<StacMosaic>)value, result);
        }

        /// <summary> Create a new collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Operation CreateCollection(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateCollectionRequest(content, context);
                return ProtocolOperationHelpers.ProcessMessage(Pipeline, message, ClientDiagnostics, "StacClient.CreateCollection", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Operation> CreateCollectionAsync(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateCollectionRequest(content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(Pipeline, message, ClientDiagnostics, "StacClient.CreateCollectionAsync", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="body"> Request collection body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        public virtual Operation CreateCollection(WaitUntil waitUntil, StacCollectionModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            return CreateCollection(waitUntil, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Create a new collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="body"> Request collection body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        public virtual async Task<Operation> CreateCollectionAsync(WaitUntil waitUntil, StacCollectionModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            return await CreateCollectionAsync(waitUntil, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary> Create or replace a collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Operation CreateOrReplaceCollection(WaitUntil waitUntil, string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceCollectionRequest(collectionId, content, context);
                return ProtocolOperationHelpers.ProcessMessage(Pipeline, message, ClientDiagnostics, "StacClient.CreateOrReplaceCollection", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or replace a collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Operation> CreateOrReplaceCollectionAsync(WaitUntil waitUntil, string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceCollectionRequest(collectionId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(Pipeline, message, ClientDiagnostics, "StacClient.CreateOrReplaceCollectionAsync", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or replace a collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="body"> Request collection body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Operation CreateOrReplaceCollection(WaitUntil waitUntil, string collectionId, StacCollectionModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            return CreateOrReplaceCollection(waitUntil, collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Create or replace a collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="body"> Request collection body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Operation> CreateOrReplaceCollectionAsync(WaitUntil waitUntil, string collectionId, StacCollectionModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            return await CreateOrReplaceCollectionAsync(waitUntil, collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary> Delete a collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Operation DeleteCollection(WaitUntil waitUntil, string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateDeleteCollectionRequest(collectionId, context);
                return ProtocolOperationHelpers.ProcessMessage(Pipeline, message, ClientDiagnostics, "StacClient.DeleteCollection", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Operation> DeleteCollectionAsync(WaitUntil waitUntil, string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateDeleteCollectionRequest(collectionId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(Pipeline, message, ClientDiagnostics, "StacClient.DeleteCollectionAsync", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Operation DeleteCollection(WaitUntil waitUntil, string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            return DeleteCollection(waitUntil, collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Delete a collection in the GeoCatalog instance. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Operation> DeleteCollectionAsync(WaitUntil waitUntil, string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            return await DeleteCollectionAsync(waitUntil, collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get a collection in the GeoCatalog instance
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="sign"> Whether to sign asset URLs in the response. </param>
        /// <param name="durationInMinutes"> URL signature duration in minutes. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCollection(string collectionId, string sign, int? durationInMinutes, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetCollectionRequest(collectionId, sign, durationInMinutes, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a collection in the GeoCatalog instance
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="sign"> Whether to sign asset URLs in the response. </param>
        /// <param name="durationInMinutes"> URL signature duration in minutes. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCollectionAsync(string collectionId, string sign, int? durationInMinutes, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetCollectionRequest(collectionId, sign, durationInMinutes, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a collection in the GeoCatalog instance. </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="sign"> Whether to sign asset URLs in the response. </param>
        /// <param name="durationInMinutes"> URL signature duration in minutes. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacCollectionModel> GetCollection(string collectionId, StacAssetUrlSigningMode? sign = default, int? durationInMinutes = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetCollection(collectionId, sign?.ToString(), durationInMinutes, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacCollectionModel)result, result);
        }

        /// <summary> Get a collection in the GeoCatalog instance. </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="sign"> Whether to sign asset URLs in the response. </param>
        /// <param name="durationInMinutes"> URL signature duration in minutes. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacCollectionModel>> GetCollectionAsync(string collectionId, StacAssetUrlSigningMode? sign = default, int? durationInMinutes = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetCollectionAsync(collectionId, sign?.ToString(), durationInMinutes, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacCollectionModel)result, result);
        }

        /// <summary>
        /// [Protocol Method] List all collections in the GeoCatalog instance
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="sign"> Whether to sign asset URLs in the response. </param>
        /// <param name="durationInMinutes"> URL signature duration in minutes. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCollections(string sign, int? durationInMinutes, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollections");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCollectionsRequest(sign, durationInMinutes, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all collections in the GeoCatalog instance
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="sign"> Whether to sign asset URLs in the response. </param>
        /// <param name="durationInMinutes"> URL signature duration in minutes. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCollectionsAsync(string sign, int? durationInMinutes, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollections");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCollectionsRequest(sign, durationInMinutes, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all collections in the GeoCatalog instance. </summary>
        /// <param name="sign"> Whether to sign asset URLs in the response. </param>
        /// <param name="durationInMinutes"> URL signature duration in minutes. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacCatalogCollections> GetCollections(StacAssetUrlSigningMode? sign = default, int? durationInMinutes = default, CancellationToken cancellationToken = default)
        {
            Response result = GetCollections(sign?.ToString(), durationInMinutes, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacCatalogCollections)result, result);
        }

        /// <summary> List all collections in the GeoCatalog instance. </summary>
        /// <param name="sign"> Whether to sign asset URLs in the response. </param>
        /// <param name="durationInMinutes"> URL signature duration in minutes. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacCatalogCollections>> GetCollectionsAsync(StacAssetUrlSigningMode? sign = default, int? durationInMinutes = default, CancellationToken cancellationToken = default)
        {
            Response result = await GetCollectionsAsync(sign?.ToString(), durationInMinutes, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacCatalogCollections)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get the partitiontype for a GeoCatalog Collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetPartitionType(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetPartitionType");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetPartitionTypeRequest(collectionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the partitiontype for a GeoCatalog Collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetPartitionTypeAsync(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetPartitionType");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetPartitionTypeRequest(collectionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the partitiontype for a GeoCatalog Collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<PartitionType> GetPartitionType(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetPartitionType(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((PartitionType)result, result);
        }

        /// <summary> Get the partitiontype for a GeoCatalog Collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<PartitionType>> GetPartitionTypeAsync(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetPartitionTypeAsync(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((PartitionType)result, result);
        }

        /// <summary>
        /// [Protocol Method] Updates partition type for a GeoCatalog Collection. This will
        /// determine the partitioning scheme for items within the database,
        /// and can only be set before any items are loaded.
        /// 
        /// Ideal partitioning schemes result in partitions of roughly 100k items each.
        /// 
        /// The default partitioning scheme is "none" which does not partition items.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response ReplacePartitionType(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.ReplacePartitionType");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateReplacePartitionTypeRequest(collectionId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates partition type for a GeoCatalog Collection. This will
        /// determine the partitioning scheme for items within the database,
        /// and can only be set before any items are loaded.
        /// 
        /// Ideal partitioning schemes result in partitions of roughly 100k items each.
        /// 
        /// The default partitioning scheme is "none" which does not partition items.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> ReplacePartitionTypeAsync(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.ReplacePartitionType");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateReplacePartitionTypeRequest(collectionId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates partition type for a GeoCatalog Collection. This will
        /// determine the partitioning scheme for items within the database,
        /// and can only be set before any items are loaded.
        /// 
        /// Ideal partitioning schemes result in partitions of roughly 100k items each.
        /// 
        /// The default partitioning scheme is "none" which does not partition items.
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Partition type configuration determining how items are partitioned in storage. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response ReplacePartitionType(string collectionId, PartitionType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            return ReplacePartitionType(collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary>
        /// Updates partition type for a GeoCatalog Collection. This will
        /// determine the partitioning scheme for items within the database,
        /// and can only be set before any items are loaded.
        /// 
        /// Ideal partitioning schemes result in partitions of roughly 100k items each.
        /// 
        /// The default partitioning scheme is "none" which does not partition items.
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Partition type configuration determining how items are partitioned in storage. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> ReplacePartitionTypeAsync(string collectionId, PartitionType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            return await ReplacePartitionTypeAsync(collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Add a render option for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateRenderOption(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateRenderOption");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateRenderOptionRequest(collectionId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a render option for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateRenderOptionAsync(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateRenderOption");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateRenderOptionRequest(collectionId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a render option for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Render option configuration to be created or updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<RenderOptionModel> CreateRenderOption(string collectionId, RenderOptionModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = CreateRenderOption(collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((RenderOptionModel)result, result);
        }

        /// <summary> Add a render option for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Render option configuration to be created or updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<RenderOptionModel>> CreateRenderOptionAsync(string collectionId, RenderOptionModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await CreateRenderOptionAsync(collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((RenderOptionModel)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update a render option for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="renderOptionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateOrReplaceRenderOption(string collectionId, string renderOptionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceRenderOption");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceRenderOptionRequest(collectionId, renderOptionId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a render option for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="renderOptionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateOrReplaceRenderOptionAsync(string collectionId, string renderOptionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceRenderOption");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceRenderOptionRequest(collectionId, renderOptionId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update a render option for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="body"> Render option configuration to be created or updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="renderOptionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<RenderOptionModel> CreateOrReplaceRenderOption(string collectionId, string renderOptionId, RenderOptionModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = CreateOrReplaceRenderOption(collectionId, renderOptionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((RenderOptionModel)result, result);
        }

        /// <summary> Update a render option for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="body"> Render option configuration to be created or updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="renderOptionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<RenderOptionModel>> CreateOrReplaceRenderOptionAsync(string collectionId, string renderOptionId, RenderOptionModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await CreateOrReplaceRenderOptionAsync(collectionId, renderOptionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((RenderOptionModel)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete a render option for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteRenderOption(string collectionId, string renderOptionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteRenderOption");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));

                using HttpMessage message = CreateDeleteRenderOptionRequest(collectionId, renderOptionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a render option for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteRenderOptionAsync(string collectionId, string renderOptionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteRenderOption");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));

                using HttpMessage message = CreateDeleteRenderOptionRequest(collectionId, renderOptionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a render option for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response DeleteRenderOption(string collectionId, string renderOptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));

            return DeleteRenderOption(collectionId, renderOptionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Delete a render option for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> DeleteRenderOptionAsync(string collectionId, string renderOptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));

            return await DeleteRenderOptionAsync(collectionId, renderOptionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get a render option for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetRenderOption(string collectionId, string renderOptionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetRenderOption");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));

                using HttpMessage message = CreateGetRenderOptionRequest(collectionId, renderOptionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a render option for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetRenderOptionAsync(string collectionId, string renderOptionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetRenderOption");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));

                using HttpMessage message = CreateGetRenderOptionRequest(collectionId, renderOptionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a render option for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<RenderOptionModel> GetRenderOption(string collectionId, string renderOptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));

            Response result = GetRenderOption(collectionId, renderOptionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((RenderOptionModel)result, result);
        }

        /// <summary> Get a render option for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="renderOptionId"> Unique identifier for the render option. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="renderOptionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<RenderOptionModel>> GetRenderOptionAsync(string collectionId, string renderOptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(renderOptionId, nameof(renderOptionId));

            Response result = await GetRenderOptionAsync(collectionId, renderOptionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((RenderOptionModel)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get all render options for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetRenderOptions(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetRenderOptions");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetRenderOptionsRequest(collectionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all render options for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetRenderOptionsAsync(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetRenderOptions");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetRenderOptionsRequest(collectionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all render options for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<RenderOptionModel>> GetRenderOptions(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetRenderOptions(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            IList<RenderOptionModel> value = new List<RenderOptionModel>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(RenderOptionModel.DeserializeRenderOptionModel(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<RenderOptionModel>)value, result);
        }

        /// <summary> Get all render options for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<RenderOptionModel>>> GetRenderOptionsAsync(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetRenderOptionsAsync(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            IList<RenderOptionModel> value = new List<RenderOptionModel>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(RenderOptionModel.DeserializeRenderOptionModel(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<RenderOptionModel>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Get thumbnail for given collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCollectionThumbnail(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollectionThumbnail");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetCollectionThumbnailRequest(collectionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get thumbnail for given collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCollectionThumbnailAsync(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollectionThumbnail");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetCollectionThumbnailRequest(collectionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get thumbnail for given collection. </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<BinaryData> GetCollectionThumbnail(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetCollectionThumbnail(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue(result.Content, result);
        }

        /// <summary> Get thumbnail for given collection. </summary>
        /// <param name="collectionId"> STAC Collection ID. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<BinaryData>> GetCollectionThumbnailAsync(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetCollectionThumbnailAsync(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue(result.Content, result);
        }

        /// <summary>
        /// [Protocol Method] Get the tile settings for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetTileSettings(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetTileSettings");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetTileSettingsRequest(collectionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the tile settings for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetTileSettingsAsync(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetTileSettings");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetTileSettingsRequest(collectionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the tile settings for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<TileSettings> GetTileSettings(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetTileSettings(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((TileSettings)result, result);
        }

        /// <summary> Get the tile settings for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<TileSettings>> GetTileSettingsAsync(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetTileSettingsAsync(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((TileSettings)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update the tile settings for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response ReplaceTileSettings(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.ReplaceTileSettings");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateReplaceTileSettingsRequest(collectionId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the tile settings for a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> ReplaceTileSettingsAsync(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.ReplaceTileSettings");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateReplaceTileSettingsRequest(collectionId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update the tile settings for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Tile settings configuration to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<TileSettings> ReplaceTileSettings(string collectionId, TileSettings body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = ReplaceTileSettings(collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((TileSettings)result, result);
        }

        /// <summary> Update the tile settings for a given collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Tile settings configuration to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<TileSettings>> ReplaceTileSettingsAsync(string collectionId, TileSettings body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await ReplaceTileSettingsAsync(collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((TileSettings)result, result);
        }

        /// <summary>
        /// [Protocol Method] Returns the STAC conformance classes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetConformanceClass(RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetConformanceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetConformanceClassRequest(context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns the STAC conformance classes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetConformanceClassAsync(RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetConformanceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetConformanceClassRequest(context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the STAC conformance classes. </summary>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacConformanceClasses> GetConformanceClass(CancellationToken cancellationToken = default)
        {
            Response result = GetConformanceClass(cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacConformanceClasses)result, result);
        }

        /// <summary> Returns the STAC conformance classes. </summary>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacConformanceClasses>> GetConformanceClassAsync(CancellationToken cancellationToken = default)
        {
            Response result = await GetConformanceClassAsync(cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacConformanceClasses)result, result);
        }

        /// <summary> Create a new STAC item or a set of items in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Operation CreateItem(WaitUntil waitUntil, string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateItemRequest(collectionId, content, context);
                return ProtocolOperationHelpers.ProcessMessage(Pipeline, message, ClientDiagnostics, "StacClient.CreateItem", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new STAC item or a set of items in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Operation> CreateItemAsync(WaitUntil waitUntil, string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateItemRequest(collectionId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(Pipeline, message, ClientDiagnostics, "StacClient.CreateItemAsync", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new STAC item or a set of items in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="body">
        /// STAC Item or StacItemCollection
        /// 
        /// Represents a STAC Item or StacItemCollection as defined by the STAC 1.0.0 standard.
        /// 
        /// **Item**: A GeoJSON Feature that represents a single spatiotemporal asset.
        /// It includes metadata such as geometry, datetime, and links to related assets.
        /// Example: A satellite image with its metadata.
        /// 
        /// **StacItemCollection**: A GeoJSON FeatureCollection that contains multiple Items.
        /// It is used to group multiple related Items together, such as a collection of satellite images.
        /// 
        /// This union allows the request body to accept either a single Item or a collection of Items.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Operation CreateItem(WaitUntil waitUntil, string collectionId, StacItemOrStacItemCollection body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            return CreateItem(waitUntil, collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Create a new STAC item or a set of items in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="body">
        /// STAC Item or StacItemCollection
        /// 
        /// Represents a STAC Item or StacItemCollection as defined by the STAC 1.0.0 standard.
        /// 
        /// **Item**: A GeoJSON Feature that represents a single spatiotemporal asset.
        /// It includes metadata such as geometry, datetime, and links to related assets.
        /// Example: A satellite image with its metadata.
        /// 
        /// **StacItemCollection**: A GeoJSON FeatureCollection that contains multiple Items.
        /// It is used to group multiple related Items together, such as a collection of satellite images.
        /// 
        /// This union allows the request body to accept either a single Item or a collection of Items.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Operation> CreateItemAsync(WaitUntil waitUntil, string collectionId, StacItemOrStacItemCollection body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            return await CreateItemAsync(waitUntil, collectionId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary> Create or replace a STAC item in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Operation CreateOrReplaceItem(WaitUntil waitUntil, string collectionId, string itemId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceItemRequest(collectionId, itemId, content, context);
                return ProtocolOperationHelpers.ProcessMessage(Pipeline, message, ClientDiagnostics, "StacClient.CreateOrReplaceItem", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or replace a STAC item in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Operation> CreateOrReplaceItemAsync(WaitUntil waitUntil, string collectionId, string itemId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceItemRequest(collectionId, itemId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(Pipeline, message, ClientDiagnostics, "StacClient.CreateOrReplaceItemAsync", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or replace a STAC item in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="body"> STAC Item. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Operation CreateOrReplaceItem(WaitUntil waitUntil, string collectionId, string itemId, StacItemModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(body, nameof(body));

            return CreateOrReplaceItem(waitUntil, collectionId, itemId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Create or replace a STAC item in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="body"> STAC Item. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Operation> CreateOrReplaceItemAsync(WaitUntil waitUntil, string collectionId, string itemId, StacItemModel body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
            Argument.AssertNotNull(body, nameof(body));

            return await CreateOrReplaceItemAsync(waitUntil, collectionId, itemId, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary> Delete a STAC item from a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Operation DeleteItem(WaitUntil waitUntil, string collectionId, string itemId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

                using HttpMessage message = CreateDeleteItemRequest(collectionId, itemId, context);
                return ProtocolOperationHelpers.ProcessMessage(Pipeline, message, ClientDiagnostics, "StacClient.DeleteItem", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a STAC item from a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Operation> DeleteItemAsync(WaitUntil waitUntil, string collectionId, string itemId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

                using HttpMessage message = CreateDeleteItemRequest(collectionId, itemId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(Pipeline, message, ClientDiagnostics, "StacClient.DeleteItemAsync", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a STAC item from a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Operation DeleteItem(WaitUntil waitUntil, string collectionId, string itemId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            return DeleteItem(waitUntil, collectionId, itemId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Delete a STAC item from a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Operation> DeleteItemAsync(WaitUntil waitUntil, string collectionId, string itemId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            return await DeleteItemAsync(waitUntil, collectionId, itemId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Fetch a single STAC Item
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetItem(string collectionId, string itemId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

                using HttpMessage message = CreateGetItemRequest(collectionId, itemId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Fetch a single STAC Item
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetItemAsync(string collectionId, string itemId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

                using HttpMessage message = CreateGetItemRequest(collectionId, itemId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Fetch a single STAC Item. </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacItemModel> GetItem(string collectionId, string itemId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            Response result = GetItem(collectionId, itemId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacItemModel)result, result);
        }

        /// <summary> Fetch a single STAC Item. </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacItemModel>> GetItemAsync(string collectionId, string itemId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));

            Response result = await GetItemAsync(collectionId, itemId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacItemModel)result, result);
        }

        /// <summary>
        /// [Protocol Method] Fetch features of the feature collection with id `collectionId`.
        /// 
        /// Every feature in a dataset belongs to a collection. A dataset may
        /// consist of multiple feature collections. A feature collection is often a
        /// collection of features of a similar type, based on a common schema.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="limit">
        /// The optional limit parameter recommends the number of items that should be present in the response document.
        /// 
        /// If the limit parameter value is greater than advertised limit maximum, the server must return the
        /// maximum possible number of items, rather than responding with an error.
        /// 
        /// Only items are counted that are on the first level of the collection in the response document.
        /// Nested objects contained within the explicitly requested items must not be counted.
        /// 
        /// Minimum = 1. Maximum = 10000. Default = 10.
        /// </param>
        /// <param name="boundingBox">
        /// Only features that have a geometry that intersects the bounding box are selected.
        /// The bounding box is provided as four or six numbers, depending on whether the
        /// coordinate reference system includes a vertical axis (height or depth):
        /// 
        /// - Lower left corner, coordinate axis 1
        /// - Lower left corner, coordinate axis 2
        /// - Minimum value, coordinate axis 3 (optional)
        /// - Upper right corner, coordinate axis 1
        /// - Upper right corner, coordinate axis 2
        /// - Maximum value, coordinate axis 3 (optional)
        /// 
        /// The coordinate reference system of the values is WGS 84 longitude/latitude
        /// (http://www.opengis.net/def/crs/OGC/1.3/CRS84).
        /// 
        /// For WGS 84 longitude/latitude the values are in most cases the sequence of
        /// minimum longitude, minimum latitude, maximum longitude and maximum latitude.
        /// However, in cases where the box spans the antimeridian the first value
        /// (west-most box edge) is larger than the third value (east-most box edge).
        /// 
        /// If the vertical axis is included, the third and the sixth number are
        /// the bottom and the top of the 3-dimensional bounding box.
        /// 
        /// If a feature has multiple spatial geometry properties, it is the decision of the
        /// server whether only a single spatial geometry property is used to determine
        /// the extent or all relevant geometries.
        /// </param>
        /// <param name="datetime">
        /// Either a date-time or an interval, open or closed. Date and time expressions
        /// adhere to RFC 3339. Open intervals are expressed using double-dots.
        /// 
        /// Examples:
        /// 
        /// - A date-time: "2018-02-12T23:20:50Z"
        /// - A closed interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z"
        /// - Open intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"
        /// 
        /// Only features that have a temporal property that intersects the value of
        /// `datetime` are selected.
        /// 
        /// If a feature has multiple temporal properties, it is the decision of the
        /// server whether only a single temporal property is used to determine
        /// the extent or all relevant temporal properties.
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetItems(string collectionId, int? limit, IEnumerable<string> boundingBox, string datetime, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetItems");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetItemsRequest(collectionId, limit, boundingBox, datetime, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Fetch features of the feature collection with id `collectionId`.
        /// 
        /// Every feature in a dataset belongs to a collection. A dataset may
        /// consist of multiple feature collections. A feature collection is often a
        /// collection of features of a similar type, based on a common schema.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="limit">
        /// The optional limit parameter recommends the number of items that should be present in the response document.
        /// 
        /// If the limit parameter value is greater than advertised limit maximum, the server must return the
        /// maximum possible number of items, rather than responding with an error.
        /// 
        /// Only items are counted that are on the first level of the collection in the response document.
        /// Nested objects contained within the explicitly requested items must not be counted.
        /// 
        /// Minimum = 1. Maximum = 10000. Default = 10.
        /// </param>
        /// <param name="boundingBox">
        /// Only features that have a geometry that intersects the bounding box are selected.
        /// The bounding box is provided as four or six numbers, depending on whether the
        /// coordinate reference system includes a vertical axis (height or depth):
        /// 
        /// - Lower left corner, coordinate axis 1
        /// - Lower left corner, coordinate axis 2
        /// - Minimum value, coordinate axis 3 (optional)
        /// - Upper right corner, coordinate axis 1
        /// - Upper right corner, coordinate axis 2
        /// - Maximum value, coordinate axis 3 (optional)
        /// 
        /// The coordinate reference system of the values is WGS 84 longitude/latitude
        /// (http://www.opengis.net/def/crs/OGC/1.3/CRS84).
        /// 
        /// For WGS 84 longitude/latitude the values are in most cases the sequence of
        /// minimum longitude, minimum latitude, maximum longitude and maximum latitude.
        /// However, in cases where the box spans the antimeridian the first value
        /// (west-most box edge) is larger than the third value (east-most box edge).
        /// 
        /// If the vertical axis is included, the third and the sixth number are
        /// the bottom and the top of the 3-dimensional bounding box.
        /// 
        /// If a feature has multiple spatial geometry properties, it is the decision of the
        /// server whether only a single spatial geometry property is used to determine
        /// the extent or all relevant geometries.
        /// </param>
        /// <param name="datetime">
        /// Either a date-time or an interval, open or closed. Date and time expressions
        /// adhere to RFC 3339. Open intervals are expressed using double-dots.
        /// 
        /// Examples:
        /// 
        /// - A date-time: "2018-02-12T23:20:50Z"
        /// - A closed interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z"
        /// - Open intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"
        /// 
        /// Only features that have a temporal property that intersects the value of
        /// `datetime` are selected.
        /// 
        /// If a feature has multiple temporal properties, it is the decision of the
        /// server whether only a single temporal property is used to determine
        /// the extent or all relevant temporal properties.
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetItemsAsync(string collectionId, int? limit, IEnumerable<string> boundingBox, string datetime, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetItems");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetItemsRequest(collectionId, limit, boundingBox, datetime, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Fetch features of the feature collection with id `collectionId`.
        /// 
        /// Every feature in a dataset belongs to a collection. A dataset may
        /// consist of multiple feature collections. A feature collection is often a
        /// collection of features of a similar type, based on a common schema.
        /// </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="limit">
        /// The optional limit parameter recommends the number of items that should be present in the response document.
        /// 
        /// If the limit parameter value is greater than advertised limit maximum, the server must return the
        /// maximum possible number of items, rather than responding with an error.
        /// 
        /// Only items are counted that are on the first level of the collection in the response document.
        /// Nested objects contained within the explicitly requested items must not be counted.
        /// 
        /// Minimum = 1. Maximum = 10000. Default = 10.
        /// </param>
        /// <param name="boundingBox">
        /// Only features that have a geometry that intersects the bounding box are selected.
        /// The bounding box is provided as four or six numbers, depending on whether the
        /// coordinate reference system includes a vertical axis (height or depth):
        /// 
        /// - Lower left corner, coordinate axis 1
        /// - Lower left corner, coordinate axis 2
        /// - Minimum value, coordinate axis 3 (optional)
        /// - Upper right corner, coordinate axis 1
        /// - Upper right corner, coordinate axis 2
        /// - Maximum value, coordinate axis 3 (optional)
        /// 
        /// The coordinate reference system of the values is WGS 84 longitude/latitude
        /// (http://www.opengis.net/def/crs/OGC/1.3/CRS84).
        /// 
        /// For WGS 84 longitude/latitude the values are in most cases the sequence of
        /// minimum longitude, minimum latitude, maximum longitude and maximum latitude.
        /// However, in cases where the box spans the antimeridian the first value
        /// (west-most box edge) is larger than the third value (east-most box edge).
        /// 
        /// If the vertical axis is included, the third and the sixth number are
        /// the bottom and the top of the 3-dimensional bounding box.
        /// 
        /// If a feature has multiple spatial geometry properties, it is the decision of the
        /// server whether only a single spatial geometry property is used to determine
        /// the extent or all relevant geometries.
        /// </param>
        /// <param name="datetime">
        /// Either a date-time or an interval, open or closed. Date and time expressions
        /// adhere to RFC 3339. Open intervals are expressed using double-dots.
        /// 
        /// Examples:
        /// 
        /// - A date-time: "2018-02-12T23:20:50Z"
        /// - A closed interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z"
        /// - Open intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"
        /// 
        /// Only features that have a temporal property that intersects the value of
        /// `datetime` are selected.
        /// 
        /// If a feature has multiple temporal properties, it is the decision of the
        /// server whether only a single temporal property is used to determine
        /// the extent or all relevant temporal properties.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacItemCollectionModel> GetItems(string collectionId, int? limit = default, IEnumerable<string> boundingBox = default, string datetime = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetItems(collectionId, limit, boundingBox, datetime, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacItemCollectionModel)result, result);
        }

        /// <summary>
        /// Fetch features of the feature collection with id `collectionId`.
        /// 
        /// Every feature in a dataset belongs to a collection. A dataset may
        /// consist of multiple feature collections. A feature collection is often a
        /// collection of features of a similar type, based on a common schema.
        /// </summary>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="limit">
        /// The optional limit parameter recommends the number of items that should be present in the response document.
        /// 
        /// If the limit parameter value is greater than advertised limit maximum, the server must return the
        /// maximum possible number of items, rather than responding with an error.
        /// 
        /// Only items are counted that are on the first level of the collection in the response document.
        /// Nested objects contained within the explicitly requested items must not be counted.
        /// 
        /// Minimum = 1. Maximum = 10000. Default = 10.
        /// </param>
        /// <param name="boundingBox">
        /// Only features that have a geometry that intersects the bounding box are selected.
        /// The bounding box is provided as four or six numbers, depending on whether the
        /// coordinate reference system includes a vertical axis (height or depth):
        /// 
        /// - Lower left corner, coordinate axis 1
        /// - Lower left corner, coordinate axis 2
        /// - Minimum value, coordinate axis 3 (optional)
        /// - Upper right corner, coordinate axis 1
        /// - Upper right corner, coordinate axis 2
        /// - Maximum value, coordinate axis 3 (optional)
        /// 
        /// The coordinate reference system of the values is WGS 84 longitude/latitude
        /// (http://www.opengis.net/def/crs/OGC/1.3/CRS84).
        /// 
        /// For WGS 84 longitude/latitude the values are in most cases the sequence of
        /// minimum longitude, minimum latitude, maximum longitude and maximum latitude.
        /// However, in cases where the box spans the antimeridian the first value
        /// (west-most box edge) is larger than the third value (east-most box edge).
        /// 
        /// If the vertical axis is included, the third and the sixth number are
        /// the bottom and the top of the 3-dimensional bounding box.
        /// 
        /// If a feature has multiple spatial geometry properties, it is the decision of the
        /// server whether only a single spatial geometry property is used to determine
        /// the extent or all relevant geometries.
        /// </param>
        /// <param name="datetime">
        /// Either a date-time or an interval, open or closed. Date and time expressions
        /// adhere to RFC 3339. Open intervals are expressed using double-dots.
        /// 
        /// Examples:
        /// 
        /// - A date-time: "2018-02-12T23:20:50Z"
        /// - A closed interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z"
        /// - Open intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"
        /// 
        /// Only features that have a temporal property that intersects the value of
        /// `datetime` are selected.
        /// 
        /// If a feature has multiple temporal properties, it is the decision of the
        /// server whether only a single temporal property is used to determine
        /// the extent or all relevant temporal properties.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacItemCollectionModel>> GetItemsAsync(string collectionId, int? limit = default, IEnumerable<string> boundingBox = default, string datetime = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetItemsAsync(collectionId, limit, boundingBox, datetime, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacItemCollectionModel)result, result);
        }

        /// <summary> Update a STAC item in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Operation UpdateItem(WaitUntil waitUntil, string collectionId, string itemId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.UpdateItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateItemRequest(collectionId, itemId, content, context);
                return ProtocolOperationHelpers.ProcessMessage(Pipeline, message, ClientDiagnostics, "StacClient.UpdateItem", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update a STAC item in a collection. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="collectionId"> Catalog collection id. </param>
        /// <param name="itemId"> STAC Item id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="itemId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="itemId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Operation> UpdateItemAsync(WaitUntil waitUntil, string collectionId, string itemId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.UpdateItem");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(itemId, nameof(itemId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateItemRequest(collectionId, itemId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(Pipeline, message, ClientDiagnostics, "StacClient.UpdateItemAsync", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Return the STAC landing page.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetStacLandingPage(RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetStacLandingPage");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStacLandingPageRequest(context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Return the STAC landing page.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetStacLandingPageAsync(RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetStacLandingPage");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStacLandingPageRequest(context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Return the STAC landing page. </summary>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacLandingPage> GetStacLandingPage(CancellationToken cancellationToken = default)
        {
            Response result = GetStacLandingPage(cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacLandingPage)result, result);
        }

        /// <summary> Return the STAC landing page. </summary>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacLandingPage>> GetStacLandingPageAsync(CancellationToken cancellationToken = default)
        {
            Response result = await GetStacLandingPageAsync(cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacLandingPage)result, result);
        }

        /// <summary>
        /// [Protocol Method] Set queryables for a collection given a list of queryable definitions
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateQueryables(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateQueryables");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateQueryablesRequest(collectionId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Set queryables for a collection given a list of queryable definitions
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateQueryablesAsync(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateQueryables");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateQueryablesRequest(collectionId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Set queryables for a collection given a list of queryable definitions. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Request queryable definition body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<QueryableProperty>> CreateQueryables(string collectionId, IEnumerable<QueryableProperty> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            Response result = CreateQueryables(collectionId, content, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            IList<QueryableProperty> value = new List<QueryableProperty>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(QueryableProperty.DeserializeQueryableProperty(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<QueryableProperty>)value, result);
        }

        /// <summary> Set queryables for a collection given a list of queryable definitions. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="body"> Request queryable definition body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<QueryableProperty>>> CreateQueryablesAsync(string collectionId, IEnumerable<QueryableProperty> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            Response result = await CreateQueryablesAsync(collectionId, content, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            IList<QueryableProperty> value = new List<QueryableProperty>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(QueryableProperty.DeserializeQueryableProperty(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<QueryableProperty>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Updates a queryable given a queryable definition and
        /// corresponding collection id.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="queryableName"> Name of the queryable property to operate on. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="queryableName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateOrReplaceQueryable(string collectionId, string queryableName, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceQueryable");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(queryableName, nameof(queryableName));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceQueryableRequest(collectionId, queryableName, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates a queryable given a queryable definition and
        /// corresponding collection id.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="queryableName"> Name of the queryable property to operate on. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="queryableName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateOrReplaceQueryableAsync(string collectionId, string queryableName, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.CreateOrReplaceQueryable");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(queryableName, nameof(queryableName));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrReplaceQueryableRequest(collectionId, queryableName, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates a queryable given a queryable definition and
        /// corresponding collection id.
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="queryableName"> Name of the queryable property to operate on. </param>
        /// <param name="body"> Request queryable definition body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="queryableName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<QueryableProperty> CreateOrReplaceQueryable(string collectionId, string queryableName, QueryableProperty body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(queryableName, nameof(queryableName));
            Argument.AssertNotNull(body, nameof(body));

            Response result = CreateOrReplaceQueryable(collectionId, queryableName, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((QueryableProperty)result, result);
        }

        /// <summary>
        /// Updates a queryable given a queryable definition and
        /// corresponding collection id.
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="queryableName"> Name of the queryable property to operate on. </param>
        /// <param name="body"> Request queryable definition body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/>, <paramref name="queryableName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<QueryableProperty>> CreateOrReplaceQueryableAsync(string collectionId, string queryableName, QueryableProperty body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(queryableName, nameof(queryableName));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await CreateOrReplaceQueryableAsync(collectionId, queryableName, body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((QueryableProperty)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete queryables by name for specified collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="queryableName"> Name of the queryable property to operate on. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteQueryable(string collectionId, string queryableName, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteQueryable");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(queryableName, nameof(queryableName));

                using HttpMessage message = CreateDeleteQueryableRequest(collectionId, queryableName, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete queryables by name for specified collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="queryableName"> Name of the queryable property to operate on. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteQueryableAsync(string collectionId, string queryableName, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.DeleteQueryable");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNullOrEmpty(queryableName, nameof(queryableName));

                using HttpMessage message = CreateDeleteQueryableRequest(collectionId, queryableName, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete queryables by name for specified collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="queryableName"> Name of the queryable property to operate on. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response DeleteQueryable(string collectionId, string queryableName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(queryableName, nameof(queryableName));

            return DeleteQueryable(collectionId, queryableName, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
        }

        /// <summary> Delete queryables by name for specified collection. </summary>
        /// <param name="collectionId"> Unique identifier for the STAC collection. </param>
        /// <param name="queryableName"> Name of the queryable property to operate on. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> or <paramref name="queryableName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> DeleteQueryableAsync(string collectionId, string queryableName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNullOrEmpty(queryableName, nameof(queryableName));

            return await DeleteQueryableAsync(collectionId, queryableName, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] List all queryables in the GeoCatalog instance
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetQueryables(RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetQueryables");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetQueryablesRequest(context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all queryables in the GeoCatalog instance
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetQueryablesAsync(RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetQueryables");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetQueryablesRequest(context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all queryables in the GeoCatalog instance. </summary>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyDictionary<string, BinaryData>> GetQueryables(CancellationToken cancellationToken = default)
        {
            Response result = GetQueryables(cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            IDictionary<string, BinaryData> value = new Dictionary<string, BinaryData>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateObject())
            {
                if (item.Value.ValueKind == JsonValueKind.Null)
                {
                    value.Add(item.Name, null);
                }
                else
                {
                    value.Add(item.Name, BinaryData.FromString(item.Value.GetRawText()));
                }
            }
            return Response.FromValue((IReadOnlyDictionary<string, BinaryData>)value, result);
        }

        /// <summary> List all queryables in the GeoCatalog instance. </summary>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyDictionary<string, BinaryData>>> GetQueryablesAsync(CancellationToken cancellationToken = default)
        {
            Response result = await GetQueryablesAsync(cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            IDictionary<string, BinaryData> value = new Dictionary<string, BinaryData>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateObject())
            {
                if (item.Value.ValueKind == JsonValueKind.Null)
                {
                    value.Add(item.Name, null);
                }
                else
                {
                    value.Add(item.Name, BinaryData.FromString(item.Value.GetRawText()));
                }
            }
            return Response.FromValue((IReadOnlyDictionary<string, BinaryData>)value, result);
        }

        /// <summary>
        /// [Protocol Method] List all queryables in a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Collection ID. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCollectionQueryables(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollectionQueryables");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetCollectionQueryablesRequest(collectionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all queryables in a given collection
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> Collection ID. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCollectionQueryablesAsync(string collectionId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.GetCollectionQueryables");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

                using HttpMessage message = CreateGetCollectionQueryablesRequest(collectionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all queryables in a given collection. </summary>
        /// <param name="collectionId"> Collection ID. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyDictionary<string, BinaryData>> GetCollectionQueryables(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = GetCollectionQueryables(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            IDictionary<string, BinaryData> value = new Dictionary<string, BinaryData>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateObject())
            {
                if (item.Value.ValueKind == JsonValueKind.Null)
                {
                    value.Add(item.Name, null);
                }
                else
                {
                    value.Add(item.Name, BinaryData.FromString(item.Value.GetRawText()));
                }
            }
            return Response.FromValue((IReadOnlyDictionary<string, BinaryData>)value, result);
        }

        /// <summary> List all queryables in a given collection. </summary>
        /// <param name="collectionId"> Collection ID. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyDictionary<string, BinaryData>>> GetCollectionQueryablesAsync(string collectionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));

            Response result = await GetCollectionQueryablesAsync(collectionId, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            IDictionary<string, BinaryData> value = new Dictionary<string, BinaryData>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateObject())
            {
                if (item.Value.ValueKind == JsonValueKind.Null)
                {
                    value.Add(item.Name, null);
                }
                else
                {
                    value.Add(item.Name, BinaryData.FromString(item.Value.GetRawText()));
                }
            }
            return Response.FromValue((IReadOnlyDictionary<string, BinaryData>)value, result);
        }

        /// <summary>
        /// [Protocol Method] STAC search operation.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response Search(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.Search");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateSearchRequest(content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] STAC search operation.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> SearchAsync(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("StacClient.Search");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateSearchRequest(content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> STAC search operation. </summary>
        /// <param name="body"> Request body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<StacItemCollectionModel> Search(SearchPostContent body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = Search(body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null);
            return Response.FromValue((StacItemCollectionModel)result, result);
        }

        /// <summary> STAC search operation. </summary>
        /// <param name="body"> Request body. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<StacItemCollectionModel>> SearchAsync(SearchPostContent body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = await SearchAsync(body, cancellationToken.CanBeCanceled ? new RequestContext { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return Response.FromValue((StacItemCollectionModel)result, result);
        }
    }
}
