// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Collections.Generic;
using Azure;
using Azure.Core;

namespace Azure.Analytics.PlanetaryComputer
{
    /// <summary></summary>
    public partial class MosaicTilerClient
    {
        private static ResponseClassifier _pipelineMessageClassifier200;
        private static ResponseClassifier _pipelineMessageClassifier200204;

        private static ResponseClassifier PipelineMessageClassifier200 => _pipelineMessageClassifier200 = new StatusCodeClassifier(stackalloc ushort[] { 200 });

        private static ResponseClassifier PipelineMessageClassifier200204 => _pipelineMessageClassifier200204 = new StatusCodeClassifier(stackalloc ushort[] { 200, 204 });

        internal HttpMessage CreateGetTileRequest(string searchId, float z, float x, float y, float scale, string format, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitwhenfull, bool? skipcovered, string algorithm, string algorithmParams, string tileMatrixSetId, string buffer, string colorFormula, string collection, string resampling, string pixelSelection, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(z.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(x.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(y.ToString(), true);
            uri.AppendPath("@", false);
            uri.AppendPath(scale.ToString(), true);
            uri.AppendPath("x.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(nodata, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitwhenfull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitwhenfull, null), true);
            }
            if (skipcovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipcovered, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileMatrixSetId != null)
            {
                uri.AppendQuery("tileMatrixSetId", tileMatrixSetId, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (collection != null)
            {
                uri.AppendQuery("collection", collection, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (pixelSelection != null)
            {
                uri.AppendQuery("pixel_selection", pixelSelection, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            return message;
        }

        internal HttpMessage CreateGetTileWithMatrixSetRequest(string searchId, string tileMatrixSetId, float z, float x, float y, float scale, string format, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitwhenfull, bool? skipcovered, string algorithm, string algorithmParams, string buffer, string colorFormula, string collection, string resampling, string pixelSelection, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(z.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(x.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(y.ToString(), true);
            uri.AppendPath("@", false);
            uri.AppendPath(scale.ToString(), true);
            uri.AppendPath("x.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(nodata, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitwhenfull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitwhenfull, null), true);
            }
            if (skipcovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipcovered, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (collection != null)
            {
                uri.AppendQuery("collection", collection, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (pixelSelection != null)
            {
                uri.AppendQuery("pixel_selection", pixelSelection, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            return message;
        }

        internal HttpMessage CreateGetTileJsonRequest(string searchId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitwhenfull, bool? skipcovered, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, double? buffer, string colorFormula, string collection, string resampling, string pixelSelection, string algorithm, string algorithmParams, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/tilejson.json", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(nodata, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitwhenfull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitwhenfull, null), true);
            }
            if (skipcovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipcovered, null), true);
            }
            if (tileMatrixSetId != null)
            {
                uri.AppendQuery("tileMatrixSetId", tileMatrixSetId, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", TypeFormatters.ConvertToString(tileScale, null), true);
            }
            if (minzoom != null)
            {
                uri.AppendQuery("minzoom", TypeFormatters.ConvertToString(minzoom, null), true);
            }
            if (maxzoom != null)
            {
                uri.AppendQuery("maxzoom", TypeFormatters.ConvertToString(maxzoom, null), true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", TypeFormatters.ConvertToString(buffer, null), true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (collection != null)
            {
                uri.AppendQuery("collection", collection, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (pixelSelection != null)
            {
                uri.AppendQuery("pixel_selection", pixelSelection, true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTileJsonWithMatrixSetRequest(string searchId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBidx, bool? assetAsBand, float? nodata, bool? unscale, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitwhenfull, bool? skipcovered, string algorithm, string algorithmParams, int? minzoom, int? maxzoom, string tileFormat, int? tileScale, string buffer, string colorFormula, string collection, string resampling, string pixelSelection, IEnumerable<string> rescale, string colormapName, string colormap, bool? returnMask, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/tilejson.json", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBidx != null && !(assetBidx is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBidx, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (nodata != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(nodata, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitwhenfull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitwhenfull, null), true);
            }
            if (skipcovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipcovered, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (minzoom != null)
            {
                uri.AppendQuery("minzoom", TypeFormatters.ConvertToString(minzoom, null), true);
            }
            if (maxzoom != null)
            {
                uri.AppendQuery("maxzoom", TypeFormatters.ConvertToString(maxzoom, null), true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", TypeFormatters.ConvertToString(tileScale, null), true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (collection != null)
            {
                uri.AppendQuery("collection", collection, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (pixelSelection != null)
            {
                uri.AppendQuery("pixel_selection", pixelSelection, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colormapName != null)
            {
                uri.AppendQuery("colormap_name", colormapName, true);
            }
            if (colormap != null)
            {
                uri.AppendQuery("colormap", colormap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetWmtsCapabilitiesRequest(string searchId, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/WMTSCapabilities.xml", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (tileMatrixSetId != null)
            {
                uri.AppendQuery("tileMatrixSetId", tileMatrixSetId, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", TypeFormatters.ConvertToString(tileScale, null), true);
            }
            if (minzoom != null)
            {
                uri.AppendQuery("minzoom", TypeFormatters.ConvertToString(minzoom, null), true);
            }
            if (maxzoom != null)
            {
                uri.AppendQuery("maxzoom", TypeFormatters.ConvertToString(maxzoom, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/xml");
            return message;
        }

        internal HttpMessage CreateGetWmtsCapabilitiesWithMatrixSetRequest(string searchId, string tileMatrixSetId, string tileFormat, int? tileScale, int? minzoom, int? maxzoom, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/WMTSCapabilities.xml", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", TypeFormatters.ConvertToString(tileScale, null), true);
            }
            if (minzoom != null)
            {
                uri.AppendQuery("minzoom", TypeFormatters.ConvertToString(minzoom, null), true);
            }
            if (maxzoom != null)
            {
                uri.AppendQuery("maxzoom", TypeFormatters.ConvertToString(maxzoom, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/xml");
            return message;
        }

        internal HttpMessage CreateRegisterSearchRequest(RequestContent content, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Post;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/register", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSearchInfoRequest(string searchId, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/info", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAssetsForTileRequest(string searchId, float z, float x, float y, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitwhenfull, bool? skipcovered, string tileMatrixSetId, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(z.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(x.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(y.ToString(), true);
            uri.AppendPath("/assets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitwhenfull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitwhenfull, null), true);
            }
            if (skipcovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipcovered, null), true);
            }
            if (tileMatrixSetId != null)
            {
                uri.AppendQuery("tileMatrixSetId", tileMatrixSetId, true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAssetsForTileWithMatrixSetRequest(string searchId, string tileMatrixSetId, float z, float x, float y, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitwhenfull, bool? skipcovered, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(z.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(x.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(y.ToString(), true);
            uri.AppendPath("/assets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitwhenfull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitwhenfull, null), true);
            }
            if (skipcovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipcovered, null), true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAssetsForPointRequest(string searchId, float lon, float lat, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitwhenfull, bool? skipcovered, string coordCrs, RequestContext context)
        {
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200204);
            Request request = message.Request;
            request.Method = RequestMethod.Get;
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(lon.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(lat.ToString(), true);
            uri.AppendPath("/assets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitwhenfull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitwhenfull, null), true);
            }
            if (skipcovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipcovered, null), true);
            }
            if (coordCrs != null)
            {
                uri.AppendQuery("coord-crs", coordCrs, true);
            }
            request.Uri = uri;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }
    }
}
