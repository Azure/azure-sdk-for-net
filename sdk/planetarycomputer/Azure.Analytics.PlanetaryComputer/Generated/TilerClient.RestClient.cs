// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Collections.Generic;
using Azure;
using Azure.Core;

namespace Azure.Analytics.PlanetaryComputer
{
    /// <summary></summary>
    public partial class TilerClient
    {
        private static ResponseClassifier _pipelineMessageClassifier200;

        private static ResponseClassifier PipelineMessageClassifier200 => _pipelineMessageClassifier200 = new StatusCodeClassifier(stackalloc ushort[] { 200 });

        internal HttpMessage CreateGetTileMatrixDefinitionsRequest(string tileMatrixSetId, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/tile-matrix-sets/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTileMatrixListRequest(RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/tile-matrix-sets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAssetStatisticsRequest(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string resampling, int? maxSize, bool? categorical, IEnumerable<string> categoriesPixels, IEnumerable<int> percentiles, string histogramBins, string histogramRange, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/asset_statistics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (categorical != null)
            {
                uri.AppendQuery("categorical", TypeFormatters.ConvertToString(categorical, null), true);
            }
            if (categoriesPixels != null && !(categoriesPixels is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                uri.AppendQueryDelimited("c", categoriesPixels, ",", null, true);
            }
            if (percentiles != null && !(percentiles is ChangeTrackingList<int> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                uri.AppendQueryDelimited("p", percentiles, ",", null, true);
            }
            if (histogramBins != null)
            {
                uri.AppendQuery("histogram_bins", histogramBins, true);
            }
            if (histogramRange != null)
            {
                uri.AppendQuery("histogram_range", histogramRange, true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAvailableAssetsRequest(string collectionId, string itemId, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/assets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBoundsRequest(string collectionId, string itemId, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/bounds", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCropGeoJsonRequest(string collectionId, string itemId, string format, RequestContent content, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string coordinateReferenceSystem, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/crop.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (coordinateReferenceSystem != null)
            {
                uri.AppendQuery("coord-crs", coordinateReferenceSystem, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (height != null)
            {
                uri.AppendQuery("height", TypeFormatters.ConvertToString(height, null), true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", TypeFormatters.ConvertToString(width, null), true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCropGeoJsonWithDimensionsRequest(string collectionId, string itemId, float width, float height, string format, RequestContent content, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string coordinateReferenceSystem, string resampling, int? maxSize, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/crop/", false);
            uri.AppendPath(width.ToString(), true);
            uri.AppendPath("x", false);
            uri.AppendPath(height.ToString(), true);
            uri.AppendPath(".", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (coordinateReferenceSystem != null)
            {
                uri.AppendQuery("coord-crs", coordinateReferenceSystem, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetGeoJsonStatisticsRequest(string collectionId, string itemId, RequestContent content, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string coordinateReferenceSystem, string resampling, int? maxSize, bool? categorical, IEnumerable<string> categoriesPixels, IEnumerable<int> percentiles, string histogramBins, string histogramRange, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/statistics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (coordinateReferenceSystem != null)
            {
                uri.AppendQuery("coord-crs", coordinateReferenceSystem, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (categorical != null)
            {
                uri.AppendQuery("categorical", TypeFormatters.ConvertToString(categorical, null), true);
            }
            if (categoriesPixels != null && !(categoriesPixels is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                uri.AppendQueryDelimited("c", categoriesPixels, ",", null, true);
            }
            if (percentiles != null && !(percentiles is ChangeTrackingList<int> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                uri.AppendQueryDelimited("p", percentiles, ",", null, true);
            }
            if (histogramBins != null)
            {
                uri.AppendQuery("histogram_bins", histogramBins, true);
            }
            if (histogramRange != null)
            {
                uri.AppendQuery("histogram_range", histogramRange, true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetInfoGeoJsonRequest(string collectionId, string itemId, IEnumerable<string> assets, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/info.geojson", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAssetsInfoRequest(string collectionId, string itemId, IEnumerable<string> assets, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/info", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPartRequest(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, string format, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string coordinateReferenceSystem, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/crop/", false);
            uri.AppendPath(minx.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(miny.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(maxx.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(maxy.ToString(), true);
            uri.AppendPath(".", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (dstCrs != null)
            {
                uri.AppendQuery("dst-crs", dstCrs, true);
            }
            if (coordinateReferenceSystem != null)
            {
                uri.AppendQuery("coord-crs", coordinateReferenceSystem, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (height != null)
            {
                uri.AppendQuery("height", TypeFormatters.ConvertToString(height, null), true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", TypeFormatters.ConvertToString(width, null), true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            return message;
        }

        internal HttpMessage CreateGetPartWithDimensionsRequest(string collectionId, string itemId, float minx, float miny, float maxx, float maxy, float width, float height, string format, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string coordinateReferenceSystem, string resampling, int? maxSize, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/crop/", false);
            uri.AppendPath(minx.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(miny.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(maxx.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(maxy.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(width.ToString(), true);
            uri.AppendPath("x", false);
            uri.AppendPath(height.ToString(), true);
            uri.AppendPath(".", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (dstCrs != null)
            {
                uri.AppendQuery("dst-crs", dstCrs, true);
            }
            if (coordinateReferenceSystem != null)
            {
                uri.AppendQuery("coord-crs", coordinateReferenceSystem, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            return message;
        }

        internal HttpMessage CreateGetPointRequest(string collectionId, string itemId, double longitude, float latitude, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string coordinateReferenceSystem, string resampling, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/point/", false);
            uri.AppendPath(longitude.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(latitude.ToString(), true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (coordinateReferenceSystem != null)
            {
                uri.AppendQuery("coord-crs", coordinateReferenceSystem, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPreviewRequest(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string format, string colorFormula, string dstCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/preview", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (format != null)
            {
                uri.AppendQuery("format", format, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (dstCrs != null)
            {
                uri.AppendQuery("dst-crs", dstCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (height != null)
            {
                uri.AppendQuery("height", TypeFormatters.ConvertToString(height, null), true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", TypeFormatters.ConvertToString(width, null), true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            return message;
        }

        internal HttpMessage CreateGetPreviewWithFormatRequest(string collectionId, string itemId, string format, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string colorFormula, string dstCrs, string resampling, int? maxSize, int? height, int? width, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/preview.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (dstCrs != null)
            {
                uri.AppendQuery("dst-crs", dstCrs, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (height != null)
            {
                uri.AppendQuery("height", TypeFormatters.ConvertToString(height, null), true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", TypeFormatters.ConvertToString(width, null), true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            return message;
        }

        internal HttpMessage CreateCreateStaticImageRequest(string collectionId, RequestContent content, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/image/static", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetStaticImageRequest(string collectionId, string id, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/image/static/", false);
            uri.AppendPath(id, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "image/png");
            return message;
        }

        internal HttpMessage CreateGetStatisticsRequest(string collectionId, string itemId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string resampling, int? maxSize, bool? categorical, IEnumerable<string> categoriesPixels, IEnumerable<int> percentiles, string histogramBins, string histogramRange, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/statistics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (maxSize != null)
            {
                uri.AppendQuery("max_size", TypeFormatters.ConvertToString(maxSize, null), true);
            }
            if (categorical != null)
            {
                uri.AppendQuery("categorical", TypeFormatters.ConvertToString(categorical, null), true);
            }
            if (categoriesPixels != null && !(categoriesPixels is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                uri.AppendQueryDelimited("c", categoriesPixels, ",", null, true);
            }
            if (percentiles != null && !(percentiles is ChangeTrackingList<int> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                uri.AppendQueryDelimited("p", percentiles, ",", null, true);
            }
            if (histogramBins != null)
            {
                uri.AppendQuery("histogram_bins", histogramBins, true);
            }
            if (histogramRange != null)
            {
                uri.AppendQuery("histogram_range", histogramRange, true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTileJsonRequest(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minZoom, int? maxZoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/tilejson.json", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", TypeFormatters.ConvertToString(tileScale, null), true);
            }
            if (minZoom != null)
            {
                uri.AppendQuery("minzoom", TypeFormatters.ConvertToString(minZoom, null), true);
            }
            if (maxZoom != null)
            {
                uri.AppendQuery("maxzoom", TypeFormatters.ConvertToString(maxZoom, null), true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTileRequest(string collectionId, string itemId, string tileMatrixSetId, float z, float x, float y, float scale, string format, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, string subdatasetName, IEnumerable<string> subdatasetBands, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(z.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(x.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(y.ToString(), true);
            uri.AppendPath("@", false);
            uri.AppendPath(scale.ToString(), true);
            uri.AppendPath("x.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            if (subdatasetName != null)
            {
                uri.AppendQuery("subdataset_name", subdatasetName, true);
            }
            if (subdatasetBands != null && !(subdatasetBands is ChangeTrackingList<string> changeTrackingList2 && changeTrackingList2.IsUndefined))
            {
                uri.AppendQueryDelimited("subdataset_bands", subdatasetBands, ",", null, true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            return message;
        }

        internal HttpMessage CreateGetWmtsCapabilitiesRequest(string collectionId, string itemId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minZoom, int? maxZoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/collections/", false);
            uri.AppendPath(collectionId, true);
            uri.AppendPath("/items/", false);
            uri.AppendPath(itemId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/WMTSCapabilities.xml", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", TypeFormatters.ConvertToString(tileScale, null), true);
            }
            if (minZoom != null)
            {
                uri.AppendQuery("minzoom", TypeFormatters.ConvertToString(minZoom, null), true);
            }
            if (maxZoom != null)
            {
                uri.AppendQuery("maxzoom", TypeFormatters.ConvertToString(maxZoom, null), true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/xml");
            return message;
        }

        internal HttpMessage CreateGetClassMapLegendRequest(string classmapName, int? trimStart, int? trimEnd, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/legend/classmap/", false);
            uri.AppendPath(classmapName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (trimStart != null)
            {
                uri.AppendQuery("trim_start", TypeFormatters.ConvertToString(trimStart, null), true);
            }
            if (trimEnd != null)
            {
                uri.AppendQuery("trim_end", TypeFormatters.ConvertToString(trimEnd, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetIntervalLegendRequest(string classmapName, int? trimStart, int? trimEnd, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/legend/interval/", false);
            uri.AppendPath(classmapName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (trimStart != null)
            {
                uri.AppendQuery("trim_start", TypeFormatters.ConvertToString(trimStart, null), true);
            }
            if (trimEnd != null)
            {
                uri.AppendQuery("trim_end", TypeFormatters.ConvertToString(trimEnd, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLegendRequest(string colorMapName, double? height, double? width, int? trimStart, int? trimEnd, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/legend/colormap/", false);
            uri.AppendPath(colorMapName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (height != null)
            {
                uri.AppendQuery("height", TypeFormatters.ConvertToString(height, null), true);
            }
            if (width != null)
            {
                uri.AppendQuery("width", TypeFormatters.ConvertToString(width, null), true);
            }
            if (trimStart != null)
            {
                uri.AppendQuery("trim_start", TypeFormatters.ConvertToString(trimStart, null), true);
            }
            if (trimEnd != null)
            {
                uri.AppendQuery("trim_end", TypeFormatters.ConvertToString(trimEnd, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "image/png");
            return message;
        }

        internal HttpMessage CreateGetMosaicsAssetsForPointRequest(string searchId, float longitude, float latitude, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitWhenFull, bool? skipCovered, string coordinateReferenceSystem, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(longitude.ToString(), true);
            uri.AppendPath(",", false);
            uri.AppendPath(latitude.ToString(), true);
            uri.AppendPath("/assets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitWhenFull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitWhenFull, null), true);
            }
            if (skipCovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipCovered, null), true);
            }
            if (coordinateReferenceSystem != null)
            {
                uri.AppendQuery("coord-crs", coordinateReferenceSystem, true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMosaicsAssetsForTileRequest(string searchId, string tileMatrixSetId, float z, float x, float y, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitWhenFull, bool? skipCovered, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(z.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(x.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(y.ToString(), true);
            uri.AppendPath("/assets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitWhenFull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitWhenFull, null), true);
            }
            if (skipCovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipCovered, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMosaicsSearchInfoRequest(string searchId, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/info", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRegisterMosaicsSearchRequest(RequestContent content, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/register", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMosaicsTileJsonRequest(string searchId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitWhenFull, bool? skipCovered, string algorithm, string algorithmParams, int? minZoom, int? maxZoom, string tileFormat, int? tileScale, string buffer, string colorFormula, string collection, string resampling, string pixelSelection, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/tilejson.json", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitWhenFull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitWhenFull, null), true);
            }
            if (skipCovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipCovered, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (minZoom != null)
            {
                uri.AppendQuery("minzoom", TypeFormatters.ConvertToString(minZoom, null), true);
            }
            if (maxZoom != null)
            {
                uri.AppendQuery("maxzoom", TypeFormatters.ConvertToString(maxZoom, null), true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", TypeFormatters.ConvertToString(tileScale, null), true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (collection != null)
            {
                uri.AppendQuery("collection", collection, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (pixelSelection != null)
            {
                uri.AppendQuery("pixel_selection", pixelSelection, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMosaicsTileRequest(string searchId, string tileMatrixSetId, float z, float x, float y, float scale, string format, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, int? scanLimit, int? itemsLimit, int? timeLimit, bool? exitWhenFull, bool? skipCovered, string algorithm, string algorithmParams, string buffer, string colorFormula, string collection, string resampling, string pixelSelection, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/tiles/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(z.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(x.ToString(), true);
            uri.AppendPath("/", false);
            uri.AppendPath(y.ToString(), true);
            uri.AppendPath("@", false);
            uri.AppendPath(scale.ToString(), true);
            uri.AppendPath("x.", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (scanLimit != null)
            {
                uri.AppendQuery("scan_limit", TypeFormatters.ConvertToString(scanLimit, null), true);
            }
            if (itemsLimit != null)
            {
                uri.AppendQuery("items_limit", TypeFormatters.ConvertToString(itemsLimit, null), true);
            }
            if (timeLimit != null)
            {
                uri.AppendQuery("time_limit", TypeFormatters.ConvertToString(timeLimit, null), true);
            }
            if (exitWhenFull != null)
            {
                uri.AppendQuery("exitwhenfull", TypeFormatters.ConvertToString(exitWhenFull, null), true);
            }
            if (skipCovered != null)
            {
                uri.AppendQuery("skipcovered", TypeFormatters.ConvertToString(skipCovered, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (collection != null)
            {
                uri.AppendQuery("collection", collection, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (pixelSelection != null)
            {
                uri.AppendQuery("pixel_selection", pixelSelection, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/x-binary, image/jp2, image/jpeg, image/jpg, image/png, image/tiff; application=geotiff, image/webp");
            return message;
        }

        internal HttpMessage CreateGetMosaicsWmtsCapabilitiesRequest(string searchId, string tileMatrixSetId, IEnumerable<string> assets, string expression, IEnumerable<string> assetBandIndices, bool? assetAsBand, float? noData, bool? unscale, string algorithm, string algorithmParams, string tileFormat, int? tileScale, int? minZoom, int? maxZoom, string buffer, string colorFormula, string resampling, IEnumerable<string> rescale, string colorMapName, string colorMap, bool? returnMask, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/data/mosaic/", false);
            uri.AppendPath(searchId, true);
            uri.AppendPath("/", false);
            uri.AppendPath(tileMatrixSetId, true);
            uri.AppendPath("/WMTSCapabilities.xml", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (assets != null && !(assets is ChangeTrackingList<string> changeTrackingList && changeTrackingList.IsUndefined))
            {
                foreach (var @param in assets)
                {
                    uri.AppendQuery("assets", @param, true);
                }
            }
            if (expression != null)
            {
                uri.AppendQuery("expression", expression, true);
            }
            if (assetBandIndices != null && !(assetBandIndices is ChangeTrackingList<string> changeTrackingList0 && changeTrackingList0.IsUndefined))
            {
                uri.AppendQueryDelimited("asset_bidx", assetBandIndices, ",", null, true);
            }
            if (assetAsBand != null)
            {
                uri.AppendQuery("asset_as_band", TypeFormatters.ConvertToString(assetAsBand, null), true);
            }
            if (noData != null)
            {
                uri.AppendQuery("nodata", TypeFormatters.ConvertToString(noData, null), true);
            }
            if (unscale != null)
            {
                uri.AppendQuery("unscale", TypeFormatters.ConvertToString(unscale, null), true);
            }
            if (algorithm != null)
            {
                uri.AppendQuery("algorithm", algorithm, true);
            }
            if (algorithmParams != null)
            {
                uri.AppendQuery("algorithm_params", algorithmParams, true);
            }
            if (tileFormat != null)
            {
                uri.AppendQuery("tile_format", tileFormat, true);
            }
            if (tileScale != null)
            {
                uri.AppendQuery("tile_scale", TypeFormatters.ConvertToString(tileScale, null), true);
            }
            if (minZoom != null)
            {
                uri.AppendQuery("minzoom", TypeFormatters.ConvertToString(minZoom, null), true);
            }
            if (maxZoom != null)
            {
                uri.AppendQuery("maxzoom", TypeFormatters.ConvertToString(maxZoom, null), true);
            }
            if (buffer != null)
            {
                uri.AppendQuery("buffer", buffer, true);
            }
            if (colorFormula != null)
            {
                uri.AppendQuery("color_formula", colorFormula, true);
            }
            if (resampling != null)
            {
                uri.AppendQuery("resampling", resampling, true);
            }
            if (rescale != null && !(rescale is ChangeTrackingList<string> changeTrackingList1 && changeTrackingList1.IsUndefined))
            {
                foreach (var @param in rescale)
                {
                    uri.AppendQuery("rescale", @param, true);
                }
            }
            if (colorMapName != null)
            {
                uri.AppendQuery("colormap_name", colorMapName, true);
            }
            if (colorMap != null)
            {
                uri.AppendQuery("colormap", colorMap, true);
            }
            if (returnMask != null)
            {
                uri.AppendQuery("return_mask", TypeFormatters.ConvertToString(returnMask, null), true);
            }
            HttpMessage message = Pipeline.CreateMessage(context, PipelineMessageClassifier200);
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/xml");
            return message;
        }
    }
}
