// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Collections.Generic;
using System.Linq;
using Azure;

namespace Azure.AI.Translation.Text
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class TranslationTextModelFactory
    {
        /// <summary> Response for the languages API. </summary>
        /// <param name="requestId"> Value generated by the service to identify the request. It is used for troubleshooting purposes. </param>
        /// <param name="etag">
        /// Current value of the entity tag for the requested groups of supported languages. 
        /// To make subsequent requests more efficient, the client may send the `ETag` value in an 
        /// `If-None-Match` header field.
        /// </param>
        /// <param name="translation"> Languages that support translate API. </param>
        /// <param name="transliteration"> Languages that support transliteration API. </param>
        /// <param name="models"> LLM models supported. </param>
        /// <returns> A new <see cref="Text.GetSupportedLanguagesResult"/> instance for mocking. </returns>
        public static GetSupportedLanguagesResult GetSupportedLanguagesResult(string requestId = default, ETag etag = default, IReadOnlyDictionary<string, TranslationLanguage> translation = default, IReadOnlyDictionary<string, TransliterationLanguage> transliteration = default, IEnumerable<string> models = default)
        {
            translation ??= new ChangeTrackingDictionary<string, TranslationLanguage>();
            transliteration ??= new ChangeTrackingDictionary<string, TransliterationLanguage>();
            models ??= new ChangeTrackingList<string>();

            return new GetSupportedLanguagesResult(
                requestId,
                etag,
                translation,
                transliteration,
                models.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// The value of the translation property is a dictionary of (key, value) pairs. Each key is a BCP 47 language tag.
        /// A key identifies a language for which text can be translated to or translated from.
        /// </summary>
        /// <param name="name"> Display name of the language in the locale requested via Accept-Language header. </param>
        /// <param name="nativeName"> Display name of the language in the locale native for this language. </param>
        /// <param name="directionality"> Directionality, which is rtl for right-to-left languages or ltr for left-to-right languages. </param>
        /// <param name="models"> LLM models supported for translation. </param>
        /// <returns> A new <see cref="Text.TranslationLanguage"/> instance for mocking. </returns>
        public static TranslationLanguage TranslationLanguage(string name = default, string nativeName = default, LanguageDirectionality directionality = default, IEnumerable<string> models = default)
        {
            models ??= new ChangeTrackingList<string>();

            return new TranslationLanguage(name, nativeName, directionality, models.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// The value of the transliteration property is a dictionary of (key, value) pairs. 
        /// Each key is a BCP 47 language tag. A key identifies a language for which text can be converted from one script 
        /// to another script.
        /// </summary>
        /// <param name="name"> Display name of the language in the locale requested via Accept-Language header. </param>
        /// <param name="nativeName"> Display name of the language in the locale native for this language. </param>
        /// <param name="scripts"> List of scripts to convert from. </param>
        /// <returns> A new <see cref="Text.TransliterationLanguage"/> instance for mocking. </returns>
        public static TransliterationLanguage TransliterationLanguage(string name = default, string nativeName = default, IEnumerable<TransliterableScript> scripts = default)
        {
            scripts ??= new ChangeTrackingList<TransliterableScript>();

            return new TransliterationLanguage(name, nativeName, scripts.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Script definition with list of script into which given script can be translitered. </summary>
        /// <param name="code"> Code identifying the script. </param>
        /// <param name="name"> Display name of the script in the locale requested via Accept-Language header. </param>
        /// <param name="nativeName"> Display name of the language in the locale native for the language. </param>
        /// <param name="directionality"> Directionality, which is rtl for right-to-left languages or ltr for left-to-right languages. </param>
        /// <param name="toScripts"> List of scripts available to convert text to. </param>
        /// <returns> A new <see cref="Text.TransliterableScript"/> instance for mocking. </returns>
        public static TransliterableScript TransliterableScript(string code = default, string name = default, string nativeName = default, LanguageDirectionality directionality = default, IEnumerable<LanguageScript> toScripts = default)
        {
            toScripts ??= new ChangeTrackingList<LanguageScript>();

            return new TransliterableScript(
                code,
                name,
                nativeName,
                directionality,
                additionalBinaryDataProperties: null,
                toScripts.ToList());
        }

        /// <summary> Common properties of language script. </summary>
        /// <param name="code"> Code identifying the script. </param>
        /// <param name="name"> Display name of the script in the locale requested via Accept-Language header. </param>
        /// <param name="nativeName"> Display name of the language in the locale native for the language. </param>
        /// <param name="directionality"> Directionality, which is rtl for right-to-left languages or ltr for left-to-right languages. </param>
        /// <returns> A new <see cref="Text.LanguageScript"/> instance for mocking. </returns>
        public static LanguageScript LanguageScript(string code = default, string name = default, string nativeName = default, LanguageDirectionality directionality = default)
        {
            return new LanguageScript(code, name, nativeName, directionality, additionalBinaryDataProperties: null);
        }

        /// <summary> Element containing the text for translation. </summary>
        /// <param name="text"> Text to translate. </param>
        /// <param name="script"> Specifies the script of the input text. </param>
        /// <param name="language">
        /// Specifies the language of the input text. Find which languages are available to translate by 
        /// looking up supported languages using the translation scope. If the language parameter isn't 
        /// specified, automatic language detection is applied to determine the source language.
        /// You must use the language parameter rather than autodetection when using the dynamic dictionary feature. 
        /// Note: the dynamic dictionary feature is case-sensitive.
        /// </param>
        /// <param name="textType">
        /// Defines whether the text being translated is plain text or HTML text. Any HTML needs to be a well-formed, 
        /// complete element. Possible values are: plain (default) or html.
        /// </param>
        /// <param name="translationTargets"> Translation target parameters. </param>
        /// <returns> A new <see cref="Text.TranslateInputItem"/> instance for mocking. </returns>
        public static TranslateInputItem TranslateInputItem(string text = default, string script = default, string language = default, TextType? textType = default, IEnumerable<TranslationTarget> translationTargets = default)
        {
            translationTargets ??= new ChangeTrackingList<TranslationTarget>();

            return new TranslateInputItem(
                text,
                script,
                language,
                textType,
                translationTargets.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Target language and translation configuration parameters. </summary>
        /// <param name="language">
        /// Specifies the language of the output text. The target language must be one of the supported languages included 
        /// in the translation scope. It's possible to translate to multiple languages simultaneously by including 
        /// multiple string values in the targetsLanguage array.
        /// </param>
        /// <param name="script"> Specifies the script of the translated text. </param>
        /// <param name="profanityAction">
        /// Specifies how profanities should be treated in translations.
        /// Possible values are: NoAction (default), Marked or Deleted.
        /// </param>
        /// <param name="profanityMarker">
        /// Specifies how profanities should be marked in translations.
        /// Possible values are: Asterisk (default) or Tag. 
        /// </param>
        /// <param name="deploymentName">
        /// Default is 'general', which uses NMT system.
        /// 'abc-inc-gpt-4o', and 'abc-inc-gpt-4o-mini' are examples of deployment names which use GPT-4o uses or
        /// GPT-4o-mini model. 'gpt-4o' uses GPT-4o model.
        /// '&lt;custom model id&gt;' uses the custom NMT model tuned by customer.
        /// 'best' system determines which is the best model to use for the request. This intelligence could be introduced
        /// in future. Customer should have deployed it in their resource.
        /// </param>
        /// <param name="allowFallback">
        /// In the case where a custom system is being used, specifies that the service is allowed to fall back to a
        /// general system when a custom system doesn't exist. 
        /// In the case where a Large Language Model is being used, specifies that the service is allowed to fall
        /// back to a Small Language Model if an error occurs.
        /// Possible values are: true (default) or false.
        /// allowFallback=false specifies that the translation should only use systems trained for the category specified 
        /// by the request. If a translation for language X to language Y requires chaining through a pivot language E, 
        /// then all the systems in the chain (X → E and E → Y) will need to be custom and have the same category. 
        /// If no system is found with the specific category, the request will return a 400 status code. allowFallback=true 
        /// specifies that the service is allowed to fall back to a general system when a custom system doesn't exist.
        /// </param>
        /// <param name="grade"> Defines complexity of LLM prompts to provide high accuracy translation. </param>
        /// <param name="tone"> Desired tone of target translation. </param>
        /// <param name="gender"> Desired gender of target translation. </param>
        /// <param name="adaptiveDatasetId"> Reference dataset ID having sentence pair to generate adaptive customized translation. </param>
        /// <param name="referenceTextPairs"> Reference text pairs to generate adaptive customized translation. </param>
        /// <returns> A new <see cref="Text.TranslationTarget"/> instance for mocking. </returns>
        public static TranslationTarget TranslationTarget(string language = default, string script = default, ProfanityAction? profanityAction = default, ProfanityMarker? profanityMarker = default, string deploymentName = default, bool? allowFallback = default, string grade = default, string tone = default, string gender = default, string adaptiveDatasetId = default, IEnumerable<ReferenceTextPair> referenceTextPairs = default)
        {
            referenceTextPairs ??= new ChangeTrackingList<ReferenceTextPair>();

            return new TranslationTarget(
                language,
                script,
                profanityAction,
                profanityMarker,
                deploymentName,
                allowFallback,
                grade,
                tone,
                gender,
                adaptiveDatasetId,
                referenceTextPairs.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Reference text pair to generate adaptive customized translation. </summary>
        /// <param name="source"> Source reference sentence. </param>
        /// <param name="target"> Target reference sentence. </param>
        /// <returns> A new <see cref="Text.ReferenceTextPair"/> instance for mocking. </returns>
        public static ReferenceTextPair ReferenceTextPair(string source = default, string target = default)
        {
            return new ReferenceTextPair(source, target, additionalBinaryDataProperties: null);
        }

        /// <summary> Element containing the translated text. </summary>
        /// <param name="detectedLanguage"> The detectedLanguage property is only present in the result object when language auto-detection is requested. </param>
        /// <param name="translations">
        /// An array of translation results. The size of the array matches the number of target 
        /// languages specified through the to query parameter.
        /// </param>
        /// <returns> A new <see cref="Text.TranslatedTextItem"/> instance for mocking. </returns>
        public static TranslatedTextItem TranslatedTextItem(DetectedLanguage detectedLanguage = default, IEnumerable<TranslationText> translations = default)
        {
            translations ??= new ChangeTrackingList<TranslationText>();

            return new TranslatedTextItem(detectedLanguage, translations.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> An object describing the detected language. </summary>
        /// <param name="language"> A string representing the code of the detected language. </param>
        /// <param name="score">
        /// A float value indicating the confidence in the result.
        /// The score is between zero and one and a low score indicates a low confidence.
        /// </param>
        /// <returns> A new <see cref="Text.DetectedLanguage"/> instance for mocking. </returns>
        public static DetectedLanguage DetectedLanguage(string language = default, float score = default)
        {
            return new DetectedLanguage(language, score, additionalBinaryDataProperties: null);
        }

        /// <summary> Translation result. </summary>
        /// <param name="language"> A string representing the language code of the target language. </param>
        /// <param name="sourceCharacters"> An integer indicating the number of characters in the source text string. </param>
        /// <param name="instructionTokens"> An integer indicating the number of tokens used in generating the translated text. </param>
        /// <param name="sourceTokens"> An integer indicating the number of tokens used in the source sentence. </param>
        /// <param name="responseTokens"> An integer indicating the number of tokens used in the translation response. </param>
        /// <param name="targetTokens"> An integer indicating the number of tokens used in the target sentence. </param>
        /// <param name="text"> A string giving the translated text. </param>
        /// <returns> A new <see cref="Text.TranslationText"/> instance for mocking. </returns>
        public static TranslationText TranslationText(string language = default, int? sourceCharacters = default, int? instructionTokens = default, int? sourceTokens = default, int? responseTokens = default, int? targetTokens = default, string text = default)
        {
            return new TranslationText(
                language,
                sourceCharacters,
                instructionTokens,
                sourceTokens,
                responseTokens,
                targetTokens,
                text,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Element containing the text for translation. </summary>
        /// <param name="text"> Text to translate. </param>
        /// <returns> A new <see cref="Text.InputTextItem"/> instance for mocking. </returns>
        public static InputTextItem InputTextItem(string text = default)
        {
            return new InputTextItem(text, additionalBinaryDataProperties: null);
        }

        /// <summary> Transliterated text element. </summary>
        /// <param name="text"> A string which is the result of converting the input string to the output script. </param>
        /// <param name="script"> A string specifying the script used in the output. </param>
        /// <returns> A new <see cref="Text.TransliteratedText"/> instance for mocking. </returns>
        public static TransliteratedText TransliteratedText(string text = default, string script = default)
        {
            return new TransliteratedText(text, script, additionalBinaryDataProperties: null);
        }
    }
}
