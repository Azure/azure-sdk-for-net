<?xml version="1.0" encoding="utf-8"?>
<doc>
  <members>
    <member name="GetLanguagesAsync(string,string,string,ETag?,RequestContext)">
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>GetLanguagesResult</c>:
<code>{
  translation: Dictionary&lt;string, TranslationLanguage&gt;, # Optional. Languages that support translate API.
  transliteration: Dictionary&lt;string, TransliterationLanguage&gt;, # Optional. Languages that support transliteration API.
  dictionary: Dictionary&lt;string, SourceDictionaryLanguage&gt;, # Optional. Languages that support dictionary API.
}
</code>

</remarks>
    </member>
    <member name="GetLanguages(string,string,string,ETag?,RequestContext)">
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>GetLanguagesResult</c>:
<code>{
  translation: Dictionary&lt;string, TranslationLanguage&gt;, # Optional. Languages that support translate API.
  transliteration: Dictionary&lt;string, TransliterationLanguage&gt;, # Optional. Languages that support transliteration API.
  dictionary: Dictionary&lt;string, SourceDictionaryLanguage&gt;, # Optional. Languages that support dictionary API.
}
</code>

</remarks>
    </member>
    <member name="TranslateAsync(IEnumerable{string},RequestContent,string,string,string,string,string,string,bool?,bool?,string,string,string,bool?,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>InputTextItem</c>:
<code>{
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>TranslatedTextItem</c>:
<code>{
  detectedLanguage: {
    language: string, # Required. A string representing the code of the detected language.
    score: number, # Required. A float value indicating the confidence in the result.
The score is between zero and one and a low score indicates a low confidence.
  }, # Optional. The detectedLanguage property is only present in the result object when language auto-detection is requested.
  translations: [
    {
      to: string, # Required. A string representing the language code of the target language.
      text: string, # Required. A string giving the translated text.
      transliteration: {
        text: string, # Required. A string which is the result of converting the input string to the output script.
        script: string, # Required. A string specifying the script used in the output.
      }, # Optional. An object giving the translated text in the script specified by the toScript parameter.
      alignment: {
        proj: string, # Required. Maps input text to translated text. The alignment information is only provided when the request 
parameter includeAlignment is true. Alignment is returned as a string value of the following 
format: [[SourceTextStartIndex]:[SourceTextEndIndex]–[TgtTextStartIndex]:[TgtTextEndIndex]]. 
The colon separates start and end index, the dash separates the languages, and space separates the words. 
One word may align with zero, one, or multiple words in the other language, and the aligned words may 
be non-contiguous. When no alignment information is available, the alignment element will be empty.
      }, # Optional. Alignment information.
      sentLen: {
        srcSentLen: [number], # Required. An integer array representing the lengths of the sentences in the input text. 
The length of the array is the number of sentences, and the values are the length of each sentence.
        transSentLen: [number], # Required. An integer array representing the lengths of the sentences in the translated text. 
The length of the array is the number of sentences, and the values are the length of each sentence.
      }, # Optional. Sentence boundaries in the input and output texts.
    }
  ], # Required. An array of translation results. The size of the array matches the number of target 
languages specified through the to query parameter.
  sourceText: {
    text: string, # Required. Input text in the default script of the source language.
  }, # Optional. Input text in the default script of the source language. sourceText property is present only when 
the input is expressed in a script that&apos;s not the usual script for the language. For example, 
if the input were Arabic written in Latin script, then sourceText.text would be the same Arabic text 
converted into Arab script.
}
</code>

</remarks>
    </member>
    <member name="Translate(IEnumerable{string},RequestContent,string,string,string,string,string,string,bool?,bool?,string,string,string,bool?,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>InputTextItem</c>:
<code>{
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>TranslatedTextItem</c>:
<code>{
  detectedLanguage: {
    language: string, # Required. A string representing the code of the detected language.
    score: number, # Required. A float value indicating the confidence in the result.
The score is between zero and one and a low score indicates a low confidence.
  }, # Optional. The detectedLanguage property is only present in the result object when language auto-detection is requested.
  translations: [
    {
      to: string, # Required. A string representing the language code of the target language.
      text: string, # Required. A string giving the translated text.
      transliteration: {
        text: string, # Required. A string which is the result of converting the input string to the output script.
        script: string, # Required. A string specifying the script used in the output.
      }, # Optional. An object giving the translated text in the script specified by the toScript parameter.
      alignment: {
        proj: string, # Required. Maps input text to translated text. The alignment information is only provided when the request 
parameter includeAlignment is true. Alignment is returned as a string value of the following 
format: [[SourceTextStartIndex]:[SourceTextEndIndex]–[TgtTextStartIndex]:[TgtTextEndIndex]]. 
The colon separates start and end index, the dash separates the languages, and space separates the words. 
One word may align with zero, one, or multiple words in the other language, and the aligned words may 
be non-contiguous. When no alignment information is available, the alignment element will be empty.
      }, # Optional. Alignment information.
      sentLen: {
        srcSentLen: [number], # Required. An integer array representing the lengths of the sentences in the input text. 
The length of the array is the number of sentences, and the values are the length of each sentence.
        transSentLen: [number], # Required. An integer array representing the lengths of the sentences in the translated text. 
The length of the array is the number of sentences, and the values are the length of each sentence.
      }, # Optional. Sentence boundaries in the input and output texts.
    }
  ], # Required. An array of translation results. The size of the array matches the number of target 
languages specified through the to query parameter.
  sourceText: {
    text: string, # Required. Input text in the default script of the source language.
  }, # Optional. Input text in the default script of the source language. sourceText property is present only when 
the input is expressed in a script that&apos;s not the usual script for the language. For example, 
if the input were Arabic written in Latin script, then sourceText.text would be the same Arabic text 
converted into Arab script.
}
</code>

</remarks>
    </member>
    <member name="TransliterateAsync(string,string,string,RequestContent,string,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>InputTextItem</c>:
<code>{
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>TransliteratedText</c>:
<code>{
  text: string, # Required. A string which is the result of converting the input string to the output script.
  script: string, # Required. A string specifying the script used in the output.
}
</code>

</remarks>
    </member>
    <member name="Transliterate(string,string,string,RequestContent,string,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>InputTextItem</c>:
<code>{
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>TransliteratedText</c>:
<code>{
  text: string, # Required. A string which is the result of converting the input string to the output script.
  script: string, # Required. A string specifying the script used in the output.
}
</code>

</remarks>
    </member>
    <member name="FindSentenceBoundariesAsync(RequestContent,string,string,string,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>InputTextItem</c>:
<code>{
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>BreakSentenceItem</c>:
<code>{
  detectedLanguage: {
    language: string, # Required. A string representing the code of the detected language.
    score: number, # Required. A float value indicating the confidence in the result.
The score is between zero and one and a low score indicates a low confidence.
  }, # Optional. The detectedLanguage property is only present in the result object when language auto-detection is requested.
  sentLen: [number], # Required. An integer array representing the lengths of the sentences in the input text.
The length of the array is the number of sentences, and the values are the length of each sentence.
}
</code>

</remarks>
    </member>
    <member name="FindSentenceBoundaries(RequestContent,string,string,string,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>InputTextItem</c>:
<code>{
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>BreakSentenceItem</c>:
<code>{
  detectedLanguage: {
    language: string, # Required. A string representing the code of the detected language.
    score: number, # Required. A float value indicating the confidence in the result.
The score is between zero and one and a low score indicates a low confidence.
  }, # Optional. The detectedLanguage property is only present in the result object when language auto-detection is requested.
  sentLen: [number], # Required. An integer array representing the lengths of the sentences in the input text.
The length of the array is the number of sentences, and the values are the length of each sentence.
}
</code>

</remarks>
    </member>
    <member name="LookupDictionaryEntriesAsync(string,string,RequestContent,string,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>InputTextItem</c>:
<code>{
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>DictionaryLookupItem</c>:
<code>{
  normalizedSource: string, # Required. A string giving the normalized form of the source term.
For example, if the request is &quot;JOHN&quot;, the normalized form will be &quot;john&quot;.
The content of this field becomes the input to lookup examples.
  displaySource: string, # Required. A string giving the source term in a form best suited for end-user display.
For example, if the input is &quot;JOHN&quot;, the display form will reflect the usual
spelling of the name: &quot;John&quot;.
  translations: [
    {
      normalizedTarget: string, # Required. A string giving the normalized form of this term in the target language.
This value should be used as input to lookup examples.
      displayTarget: string, # Required. A string giving the term in the target language and in a form best suited
for end-user display. Generally, this will only differ from the normalizedTarget
in terms of capitalization. For example, a proper noun like &quot;Juan&quot; will have
normalizedTarget = &quot;juan&quot; and displayTarget = &quot;Juan&quot;.
      posTag: string, # Required. A string associating this term with a part-of-speech tag.
      confidence: number, # Required. A value between 0.0 and 1.0 which represents the &quot;confidence&quot; 
(or perhaps more accurately, &quot;probability in the training data&quot;) of that translation pair. 
The sum of confidence scores for one source word may or may not sum to 1.0.
      prefixWord: string, # Required. A string giving the word to display as a prefix of the translation. Currently,
this is the gendered determiner of nouns, in languages that have gendered determiners.
For example, the prefix of the Spanish word &quot;mosca&quot; is &quot;la&quot;, since &quot;mosca&quot; is a feminine noun in Spanish. 
This is only dependent on the translation, and not on the source. 
If there is no prefix, it will be the empty string.
      backTranslations: [BackTranslation], # Required. A list of &quot;back translations&quot; of the target. For example, source words that the target can translate to.
The list is guaranteed to contain the source word that was requested (e.g., if the source word being
looked up is &quot;fly&quot;, then it is guaranteed that &quot;fly&quot; will be in the backTranslations list).
However, it is not guaranteed to be in the first position, and often will not be.
    }
  ], # Required. A list of translations for the source term.
}
</code>

</remarks>
    </member>
    <member name="LookupDictionaryEntries(string,string,RequestContent,string,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>InputTextItem</c>:
<code>{
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>DictionaryLookupItem</c>:
<code>{
  normalizedSource: string, # Required. A string giving the normalized form of the source term.
For example, if the request is &quot;JOHN&quot;, the normalized form will be &quot;john&quot;.
The content of this field becomes the input to lookup examples.
  displaySource: string, # Required. A string giving the source term in a form best suited for end-user display.
For example, if the input is &quot;JOHN&quot;, the display form will reflect the usual
spelling of the name: &quot;John&quot;.
  translations: [
    {
      normalizedTarget: string, # Required. A string giving the normalized form of this term in the target language.
This value should be used as input to lookup examples.
      displayTarget: string, # Required. A string giving the term in the target language and in a form best suited
for end-user display. Generally, this will only differ from the normalizedTarget
in terms of capitalization. For example, a proper noun like &quot;Juan&quot; will have
normalizedTarget = &quot;juan&quot; and displayTarget = &quot;Juan&quot;.
      posTag: string, # Required. A string associating this term with a part-of-speech tag.
      confidence: number, # Required. A value between 0.0 and 1.0 which represents the &quot;confidence&quot; 
(or perhaps more accurately, &quot;probability in the training data&quot;) of that translation pair. 
The sum of confidence scores for one source word may or may not sum to 1.0.
      prefixWord: string, # Required. A string giving the word to display as a prefix of the translation. Currently,
this is the gendered determiner of nouns, in languages that have gendered determiners.
For example, the prefix of the Spanish word &quot;mosca&quot; is &quot;la&quot;, since &quot;mosca&quot; is a feminine noun in Spanish. 
This is only dependent on the translation, and not on the source. 
If there is no prefix, it will be the empty string.
      backTranslations: [BackTranslation], # Required. A list of &quot;back translations&quot; of the target. For example, source words that the target can translate to.
The list is guaranteed to contain the source word that was requested (e.g., if the source word being
looked up is &quot;fly&quot;, then it is guaranteed that &quot;fly&quot; will be in the backTranslations list).
However, it is not guaranteed to be in the first position, and often will not be.
    }
  ], # Required. A list of translations for the source term.
}
</code>

</remarks>
    </member>
    <member name="LookupDictionaryExamplesAsync(string,string,RequestContent,string,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>DictionaryExampleTextItem</c>:
<code>{
  translation: string, # Required. A string specifying the translated text previously returned by the Dictionary lookup operation. 
This should be the value from the normalizedTarget field in the translations list of the Dictionary 
lookup response. The service will return examples for the specific source-target word-pair.
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>DictionaryExampleItem</c>:
<code>{
  normalizedSource: string, # Required. A string giving the normalized form of the source term. Generally, this should be identical
to the value of the Text field at the matching list index in the body of the request.
  normalizedTarget: string, # Required. A string giving the normalized form of the target term. Generally, this should be identical
to the value of the Translation field at the matching list index in the body of the request.
  examples: [
    {
      sourcePrefix: string, # Required. The string to concatenate before the value of sourceTerm to form a complete example.
Do not add a space character, since it is already there when it should be.
This value may be an empty string.
      sourceTerm: string, # Required. A string equal to the actual term looked up. The string is added with sourcePrefix
and sourceSuffix to form the complete example. Its value is separated so it can be
marked in a user interface, e.g., by bolding it.
      sourceSuffix: string, # Required. The string to concatenate after the value of sourceTerm to form a complete example.
Do not add a space character, since it is already there when it should be.
This value may be an empty string.
      targetPrefix: string, # Required. A string similar to sourcePrefix but for the target.
      targetTerm: string, # Required. A string similar to sourceTerm but for the target.
      targetSuffix: string, # Required. A string similar to sourceSuffix but for the target.
    }
  ], # Required. A list of examples for the (source term, target term) pair.
}
</code>

</remarks>
    </member>
    <member name="LookupDictionaryExamples(string,string,RequestContent,string,RequestContext)">
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>DictionaryExampleTextItem</c>:
<code>{
  translation: string, # Required. A string specifying the translated text previously returned by the Dictionary lookup operation. 
This should be the value from the normalizedTarget field in the translations list of the Dictionary 
lookup response. The service will return examples for the specific source-target word-pair.
  text: string, # Required. Text to translate.
}
</code>

Response Body:

Schema for <c>DictionaryExampleItem</c>:
<code>{
  normalizedSource: string, # Required. A string giving the normalized form of the source term. Generally, this should be identical
to the value of the Text field at the matching list index in the body of the request.
  normalizedTarget: string, # Required. A string giving the normalized form of the target term. Generally, this should be identical
to the value of the Translation field at the matching list index in the body of the request.
  examples: [
    {
      sourcePrefix: string, # Required. The string to concatenate before the value of sourceTerm to form a complete example.
Do not add a space character, since it is already there when it should be.
This value may be an empty string.
      sourceTerm: string, # Required. A string equal to the actual term looked up. The string is added with sourcePrefix
and sourceSuffix to form the complete example. Its value is separated so it can be
marked in a user interface, e.g., by bolding it.
      sourceSuffix: string, # Required. The string to concatenate after the value of sourceTerm to form a complete example.
Do not add a space character, since it is already there when it should be.
This value may be an empty string.
      targetPrefix: string, # Required. A string similar to sourcePrefix but for the target.
      targetTerm: string, # Required. A string similar to sourceTerm but for the target.
      targetSuffix: string, # Required. A string similar to sourceSuffix but for the target.
    }
  ], # Required. A list of examples for the (source term, target term) pair.
}
</code>

</remarks>
    </member>
  </members>
</doc>