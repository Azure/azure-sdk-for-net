// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.AI.Translation.Text
{
    /// <summary> Translate targets parameters. </summary>
    public partial class TranslateTarget
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="TranslateTarget"/>. </summary>
        /// <param name="language">
        /// Specifies the language of the output text. The target language must be one of the supported languages included
        /// in the translation scope. It's possible to translate to multiple languages simultaneously by including
        /// multiple string values in the targetsLanguage array.
        /// </param>
        /// <exception cref="ArgumentNullException"> <paramref name="language"/> is null. </exception>
        public TranslateTarget(string language)
        {
            Argument.AssertNotNull(language, nameof(language));

            Language = language;
            ReferenceTextPairs = new ChangeTrackingList<ReferenceSentencePair>();
        }

        /// <summary> Initializes a new instance of <see cref="TranslateTarget"/>. </summary>
        /// <param name="language">
        /// Specifies the language of the output text. The target language must be one of the supported languages included
        /// in the translation scope. It's possible to translate to multiple languages simultaneously by including
        /// multiple string values in the targetsLanguage array.
        /// </param>
        /// <param name="script"> Specifies the script of the translated text. </param>
        /// <param name="profanityAction">
        /// Specifies how profanities should be treated in translations.
        /// Possible values are: NoAction (default), Marked or Deleted.
        /// </param>
        /// <param name="profanityMarker">
        /// Specifies how profanities should be marked in translations.
        /// Possible values are: Asterisk (default) or Tag.
        /// </param>
        /// <param name="deploymentName">
        /// Default is ‘general’, which uses NMT system.
        /// ‘abc-inc-gpt-4o’, and ‘abc-inc-gpt-4o-mini’ are examples of deployment names which use GPT-4o uses or
        /// GPT-4o-mini model. ‘gpt-4o’ uses GPT-4o model.
        ///
        /// ‘&lt;custom model id&gt;’ uses the custom NMT model tuned by customer.
        /// ‘best’ system determines which is the best model to use for the request. This intelligence could be introduced
        /// in future. Customer should have deployed it in their resource.
        ///
        /// </param>
        /// <param name="allowFallback">
        /// In the case where a custom system is being used, specifies that the service is allowed to fall back to a
        /// general system when a custom system doesn't exist.
        /// In the case where a Large Language Model is being used, specifies that the service is allowed to fall
        /// back to a Small Language Model if an error occurs.
        /// Possible values are: true (default) or false.
        ///
        /// allowFallback=false specifies that the translation should only use systems trained for the category specified
        /// by the request. If a translation for language X to language Y requires chaining through a pivot language E,
        /// then all the systems in the chain (X → E and E → Y) will need to be custom and have the same category.
        /// If no system is found with the specific category, the request will return a 400 status code. allowFallback=true
        /// specifies that the service is allowed to fall back to a general system when a custom system doesn't exist.
        /// </param>
        /// <param name="grade"> Defines complexity of LLM prompts to provide high accuracy translation. </param>
        /// <param name="tone"> Desired tone of target translation. </param>
        /// <param name="gender"> Desired gender of target translation. </param>
        /// <param name="adaptiveDatasetId"> Reference dataset ID having sentence pair to generate adaptive customized translation. </param>
        /// <param name="referenceTextPairs"> Reference sentence pairs to generate adaptive results. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal TranslateTarget(string language, string script, ProfanityAction? profanityAction, ProfanityMarker? profanityMarker, string deploymentName, bool? allowFallback, string grade, string tone, string gender, string adaptiveDatasetId, IList<ReferenceSentencePair> referenceTextPairs, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Language = language;
            Script = script;
            ProfanityAction = profanityAction;
            ProfanityMarker = profanityMarker;
            DeploymentName = deploymentName;
            AllowFallback = allowFallback;
            Grade = grade;
            Tone = tone;
            Gender = gender;
            AdaptiveDatasetId = adaptiveDatasetId;
            ReferenceTextPairs = referenceTextPairs;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="TranslateTarget"/> for deserialization. </summary>
        internal TranslateTarget()
        {
        }

        /// <summary>
        /// Specifies the language of the output text. The target language must be one of the supported languages included
        /// in the translation scope. It's possible to translate to multiple languages simultaneously by including
        /// multiple string values in the targetsLanguage array.
        /// </summary>
        public string Language { get; }
        /// <summary> Specifies the script of the translated text. </summary>
        public string Script { get; set; }
        /// <summary>
        /// Specifies how profanities should be treated in translations.
        /// Possible values are: NoAction (default), Marked or Deleted.
        /// </summary>
        public ProfanityAction? ProfanityAction { get; set; }
        /// <summary>
        /// Specifies how profanities should be marked in translations.
        /// Possible values are: Asterisk (default) or Tag.
        /// </summary>
        public ProfanityMarker? ProfanityMarker { get; set; }
        /// <summary>
        /// Default is ‘general’, which uses NMT system.
        /// ‘abc-inc-gpt-4o’, and ‘abc-inc-gpt-4o-mini’ are examples of deployment names which use GPT-4o uses or
        /// GPT-4o-mini model. ‘gpt-4o’ uses GPT-4o model.
        ///
        /// ‘&lt;custom model id&gt;’ uses the custom NMT model tuned by customer.
        /// ‘best’ system determines which is the best model to use for the request. This intelligence could be introduced
        /// in future. Customer should have deployed it in their resource.
        ///
        /// </summary>
        public string DeploymentName { get; set; }
        /// <summary>
        /// In the case where a custom system is being used, specifies that the service is allowed to fall back to a
        /// general system when a custom system doesn't exist.
        /// In the case where a Large Language Model is being used, specifies that the service is allowed to fall
        /// back to a Small Language Model if an error occurs.
        /// Possible values are: true (default) or false.
        ///
        /// allowFallback=false specifies that the translation should only use systems trained for the category specified
        /// by the request. If a translation for language X to language Y requires chaining through a pivot language E,
        /// then all the systems in the chain (X → E and E → Y) will need to be custom and have the same category.
        /// If no system is found with the specific category, the request will return a 400 status code. allowFallback=true
        /// specifies that the service is allowed to fall back to a general system when a custom system doesn't exist.
        /// </summary>
        public bool? AllowFallback { get; set; }
        /// <summary> Defines complexity of LLM prompts to provide high accuracy translation. </summary>
        public string Grade { get; set; }
        /// <summary> Desired tone of target translation. </summary>
        public string Tone { get; set; }
        /// <summary> Desired gender of target translation. </summary>
        public string Gender { get; set; }
        /// <summary> Reference dataset ID having sentence pair to generate adaptive customized translation. </summary>
        public string AdaptiveDatasetId { get; set; }
        /// <summary> Reference sentence pairs to generate adaptive results. </summary>
        public IList<ReferenceSentencePair> ReferenceTextPairs { get; }
    }
}
