// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Temp.Batch.Models;

namespace Azure.Temp.Batch
{
    internal partial class JobRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of JobRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientDiagnostics"/>, <paramref name="pipeline"/>, <paramref name="batchUrl"/> or <paramref name="apiVersion"/> is null. </exception>
        public JobRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2023-05-01.17.0")
        {
            ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException(nameof(clientDiagnostics));
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _batchUrl = batchUrl ?? throw new ArgumentNullException(nameof(batchUrl));
            _apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
        }

        internal HttpMessage CreateDeleteRequest(string jobId, JobDeleteOptions jobDeleteOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            if (jobDeleteOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobDeleteOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobDeleteOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobDeleteOptions.ClientRequestId.Value);
            }
            if (jobDeleteOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobDeleteOptions.ReturnClientRequestId.Value);
            }
            if (jobDeleteOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobDeleteOptions.OcpDate.Value, "R");
            }
            if (jobDeleteOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobDeleteOptions.IfMatch);
            }
            if (jobDeleteOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobDeleteOptions.IfNoneMatch);
            }
            if (jobDeleteOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobDeleteOptions.IfModifiedSince.Value, "R");
            }
            if (jobDeleteOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobDeleteOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Deletes a Job. </summary>
        /// <param name="jobId"> The ID of the Job to delete. </param>
        /// <param name="jobDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> Deleting a Job also deletes all Tasks that are part of that Job, and all Job statistics. This also overrides the retention period for Task data; that is, if the Job contains Tasks which are still retained on Compute Nodes, the Batch services deletes those Tasks' working directories and all their contents.  When a Delete Job request is received, the Batch service sets the Job to the deleting state. All update operations on a Job that is in deleting state will fail with status code 409 (Conflict), with additional information indicating that the Job is being deleted. </remarks>
        public async Task<ResponseWithHeaders<JobDeleteHeaders>> DeleteAsync(string jobId, JobDeleteOptions jobDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateDeleteRequest(jobId, jobDeleteOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Deletes a Job. </summary>
        /// <param name="jobId"> The ID of the Job to delete. </param>
        /// <param name="jobDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> Deleting a Job also deletes all Tasks that are part of that Job, and all Job statistics. This also overrides the retention period for Task data; that is, if the Job contains Tasks which are still retained on Compute Nodes, the Batch services deletes those Tasks' working directories and all their contents.  When a Delete Job request is received, the Batch service sets the Job to the deleting state. All update operations on a Job that is in deleting state will fail with status code 409 (Conflict), with additional information indicating that the Job is being deleted. </remarks>
        public ResponseWithHeaders<JobDeleteHeaders> Delete(string jobId, JobDeleteOptions jobDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateDeleteRequest(jobId, jobDeleteOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetRequest(string jobId, JobGetOptions jobGetOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            if (jobGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", jobGetOptions.Select, true);
            }
            if (jobGetOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", jobGetOptions.Expand, true);
            }
            if (jobGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobGetOptions.ClientRequestId.Value);
            }
            if (jobGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobGetOptions.ReturnClientRequestId.Value);
            }
            if (jobGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobGetOptions.OcpDate.Value, "R");
            }
            if (jobGetOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobGetOptions.IfMatch);
            }
            if (jobGetOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobGetOptions.IfNoneMatch);
            }
            if (jobGetOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobGetOptions.IfModifiedSince.Value, "R");
            }
            if (jobGetOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobGetOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets information about the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="jobGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudJob, JobGetHeaders>> GetAsync(string jobId, JobGetOptions jobGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateGetRequest(jobId, jobGetOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJob value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudJob.DeserializeCloudJob(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Gets information about the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="jobGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        public ResponseWithHeaders<CloudJob, JobGetHeaders> Get(string jobId, JobGetOptions jobGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateGetRequest(jobId, jobGetOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJob value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudJob.DeserializeCloudJob(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePatchRequest(string jobId, JobPatchParameter jobPatchParameter, JobPatchOptions jobPatchOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            if (jobPatchOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobPatchOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobPatchOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobPatchOptions.ClientRequestId.Value);
            }
            if (jobPatchOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobPatchOptions.ReturnClientRequestId.Value);
            }
            if (jobPatchOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobPatchOptions.OcpDate.Value, "R");
            }
            if (jobPatchOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobPatchOptions.IfMatch);
            }
            if (jobPatchOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobPatchOptions.IfNoneMatch);
            }
            if (jobPatchOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobPatchOptions.IfModifiedSince.Value, "R");
            }
            if (jobPatchOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobPatchOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(jobPatchParameter);
            request.Content = content;
            return message;
        }

        /// <summary> Updates the properties of the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="jobPatchParameter"> The parameters for the request. </param>
        /// <param name="jobPatchOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="jobPatchParameter"/> is null. </exception>
        /// <remarks> This replaces only the Job properties specified in the request. For example, if the Job has constraints, and a request does not specify the constraints element, then the Job keeps the existing constraints. </remarks>
        public async Task<ResponseWithHeaders<JobPatchHeaders>> PatchAsync(string jobId, JobPatchParameter jobPatchParameter, JobPatchOptions jobPatchOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (jobPatchParameter == null)
            {
                throw new ArgumentNullException(nameof(jobPatchParameter));
            }

            using var message = CreatePatchRequest(jobId, jobPatchParameter, jobPatchOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobPatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Updates the properties of the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="jobPatchParameter"> The parameters for the request. </param>
        /// <param name="jobPatchOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="jobPatchParameter"/> is null. </exception>
        /// <remarks> This replaces only the Job properties specified in the request. For example, if the Job has constraints, and a request does not specify the constraints element, then the Job keeps the existing constraints. </remarks>
        public ResponseWithHeaders<JobPatchHeaders> Patch(string jobId, JobPatchParameter jobPatchParameter, JobPatchOptions jobPatchOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (jobPatchParameter == null)
            {
                throw new ArgumentNullException(nameof(jobPatchParameter));
            }

            using var message = CreatePatchRequest(jobId, jobPatchParameter, jobPatchOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobPatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdateRequest(string jobId, JobUpdateParameter jobUpdateParameter, JobUpdateOptions jobUpdateOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            if (jobUpdateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobUpdateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobUpdateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobUpdateOptions.ClientRequestId.Value);
            }
            if (jobUpdateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobUpdateOptions.ReturnClientRequestId.Value);
            }
            if (jobUpdateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobUpdateOptions.OcpDate.Value, "R");
            }
            if (jobUpdateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobUpdateOptions.IfMatch);
            }
            if (jobUpdateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobUpdateOptions.IfNoneMatch);
            }
            if (jobUpdateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobUpdateOptions.IfModifiedSince.Value, "R");
            }
            if (jobUpdateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobUpdateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(jobUpdateParameter);
            request.Content = content;
            return message;
        }

        /// <summary> Updates the properties of the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="jobUpdateParameter"> The parameters for the request. </param>
        /// <param name="jobUpdateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="jobUpdateParameter"/> is null. </exception>
        /// <remarks> This fully replaces all the updatable properties of the Job. For example, if the Job has constraints associated with it and if constraints is not specified with this request, then the Batch service will remove the existing constraints. </remarks>
        public async Task<ResponseWithHeaders<JobUpdateHeaders>> UpdateAsync(string jobId, JobUpdateParameter jobUpdateParameter, JobUpdateOptions jobUpdateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (jobUpdateParameter == null)
            {
                throw new ArgumentNullException(nameof(jobUpdateParameter));
            }

            using var message = CreateUpdateRequest(jobId, jobUpdateParameter, jobUpdateOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobUpdateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Updates the properties of the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="jobUpdateParameter"> The parameters for the request. </param>
        /// <param name="jobUpdateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="jobUpdateParameter"/> is null. </exception>
        /// <remarks> This fully replaces all the updatable properties of the Job. For example, if the Job has constraints associated with it and if constraints is not specified with this request, then the Batch service will remove the existing constraints. </remarks>
        public ResponseWithHeaders<JobUpdateHeaders> Update(string jobId, JobUpdateParameter jobUpdateParameter, JobUpdateOptions jobUpdateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (jobUpdateParameter == null)
            {
                throw new ArgumentNullException(nameof(jobUpdateParameter));
            }

            using var message = CreateUpdateRequest(jobId, jobUpdateParameter, jobUpdateOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobUpdateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDisableRequest(string jobId, JobDisableParameter jobDisableParameter, JobDisableOptions jobDisableOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/disable", false);
            if (jobDisableOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobDisableOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobDisableOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobDisableOptions.ClientRequestId.Value);
            }
            if (jobDisableOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobDisableOptions.ReturnClientRequestId.Value);
            }
            if (jobDisableOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobDisableOptions.OcpDate.Value, "R");
            }
            if (jobDisableOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobDisableOptions.IfMatch);
            }
            if (jobDisableOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobDisableOptions.IfNoneMatch);
            }
            if (jobDisableOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobDisableOptions.IfModifiedSince.Value, "R");
            }
            if (jobDisableOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobDisableOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(jobDisableParameter);
            request.Content = content;
            return message;
        }

        /// <summary> Disables the specified Job, preventing new Tasks from running. </summary>
        /// <param name="jobId"> The ID of the Job to disable. </param>
        /// <param name="jobDisableParameter"> The parameters for the request. </param>
        /// <param name="jobDisableOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="jobDisableParameter"/> is null. </exception>
        /// <remarks> The Batch Service immediately moves the Job to the disabling state. Batch then uses the disableTasks parameter to determine what to do with the currently running Tasks of the Job. The Job remains in the disabling state until the disable operation is completed and all Tasks have been dealt with according to the disableTasks option; the Job then moves to the disabled state. No new Tasks are started under the Job until it moves back to active state. If you try to disable a Job that is in any state other than active, disabling, or disabled, the request fails with status code 409. </remarks>
        public async Task<ResponseWithHeaders<JobDisableHeaders>> DisableAsync(string jobId, JobDisableParameter jobDisableParameter, JobDisableOptions jobDisableOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (jobDisableParameter == null)
            {
                throw new ArgumentNullException(nameof(jobDisableParameter));
            }

            using var message = CreateDisableRequest(jobId, jobDisableParameter, jobDisableOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobDisableHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Disables the specified Job, preventing new Tasks from running. </summary>
        /// <param name="jobId"> The ID of the Job to disable. </param>
        /// <param name="jobDisableParameter"> The parameters for the request. </param>
        /// <param name="jobDisableOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="jobDisableParameter"/> is null. </exception>
        /// <remarks> The Batch Service immediately moves the Job to the disabling state. Batch then uses the disableTasks parameter to determine what to do with the currently running Tasks of the Job. The Job remains in the disabling state until the disable operation is completed and all Tasks have been dealt with according to the disableTasks option; the Job then moves to the disabled state. No new Tasks are started under the Job until it moves back to active state. If you try to disable a Job that is in any state other than active, disabling, or disabled, the request fails with status code 409. </remarks>
        public ResponseWithHeaders<JobDisableHeaders> Disable(string jobId, JobDisableParameter jobDisableParameter, JobDisableOptions jobDisableOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (jobDisableParameter == null)
            {
                throw new ArgumentNullException(nameof(jobDisableParameter));
            }

            using var message = CreateDisableRequest(jobId, jobDisableParameter, jobDisableOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobDisableHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateEnableRequest(string jobId, JobEnableOptions jobEnableOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/enable", false);
            if (jobEnableOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobEnableOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobEnableOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobEnableOptions.ClientRequestId.Value);
            }
            if (jobEnableOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobEnableOptions.ReturnClientRequestId.Value);
            }
            if (jobEnableOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobEnableOptions.OcpDate.Value, "R");
            }
            if (jobEnableOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobEnableOptions.IfMatch);
            }
            if (jobEnableOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobEnableOptions.IfNoneMatch);
            }
            if (jobEnableOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobEnableOptions.IfModifiedSince.Value, "R");
            }
            if (jobEnableOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobEnableOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Enables the specified Job, allowing new Tasks to run. </summary>
        /// <param name="jobId"> The ID of the Job to enable. </param>
        /// <param name="jobEnableOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> When you call this API, the Batch service sets a disabled Job to the enabling state. After the this operation is completed, the Job moves to the active state, and scheduling of new Tasks under the Job resumes. The Batch service does not allow a Task to remain in the active state for more than 180 days. Therefore, if you enable a Job containing active Tasks which were added more than 180 days ago, those Tasks will not run. </remarks>
        public async Task<ResponseWithHeaders<JobEnableHeaders>> EnableAsync(string jobId, JobEnableOptions jobEnableOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateEnableRequest(jobId, jobEnableOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobEnableHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Enables the specified Job, allowing new Tasks to run. </summary>
        /// <param name="jobId"> The ID of the Job to enable. </param>
        /// <param name="jobEnableOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> When you call this API, the Batch service sets a disabled Job to the enabling state. After the this operation is completed, the Job moves to the active state, and scheduling of new Tasks under the Job resumes. The Batch service does not allow a Task to remain in the active state for more than 180 days. Therefore, if you enable a Job containing active Tasks which were added more than 180 days ago, those Tasks will not run. </remarks>
        public ResponseWithHeaders<JobEnableHeaders> Enable(string jobId, JobEnableOptions jobEnableOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateEnableRequest(jobId, jobEnableOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobEnableHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateTerminateRequest(string jobId, JobTerminateParameter jobTerminateParameter, JobTerminateOptions jobTerminateOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/terminate", false);
            if (jobTerminateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobTerminateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobTerminateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobTerminateOptions.ClientRequestId.Value);
            }
            if (jobTerminateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobTerminateOptions.ReturnClientRequestId.Value);
            }
            if (jobTerminateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobTerminateOptions.OcpDate.Value, "R");
            }
            if (jobTerminateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobTerminateOptions.IfMatch);
            }
            if (jobTerminateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobTerminateOptions.IfNoneMatch);
            }
            if (jobTerminateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobTerminateOptions.IfModifiedSince.Value, "R");
            }
            if (jobTerminateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobTerminateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (jobTerminateParameter != null)
            {
                request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
                var content = new Utf8JsonRequestContent();
                content.JsonWriter.WriteObjectValue(jobTerminateParameter);
                request.Content = content;
            }
            return message;
        }

        /// <summary> Terminates the specified Job, marking it as completed. </summary>
        /// <param name="jobId"> The ID of the Job to terminate. </param>
        /// <param name="jobTerminateParameter"> The parameters for the request. </param>
        /// <param name="jobTerminateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> When a Terminate Job request is received, the Batch service sets the Job to the terminating state. The Batch service then terminates any running Tasks associated with the Job and runs any required Job release Tasks. Then the Job moves into the completed state. If there are any Tasks in the Job in the active state, they will remain in the active state. Once a Job is terminated, new Tasks cannot be added and any remaining active Tasks will not be scheduled. </remarks>
        public async Task<ResponseWithHeaders<JobTerminateHeaders>> TerminateAsync(string jobId, JobTerminateParameter jobTerminateParameter = null, JobTerminateOptions jobTerminateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateTerminateRequest(jobId, jobTerminateParameter, jobTerminateOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobTerminateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Terminates the specified Job, marking it as completed. </summary>
        /// <param name="jobId"> The ID of the Job to terminate. </param>
        /// <param name="jobTerminateParameter"> The parameters for the request. </param>
        /// <param name="jobTerminateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> When a Terminate Job request is received, the Batch service sets the Job to the terminating state. The Batch service then terminates any running Tasks associated with the Job and runs any required Job release Tasks. Then the Job moves into the completed state. If there are any Tasks in the Job in the active state, they will remain in the active state. Once a Job is terminated, new Tasks cannot be added and any remaining active Tasks will not be scheduled. </remarks>
        public ResponseWithHeaders<JobTerminateHeaders> Terminate(string jobId, JobTerminateParameter jobTerminateParameter = null, JobTerminateOptions jobTerminateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateTerminateRequest(jobId, jobTerminateParameter, jobTerminateOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobTerminateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAddRequest(JobAddParameter job, JobAddOptions jobAddOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs", false);
            if (jobAddOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobAddOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobAddOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobAddOptions.ClientRequestId.Value);
            }
            if (jobAddOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobAddOptions.ReturnClientRequestId.Value);
            }
            if (jobAddOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobAddOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(job);
            request.Content = content;
            return message;
        }

        /// <summary> Adds a Job to the specified Account. </summary>
        /// <param name="job"> The Job to be added. </param>
        /// <param name="jobAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="job"/> is null. </exception>
        /// <remarks> The Batch service supports two ways to control the work done as part of a Job. In the first approach, the user specifies a Job Manager Task. The Batch service launches this Task when it is ready to start the Job. The Job Manager Task controls all other Tasks that run under this Job, by using the Task APIs. In the second approach, the user directly controls the execution of Tasks under an active Job, by using the Task APIs. Also note: when naming Jobs, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers. </remarks>
        public async Task<ResponseWithHeaders<JobAddHeaders>> AddAsync(JobAddParameter job, JobAddOptions jobAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (job == null)
            {
                throw new ArgumentNullException(nameof(job));
            }

            using var message = CreateAddRequest(job, jobAddOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Adds a Job to the specified Account. </summary>
        /// <param name="job"> The Job to be added. </param>
        /// <param name="jobAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="job"/> is null. </exception>
        /// <remarks> The Batch service supports two ways to control the work done as part of a Job. In the first approach, the user specifies a Job Manager Task. The Batch service launches this Task when it is ready to start the Job. The Job Manager Task controls all other Tasks that run under this Job, by using the Task APIs. In the second approach, the user directly controls the execution of Tasks under an active Job, by using the Task APIs. Also note: when naming Jobs, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers. </remarks>
        public ResponseWithHeaders<JobAddHeaders> Add(JobAddParameter job, JobAddOptions jobAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (job == null)
            {
                throw new ArgumentNullException(nameof(job));
            }

            using var message = CreateAddRequest(job, jobAddOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListRequest(JobListOptions jobListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs", false);
            if (jobListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", jobListOptions.Filter, true);
            }
            if (jobListOptions?.Select != null)
            {
                uri.AppendQuery("$select", jobListOptions.Select, true);
            }
            if (jobListOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", jobListOptions.Expand, true);
            }
            if (jobListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", jobListOptions.MaxResults.Value, true);
            }
            if (jobListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobListOptions.ClientRequestId.Value);
            }
            if (jobListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobListOptions.ReturnClientRequestId.Value);
            }
            if (jobListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the Jobs in the specified Account. </summary>
        /// <param name="jobListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<CloudJobListResult, JobListHeaders>> ListAsync(JobListOptions jobListOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateListRequest(jobListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudJobListResult.DeserializeCloudJobListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists all of the Jobs in the specified Account. </summary>
        /// <param name="jobListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CloudJobListResult, JobListHeaders> List(JobListOptions jobListOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateListRequest(jobListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudJobListResult.DeserializeCloudJobListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListFromJobScheduleRequest(string jobScheduleId, JobListFromJobScheduleOptions jobListFromJobScheduleOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendPath("/jobs", false);
            if (jobListFromJobScheduleOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", jobListFromJobScheduleOptions.Filter, true);
            }
            if (jobListFromJobScheduleOptions?.Select != null)
            {
                uri.AppendQuery("$select", jobListFromJobScheduleOptions.Select, true);
            }
            if (jobListFromJobScheduleOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", jobListFromJobScheduleOptions.Expand, true);
            }
            if (jobListFromJobScheduleOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", jobListFromJobScheduleOptions.MaxResults.Value, true);
            }
            if (jobListFromJobScheduleOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobListFromJobScheduleOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobListFromJobScheduleOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobListFromJobScheduleOptions.ClientRequestId.Value);
            }
            if (jobListFromJobScheduleOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobListFromJobScheduleOptions.ReturnClientRequestId.Value);
            }
            if (jobListFromJobScheduleOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobListFromJobScheduleOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists the Jobs that have been created under the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        /// <param name="jobListFromJobScheduleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudJobListResult, JobListFromJobScheduleHeaders>> ListFromJobScheduleAsync(string jobScheduleId, JobListFromJobScheduleOptions jobListFromJobScheduleOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var message = CreateListFromJobScheduleRequest(jobScheduleId, jobListFromJobScheduleOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobListFromJobScheduleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudJobListResult.DeserializeCloudJobListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists the Jobs that have been created under the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        /// <param name="jobListFromJobScheduleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        public ResponseWithHeaders<CloudJobListResult, JobListFromJobScheduleHeaders> ListFromJobSchedule(string jobScheduleId, JobListFromJobScheduleOptions jobListFromJobScheduleOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var message = CreateListFromJobScheduleRequest(jobScheduleId, jobListFromJobScheduleOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobListFromJobScheduleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudJobListResult.DeserializeCloudJobListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListPreparationAndReleaseTaskStatusRequest(string jobId, JobListPreparationAndReleaseTaskStatusOptions jobListPreparationAndReleaseTaskStatusOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/jobpreparationandreleasetaskstatus", false);
            if (jobListPreparationAndReleaseTaskStatusOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", jobListPreparationAndReleaseTaskStatusOptions.Filter, true);
            }
            if (jobListPreparationAndReleaseTaskStatusOptions?.Select != null)
            {
                uri.AppendQuery("$select", jobListPreparationAndReleaseTaskStatusOptions.Select, true);
            }
            if (jobListPreparationAndReleaseTaskStatusOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", jobListPreparationAndReleaseTaskStatusOptions.MaxResults.Value, true);
            }
            if (jobListPreparationAndReleaseTaskStatusOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobListPreparationAndReleaseTaskStatusOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobListPreparationAndReleaseTaskStatusOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobListPreparationAndReleaseTaskStatusOptions.ClientRequestId.Value);
            }
            if (jobListPreparationAndReleaseTaskStatusOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobListPreparationAndReleaseTaskStatusOptions.ReturnClientRequestId.Value);
            }
            if (jobListPreparationAndReleaseTaskStatusOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobListPreparationAndReleaseTaskStatusOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute Nodes where the Job has run. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="jobListPreparationAndReleaseTaskStatusOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified. </remarks>
        public async Task<ResponseWithHeaders<CloudJobListPreparationAndReleaseTaskStatusResult, JobListPreparationAndReleaseTaskStatusHeaders>> ListPreparationAndReleaseTaskStatusAsync(string jobId, JobListPreparationAndReleaseTaskStatusOptions jobListPreparationAndReleaseTaskStatusOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListPreparationAndReleaseTaskStatusRequest(jobId, jobListPreparationAndReleaseTaskStatusOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobListPreparationAndReleaseTaskStatusHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListPreparationAndReleaseTaskStatusResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudJobListPreparationAndReleaseTaskStatusResult.DeserializeCloudJobListPreparationAndReleaseTaskStatusResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute Nodes where the Job has run. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="jobListPreparationAndReleaseTaskStatusOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified. </remarks>
        public ResponseWithHeaders<CloudJobListPreparationAndReleaseTaskStatusResult, JobListPreparationAndReleaseTaskStatusHeaders> ListPreparationAndReleaseTaskStatus(string jobId, JobListPreparationAndReleaseTaskStatusOptions jobListPreparationAndReleaseTaskStatusOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListPreparationAndReleaseTaskStatusRequest(jobId, jobListPreparationAndReleaseTaskStatusOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobListPreparationAndReleaseTaskStatusHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListPreparationAndReleaseTaskStatusResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudJobListPreparationAndReleaseTaskStatusResult.DeserializeCloudJobListPreparationAndReleaseTaskStatusResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetTaskCountsRequest(string jobId, JobGetTaskCountsOptions jobGetTaskCountsOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/taskcounts", false);
            if (jobGetTaskCountsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobGetTaskCountsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (jobGetTaskCountsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobGetTaskCountsOptions.ClientRequestId.Value);
            }
            if (jobGetTaskCountsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobGetTaskCountsOptions.ReturnClientRequestId.Value);
            }
            if (jobGetTaskCountsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobGetTaskCountsOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets the Task counts for the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="jobGetTaskCountsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> Task counts provide a count of the Tasks by active, running or completed Task state, and a count of Tasks which succeeded or failed. Tasks in the preparing state are counted as running. Note that the numbers returned may not always be up to date. If you need exact task counts, use a list query. </remarks>
        public async Task<ResponseWithHeaders<TaskCountsResult, JobGetTaskCountsHeaders>> GetTaskCountsAsync(string jobId, JobGetTaskCountsOptions jobGetTaskCountsOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateGetTaskCountsRequest(jobId, jobGetTaskCountsOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobGetTaskCountsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TaskCountsResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TaskCountsResult.DeserializeTaskCountsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Gets the Task counts for the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="jobGetTaskCountsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> Task counts provide a count of the Tasks by active, running or completed Task state, and a count of Tasks which succeeded or failed. Tasks in the preparing state are counted as running. Note that the numbers returned may not always be up to date. If you need exact task counts, use a list query. </remarks>
        public ResponseWithHeaders<TaskCountsResult, JobGetTaskCountsHeaders> GetTaskCounts(string jobId, JobGetTaskCountsOptions jobGetTaskCountsOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateGetTaskCountsRequest(jobId, jobGetTaskCountsOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobGetTaskCountsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TaskCountsResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TaskCountsResult.DeserializeTaskCountsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, JobListOptions jobListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (jobListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobListOptions.ClientRequestId.Value);
            }
            if (jobListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobListOptions.ReturnClientRequestId.Value);
            }
            if (jobListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the Jobs in the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudJobListResult, JobListHeaders>> ListNextPageAsync(string nextLink, JobListOptions jobListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateListNextPageRequest(nextLink, jobListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudJobListResult.DeserializeCloudJobListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists all of the Jobs in the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public ResponseWithHeaders<CloudJobListResult, JobListHeaders> ListNextPage(string nextLink, JobListOptions jobListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateListNextPageRequest(nextLink, jobListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudJobListResult.DeserializeCloudJobListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListFromJobScheduleNextPageRequest(string nextLink, string jobScheduleId, JobListFromJobScheduleOptions jobListFromJobScheduleOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (jobListFromJobScheduleOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobListFromJobScheduleOptions.ClientRequestId.Value);
            }
            if (jobListFromJobScheduleOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobListFromJobScheduleOptions.ReturnClientRequestId.Value);
            }
            if (jobListFromJobScheduleOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobListFromJobScheduleOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists the Jobs that have been created under the specified Job Schedule. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        /// <param name="jobListFromJobScheduleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="jobScheduleId"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudJobListResult, JobListFromJobScheduleHeaders>> ListFromJobScheduleNextPageAsync(string nextLink, string jobScheduleId, JobListFromJobScheduleOptions jobListFromJobScheduleOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var message = CreateListFromJobScheduleNextPageRequest(nextLink, jobScheduleId, jobListFromJobScheduleOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobListFromJobScheduleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudJobListResult.DeserializeCloudJobListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists the Jobs that have been created under the specified Job Schedule. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        /// <param name="jobListFromJobScheduleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="jobScheduleId"/> is null. </exception>
        public ResponseWithHeaders<CloudJobListResult, JobListFromJobScheduleHeaders> ListFromJobScheduleNextPage(string nextLink, string jobScheduleId, JobListFromJobScheduleOptions jobListFromJobScheduleOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var message = CreateListFromJobScheduleNextPageRequest(nextLink, jobScheduleId, jobListFromJobScheduleOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobListFromJobScheduleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudJobListResult.DeserializeCloudJobListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListPreparationAndReleaseTaskStatusNextPageRequest(string nextLink, string jobId, JobListPreparationAndReleaseTaskStatusOptions jobListPreparationAndReleaseTaskStatusOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (jobListPreparationAndReleaseTaskStatusOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobListPreparationAndReleaseTaskStatusOptions.ClientRequestId.Value);
            }
            if (jobListPreparationAndReleaseTaskStatusOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobListPreparationAndReleaseTaskStatusOptions.ReturnClientRequestId.Value);
            }
            if (jobListPreparationAndReleaseTaskStatusOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobListPreparationAndReleaseTaskStatusOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute Nodes where the Job has run. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="jobListPreparationAndReleaseTaskStatusOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="jobId"/> is null. </exception>
        /// <remarks> This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified. </remarks>
        public async Task<ResponseWithHeaders<CloudJobListPreparationAndReleaseTaskStatusResult, JobListPreparationAndReleaseTaskStatusHeaders>> ListPreparationAndReleaseTaskStatusNextPageAsync(string nextLink, string jobId, JobListPreparationAndReleaseTaskStatusOptions jobListPreparationAndReleaseTaskStatusOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListPreparationAndReleaseTaskStatusNextPageRequest(nextLink, jobId, jobListPreparationAndReleaseTaskStatusOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new JobListPreparationAndReleaseTaskStatusHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListPreparationAndReleaseTaskStatusResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudJobListPreparationAndReleaseTaskStatusResult.DeserializeCloudJobListPreparationAndReleaseTaskStatusResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists the execution status of the Job Preparation and Job Release Task for the specified Job across the Compute Nodes where the Job has run. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="jobListPreparationAndReleaseTaskStatusOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="jobId"/> is null. </exception>
        /// <remarks> This API returns the Job Preparation and Job Release Task status on all Compute Nodes that have run the Job Preparation or Job Release Task. This includes Compute Nodes which have since been removed from the Pool. If this API is invoked on a Job which has no Job Preparation or Job Release Task, the Batch service returns HTTP status code 409 (Conflict) with an error code of JobPreparationTaskNotSpecified. </remarks>
        public ResponseWithHeaders<CloudJobListPreparationAndReleaseTaskStatusResult, JobListPreparationAndReleaseTaskStatusHeaders> ListPreparationAndReleaseTaskStatusNextPage(string nextLink, string jobId, JobListPreparationAndReleaseTaskStatusOptions jobListPreparationAndReleaseTaskStatusOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListPreparationAndReleaseTaskStatusNextPageRequest(nextLink, jobId, jobListPreparationAndReleaseTaskStatusOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new JobListPreparationAndReleaseTaskStatusHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudJobListPreparationAndReleaseTaskStatusResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudJobListPreparationAndReleaseTaskStatusResult.DeserializeCloudJobListPreparationAndReleaseTaskStatusResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}
