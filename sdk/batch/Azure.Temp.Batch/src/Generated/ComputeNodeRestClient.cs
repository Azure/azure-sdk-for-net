// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Temp.Batch.Models;

namespace Azure.Temp.Batch
{
    internal partial class ComputeNodeRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of ComputeNodeRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientDiagnostics"/>, <paramref name="pipeline"/>, <paramref name="batchUrl"/> or <paramref name="apiVersion"/> is null. </exception>
        public ComputeNodeRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2023-05-01.17.0")
        {
            ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException(nameof(clientDiagnostics));
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _batchUrl = batchUrl ?? throw new ArgumentNullException(nameof(batchUrl));
            _apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
        }

        internal HttpMessage CreateAddUserRequest(string poolId, string nodeId, ComputeNodeUser user, ComputeNodeAddUserOptions computeNodeAddUserOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users", false);
            if (computeNodeAddUserOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeAddUserOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeAddUserOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeAddUserOptions.ClientRequestId.Value);
            }
            if (computeNodeAddUserOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeAddUserOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeAddUserOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeAddUserOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(user);
            request.Content = content;
            return message;
        }

        /// <summary> Adds a user Account to the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="user"> The user Account to be created. </param>
        /// <param name="computeNodeAddUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="user"/> is null. </exception>
        /// <remarks> You can add a user Account to a Compute Node only when it is in the idle or running state. </remarks>
        public async Task<ResponseWithHeaders<ComputeNodeAddUserHeaders>> AddUserAsync(string poolId, string nodeId, ComputeNodeUser user, ComputeNodeAddUserOptions computeNodeAddUserOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            using var message = CreateAddUserRequest(poolId, nodeId, user, computeNodeAddUserOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeAddUserHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Adds a user Account to the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="user"> The user Account to be created. </param>
        /// <param name="computeNodeAddUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="user"/> is null. </exception>
        /// <remarks> You can add a user Account to a Compute Node only when it is in the idle or running state. </remarks>
        public ResponseWithHeaders<ComputeNodeAddUserHeaders> AddUser(string poolId, string nodeId, ComputeNodeUser user, ComputeNodeAddUserOptions computeNodeAddUserOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            using var message = CreateAddUserRequest(poolId, nodeId, user, computeNodeAddUserOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeAddUserHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteUserRequest(string poolId, string nodeId, string userName, ComputeNodeDeleteUserOptions computeNodeDeleteUserOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userName, true);
            if (computeNodeDeleteUserOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeDeleteUserOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeDeleteUserOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeDeleteUserOptions.ClientRequestId.Value);
            }
            if (computeNodeDeleteUserOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeDeleteUserOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeDeleteUserOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeDeleteUserOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Deletes a user Account from the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        /// <param name="userName"> The name of the user Account to delete. </param>
        /// <param name="computeNodeDeleteUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is null. </exception>
        /// <remarks> You can delete a user Account to a Compute Node only when it is in the idle or running state. </remarks>
        public async Task<ResponseWithHeaders<ComputeNodeDeleteUserHeaders>> DeleteUserAsync(string poolId, string nodeId, string userName, ComputeNodeDeleteUserOptions computeNodeDeleteUserOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (userName == null)
            {
                throw new ArgumentNullException(nameof(userName));
            }

            using var message = CreateDeleteUserRequest(poolId, nodeId, userName, computeNodeDeleteUserOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeDeleteUserHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Deletes a user Account from the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        /// <param name="userName"> The name of the user Account to delete. </param>
        /// <param name="computeNodeDeleteUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is null. </exception>
        /// <remarks> You can delete a user Account to a Compute Node only when it is in the idle or running state. </remarks>
        public ResponseWithHeaders<ComputeNodeDeleteUserHeaders> DeleteUser(string poolId, string nodeId, string userName, ComputeNodeDeleteUserOptions computeNodeDeleteUserOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (userName == null)
            {
                throw new ArgumentNullException(nameof(userName));
            }

            using var message = CreateDeleteUserRequest(poolId, nodeId, userName, computeNodeDeleteUserOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeDeleteUserHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdateUserRequest(string poolId, string nodeId, string userName, NodeUpdateUserParameter nodeUpdateUserParameter, ComputeNodeUpdateUserOptions computeNodeUpdateUserOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userName, true);
            if (computeNodeUpdateUserOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeUpdateUserOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeUpdateUserOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeUpdateUserOptions.ClientRequestId.Value);
            }
            if (computeNodeUpdateUserOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeUpdateUserOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeUpdateUserOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeUpdateUserOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(nodeUpdateUserParameter);
            request.Content = content;
            return message;
        }

        /// <summary> Updates the password and expiration time of a user Account on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="nodeUpdateUserParameter"> The parameters for the request. </param>
        /// <param name="computeNodeUpdateUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/>, <paramref name="userName"/> or <paramref name="nodeUpdateUserParameter"/> is null. </exception>
        /// <remarks> This operation replaces of all the updatable properties of the Account. For example, if the expiryTime element is not specified, the current value is replaced with the default value, not left unmodified. You can update a user Account on a Compute Node only when it is in the idle or running state. </remarks>
        public async Task<ResponseWithHeaders<ComputeNodeUpdateUserHeaders>> UpdateUserAsync(string poolId, string nodeId, string userName, NodeUpdateUserParameter nodeUpdateUserParameter, ComputeNodeUpdateUserOptions computeNodeUpdateUserOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (userName == null)
            {
                throw new ArgumentNullException(nameof(userName));
            }
            if (nodeUpdateUserParameter == null)
            {
                throw new ArgumentNullException(nameof(nodeUpdateUserParameter));
            }

            using var message = CreateUpdateUserRequest(poolId, nodeId, userName, nodeUpdateUserParameter, computeNodeUpdateUserOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeUpdateUserHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Updates the password and expiration time of a user Account on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="nodeUpdateUserParameter"> The parameters for the request. </param>
        /// <param name="computeNodeUpdateUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/>, <paramref name="userName"/> or <paramref name="nodeUpdateUserParameter"/> is null. </exception>
        /// <remarks> This operation replaces of all the updatable properties of the Account. For example, if the expiryTime element is not specified, the current value is replaced with the default value, not left unmodified. You can update a user Account on a Compute Node only when it is in the idle or running state. </remarks>
        public ResponseWithHeaders<ComputeNodeUpdateUserHeaders> UpdateUser(string poolId, string nodeId, string userName, NodeUpdateUserParameter nodeUpdateUserParameter, ComputeNodeUpdateUserOptions computeNodeUpdateUserOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (userName == null)
            {
                throw new ArgumentNullException(nameof(userName));
            }
            if (nodeUpdateUserParameter == null)
            {
                throw new ArgumentNullException(nameof(nodeUpdateUserParameter));
            }

            using var message = CreateUpdateUserRequest(poolId, nodeId, userName, nodeUpdateUserParameter, computeNodeUpdateUserOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeUpdateUserHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetRequest(string poolId, string nodeId, ComputeNodeGetOptions computeNodeGetOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            if (computeNodeGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", computeNodeGetOptions.Select, true);
            }
            if (computeNodeGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeGetOptions.ClientRequestId.Value);
            }
            if (computeNodeGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeGetOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeGetOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets information about the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="computeNodeGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        public async Task<ResponseWithHeaders<ComputeNode, ComputeNodeGetHeaders>> GetAsync(string poolId, string nodeId, ComputeNodeGetOptions computeNodeGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateGetRequest(poolId, nodeId, computeNodeGetOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ComputeNode value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ComputeNode.DeserializeComputeNode(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Gets information about the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="computeNodeGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        public ResponseWithHeaders<ComputeNode, ComputeNodeGetHeaders> Get(string poolId, string nodeId, ComputeNodeGetOptions computeNodeGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateGetRequest(poolId, nodeId, computeNodeGetOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ComputeNode value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ComputeNode.DeserializeComputeNode(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateRebootRequest(string poolId, string nodeId, NodeRebootParameter nodeRebootParameter, ComputeNodeRebootOptions computeNodeRebootOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/reboot", false);
            if (computeNodeRebootOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeRebootOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeRebootOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeRebootOptions.ClientRequestId.Value);
            }
            if (computeNodeRebootOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeRebootOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeRebootOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeRebootOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (nodeRebootParameter != null)
            {
                request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
                var content = new Utf8JsonRequestContent();
                content.JsonWriter.WriteObjectValue(nodeRebootParameter);
                request.Content = content;
            }
            return message;
        }

        /// <summary> Restarts the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="nodeRebootParameter"> The parameters for the request. </param>
        /// <param name="computeNodeRebootOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> You can restart a Compute Node only if it is in an idle or running state. </remarks>
        public async Task<ResponseWithHeaders<ComputeNodeRebootHeaders>> RebootAsync(string poolId, string nodeId, NodeRebootParameter nodeRebootParameter = null, ComputeNodeRebootOptions computeNodeRebootOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateRebootRequest(poolId, nodeId, nodeRebootParameter, computeNodeRebootOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeRebootHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Restarts the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="nodeRebootParameter"> The parameters for the request. </param>
        /// <param name="computeNodeRebootOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> You can restart a Compute Node only if it is in an idle or running state. </remarks>
        public ResponseWithHeaders<ComputeNodeRebootHeaders> Reboot(string poolId, string nodeId, NodeRebootParameter nodeRebootParameter = null, ComputeNodeRebootOptions computeNodeRebootOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateRebootRequest(poolId, nodeId, nodeRebootParameter, computeNodeRebootOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeRebootHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateReimageRequest(string poolId, string nodeId, NodeReimageParameter nodeReimageParameter, ComputeNodeReimageOptions computeNodeReimageOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/reimage", false);
            if (computeNodeReimageOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeReimageOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeReimageOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeReimageOptions.ClientRequestId.Value);
            }
            if (computeNodeReimageOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeReimageOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeReimageOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeReimageOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (nodeReimageParameter != null)
            {
                request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
                var content = new Utf8JsonRequestContent();
                content.JsonWriter.WriteObjectValue(nodeReimageParameter);
                request.Content = content;
            }
            return message;
        }

        /// <summary> Reinstalls the operating system on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="nodeReimageParameter"> The parameters for the request. </param>
        /// <param name="computeNodeReimageOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> You can reinstall the operating system on a Compute Node only if it is in an idle or running state. This API can be invoked only on Pools created with the cloud service configuration property. </remarks>
        public async Task<ResponseWithHeaders<ComputeNodeReimageHeaders>> ReimageAsync(string poolId, string nodeId, NodeReimageParameter nodeReimageParameter = null, ComputeNodeReimageOptions computeNodeReimageOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateReimageRequest(poolId, nodeId, nodeReimageParameter, computeNodeReimageOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeReimageHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Reinstalls the operating system on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="nodeReimageParameter"> The parameters for the request. </param>
        /// <param name="computeNodeReimageOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> You can reinstall the operating system on a Compute Node only if it is in an idle or running state. This API can be invoked only on Pools created with the cloud service configuration property. </remarks>
        public ResponseWithHeaders<ComputeNodeReimageHeaders> Reimage(string poolId, string nodeId, NodeReimageParameter nodeReimageParameter = null, ComputeNodeReimageOptions computeNodeReimageOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateReimageRequest(poolId, nodeId, nodeReimageParameter, computeNodeReimageOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeReimageHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDisableSchedulingRequest(string poolId, string nodeId, NodeDisableSchedulingParameter nodeDisableSchedulingParameter, ComputeNodeDisableSchedulingOptions computeNodeDisableSchedulingOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/disablescheduling", false);
            if (computeNodeDisableSchedulingOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeDisableSchedulingOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeDisableSchedulingOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeDisableSchedulingOptions.ClientRequestId.Value);
            }
            if (computeNodeDisableSchedulingOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeDisableSchedulingOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeDisableSchedulingOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeDisableSchedulingOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (nodeDisableSchedulingParameter != null)
            {
                request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
                var content = new Utf8JsonRequestContent();
                content.JsonWriter.WriteObjectValue(nodeDisableSchedulingParameter);
                request.Content = content;
            }
            return message;
        }

        /// <summary> Disables Task scheduling on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="nodeDisableSchedulingParameter"> The parameters for the request. </param>
        /// <param name="computeNodeDisableSchedulingOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled. </remarks>
        public async Task<ResponseWithHeaders<ComputeNodeDisableSchedulingHeaders>> DisableSchedulingAsync(string poolId, string nodeId, NodeDisableSchedulingParameter nodeDisableSchedulingParameter = null, ComputeNodeDisableSchedulingOptions computeNodeDisableSchedulingOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateDisableSchedulingRequest(poolId, nodeId, nodeDisableSchedulingParameter, computeNodeDisableSchedulingOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeDisableSchedulingHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Disables Task scheduling on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="nodeDisableSchedulingParameter"> The parameters for the request. </param>
        /// <param name="computeNodeDisableSchedulingOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled. </remarks>
        public ResponseWithHeaders<ComputeNodeDisableSchedulingHeaders> DisableScheduling(string poolId, string nodeId, NodeDisableSchedulingParameter nodeDisableSchedulingParameter = null, ComputeNodeDisableSchedulingOptions computeNodeDisableSchedulingOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateDisableSchedulingRequest(poolId, nodeId, nodeDisableSchedulingParameter, computeNodeDisableSchedulingOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeDisableSchedulingHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateEnableSchedulingRequest(string poolId, string nodeId, ComputeNodeEnableSchedulingOptions computeNodeEnableSchedulingOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/enablescheduling", false);
            if (computeNodeEnableSchedulingOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeEnableSchedulingOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeEnableSchedulingOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeEnableSchedulingOptions.ClientRequestId.Value);
            }
            if (computeNodeEnableSchedulingOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeEnableSchedulingOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeEnableSchedulingOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeEnableSchedulingOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Enables Task scheduling on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        /// <param name="computeNodeEnableSchedulingOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled. </remarks>
        public async Task<ResponseWithHeaders<ComputeNodeEnableSchedulingHeaders>> EnableSchedulingAsync(string poolId, string nodeId, ComputeNodeEnableSchedulingOptions computeNodeEnableSchedulingOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateEnableSchedulingRequest(poolId, nodeId, computeNodeEnableSchedulingOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeEnableSchedulingHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Enables Task scheduling on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        /// <param name="computeNodeEnableSchedulingOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled. </remarks>
        public ResponseWithHeaders<ComputeNodeEnableSchedulingHeaders> EnableScheduling(string poolId, string nodeId, ComputeNodeEnableSchedulingOptions computeNodeEnableSchedulingOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateEnableSchedulingRequest(poolId, nodeId, computeNodeEnableSchedulingOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeEnableSchedulingHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetRemoteLoginSettingsRequest(string poolId, string nodeId, ComputeNodeGetRemoteLoginSettingsOptions computeNodeGetRemoteLoginSettingsOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/remoteloginsettings", false);
            if (computeNodeGetRemoteLoginSettingsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeGetRemoteLoginSettingsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeGetRemoteLoginSettingsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeGetRemoteLoginSettingsOptions.ClientRequestId.Value);
            }
            if (computeNodeGetRemoteLoginSettingsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeGetRemoteLoginSettingsOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeGetRemoteLoginSettingsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeGetRemoteLoginSettingsOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets the settings required for remote login to a Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="computeNodeGetRemoteLoginSettingsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> Before you can remotely login to a Compute Node using the remote login settings, you must create a user Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API. </remarks>
        public async Task<ResponseWithHeaders<ComputeNodeGetRemoteLoginSettingsResult, ComputeNodeGetRemoteLoginSettingsHeaders>> GetRemoteLoginSettingsAsync(string poolId, string nodeId, ComputeNodeGetRemoteLoginSettingsOptions computeNodeGetRemoteLoginSettingsOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateGetRemoteLoginSettingsRequest(poolId, nodeId, computeNodeGetRemoteLoginSettingsOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeGetRemoteLoginSettingsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ComputeNodeGetRemoteLoginSettingsResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ComputeNodeGetRemoteLoginSettingsResult.DeserializeComputeNodeGetRemoteLoginSettingsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Gets the settings required for remote login to a Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="computeNodeGetRemoteLoginSettingsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> Before you can remotely login to a Compute Node using the remote login settings, you must create a user Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API. </remarks>
        public ResponseWithHeaders<ComputeNodeGetRemoteLoginSettingsResult, ComputeNodeGetRemoteLoginSettingsHeaders> GetRemoteLoginSettings(string poolId, string nodeId, ComputeNodeGetRemoteLoginSettingsOptions computeNodeGetRemoteLoginSettingsOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateGetRemoteLoginSettingsRequest(poolId, nodeId, computeNodeGetRemoteLoginSettingsOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeGetRemoteLoginSettingsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ComputeNodeGetRemoteLoginSettingsResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ComputeNodeGetRemoteLoginSettingsResult.DeserializeComputeNodeGetRemoteLoginSettingsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetRemoteDesktopRequest(string poolId, string nodeId, ComputeNodeGetRemoteDesktopOptions computeNodeGetRemoteDesktopOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/rdp", false);
            if (computeNodeGetRemoteDesktopOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeGetRemoteDesktopOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeGetRemoteDesktopOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeGetRemoteDesktopOptions.ClientRequestId.Value);
            }
            if (computeNodeGetRemoteDesktopOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeGetRemoteDesktopOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeGetRemoteDesktopOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeGetRemoteDesktopOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json, application/octet-stream");
            return message;
        }

        /// <summary> Gets the Remote Desktop Protocol file for the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which you want to get the Remote Desktop Protocol file. </param>
        /// <param name="computeNodeGetRemoteDesktopOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> Before you can access a Compute Node by using the RDP file, you must create a user Account on the Compute Node. This API can only be invoked on Pools created with a cloud service configuration. For Pools created with a virtual machine configuration, see the GetRemoteLoginSettings API. </remarks>
        public async Task<ResponseWithHeaders<Stream, ComputeNodeGetRemoteDesktopHeaders>> GetRemoteDesktopAsync(string poolId, string nodeId, ComputeNodeGetRemoteDesktopOptions computeNodeGetRemoteDesktopOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateGetRemoteDesktopRequest(poolId, nodeId, computeNodeGetRemoteDesktopOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeGetRemoteDesktopHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Gets the Remote Desktop Protocol file for the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which you want to get the Remote Desktop Protocol file. </param>
        /// <param name="computeNodeGetRemoteDesktopOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <remarks> Before you can access a Compute Node by using the RDP file, you must create a user Account on the Compute Node. This API can only be invoked on Pools created with a cloud service configuration. For Pools created with a virtual machine configuration, see the GetRemoteLoginSettings API. </remarks>
        public ResponseWithHeaders<Stream, ComputeNodeGetRemoteDesktopHeaders> GetRemoteDesktop(string poolId, string nodeId, ComputeNodeGetRemoteDesktopOptions computeNodeGetRemoteDesktopOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateGetRemoteDesktopRequest(poolId, nodeId, computeNodeGetRemoteDesktopOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeGetRemoteDesktopHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUploadBatchServiceLogsRequest(string poolId, string nodeId, UploadBatchServiceLogsConfiguration uploadBatchServiceLogsConfiguration, ComputeNodeUploadBatchServiceLogsOptions computeNodeUploadBatchServiceLogsOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/uploadbatchservicelogs", false);
            if (computeNodeUploadBatchServiceLogsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeUploadBatchServiceLogsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeUploadBatchServiceLogsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeUploadBatchServiceLogsOptions.ClientRequestId.Value);
            }
            if (computeNodeUploadBatchServiceLogsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeUploadBatchServiceLogsOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeUploadBatchServiceLogsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeUploadBatchServiceLogsOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(uploadBatchServiceLogsConfiguration);
            request.Content = content;
            return message;
        }

        /// <summary> Upload Azure Batch service log files from the specified Compute Node to Azure Blob Storage. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to upload the Azure Batch service log files. </param>
        /// <param name="uploadBatchServiceLogsConfiguration"> The Azure Batch service log files upload configuration. </param>
        /// <param name="computeNodeUploadBatchServiceLogsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="uploadBatchServiceLogsConfiguration"/> is null. </exception>
        /// <remarks> This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared with Azure support to aid in debugging issues with the Batch service. </remarks>
        public async Task<ResponseWithHeaders<UploadBatchServiceLogsResult, ComputeNodeUploadBatchServiceLogsHeaders>> UploadBatchServiceLogsAsync(string poolId, string nodeId, UploadBatchServiceLogsConfiguration uploadBatchServiceLogsConfiguration, ComputeNodeUploadBatchServiceLogsOptions computeNodeUploadBatchServiceLogsOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (uploadBatchServiceLogsConfiguration == null)
            {
                throw new ArgumentNullException(nameof(uploadBatchServiceLogsConfiguration));
            }

            using var message = CreateUploadBatchServiceLogsRequest(poolId, nodeId, uploadBatchServiceLogsConfiguration, computeNodeUploadBatchServiceLogsOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeUploadBatchServiceLogsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        UploadBatchServiceLogsResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = UploadBatchServiceLogsResult.DeserializeUploadBatchServiceLogsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Upload Azure Batch service log files from the specified Compute Node to Azure Blob Storage. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to upload the Azure Batch service log files. </param>
        /// <param name="uploadBatchServiceLogsConfiguration"> The Azure Batch service log files upload configuration. </param>
        /// <param name="computeNodeUploadBatchServiceLogsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="uploadBatchServiceLogsConfiguration"/> is null. </exception>
        /// <remarks> This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared with Azure support to aid in debugging issues with the Batch service. </remarks>
        public ResponseWithHeaders<UploadBatchServiceLogsResult, ComputeNodeUploadBatchServiceLogsHeaders> UploadBatchServiceLogs(string poolId, string nodeId, UploadBatchServiceLogsConfiguration uploadBatchServiceLogsConfiguration, ComputeNodeUploadBatchServiceLogsOptions computeNodeUploadBatchServiceLogsOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (uploadBatchServiceLogsConfiguration == null)
            {
                throw new ArgumentNullException(nameof(uploadBatchServiceLogsConfiguration));
            }

            using var message = CreateUploadBatchServiceLogsRequest(poolId, nodeId, uploadBatchServiceLogsConfiguration, computeNodeUploadBatchServiceLogsOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeUploadBatchServiceLogsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        UploadBatchServiceLogsResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = UploadBatchServiceLogsResult.DeserializeUploadBatchServiceLogsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListRequest(string poolId, ComputeNodeListOptions computeNodeListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes", false);
            if (computeNodeListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", computeNodeListOptions.Filter, true);
            }
            if (computeNodeListOptions?.Select != null)
            {
                uri.AppendQuery("$select", computeNodeListOptions.Select, true);
            }
            if (computeNodeListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", computeNodeListOptions.MaxResults.Value, true);
            }
            if (computeNodeListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (computeNodeListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeListOptions.ClientRequestId.Value);
            }
            if (computeNodeListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeListOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="computeNodeListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public async Task<ResponseWithHeaders<ComputeNodeListResult, ComputeNodeListHeaders>> ListAsync(string poolId, ComputeNodeListOptions computeNodeListOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateListRequest(poolId, computeNodeListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ComputeNodeListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ComputeNodeListResult.DeserializeComputeNodeListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="computeNodeListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public ResponseWithHeaders<ComputeNodeListResult, ComputeNodeListHeaders> List(string poolId, ComputeNodeListOptions computeNodeListOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateListRequest(poolId, computeNodeListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ComputeNodeListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ComputeNodeListResult.DeserializeComputeNodeListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, string poolId, ComputeNodeListOptions computeNodeListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (computeNodeListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeListOptions.ClientRequestId.Value);
            }
            if (computeNodeListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeListOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="computeNodeListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="poolId"/> is null. </exception>
        public async Task<ResponseWithHeaders<ComputeNodeListResult, ComputeNodeListHeaders>> ListNextPageAsync(string nextLink, string poolId, ComputeNodeListOptions computeNodeListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateListNextPageRequest(nextLink, poolId, computeNodeListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ComputeNodeListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ComputeNodeListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ComputeNodeListResult.DeserializeComputeNodeListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="computeNodeListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="poolId"/> is null. </exception>
        public ResponseWithHeaders<ComputeNodeListResult, ComputeNodeListHeaders> ListNextPage(string nextLink, string poolId, ComputeNodeListOptions computeNodeListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateListNextPageRequest(nextLink, poolId, computeNodeListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new ComputeNodeListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ComputeNodeListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ComputeNodeListResult.DeserializeComputeNodeListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}
