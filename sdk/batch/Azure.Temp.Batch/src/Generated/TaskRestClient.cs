// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Temp.Batch.Models;

namespace Azure.Temp.Batch
{
    internal partial class TaskRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of TaskRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientDiagnostics"/>, <paramref name="pipeline"/>, <paramref name="batchUrl"/> or <paramref name="apiVersion"/> is null. </exception>
        public TaskRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2023-05-01.17.0")
        {
            ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException(nameof(clientDiagnostics));
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _batchUrl = batchUrl ?? throw new ArgumentNullException(nameof(batchUrl));
            _apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
        }

        internal HttpMessage CreateAddRequest(string jobId, TaskAddParameter task, TaskAddOptions taskAddOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks", false);
            if (taskAddOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskAddOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskAddOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskAddOptions.ClientRequestId.Value);
            }
            if (taskAddOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskAddOptions.ReturnClientRequestId.Value);
            }
            if (taskAddOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskAddOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(task);
            request.Content = content;
            return message;
        }

        /// <summary> Adds a Task to the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be added. </param>
        /// <param name="task"> The Task to be added. </param>
        /// <param name="taskAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="task"/> is null. </exception>
        /// <remarks> The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </remarks>
        public async Task<ResponseWithHeaders<TaskAddHeaders>> AddAsync(string jobId, TaskAddParameter task, TaskAddOptions taskAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (task == null)
            {
                throw new ArgumentNullException(nameof(task));
            }

            using var message = CreateAddRequest(jobId, task, taskAddOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Adds a Task to the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be added. </param>
        /// <param name="task"> The Task to be added. </param>
        /// <param name="taskAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="task"/> is null. </exception>
        /// <remarks> The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </remarks>
        public ResponseWithHeaders<TaskAddHeaders> Add(string jobId, TaskAddParameter task, TaskAddOptions taskAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (task == null)
            {
                throw new ArgumentNullException(nameof(task));
            }

            using var message = CreateAddRequest(jobId, task, taskAddOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListRequest(string jobId, TaskListOptions taskListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks", false);
            if (taskListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", taskListOptions.Filter, true);
            }
            if (taskListOptions?.Select != null)
            {
                uri.AppendQuery("$select", taskListOptions.Select, true);
            }
            if (taskListOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", taskListOptions.Expand, true);
            }
            if (taskListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", taskListOptions.MaxResults.Value, true);
            }
            if (taskListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskListOptions.ClientRequestId.Value);
            }
            if (taskListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskListOptions.ReturnClientRequestId.Value);
            }
            if (taskListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the Tasks that are associated with the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </remarks>
        public async Task<ResponseWithHeaders<CloudTaskListResult, TaskListHeaders>> ListAsync(string jobId, TaskListOptions taskListOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListRequest(jobId, taskListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudTaskListResult.DeserializeCloudTaskListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists all of the Tasks that are associated with the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <remarks> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </remarks>
        public ResponseWithHeaders<CloudTaskListResult, TaskListHeaders> List(string jobId, TaskListOptions taskListOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListRequest(jobId, taskListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudTaskListResult.DeserializeCloudTaskListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAddCollectionRequest(string jobId, TaskAddCollectionParameter taskCollection, TaskAddCollectionOptions taskAddCollectionOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/addtaskcollection", false);
            if (taskAddCollectionOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskAddCollectionOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskAddCollectionOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskAddCollectionOptions.ClientRequestId.Value);
            }
            if (taskAddCollectionOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskAddCollectionOptions.ReturnClientRequestId.Value);
            }
            if (taskAddCollectionOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskAddCollectionOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(taskCollection);
            request.Content = content;
            return message;
        }

        /// <summary> Adds a collection of Tasks to the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="taskCollection"> The Tasks to be added. </param>
        /// <param name="taskAddCollectionOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskCollection"/> is null. </exception>
        /// <remarks> Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the same order the Tasks were submitted in this request. If the server times out or the connection is closed during the request, the request may have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded, the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </remarks>
        public async Task<ResponseWithHeaders<TaskAddCollectionResult, TaskAddCollectionHeaders>> AddCollectionAsync(string jobId, TaskAddCollectionParameter taskCollection, TaskAddCollectionOptions taskAddCollectionOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskCollection == null)
            {
                throw new ArgumentNullException(nameof(taskCollection));
            }

            using var message = CreateAddCollectionRequest(jobId, taskCollection, taskAddCollectionOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskAddCollectionHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TaskAddCollectionResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TaskAddCollectionResult.DeserializeTaskAddCollectionResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Adds a collection of Tasks to the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="taskCollection"> The Tasks to be added. </param>
        /// <param name="taskAddCollectionOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskCollection"/> is null. </exception>
        /// <remarks> Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the same order the Tasks were submitted in this request. If the server times out or the connection is closed during the request, the request may have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded, the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </remarks>
        public ResponseWithHeaders<TaskAddCollectionResult, TaskAddCollectionHeaders> AddCollection(string jobId, TaskAddCollectionParameter taskCollection, TaskAddCollectionOptions taskAddCollectionOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskCollection == null)
            {
                throw new ArgumentNullException(nameof(taskCollection));
            }

            using var message = CreateAddCollectionRequest(jobId, taskCollection, taskAddCollectionOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskAddCollectionHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TaskAddCollectionResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TaskAddCollectionResult.DeserializeTaskAddCollectionResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteRequest(string jobId, string taskId, TaskDeleteOptions taskDeleteOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (taskDeleteOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskDeleteOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskDeleteOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskDeleteOptions.ClientRequestId.Value);
            }
            if (taskDeleteOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskDeleteOptions.ReturnClientRequestId.Value);
            }
            if (taskDeleteOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskDeleteOptions.OcpDate.Value, "R");
            }
            if (taskDeleteOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskDeleteOptions.IfMatch);
            }
            if (taskDeleteOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskDeleteOptions.IfNoneMatch);
            }
            if (taskDeleteOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskDeleteOptions.IfModifiedSince.Value, "R");
            }
            if (taskDeleteOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskDeleteOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Deletes a Task from the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        /// <param name="taskId"> The ID of the Task to delete. </param>
        /// <param name="taskDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to the primary task; subtasks and their files are then deleted asynchronously in the background. </remarks>
        public async Task<ResponseWithHeaders<TaskDeleteHeaders>> DeleteAsync(string jobId, string taskId, TaskDeleteOptions taskDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateDeleteRequest(jobId, taskId, taskDeleteOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Deletes a Task from the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        /// <param name="taskId"> The ID of the Task to delete. </param>
        /// <param name="taskDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to the primary task; subtasks and their files are then deleted asynchronously in the background. </remarks>
        public ResponseWithHeaders<TaskDeleteHeaders> Delete(string jobId, string taskId, TaskDeleteOptions taskDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateDeleteRequest(jobId, taskId, taskDeleteOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetRequest(string jobId, string taskId, TaskGetOptions taskGetOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (taskGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", taskGetOptions.Select, true);
            }
            if (taskGetOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", taskGetOptions.Expand, true);
            }
            if (taskGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskGetOptions.ClientRequestId.Value);
            }
            if (taskGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskGetOptions.ReturnClientRequestId.Value);
            }
            if (taskGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskGetOptions.OcpDate.Value, "R");
            }
            if (taskGetOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskGetOptions.IfMatch);
            }
            if (taskGetOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskGetOptions.IfNoneMatch);
            }
            if (taskGetOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskGetOptions.IfModifiedSince.Value, "R");
            }
            if (taskGetOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskGetOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets information about the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="taskGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </remarks>
        public async Task<ResponseWithHeaders<CloudTask, TaskGetHeaders>> GetAsync(string jobId, string taskId, TaskGetOptions taskGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateGetRequest(jobId, taskId, taskGetOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTask value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudTask.DeserializeCloudTask(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Gets information about the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="taskGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </remarks>
        public ResponseWithHeaders<CloudTask, TaskGetHeaders> Get(string jobId, string taskId, TaskGetOptions taskGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateGetRequest(jobId, taskId, taskGetOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTask value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudTask.DeserializeCloudTask(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdateRequest(string jobId, string taskId, TaskUpdateParameter taskUpdateParameter, TaskUpdateOptions taskUpdateOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (taskUpdateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskUpdateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskUpdateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskUpdateOptions.ClientRequestId.Value);
            }
            if (taskUpdateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskUpdateOptions.ReturnClientRequestId.Value);
            }
            if (taskUpdateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskUpdateOptions.OcpDate.Value, "R");
            }
            if (taskUpdateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskUpdateOptions.IfMatch);
            }
            if (taskUpdateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskUpdateOptions.IfNoneMatch);
            }
            if (taskUpdateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskUpdateOptions.IfModifiedSince.Value, "R");
            }
            if (taskUpdateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskUpdateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(taskUpdateParameter);
            request.Content = content;
            return message;
        }

        /// <summary> Updates the properties of the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="taskUpdateParameter"> The parameters for the request. </param>
        /// <param name="taskUpdateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="taskUpdateParameter"/> is null. </exception>
        public async Task<ResponseWithHeaders<TaskUpdateHeaders>> UpdateAsync(string jobId, string taskId, TaskUpdateParameter taskUpdateParameter, TaskUpdateOptions taskUpdateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (taskUpdateParameter == null)
            {
                throw new ArgumentNullException(nameof(taskUpdateParameter));
            }

            using var message = CreateUpdateRequest(jobId, taskId, taskUpdateParameter, taskUpdateOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskUpdateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Updates the properties of the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="taskUpdateParameter"> The parameters for the request. </param>
        /// <param name="taskUpdateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="taskUpdateParameter"/> is null. </exception>
        public ResponseWithHeaders<TaskUpdateHeaders> Update(string jobId, string taskId, TaskUpdateParameter taskUpdateParameter, TaskUpdateOptions taskUpdateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (taskUpdateParameter == null)
            {
                throw new ArgumentNullException(nameof(taskUpdateParameter));
            }

            using var message = CreateUpdateRequest(jobId, taskId, taskUpdateParameter, taskUpdateOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskUpdateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListSubtasksRequest(string jobId, string taskId, TaskListSubtasksOptions taskListSubtasksOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/subtasksinfo", false);
            if (taskListSubtasksOptions?.Select != null)
            {
                uri.AppendQuery("$select", taskListSubtasksOptions.Select, true);
            }
            if (taskListSubtasksOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskListSubtasksOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskListSubtasksOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskListSubtasksOptions.ClientRequestId.Value);
            }
            if (taskListSubtasksOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskListSubtasksOptions.ReturnClientRequestId.Value);
            }
            if (taskListSubtasksOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskListSubtasksOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the subtasks that are associated with the specified multi-instance Task. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="taskListSubtasksOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> If the Task is not a multi-instance Task then this returns an empty collection. </remarks>
        public async Task<ResponseWithHeaders<CloudTaskListSubtasksResult, TaskListSubtasksHeaders>> ListSubtasksAsync(string jobId, string taskId, TaskListSubtasksOptions taskListSubtasksOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateListSubtasksRequest(jobId, taskId, taskListSubtasksOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskListSubtasksHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListSubtasksResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudTaskListSubtasksResult.DeserializeCloudTaskListSubtasksResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists all of the subtasks that are associated with the specified multi-instance Task. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="taskListSubtasksOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> If the Task is not a multi-instance Task then this returns an empty collection. </remarks>
        public ResponseWithHeaders<CloudTaskListSubtasksResult, TaskListSubtasksHeaders> ListSubtasks(string jobId, string taskId, TaskListSubtasksOptions taskListSubtasksOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateListSubtasksRequest(jobId, taskId, taskListSubtasksOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskListSubtasksHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListSubtasksResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudTaskListSubtasksResult.DeserializeCloudTaskListSubtasksResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateTerminateRequest(string jobId, string taskId, TaskTerminateOptions taskTerminateOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/terminate", false);
            if (taskTerminateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskTerminateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskTerminateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskTerminateOptions.ClientRequestId.Value);
            }
            if (taskTerminateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskTerminateOptions.ReturnClientRequestId.Value);
            }
            if (taskTerminateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskTerminateOptions.OcpDate.Value, "R");
            }
            if (taskTerminateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskTerminateOptions.IfMatch);
            }
            if (taskTerminateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskTerminateOptions.IfNoneMatch);
            }
            if (taskTerminateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskTerminateOptions.IfModifiedSince.Value, "R");
            }
            if (taskTerminateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskTerminateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Terminates the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to terminate. </param>
        /// <param name="taskTerminateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the background. </remarks>
        public async Task<ResponseWithHeaders<TaskTerminateHeaders>> TerminateAsync(string jobId, string taskId, TaskTerminateOptions taskTerminateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateTerminateRequest(jobId, taskId, taskTerminateOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskTerminateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Terminates the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to terminate. </param>
        /// <param name="taskTerminateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the background. </remarks>
        public ResponseWithHeaders<TaskTerminateHeaders> Terminate(string jobId, string taskId, TaskTerminateOptions taskTerminateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateTerminateRequest(jobId, taskId, taskTerminateOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskTerminateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateReactivateRequest(string jobId, string taskId, TaskReactivateOptions taskReactivateOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/reactivate", false);
            if (taskReactivateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskReactivateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskReactivateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskReactivateOptions.ClientRequestId.Value);
            }
            if (taskReactivateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskReactivateOptions.ReturnClientRequestId.Value);
            }
            if (taskReactivateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskReactivateOptions.OcpDate.Value, "R");
            }
            if (taskReactivateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskReactivateOptions.IfMatch);
            }
            if (taskReactivateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskReactivateOptions.IfNoneMatch);
            }
            if (taskReactivateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskReactivateOptions.IfModifiedSince.Value, "R");
            }
            if (taskReactivateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskReactivateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Reactivates a Task, allowing it to run again even if its retry count has been exhausted. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to reactivate. </param>
        /// <param name="taskReactivateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is changed to active. As the Task is no longer in the completed state, any previous exit code or failure information is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0. Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting). </remarks>
        public async Task<ResponseWithHeaders<TaskReactivateHeaders>> ReactivateAsync(string jobId, string taskId, TaskReactivateOptions taskReactivateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateReactivateRequest(jobId, taskId, taskReactivateOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskReactivateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Reactivates a Task, allowing it to run again even if its retry count has been exhausted. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to reactivate. </param>
        /// <param name="taskReactivateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <remarks> Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task's state is changed to active. As the Task is no longer in the completed state, any previous exit code or failure information is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0. Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting). </remarks>
        public ResponseWithHeaders<TaskReactivateHeaders> Reactivate(string jobId, string taskId, TaskReactivateOptions taskReactivateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateReactivateRequest(jobId, taskId, taskReactivateOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskReactivateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, string jobId, TaskListOptions taskListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (taskListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskListOptions.ClientRequestId.Value);
            }
            if (taskListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskListOptions.ReturnClientRequestId.Value);
            }
            if (taskListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the Tasks that are associated with the specified Job. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="jobId"/> is null. </exception>
        /// <remarks> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </remarks>
        public async Task<ResponseWithHeaders<CloudTaskListResult, TaskListHeaders>> ListNextPageAsync(string nextLink, string jobId, TaskListOptions taskListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListNextPageRequest(nextLink, jobId, taskListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudTaskListResult.DeserializeCloudTaskListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists all of the Tasks that are associated with the specified Job. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="jobId"/> is null. </exception>
        /// <remarks> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </remarks>
        public ResponseWithHeaders<CloudTaskListResult, TaskListHeaders> ListNextPage(string nextLink, string jobId, TaskListOptions taskListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListNextPageRequest(nextLink, jobId, taskListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudTaskListResult.DeserializeCloudTaskListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}
