// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Client;

namespace Azure.Batch
{
    internal partial class BatchClientGetNodeFilesCollectionResult : Pageable<BinaryData>
    {
        private readonly BatchClient _client;
        private readonly string _poolId;
        private readonly string _nodeId;
        private readonly int? _timeOutInSeconds;
        private readonly string _clientRequestId;
        private readonly bool? _returnClientRequestId;
        private readonly DateTimeOffset? _ocpdate;
        private readonly int? _maxresults;
        private readonly string _filter;
        private readonly bool? _recursive;
        private readonly RequestContext _context;

        /// <summary> Initializes a new instance of BatchClientGetNodeFilesCollectionResult, which is used to iterate over the pages of a collection. </summary>
        /// <param name="client"> The BatchClient client used to send requests. </param>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="timeOutInSeconds"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. If the value is larger than 30, the default will be used instead.". </param>
        /// <param name="clientRequestId">
        /// The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.
        /// </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpdate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
        /// </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        public BatchClientGetNodeFilesCollectionResult(BatchClient client, string poolId, string nodeId, int? timeOutInSeconds, string clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpdate, int? maxresults, string filter, bool? recursive, RequestContext context) : base(context?.CancellationToken ?? default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            _client = client;
            _poolId = poolId;
            _nodeId = nodeId;
            _timeOutInSeconds = timeOutInSeconds;
            _clientRequestId = clientRequestId;
            _returnClientRequestId = returnClientRequestId;
            _ocpdate = ocpdate;
            _maxresults = maxresults;
            _filter = filter;
            _recursive = recursive;
            _context = context;
        }

        /// <summary> Gets the pages of BatchClientGetNodeFilesCollectionResult as an enumerable collection. </summary>
        /// <param name="continuationToken"> A continuation token indicating where to resume paging. </param>
        /// <param name="pageSizeHint"> The number of items per page. </param>
        /// <returns> The pages of BatchClientGetNodeFilesCollectionResult as an enumerable collection. </returns>
        public override IEnumerable<Page<BinaryData>> AsPages(string continuationToken, int? pageSizeHint)
        {
            Uri nextPage = continuationToken != null ? new Uri(continuationToken) : null;
            do
            {
                Response response = GetNextResponse(pageSizeHint, nextPage);
                if (response is null)
                {
                    yield break;
                }
                BatchNodeFileListResult responseWithType = (BatchNodeFileListResult)response;
                List<BinaryData> items = new List<BinaryData>();
                foreach (var item in responseWithType.Value)
                {
                    items.Add(BinaryData.FromObjectAsJson(item));
                }
                nextPage = responseWithType.OdataNextLink;
                yield return Page<BinaryData>.FromValues(items, nextPage?.AbsoluteUri, response);
            }
            while (nextPage != null);
        }

        /// <summary> Get next page. </summary>
        /// <param name="pageSizeHint"> The number of items per page. </param>
        /// <param name="nextLink"> The next link to use for the next page of results. </param>
        private Response GetNextResponse(int? pageSizeHint, Uri nextLink)
        {
            HttpMessage message = nextLink != null ? _client.CreateNextListNodeFilesRequest(nextLink, _poolId, _nodeId, _timeOutInSeconds, _clientRequestId, _returnClientRequestId, _ocpdate, _maxresults, _filter, _recursive, _context) : _client.CreateListNodeFilesRequest(_poolId, _nodeId, _timeOutInSeconds, _clientRequestId, _returnClientRequestId, _ocpdate, _maxresults, _filter, _recursive, _context);
            using DiagnosticScope scope = _client.ClientDiagnostics.CreateScope("BatchClient.GetNodeFiles");
            scope.Start();
            try
            {
                return _client.Pipeline.ProcessMessage(message, _context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
