// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Service.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch.Service
{
    internal partial class TaskRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of TaskRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="batchUrl"/> or <paramref name="apiVersion"/> is null. </exception>
        public TaskRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2022-01-01.15.0")
        {
            _batchUrl = batchUrl ?? throw new ArgumentNullException(nameof(batchUrl));
            _apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateAddRequest(string jobId, TaskAddParameter task, TaskAddOptions taskAddOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks", false);
            if (taskAddOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskAddOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskAddOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskAddOptions.ClientRequestId.Value);
            }
            if (taskAddOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskAddOptions.ReturnClientRequestId.Value);
            }
            if (taskAddOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskAddOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(task);
            request.Content = content;
            return message;
        }

        /// <summary> The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be added. </param>
        /// <param name="task"> The Task to be added. </param>
        /// <param name="taskAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="task"/> is null. </exception>
        public async Task<ResponseWithHeaders<TaskAddHeaders>> AddAsync(string jobId, TaskAddParameter task, TaskAddOptions taskAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (task == null)
            {
                throw new ArgumentNullException(nameof(task));
            }

            using var message = CreateAddRequest(jobId, task, taskAddOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be added. </param>
        /// <param name="task"> The Task to be added. </param>
        /// <param name="taskAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="task"/> is null. </exception>
        public ResponseWithHeaders<TaskAddHeaders> Add(string jobId, TaskAddParameter task, TaskAddOptions taskAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (task == null)
            {
                throw new ArgumentNullException(nameof(task));
            }

            using var message = CreateAddRequest(jobId, task, taskAddOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListRequest(string jobId, TaskListOptions taskListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks", false);
            if (taskListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", taskListOptions.Filter, true);
            }
            if (taskListOptions?.Select != null)
            {
                uri.AppendQuery("$select", taskListOptions.Select, true);
            }
            if (taskListOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", taskListOptions.Expand, true);
            }
            if (taskListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", taskListOptions.MaxResults.Value, true);
            }
            if (taskListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskListOptions.ClientRequestId.Value);
            }
            if (taskListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskListOptions.ReturnClientRequestId.Value);
            }
            if (taskListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudTaskListResult, TaskListHeaders>> ListAsync(string jobId, TaskListOptions taskListOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListRequest(jobId, taskListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudTaskListResult.DeserializeCloudTaskListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        public ResponseWithHeaders<CloudTaskListResult, TaskListHeaders> List(string jobId, TaskListOptions taskListOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListRequest(jobId, taskListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudTaskListResult.DeserializeCloudTaskListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAddCollectionRequest(string jobId, TaskAddCollectionParameter taskCollection, TaskAddCollectionOptions taskAddCollectionOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/addtaskcollection", false);
            if (taskAddCollectionOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskAddCollectionOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskAddCollectionOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskAddCollectionOptions.ClientRequestId.Value);
            }
            if (taskAddCollectionOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskAddCollectionOptions.ReturnClientRequestId.Value);
            }
            if (taskAddCollectionOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskAddCollectionOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(taskCollection);
            request.Content = content;
            return message;
        }

        /// <summary> Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the same order the Tasks were submitted in this request. If the server times out or the connection is closed during the request, the request may have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded, the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="taskCollection"> The Tasks to be added. </param>
        /// <param name="taskAddCollectionOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskCollection"/> is null. </exception>
        public async Task<ResponseWithHeaders<TaskAddCollectionResult, TaskAddCollectionHeaders>> AddCollectionAsync(string jobId, TaskAddCollectionParameter taskCollection, TaskAddCollectionOptions taskAddCollectionOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskCollection == null)
            {
                throw new ArgumentNullException(nameof(taskCollection));
            }

            using var message = CreateAddCollectionRequest(jobId, taskCollection, taskAddCollectionOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskAddCollectionHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TaskAddCollectionResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TaskAddCollectionResult.DeserializeTaskAddCollectionResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the same order the Tasks were submitted in this request. If the server times out or the connection is closed during the request, the request may have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded, the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="taskCollection"> The Tasks to be added. </param>
        /// <param name="taskAddCollectionOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskCollection"/> is null. </exception>
        public ResponseWithHeaders<TaskAddCollectionResult, TaskAddCollectionHeaders> AddCollection(string jobId, TaskAddCollectionParameter taskCollection, TaskAddCollectionOptions taskAddCollectionOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskCollection == null)
            {
                throw new ArgumentNullException(nameof(taskCollection));
            }

            using var message = CreateAddCollectionRequest(jobId, taskCollection, taskAddCollectionOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskAddCollectionHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TaskAddCollectionResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TaskAddCollectionResult.DeserializeTaskAddCollectionResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteRequest(string jobId, string taskId, TaskDeleteOptions taskDeleteOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (taskDeleteOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskDeleteOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskDeleteOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskDeleteOptions.ClientRequestId.Value);
            }
            if (taskDeleteOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskDeleteOptions.ReturnClientRequestId.Value);
            }
            if (taskDeleteOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskDeleteOptions.OcpDate.Value, "R");
            }
            if (taskDeleteOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskDeleteOptions.IfMatch);
            }
            if (taskDeleteOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskDeleteOptions.IfNoneMatch);
            }
            if (taskDeleteOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskDeleteOptions.IfModifiedSince.Value, "R");
            }
            if (taskDeleteOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskDeleteOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to the primary task; subtasks and their files are then deleted asynchronously in the background. </summary>
        /// <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        /// <param name="taskId"> The ID of the Task to delete. </param>
        /// <param name="taskDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public async Task<ResponseWithHeaders<TaskDeleteHeaders>> DeleteAsync(string jobId, string taskId, TaskDeleteOptions taskDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateDeleteRequest(jobId, taskId, taskDeleteOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to the primary task; subtasks and their files are then deleted asynchronously in the background. </summary>
        /// <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        /// <param name="taskId"> The ID of the Task to delete. </param>
        /// <param name="taskDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public ResponseWithHeaders<TaskDeleteHeaders> Delete(string jobId, string taskId, TaskDeleteOptions taskDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateDeleteRequest(jobId, taskId, taskDeleteOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetRequest(string jobId, string taskId, TaskGetOptions taskGetOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (taskGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", taskGetOptions.Select, true);
            }
            if (taskGetOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", taskGetOptions.Expand, true);
            }
            if (taskGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskGetOptions.ClientRequestId.Value);
            }
            if (taskGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskGetOptions.ReturnClientRequestId.Value);
            }
            if (taskGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskGetOptions.OcpDate.Value, "R");
            }
            if (taskGetOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskGetOptions.IfMatch);
            }
            if (taskGetOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskGetOptions.IfNoneMatch);
            }
            if (taskGetOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskGetOptions.IfModifiedSince.Value, "R");
            }
            if (taskGetOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskGetOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="taskGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudTask, TaskGetHeaders>> GetAsync(string jobId, string taskId, TaskGetOptions taskGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateGetRequest(jobId, taskId, taskGetOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTask value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudTask.DeserializeCloudTask(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="taskGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public ResponseWithHeaders<CloudTask, TaskGetHeaders> Get(string jobId, string taskId, TaskGetOptions taskGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateGetRequest(jobId, taskId, taskGetOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTask value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudTask.DeserializeCloudTask(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdateRequest(string jobId, string taskId, TaskUpdateParameter taskUpdateParameter, TaskUpdateOptions taskUpdateOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (taskUpdateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskUpdateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskUpdateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskUpdateOptions.ClientRequestId.Value);
            }
            if (taskUpdateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskUpdateOptions.ReturnClientRequestId.Value);
            }
            if (taskUpdateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskUpdateOptions.OcpDate.Value, "R");
            }
            if (taskUpdateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskUpdateOptions.IfMatch);
            }
            if (taskUpdateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskUpdateOptions.IfNoneMatch);
            }
            if (taskUpdateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskUpdateOptions.IfModifiedSince.Value, "R");
            }
            if (taskUpdateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskUpdateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(taskUpdateParameter);
            request.Content = content;
            return message;
        }

        /// <summary> Updates the properties of the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="taskUpdateParameter"> The parameters for the request. </param>
        /// <param name="taskUpdateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="taskUpdateParameter"/> is null. </exception>
        public async Task<ResponseWithHeaders<TaskUpdateHeaders>> UpdateAsync(string jobId, string taskId, TaskUpdateParameter taskUpdateParameter, TaskUpdateOptions taskUpdateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (taskUpdateParameter == null)
            {
                throw new ArgumentNullException(nameof(taskUpdateParameter));
            }

            using var message = CreateUpdateRequest(jobId, taskId, taskUpdateParameter, taskUpdateOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskUpdateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Updates the properties of the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="taskUpdateParameter"> The parameters for the request. </param>
        /// <param name="taskUpdateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="taskUpdateParameter"/> is null. </exception>
        public ResponseWithHeaders<TaskUpdateHeaders> Update(string jobId, string taskId, TaskUpdateParameter taskUpdateParameter, TaskUpdateOptions taskUpdateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (taskUpdateParameter == null)
            {
                throw new ArgumentNullException(nameof(taskUpdateParameter));
            }

            using var message = CreateUpdateRequest(jobId, taskId, taskUpdateParameter, taskUpdateOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskUpdateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListSubtasksRequest(string jobId, string taskId, TaskListSubtasksOptions taskListSubtasksOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/subtasksinfo", false);
            if (taskListSubtasksOptions?.Select != null)
            {
                uri.AppendQuery("$select", taskListSubtasksOptions.Select, true);
            }
            if (taskListSubtasksOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskListSubtasksOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskListSubtasksOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskListSubtasksOptions.ClientRequestId.Value);
            }
            if (taskListSubtasksOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskListSubtasksOptions.ReturnClientRequestId.Value);
            }
            if (taskListSubtasksOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskListSubtasksOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> If the Task is not a multi-instance Task then this returns an empty collection. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="taskListSubtasksOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudTaskListSubtasksResult, TaskListSubtasksHeaders>> ListSubtasksAsync(string jobId, string taskId, TaskListSubtasksOptions taskListSubtasksOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateListSubtasksRequest(jobId, taskId, taskListSubtasksOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskListSubtasksHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListSubtasksResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudTaskListSubtasksResult.DeserializeCloudTaskListSubtasksResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> If the Task is not a multi-instance Task then this returns an empty collection. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="taskListSubtasksOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public ResponseWithHeaders<CloudTaskListSubtasksResult, TaskListSubtasksHeaders> ListSubtasks(string jobId, string taskId, TaskListSubtasksOptions taskListSubtasksOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateListSubtasksRequest(jobId, taskId, taskListSubtasksOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskListSubtasksHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListSubtasksResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudTaskListSubtasksResult.DeserializeCloudTaskListSubtasksResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateTerminateRequest(string jobId, string taskId, TaskTerminateOptions taskTerminateOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/terminate", false);
            if (taskTerminateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskTerminateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskTerminateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskTerminateOptions.ClientRequestId.Value);
            }
            if (taskTerminateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskTerminateOptions.ReturnClientRequestId.Value);
            }
            if (taskTerminateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskTerminateOptions.OcpDate.Value, "R");
            }
            if (taskTerminateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskTerminateOptions.IfMatch);
            }
            if (taskTerminateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskTerminateOptions.IfNoneMatch);
            }
            if (taskTerminateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskTerminateOptions.IfModifiedSince.Value, "R");
            }
            if (taskTerminateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskTerminateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the background. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to terminate. </param>
        /// <param name="taskTerminateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public async Task<ResponseWithHeaders<TaskTerminateHeaders>> TerminateAsync(string jobId, string taskId, TaskTerminateOptions taskTerminateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateTerminateRequest(jobId, taskId, taskTerminateOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskTerminateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the background. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to terminate. </param>
        /// <param name="taskTerminateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public ResponseWithHeaders<TaskTerminateHeaders> Terminate(string jobId, string taskId, TaskTerminateOptions taskTerminateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateTerminateRequest(jobId, taskId, taskTerminateOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskTerminateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateReactivateRequest(string jobId, string taskId, TaskReactivateOptions taskReactivateOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/reactivate", false);
            if (taskReactivateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", taskReactivateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (taskReactivateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskReactivateOptions.ClientRequestId.Value);
            }
            if (taskReactivateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskReactivateOptions.ReturnClientRequestId.Value);
            }
            if (taskReactivateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskReactivateOptions.OcpDate.Value, "R");
            }
            if (taskReactivateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", taskReactivateOptions.IfMatch);
            }
            if (taskReactivateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", taskReactivateOptions.IfNoneMatch);
            }
            if (taskReactivateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", taskReactivateOptions.IfModifiedSince.Value, "R");
            }
            if (taskReactivateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", taskReactivateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task&apos;s state is changed to active. As the Task is no longer in the completed state, any previous exit code or failure information is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0. Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting). </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to reactivate. </param>
        /// <param name="taskReactivateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public async Task<ResponseWithHeaders<TaskReactivateHeaders>> ReactivateAsync(string jobId, string taskId, TaskReactivateOptions taskReactivateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateReactivateRequest(jobId, taskId, taskReactivateOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskReactivateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task&apos;s state is changed to active. As the Task is no longer in the completed state, any previous exit code or failure information is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0. Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting). </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to reactivate. </param>
        /// <param name="taskReactivateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public ResponseWithHeaders<TaskReactivateHeaders> Reactivate(string jobId, string taskId, TaskReactivateOptions taskReactivateOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateReactivateRequest(jobId, taskId, taskReactivateOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskReactivateHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, string jobId, TaskListOptions taskListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (taskListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", taskListOptions.ClientRequestId.Value);
            }
            if (taskListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", taskListOptions.ReturnClientRequestId.Value);
            }
            if (taskListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", taskListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="jobId"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudTaskListResult, TaskListHeaders>> ListNextPageAsync(string nextLink, string jobId, TaskListOptions taskListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListNextPageRequest(nextLink, jobId, taskListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TaskListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudTaskListResult.DeserializeCloudTaskListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="jobId"/> is null. </exception>
        public ResponseWithHeaders<CloudTaskListResult, TaskListHeaders> ListNextPage(string nextLink, string jobId, TaskListOptions taskListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            using var message = CreateListNextPageRequest(nextLink, jobId, taskListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new TaskListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudTaskListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudTaskListResult.DeserializeCloudTaskListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
