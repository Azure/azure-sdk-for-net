// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Service.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch.Service
{
    internal partial class CertificateRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of CertificateRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="batchUrl"/> or <paramref name="apiVersion"/> is null. </exception>
        public CertificateRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2022-01-01.15.0")
        {
            _batchUrl = batchUrl ?? throw new ArgumentNullException(nameof(batchUrl));
            _apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateAddRequest(CertificateAddParameter certificate, CertificateAddOptions certificateAddOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates", false);
            if (certificateAddOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateAddOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (certificateAddOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateAddOptions.ClientRequestId.Value);
            }
            if (certificateAddOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateAddOptions.ReturnClientRequestId.Value);
            }
            if (certificateAddOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateAddOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(certificate);
            request.Content = content;
            return message;
        }

        /// <summary> Adds a Certificate to the specified Account. </summary>
        /// <param name="certificate"> The Certificate to be added. </param>
        /// <param name="certificateAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="certificate"/> is null. </exception>
        public async Task<ResponseWithHeaders<CertificateAddHeaders>> AddAsync(CertificateAddParameter certificate, CertificateAddOptions certificateAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            using var message = CreateAddRequest(certificate, certificateAddOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new CertificateAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Adds a Certificate to the specified Account. </summary>
        /// <param name="certificate"> The Certificate to be added. </param>
        /// <param name="certificateAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="certificate"/> is null. </exception>
        public ResponseWithHeaders<CertificateAddHeaders> Add(CertificateAddParameter certificate, CertificateAddOptions certificateAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            using var message = CreateAddRequest(certificate, certificateAddOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new CertificateAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListRequest(CertificateListOptions certificateListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates", false);
            if (certificateListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", certificateListOptions.Filter, true);
            }
            if (certificateListOptions?.Select != null)
            {
                uri.AppendQuery("$select", certificateListOptions.Select, true);
            }
            if (certificateListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", certificateListOptions.MaxResults.Value, true);
            }
            if (certificateListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (certificateListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateListOptions.ClientRequestId.Value);
            }
            if (certificateListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateListOptions.ReturnClientRequestId.Value);
            }
            if (certificateListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="certificateListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<CertificateListResult, CertificateListHeaders>> ListAsync(CertificateListOptions certificateListOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateListRequest(certificateListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new CertificateListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CertificateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CertificateListResult.DeserializeCertificateListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="certificateListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CertificateListResult, CertificateListHeaders> List(CertificateListOptions certificateListOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateListRequest(certificateListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new CertificateListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CertificateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CertificateListResult.DeserializeCertificateListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCancelDeletionRequest(string thumbprintAlgorithm, string thumbprint, CertificateCancelDeletionOptions certificateCancelDeletionOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")/canceldelete", false);
            if (certificateCancelDeletionOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateCancelDeletionOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (certificateCancelDeletionOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateCancelDeletionOptions.ClientRequestId.Value);
            }
            if (certificateCancelDeletionOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateCancelDeletionOptions.ReturnClientRequestId.Value);
            }
            if (certificateCancelDeletionOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateCancelDeletionOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> If you try to delete a Certificate that is being used by a Pool or Compute Node, the status of the Certificate changes to deleteFailed. If you decide that you want to continue using the Certificate, you can use this operation to set the status of the Certificate back to active. If you intend to delete the Certificate, you do not need to run this operation after the deletion failed. You must make sure that the Certificate is not being used by any resources, and then you can try again to delete the Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate being deleted. </param>
        /// <param name="certificateCancelDeletionOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        public async Task<ResponseWithHeaders<CertificateCancelDeletionHeaders>> CancelDeletionAsync(string thumbprintAlgorithm, string thumbprint, CertificateCancelDeletionOptions certificateCancelDeletionOptions = null, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var message = CreateCancelDeletionRequest(thumbprintAlgorithm, thumbprint, certificateCancelDeletionOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new CertificateCancelDeletionHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> If you try to delete a Certificate that is being used by a Pool or Compute Node, the status of the Certificate changes to deleteFailed. If you decide that you want to continue using the Certificate, you can use this operation to set the status of the Certificate back to active. If you intend to delete the Certificate, you do not need to run this operation after the deletion failed. You must make sure that the Certificate is not being used by any resources, and then you can try again to delete the Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate being deleted. </param>
        /// <param name="certificateCancelDeletionOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        public ResponseWithHeaders<CertificateCancelDeletionHeaders> CancelDeletion(string thumbprintAlgorithm, string thumbprint, CertificateCancelDeletionOptions certificateCancelDeletionOptions = null, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var message = CreateCancelDeletionRequest(thumbprintAlgorithm, thumbprint, certificateCancelDeletionOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new CertificateCancelDeletionHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteRequest(string thumbprintAlgorithm, string thumbprint, CertificateDeleteOptions certificateDeleteOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")", false);
            if (certificateDeleteOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateDeleteOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (certificateDeleteOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateDeleteOptions.ClientRequestId.Value);
            }
            if (certificateDeleteOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateDeleteOptions.ReturnClientRequestId.Value);
            }
            if (certificateDeleteOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateDeleteOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> You cannot delete a Certificate if a resource (Pool or Compute Node) is using it. Before you can delete a Certificate, you must therefore make sure that the Certificate is not associated with any existing Pools, the Certificate is not installed on any Nodes (even if you remove a Certificate from a Pool, it is not removed from existing Compute Nodes in that Pool until they restart), and no running Tasks depend on the Certificate. If you try to delete a Certificate that is in use, the deletion fails. The Certificate status changes to deleteFailed. You can use Cancel Delete Certificate to set the status back to active if you decide that you want to continue using the Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to be deleted. </param>
        /// <param name="certificateDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        public async Task<ResponseWithHeaders<CertificateDeleteHeaders>> DeleteAsync(string thumbprintAlgorithm, string thumbprint, CertificateDeleteOptions certificateDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var message = CreateDeleteRequest(thumbprintAlgorithm, thumbprint, certificateDeleteOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new CertificateDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> You cannot delete a Certificate if a resource (Pool or Compute Node) is using it. Before you can delete a Certificate, you must therefore make sure that the Certificate is not associated with any existing Pools, the Certificate is not installed on any Nodes (even if you remove a Certificate from a Pool, it is not removed from existing Compute Nodes in that Pool until they restart), and no running Tasks depend on the Certificate. If you try to delete a Certificate that is in use, the deletion fails. The Certificate status changes to deleteFailed. You can use Cancel Delete Certificate to set the status back to active if you decide that you want to continue using the Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to be deleted. </param>
        /// <param name="certificateDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        public ResponseWithHeaders<CertificateDeleteHeaders> Delete(string thumbprintAlgorithm, string thumbprint, CertificateDeleteOptions certificateDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var message = CreateDeleteRequest(thumbprintAlgorithm, thumbprint, certificateDeleteOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new CertificateDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetRequest(string thumbprintAlgorithm, string thumbprint, CertificateGetOptions certificateGetOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")", false);
            if (certificateGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", certificateGetOptions.Select, true);
            }
            if (certificateGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (certificateGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateGetOptions.ClientRequestId.Value);
            }
            if (certificateGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateGetOptions.ReturnClientRequestId.Value);
            }
            if (certificateGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateGetOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets information about the specified Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="certificateGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        public async Task<ResponseWithHeaders<Certificate, CertificateGetHeaders>> GetAsync(string thumbprintAlgorithm, string thumbprint, CertificateGetOptions certificateGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var message = CreateGetRequest(thumbprintAlgorithm, thumbprint, certificateGetOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new CertificateGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Certificate value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = Certificate.DeserializeCertificate(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Gets information about the specified Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="certificateGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        public ResponseWithHeaders<Certificate, CertificateGetHeaders> Get(string thumbprintAlgorithm, string thumbprint, CertificateGetOptions certificateGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var message = CreateGetRequest(thumbprintAlgorithm, thumbprint, certificateGetOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new CertificateGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        Certificate value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = Certificate.DeserializeCertificate(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, CertificateListOptions certificateListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (certificateListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateListOptions.ClientRequestId.Value);
            }
            if (certificateListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateListOptions.ReturnClientRequestId.Value);
            }
            if (certificateListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="certificateListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public async Task<ResponseWithHeaders<CertificateListResult, CertificateListHeaders>> ListNextPageAsync(string nextLink, CertificateListOptions certificateListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateListNextPageRequest(nextLink, certificateListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new CertificateListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CertificateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CertificateListResult.DeserializeCertificateListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="certificateListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public ResponseWithHeaders<CertificateListResult, CertificateListHeaders> ListNextPage(string nextLink, CertificateListOptions certificateListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateListNextPageRequest(nextLink, certificateListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new CertificateListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CertificateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CertificateListResult.DeserializeCertificateListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
