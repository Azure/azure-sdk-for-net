// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Service.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch.Service
{
    internal partial class PoolRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of PoolRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="batchUrl"/> or <paramref name="apiVersion"/> is null. </exception>
        public PoolRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2022-01-01.15.0")
        {
            _batchUrl = batchUrl ?? throw new ArgumentNullException(nameof(batchUrl));
            _apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateListUsageMetricsRequest(PoolListUsageMetricsOptions poolListUsageMetricsOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/poolusagemetrics", false);
            if (poolListUsageMetricsOptions?.StartTime != null)
            {
                uri.AppendQuery("starttime", poolListUsageMetricsOptions.StartTime.Value, "O", true);
            }
            if (poolListUsageMetricsOptions?.EndTime != null)
            {
                uri.AppendQuery("endtime", poolListUsageMetricsOptions.EndTime.Value, "O", true);
            }
            if (poolListUsageMetricsOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", poolListUsageMetricsOptions.Filter, true);
            }
            if (poolListUsageMetricsOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", poolListUsageMetricsOptions.MaxResults.Value, true);
            }
            if (poolListUsageMetricsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolListUsageMetricsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolListUsageMetricsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolListUsageMetricsOptions.ClientRequestId.Value);
            }
            if (poolListUsageMetricsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolListUsageMetricsOptions.ReturnClientRequestId.Value);
            }
            if (poolListUsageMetricsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolListUsageMetricsOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="poolListUsageMetricsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<PoolListUsageMetricsResult, PoolListUsageMetricsHeaders>> ListUsageMetricsAsync(PoolListUsageMetricsOptions poolListUsageMetricsOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateListUsageMetricsRequest(poolListUsageMetricsOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolListUsageMetricsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PoolListUsageMetricsResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PoolListUsageMetricsResult.DeserializePoolListUsageMetricsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="poolListUsageMetricsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<PoolListUsageMetricsResult, PoolListUsageMetricsHeaders> ListUsageMetrics(PoolListUsageMetricsOptions poolListUsageMetricsOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateListUsageMetricsRequest(poolListUsageMetricsOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolListUsageMetricsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PoolListUsageMetricsResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PoolListUsageMetricsResult.DeserializePoolListUsageMetricsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetAllLifetimeStatisticsRequest(PoolGetAllLifetimeStatisticsOptions poolGetAllLifetimeStatisticsOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/lifetimepoolstats", false);
            if (poolGetAllLifetimeStatisticsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolGetAllLifetimeStatisticsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolGetAllLifetimeStatisticsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolGetAllLifetimeStatisticsOptions.ClientRequestId.Value);
            }
            if (poolGetAllLifetimeStatisticsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolGetAllLifetimeStatisticsOptions.ReturnClientRequestId.Value);
            }
            if (poolGetAllLifetimeStatisticsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolGetAllLifetimeStatisticsOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Statistics are aggregated across all Pools that have ever existed in the Account, from Account creation to the last update time of the statistics. The statistics may not be immediately available. The Batch service performs periodic roll-up of statistics. The typical delay is about 30 minutes. </summary>
        /// <param name="poolGetAllLifetimeStatisticsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<PoolStatistics, PoolGetAllLifetimeStatisticsHeaders>> GetAllLifetimeStatisticsAsync(PoolGetAllLifetimeStatisticsOptions poolGetAllLifetimeStatisticsOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetAllLifetimeStatisticsRequest(poolGetAllLifetimeStatisticsOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolGetAllLifetimeStatisticsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PoolStatistics value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PoolStatistics.DeserializePoolStatistics(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Statistics are aggregated across all Pools that have ever existed in the Account, from Account creation to the last update time of the statistics. The statistics may not be immediately available. The Batch service performs periodic roll-up of statistics. The typical delay is about 30 minutes. </summary>
        /// <param name="poolGetAllLifetimeStatisticsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<PoolStatistics, PoolGetAllLifetimeStatisticsHeaders> GetAllLifetimeStatistics(PoolGetAllLifetimeStatisticsOptions poolGetAllLifetimeStatisticsOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetAllLifetimeStatisticsRequest(poolGetAllLifetimeStatisticsOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolGetAllLifetimeStatisticsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PoolStatistics value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PoolStatistics.DeserializePoolStatistics(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAddRequest(PoolAddParameter pool, PoolAddOptions poolAddOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools", false);
            if (poolAddOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolAddOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolAddOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolAddOptions.ClientRequestId.Value);
            }
            if (poolAddOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolAddOptions.ReturnClientRequestId.Value);
            }
            if (poolAddOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolAddOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(pool);
            request.Content = content;
            return message;
        }

        /// <summary> When naming Pools, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers. </summary>
        /// <param name="pool"> The Pool to be added. </param>
        /// <param name="poolAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pool"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolAddHeaders>> AddAsync(PoolAddParameter pool, PoolAddOptions poolAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (pool == null)
            {
                throw new ArgumentNullException(nameof(pool));
            }

            using var message = CreateAddRequest(pool, poolAddOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> When naming Pools, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers. </summary>
        /// <param name="pool"> The Pool to be added. </param>
        /// <param name="poolAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pool"/> is null. </exception>
        public ResponseWithHeaders<PoolAddHeaders> Add(PoolAddParameter pool, PoolAddOptions poolAddOptions = null, CancellationToken cancellationToken = default)
        {
            if (pool == null)
            {
                throw new ArgumentNullException(nameof(pool));
            }

            using var message = CreateAddRequest(pool, poolAddOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolAddHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListRequest(PoolListOptions poolListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools", false);
            if (poolListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", poolListOptions.Filter, true);
            }
            if (poolListOptions?.Select != null)
            {
                uri.AppendQuery("$select", poolListOptions.Select, true);
            }
            if (poolListOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", poolListOptions.Expand, true);
            }
            if (poolListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", poolListOptions.MaxResults.Value, true);
            }
            if (poolListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolListOptions.ClientRequestId.Value);
            }
            if (poolListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolListOptions.ReturnClientRequestId.Value);
            }
            if (poolListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="poolListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<CloudPoolListResult, PoolListHeaders>> ListAsync(PoolListOptions poolListOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateListRequest(poolListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudPoolListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudPoolListResult.DeserializeCloudPoolListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="poolListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CloudPoolListResult, PoolListHeaders> List(PoolListOptions poolListOptions = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateListRequest(poolListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudPoolListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudPoolListResult.DeserializeCloudPoolListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteRequest(string poolId, PoolDeleteOptions poolDeleteOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (poolDeleteOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolDeleteOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolDeleteOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolDeleteOptions.ClientRequestId.Value);
            }
            if (poolDeleteOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolDeleteOptions.ReturnClientRequestId.Value);
            }
            if (poolDeleteOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolDeleteOptions.OcpDate.Value, "R");
            }
            if (poolDeleteOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolDeleteOptions.IfMatch);
            }
            if (poolDeleteOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolDeleteOptions.IfNoneMatch);
            }
            if (poolDeleteOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolDeleteOptions.IfModifiedSince.Value, "R");
            }
            if (poolDeleteOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolDeleteOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had been requested with the default requeue option); finally, the Pool is removed from the system. Because running Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted. </summary>
        /// <param name="poolId"> The ID of the Pool to delete. </param>
        /// <param name="poolDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolDeleteHeaders>> DeleteAsync(string poolId, PoolDeleteOptions poolDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateDeleteRequest(poolId, poolDeleteOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had been requested with the default requeue option); finally, the Pool is removed from the system. Because running Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted. </summary>
        /// <param name="poolId"> The ID of the Pool to delete. </param>
        /// <param name="poolDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public ResponseWithHeaders<PoolDeleteHeaders> Delete(string poolId, PoolDeleteOptions poolDeleteOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateDeleteRequest(poolId, poolDeleteOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolDeleteHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateExistsRequest(string poolId, PoolExistsOptions poolExistsOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (poolExistsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolExistsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolExistsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolExistsOptions.ClientRequestId.Value);
            }
            if (poolExistsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolExistsOptions.ReturnClientRequestId.Value);
            }
            if (poolExistsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolExistsOptions.OcpDate.Value, "R");
            }
            if (poolExistsOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolExistsOptions.IfMatch);
            }
            if (poolExistsOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolExistsOptions.IfNoneMatch);
            }
            if (poolExistsOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolExistsOptions.IfModifiedSince.Value, "R");
            }
            if (poolExistsOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolExistsOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets basic properties of a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="poolExistsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolExistsHeaders>> ExistsAsync(string poolId, PoolExistsOptions poolExistsOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateExistsRequest(poolId, poolExistsOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolExistsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 404:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Gets basic properties of a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="poolExistsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public ResponseWithHeaders<PoolExistsHeaders> Exists(string poolId, PoolExistsOptions poolExistsOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateExistsRequest(poolId, poolExistsOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolExistsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 404:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetRequest(string poolId, PoolGetOptions poolGetOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (poolGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", poolGetOptions.Select, true);
            }
            if (poolGetOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", poolGetOptions.Expand, true);
            }
            if (poolGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolGetOptions.ClientRequestId.Value);
            }
            if (poolGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolGetOptions.ReturnClientRequestId.Value);
            }
            if (poolGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolGetOptions.OcpDate.Value, "R");
            }
            if (poolGetOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolGetOptions.IfMatch);
            }
            if (poolGetOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolGetOptions.IfNoneMatch);
            }
            if (poolGetOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolGetOptions.IfModifiedSince.Value, "R");
            }
            if (poolGetOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolGetOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets information about the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="poolGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudPool, PoolGetHeaders>> GetAsync(string poolId, PoolGetOptions poolGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateGetRequest(poolId, poolGetOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudPool value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudPool.DeserializeCloudPool(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Gets information about the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="poolGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public ResponseWithHeaders<CloudPool, PoolGetHeaders> Get(string poolId, PoolGetOptions poolGetOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateGetRequest(poolId, poolGetOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolGetHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudPool value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudPool.DeserializeCloudPool(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePatchRequest(string poolId, PoolPatchParameter poolPatchParameter, PoolPatchOptions poolPatchOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (poolPatchOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolPatchOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolPatchOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolPatchOptions.ClientRequestId.Value);
            }
            if (poolPatchOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolPatchOptions.ReturnClientRequestId.Value);
            }
            if (poolPatchOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolPatchOptions.OcpDate.Value, "R");
            }
            if (poolPatchOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolPatchOptions.IfMatch);
            }
            if (poolPatchOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolPatchOptions.IfNoneMatch);
            }
            if (poolPatchOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolPatchOptions.IfModifiedSince.Value, "R");
            }
            if (poolPatchOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolPatchOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolPatchParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="poolPatchParameter"> The parameters for the request. </param>
        /// <param name="poolPatchOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolPatchParameter"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolPatchHeaders>> PatchAsync(string poolId, PoolPatchParameter poolPatchParameter, PoolPatchOptions poolPatchOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolPatchParameter == null)
            {
                throw new ArgumentNullException(nameof(poolPatchParameter));
            }

            using var message = CreatePatchRequest(poolId, poolPatchParameter, poolPatchOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolPatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="poolPatchParameter"> The parameters for the request. </param>
        /// <param name="poolPatchOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolPatchParameter"/> is null. </exception>
        public ResponseWithHeaders<PoolPatchHeaders> Patch(string poolId, PoolPatchParameter poolPatchParameter, PoolPatchOptions poolPatchOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolPatchParameter == null)
            {
                throw new ArgumentNullException(nameof(poolPatchParameter));
            }

            using var message = CreatePatchRequest(poolId, poolPatchParameter, poolPatchOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolPatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDisableAutoScaleRequest(string poolId, PoolDisableAutoScaleOptions poolDisableAutoScaleOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/disableautoscale", false);
            if (poolDisableAutoScaleOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolDisableAutoScaleOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolDisableAutoScaleOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolDisableAutoScaleOptions.ClientRequestId.Value);
            }
            if (poolDisableAutoScaleOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolDisableAutoScaleOptions.ReturnClientRequestId.Value);
            }
            if (poolDisableAutoScaleOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolDisableAutoScaleOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Disables automatic scaling for a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        /// <param name="poolDisableAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolDisableAutoScaleHeaders>> DisableAutoScaleAsync(string poolId, PoolDisableAutoScaleOptions poolDisableAutoScaleOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateDisableAutoScaleRequest(poolId, poolDisableAutoScaleOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolDisableAutoScaleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Disables automatic scaling for a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        /// <param name="poolDisableAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public ResponseWithHeaders<PoolDisableAutoScaleHeaders> DisableAutoScale(string poolId, PoolDisableAutoScaleOptions poolDisableAutoScaleOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateDisableAutoScaleRequest(poolId, poolDisableAutoScaleOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolDisableAutoScaleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateEnableAutoScaleRequest(string poolId, PoolEnableAutoScaleParameter poolEnableAutoScaleParameter, PoolEnableAutoScaleOptions poolEnableAutoScaleOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/enableautoscale", false);
            if (poolEnableAutoScaleOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolEnableAutoScaleOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolEnableAutoScaleOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolEnableAutoScaleOptions.ClientRequestId.Value);
            }
            if (poolEnableAutoScaleOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolEnableAutoScaleOptions.ReturnClientRequestId.Value);
            }
            if (poolEnableAutoScaleOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolEnableAutoScaleOptions.OcpDate.Value, "R");
            }
            if (poolEnableAutoScaleOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolEnableAutoScaleOptions.IfMatch);
            }
            if (poolEnableAutoScaleOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolEnableAutoScaleOptions.IfNoneMatch);
            }
            if (poolEnableAutoScaleOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolEnableAutoScaleOptions.IfModifiedSince.Value, "R");
            }
            if (poolEnableAutoScaleOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolEnableAutoScaleOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolEnableAutoScaleParameter);
            request.Content = content;
            return message;
        }

        /// <summary> You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for the same Pool more than once every 30 seconds. </summary>
        /// <param name="poolId"> The ID of the Pool on which to enable automatic scaling. </param>
        /// <param name="poolEnableAutoScaleParameter"> The parameters for the request. </param>
        /// <param name="poolEnableAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolEnableAutoScaleParameter"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolEnableAutoScaleHeaders>> EnableAutoScaleAsync(string poolId, PoolEnableAutoScaleParameter poolEnableAutoScaleParameter, PoolEnableAutoScaleOptions poolEnableAutoScaleOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolEnableAutoScaleParameter == null)
            {
                throw new ArgumentNullException(nameof(poolEnableAutoScaleParameter));
            }

            using var message = CreateEnableAutoScaleRequest(poolId, poolEnableAutoScaleParameter, poolEnableAutoScaleOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolEnableAutoScaleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for the same Pool more than once every 30 seconds. </summary>
        /// <param name="poolId"> The ID of the Pool on which to enable automatic scaling. </param>
        /// <param name="poolEnableAutoScaleParameter"> The parameters for the request. </param>
        /// <param name="poolEnableAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolEnableAutoScaleParameter"/> is null. </exception>
        public ResponseWithHeaders<PoolEnableAutoScaleHeaders> EnableAutoScale(string poolId, PoolEnableAutoScaleParameter poolEnableAutoScaleParameter, PoolEnableAutoScaleOptions poolEnableAutoScaleOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolEnableAutoScaleParameter == null)
            {
                throw new ArgumentNullException(nameof(poolEnableAutoScaleParameter));
            }

            using var message = CreateEnableAutoScaleRequest(poolId, poolEnableAutoScaleParameter, poolEnableAutoScaleOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolEnableAutoScaleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateEvaluateAutoScaleRequest(string poolId, PoolEvaluateAutoScaleParameter poolEvaluateAutoScaleParameter, PoolEvaluateAutoScaleOptions poolEvaluateAutoScaleOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/evaluateautoscale", false);
            if (poolEvaluateAutoScaleOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolEvaluateAutoScaleOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolEvaluateAutoScaleOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolEvaluateAutoScaleOptions.ClientRequestId.Value);
            }
            if (poolEvaluateAutoScaleOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolEvaluateAutoScaleOptions.ReturnClientRequestId.Value);
            }
            if (poolEvaluateAutoScaleOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolEvaluateAutoScaleOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolEvaluateAutoScaleParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This API is primarily for validating an autoscale formula, as it simply returns the result without applying the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula. </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="poolEvaluateAutoScaleParameter"> The parameters for the request. </param>
        /// <param name="poolEvaluateAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolEvaluateAutoScaleParameter"/> is null. </exception>
        public async Task<ResponseWithHeaders<AutoScaleRun, PoolEvaluateAutoScaleHeaders>> EvaluateAutoScaleAsync(string poolId, PoolEvaluateAutoScaleParameter poolEvaluateAutoScaleParameter, PoolEvaluateAutoScaleOptions poolEvaluateAutoScaleOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolEvaluateAutoScaleParameter == null)
            {
                throw new ArgumentNullException(nameof(poolEvaluateAutoScaleParameter));
            }

            using var message = CreateEvaluateAutoScaleRequest(poolId, poolEvaluateAutoScaleParameter, poolEvaluateAutoScaleOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolEvaluateAutoScaleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AutoScaleRun value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = AutoScaleRun.DeserializeAutoScaleRun(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> This API is primarily for validating an autoscale formula, as it simply returns the result without applying the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula. </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="poolEvaluateAutoScaleParameter"> The parameters for the request. </param>
        /// <param name="poolEvaluateAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolEvaluateAutoScaleParameter"/> is null. </exception>
        public ResponseWithHeaders<AutoScaleRun, PoolEvaluateAutoScaleHeaders> EvaluateAutoScale(string poolId, PoolEvaluateAutoScaleParameter poolEvaluateAutoScaleParameter, PoolEvaluateAutoScaleOptions poolEvaluateAutoScaleOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolEvaluateAutoScaleParameter == null)
            {
                throw new ArgumentNullException(nameof(poolEvaluateAutoScaleParameter));
            }

            using var message = CreateEvaluateAutoScaleRequest(poolId, poolEvaluateAutoScaleParameter, poolEvaluateAutoScaleOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolEvaluateAutoScaleHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AutoScaleRun value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = AutoScaleRun.DeserializeAutoScaleRun(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateResizeRequest(string poolId, PoolResizeParameter poolResizeParameter, PoolResizeOptions poolResizeOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/resize", false);
            if (poolResizeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolResizeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolResizeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolResizeOptions.ClientRequestId.Value);
            }
            if (poolResizeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolResizeOptions.ReturnClientRequestId.Value);
            }
            if (poolResizeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolResizeOptions.OcpDate.Value, "R");
            }
            if (poolResizeOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolResizeOptions.IfMatch);
            }
            if (poolResizeOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolResizeOptions.IfNoneMatch);
            }
            if (poolResizeOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolResizeOptions.IfModifiedSince.Value, "R");
            }
            if (poolResizeOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolResizeOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolResizeParameter);
            request.Content = content;
            return message;
        }

        /// <summary> You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request fails with status code 409. When you resize a Pool, the Pool&apos;s allocation state changes from steady to resizing. You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To remove specific Compute Nodes, use the Pool remove Compute Nodes API instead. </summary>
        /// <param name="poolId"> The ID of the Pool to resize. </param>
        /// <param name="poolResizeParameter"> The parameters for the request. </param>
        /// <param name="poolResizeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolResizeParameter"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolResizeHeaders>> ResizeAsync(string poolId, PoolResizeParameter poolResizeParameter, PoolResizeOptions poolResizeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolResizeParameter == null)
            {
                throw new ArgumentNullException(nameof(poolResizeParameter));
            }

            using var message = CreateResizeRequest(poolId, poolResizeParameter, poolResizeOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolResizeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request fails with status code 409. When you resize a Pool, the Pool&apos;s allocation state changes from steady to resizing. You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To remove specific Compute Nodes, use the Pool remove Compute Nodes API instead. </summary>
        /// <param name="poolId"> The ID of the Pool to resize. </param>
        /// <param name="poolResizeParameter"> The parameters for the request. </param>
        /// <param name="poolResizeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolResizeParameter"/> is null. </exception>
        public ResponseWithHeaders<PoolResizeHeaders> Resize(string poolId, PoolResizeParameter poolResizeParameter, PoolResizeOptions poolResizeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolResizeParameter == null)
            {
                throw new ArgumentNullException(nameof(poolResizeParameter));
            }

            using var message = CreateResizeRequest(poolId, poolResizeParameter, poolResizeOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolResizeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateStopResizeRequest(string poolId, PoolStopResizeOptions poolStopResizeOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/stopresize", false);
            if (poolStopResizeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolStopResizeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolStopResizeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolStopResizeOptions.ClientRequestId.Value);
            }
            if (poolStopResizeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolStopResizeOptions.ReturnClientRequestId.Value);
            }
            if (poolStopResizeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolStopResizeOptions.OcpDate.Value, "R");
            }
            if (poolStopResizeOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolStopResizeOptions.IfMatch);
            }
            if (poolStopResizeOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolStopResizeOptions.IfNoneMatch);
            }
            if (poolStopResizeOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolStopResizeOptions.IfModifiedSince.Value, "R");
            }
            if (poolStopResizeOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolStopResizeOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> This does not restore the Pool to its previous state before the resize operation: it only stops any further changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request; this API can also be used to halt the initial sizing of the Pool when it is created. </summary>
        /// <param name="poolId"> The ID of the Pool whose resizing you want to stop. </param>
        /// <param name="poolStopResizeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolStopResizeHeaders>> StopResizeAsync(string poolId, PoolStopResizeOptions poolStopResizeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateStopResizeRequest(poolId, poolStopResizeOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolStopResizeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> This does not restore the Pool to its previous state before the resize operation: it only stops any further changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request; this API can also be used to halt the initial sizing of the Pool when it is created. </summary>
        /// <param name="poolId"> The ID of the Pool whose resizing you want to stop. </param>
        /// <param name="poolStopResizeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        public ResponseWithHeaders<PoolStopResizeHeaders> StopResize(string poolId, PoolStopResizeOptions poolStopResizeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var message = CreateStopResizeRequest(poolId, poolStopResizeOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolStopResizeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdatePropertiesRequest(string poolId, PoolUpdatePropertiesParameter poolUpdatePropertiesParameter, PoolUpdatePropertiesOptions poolUpdatePropertiesOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/updateproperties", false);
            if (poolUpdatePropertiesOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolUpdatePropertiesOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolUpdatePropertiesOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolUpdatePropertiesOptions.ClientRequestId.Value);
            }
            if (poolUpdatePropertiesOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolUpdatePropertiesOptions.ReturnClientRequestId.Value);
            }
            if (poolUpdatePropertiesOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolUpdatePropertiesOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolUpdatePropertiesParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask associated with it and if StartTask is not specified with this request, then the Batch service will remove the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="poolUpdatePropertiesParameter"> The parameters for the request. </param>
        /// <param name="poolUpdatePropertiesOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolUpdatePropertiesParameter"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolUpdatePropertiesHeaders>> UpdatePropertiesAsync(string poolId, PoolUpdatePropertiesParameter poolUpdatePropertiesParameter, PoolUpdatePropertiesOptions poolUpdatePropertiesOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolUpdatePropertiesParameter == null)
            {
                throw new ArgumentNullException(nameof(poolUpdatePropertiesParameter));
            }

            using var message = CreateUpdatePropertiesRequest(poolId, poolUpdatePropertiesParameter, poolUpdatePropertiesOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolUpdatePropertiesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask associated with it and if StartTask is not specified with this request, then the Batch service will remove the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="poolUpdatePropertiesParameter"> The parameters for the request. </param>
        /// <param name="poolUpdatePropertiesOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="poolUpdatePropertiesParameter"/> is null. </exception>
        public ResponseWithHeaders<PoolUpdatePropertiesHeaders> UpdateProperties(string poolId, PoolUpdatePropertiesParameter poolUpdatePropertiesParameter, PoolUpdatePropertiesOptions poolUpdatePropertiesOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolUpdatePropertiesParameter == null)
            {
                throw new ArgumentNullException(nameof(poolUpdatePropertiesParameter));
            }

            using var message = CreateUpdatePropertiesRequest(poolId, poolUpdatePropertiesParameter, poolUpdatePropertiesOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolUpdatePropertiesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 204:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateRemoveNodesRequest(string poolId, NodeRemoveParameter nodeRemoveParameter, PoolRemoveNodesOptions poolRemoveNodesOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/removenodes", false);
            if (poolRemoveNodesOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolRemoveNodesOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (poolRemoveNodesOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolRemoveNodesOptions.ClientRequestId.Value);
            }
            if (poolRemoveNodesOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolRemoveNodesOptions.ReturnClientRequestId.Value);
            }
            if (poolRemoveNodesOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolRemoveNodesOptions.OcpDate.Value, "R");
            }
            if (poolRemoveNodesOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolRemoveNodesOptions.IfMatch);
            }
            if (poolRemoveNodesOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolRemoveNodesOptions.IfNoneMatch);
            }
            if (poolRemoveNodesOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolRemoveNodesOptions.IfModifiedSince.Value, "R");
            }
            if (poolRemoveNodesOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolRemoveNodesOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(nodeRemoveParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This operation can only run when the allocation state of the Pool is steady. When this operation runs, the allocation state changes from steady to resizing. Each request may remove up to 100 nodes. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to remove Compute Nodes. </param>
        /// <param name="nodeRemoveParameter"> The parameters for the request. </param>
        /// <param name="poolRemoveNodesOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeRemoveParameter"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolRemoveNodesHeaders>> RemoveNodesAsync(string poolId, NodeRemoveParameter nodeRemoveParameter, PoolRemoveNodesOptions poolRemoveNodesOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeRemoveParameter == null)
            {
                throw new ArgumentNullException(nameof(nodeRemoveParameter));
            }

            using var message = CreateRemoveNodesRequest(poolId, nodeRemoveParameter, poolRemoveNodesOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolRemoveNodesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> This operation can only run when the allocation state of the Pool is steady. When this operation runs, the allocation state changes from steady to resizing. Each request may remove up to 100 nodes. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to remove Compute Nodes. </param>
        /// <param name="nodeRemoveParameter"> The parameters for the request. </param>
        /// <param name="poolRemoveNodesOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeRemoveParameter"/> is null. </exception>
        public ResponseWithHeaders<PoolRemoveNodesHeaders> RemoveNodes(string poolId, NodeRemoveParameter nodeRemoveParameter, PoolRemoveNodesOptions poolRemoveNodesOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeRemoveParameter == null)
            {
                throw new ArgumentNullException(nameof(nodeRemoveParameter));
            }

            using var message = CreateRemoveNodesRequest(poolId, nodeRemoveParameter, poolRemoveNodesOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolRemoveNodesHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListUsageMetricsNextPageRequest(string nextLink, PoolListUsageMetricsOptions poolListUsageMetricsOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (poolListUsageMetricsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolListUsageMetricsOptions.ClientRequestId.Value);
            }
            if (poolListUsageMetricsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolListUsageMetricsOptions.ReturnClientRequestId.Value);
            }
            if (poolListUsageMetricsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolListUsageMetricsOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolListUsageMetricsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public async Task<ResponseWithHeaders<PoolListUsageMetricsResult, PoolListUsageMetricsHeaders>> ListUsageMetricsNextPageAsync(string nextLink, PoolListUsageMetricsOptions poolListUsageMetricsOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateListUsageMetricsNextPageRequest(nextLink, poolListUsageMetricsOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolListUsageMetricsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PoolListUsageMetricsResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PoolListUsageMetricsResult.DeserializePoolListUsageMetricsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolListUsageMetricsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public ResponseWithHeaders<PoolListUsageMetricsResult, PoolListUsageMetricsHeaders> ListUsageMetricsNextPage(string nextLink, PoolListUsageMetricsOptions poolListUsageMetricsOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateListUsageMetricsNextPageRequest(nextLink, poolListUsageMetricsOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolListUsageMetricsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PoolListUsageMetricsResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PoolListUsageMetricsResult.DeserializePoolListUsageMetricsResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, PoolListOptions poolListOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (poolListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolListOptions.ClientRequestId.Value);
            }
            if (poolListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolListOptions.ReturnClientRequestId.Value);
            }
            if (poolListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolListOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public async Task<ResponseWithHeaders<CloudPoolListResult, PoolListHeaders>> ListNextPageAsync(string nextLink, PoolListOptions poolListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateListNextPageRequest(nextLink, poolListOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new PoolListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudPoolListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CloudPoolListResult.DeserializeCloudPoolListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> is null. </exception>
        public ResponseWithHeaders<CloudPoolListResult, PoolListHeaders> ListNextPage(string nextLink, PoolListOptions poolListOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var message = CreateListNextPageRequest(nextLink, poolListOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new PoolListHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CloudPoolListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CloudPoolListResult.DeserializeCloudPoolListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
