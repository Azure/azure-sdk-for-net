// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Service.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch.Service
{
    internal partial class FileRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of FileRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="batchUrl"/> or <paramref name="apiVersion"/> is null. </exception>
        public FileRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2022-01-01.15.0")
        {
            _batchUrl = batchUrl ?? throw new ArgumentNullException(nameof(batchUrl));
            _apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateDeleteFromTaskRequest(string jobId, string taskId, string filePath, bool? recursive, FileDeleteFromTaskOptions fileDeleteFromTaskOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            if (fileDeleteFromTaskOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileDeleteFromTaskOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (fileDeleteFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileDeleteFromTaskOptions.ClientRequestId.Value);
            }
            if (fileDeleteFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileDeleteFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileDeleteFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileDeleteFromTaskOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Deletes the specified Task file from the Compute Node where the Task ran. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to delete. </param>
        /// <param name="filePath"> The path to the Task file or directory that you want to delete. </param>
        /// <param name="recursive"> Whether to delete children of a directory. If the filePath parameter represents a directory instead of a file, you can set recursive to true to delete the directory and all of the files and subdirectories in it. If recursive is false then the directory must be empty or deletion will fail. </param>
        /// <param name="fileDeleteFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        public async Task<ResponseWithHeaders<FileDeleteFromTaskHeaders>> DeleteFromTaskAsync(string jobId, string taskId, string filePath, bool? recursive = null, FileDeleteFromTaskOptions fileDeleteFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateDeleteFromTaskRequest(jobId, taskId, filePath, recursive, fileDeleteFromTaskOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileDeleteFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Deletes the specified Task file from the Compute Node where the Task ran. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to delete. </param>
        /// <param name="filePath"> The path to the Task file or directory that you want to delete. </param>
        /// <param name="recursive"> Whether to delete children of a directory. If the filePath parameter represents a directory instead of a file, you can set recursive to true to delete the directory and all of the files and subdirectories in it. If recursive is false then the directory must be empty or deletion will fail. </param>
        /// <param name="fileDeleteFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        public ResponseWithHeaders<FileDeleteFromTaskHeaders> DeleteFromTask(string jobId, string taskId, string filePath, bool? recursive = null, FileDeleteFromTaskOptions fileDeleteFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateDeleteFromTaskRequest(jobId, taskId, filePath, recursive, fileDeleteFromTaskOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileDeleteFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetFromTaskRequest(string jobId, string taskId, string filePath, FileGetFromTaskOptions fileGetFromTaskOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (fileGetFromTaskOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileGetFromTaskOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (fileGetFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileGetFromTaskOptions.ClientRequestId.Value);
            }
            if (fileGetFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileGetFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileGetFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileGetFromTaskOptions.OcpDate.Value, "R");
            }
            if (fileGetFromTaskOptions?.OcpRange != null)
            {
                request.Headers.Add("ocp-range", fileGetFromTaskOptions.OcpRange);
            }
            if (fileGetFromTaskOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", fileGetFromTaskOptions.IfModifiedSince.Value, "R");
            }
            if (fileGetFromTaskOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", fileGetFromTaskOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json, application/octet-stream");
            return message;
        }

        /// <summary> Returns the content of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="fileGetFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        public async Task<ResponseWithHeaders<Stream, FileGetFromTaskHeaders>> GetFromTaskAsync(string jobId, string taskId, string filePath, FileGetFromTaskOptions fileGetFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateGetFromTaskRequest(jobId, taskId, filePath, fileGetFromTaskOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileGetFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Returns the content of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="fileGetFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        public ResponseWithHeaders<Stream, FileGetFromTaskHeaders> GetFromTask(string jobId, string taskId, string filePath, FileGetFromTaskOptions fileGetFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateGetFromTaskRequest(jobId, taskId, filePath, fileGetFromTaskOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileGetFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetPropertiesFromTaskRequest(string jobId, string taskId, string filePath, FileGetPropertiesFromTaskOptions fileGetPropertiesFromTaskOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (fileGetPropertiesFromTaskOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileGetPropertiesFromTaskOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (fileGetPropertiesFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileGetPropertiesFromTaskOptions.ClientRequestId.Value);
            }
            if (fileGetPropertiesFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileGetPropertiesFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileGetPropertiesFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileGetPropertiesFromTaskOptions.OcpDate.Value, "R");
            }
            if (fileGetPropertiesFromTaskOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", fileGetPropertiesFromTaskOptions.IfModifiedSince.Value, "R");
            }
            if (fileGetPropertiesFromTaskOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", fileGetPropertiesFromTaskOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets the properties of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to get the properties of. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the properties of. </param>
        /// <param name="fileGetPropertiesFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        public async Task<ResponseWithHeaders<FileGetPropertiesFromTaskHeaders>> GetPropertiesFromTaskAsync(string jobId, string taskId, string filePath, FileGetPropertiesFromTaskOptions fileGetPropertiesFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateGetPropertiesFromTaskRequest(jobId, taskId, filePath, fileGetPropertiesFromTaskOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileGetPropertiesFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Gets the properties of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to get the properties of. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the properties of. </param>
        /// <param name="fileGetPropertiesFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        public ResponseWithHeaders<FileGetPropertiesFromTaskHeaders> GetPropertiesFromTask(string jobId, string taskId, string filePath, FileGetPropertiesFromTaskOptions fileGetPropertiesFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateGetPropertiesFromTaskRequest(jobId, taskId, filePath, fileGetPropertiesFromTaskOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileGetPropertiesFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteFromComputeNodeRequest(string poolId, string nodeId, string filePath, bool? recursive, FileDeleteFromComputeNodeOptions fileDeleteFromComputeNodeOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            if (fileDeleteFromComputeNodeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileDeleteFromComputeNodeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (fileDeleteFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileDeleteFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileDeleteFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileDeleteFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileDeleteFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileDeleteFromComputeNodeOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Deletes the specified file from the Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="recursive"> Whether to delete children of a directory. If the filePath parameter represents a directory instead of a file, you can set recursive to true to delete the directory and all of the files and subdirectories in it. If recursive is false then the directory must be empty or deletion will fail. </param>
        /// <param name="fileDeleteFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        public async Task<ResponseWithHeaders<FileDeleteFromComputeNodeHeaders>> DeleteFromComputeNodeAsync(string poolId, string nodeId, string filePath, bool? recursive = null, FileDeleteFromComputeNodeOptions fileDeleteFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateDeleteFromComputeNodeRequest(poolId, nodeId, filePath, recursive, fileDeleteFromComputeNodeOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileDeleteFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Deletes the specified file from the Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="recursive"> Whether to delete children of a directory. If the filePath parameter represents a directory instead of a file, you can set recursive to true to delete the directory and all of the files and subdirectories in it. If recursive is false then the directory must be empty or deletion will fail. </param>
        /// <param name="fileDeleteFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        public ResponseWithHeaders<FileDeleteFromComputeNodeHeaders> DeleteFromComputeNode(string poolId, string nodeId, string filePath, bool? recursive = null, FileDeleteFromComputeNodeOptions fileDeleteFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateDeleteFromComputeNodeRequest(poolId, nodeId, filePath, recursive, fileDeleteFromComputeNodeOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileDeleteFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetFromComputeNodeRequest(string poolId, string nodeId, string filePath, FileGetFromComputeNodeOptions fileGetFromComputeNodeOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (fileGetFromComputeNodeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileGetFromComputeNodeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (fileGetFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileGetFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileGetFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileGetFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileGetFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileGetFromComputeNodeOptions.OcpDate.Value, "R");
            }
            if (fileGetFromComputeNodeOptions?.OcpRange != null)
            {
                request.Headers.Add("ocp-range", fileGetFromComputeNodeOptions.OcpRange);
            }
            if (fileGetFromComputeNodeOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", fileGetFromComputeNodeOptions.IfModifiedSince.Value, "R");
            }
            if (fileGetFromComputeNodeOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", fileGetFromComputeNodeOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json, application/octet-stream");
            return message;
        }

        /// <summary> Returns the content of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the file. </param>
        /// <param name="filePath"> The path to the Compute Node file that you want to get the content of. </param>
        /// <param name="fileGetFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        public async Task<ResponseWithHeaders<Stream, FileGetFromComputeNodeHeaders>> GetFromComputeNodeAsync(string poolId, string nodeId, string filePath, FileGetFromComputeNodeOptions fileGetFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateGetFromComputeNodeRequest(poolId, nodeId, filePath, fileGetFromComputeNodeOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileGetFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Returns the content of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the file. </param>
        /// <param name="filePath"> The path to the Compute Node file that you want to get the content of. </param>
        /// <param name="fileGetFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        public ResponseWithHeaders<Stream, FileGetFromComputeNodeHeaders> GetFromComputeNode(string poolId, string nodeId, string filePath, FileGetFromComputeNodeOptions fileGetFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateGetFromComputeNodeRequest(poolId, nodeId, filePath, fileGetFromComputeNodeOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileGetFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetPropertiesFromComputeNodeRequest(string poolId, string nodeId, string filePath, FileGetPropertiesFromComputeNodeOptions fileGetPropertiesFromComputeNodeOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (fileGetPropertiesFromComputeNodeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileGetPropertiesFromComputeNodeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (fileGetPropertiesFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileGetPropertiesFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileGetPropertiesFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileGetPropertiesFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileGetPropertiesFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileGetPropertiesFromComputeNodeOptions.OcpDate.Value, "R");
            }
            if (fileGetPropertiesFromComputeNodeOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", fileGetPropertiesFromComputeNodeOptions.IfModifiedSince.Value, "R");
            }
            if (fileGetPropertiesFromComputeNodeOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", fileGetPropertiesFromComputeNodeOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Gets the properties of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the file. </param>
        /// <param name="filePath"> The path to the Compute Node file that you want to get the properties of. </param>
        /// <param name="fileGetPropertiesFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        public async Task<ResponseWithHeaders<FileGetPropertiesFromComputeNodeHeaders>> GetPropertiesFromComputeNodeAsync(string poolId, string nodeId, string filePath, FileGetPropertiesFromComputeNodeOptions fileGetPropertiesFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateGetPropertiesFromComputeNodeRequest(poolId, nodeId, filePath, fileGetPropertiesFromComputeNodeOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileGetPropertiesFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Gets the properties of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the file. </param>
        /// <param name="filePath"> The path to the Compute Node file that you want to get the properties of. </param>
        /// <param name="fileGetPropertiesFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        public ResponseWithHeaders<FileGetPropertiesFromComputeNodeHeaders> GetPropertiesFromComputeNode(string poolId, string nodeId, string filePath, FileGetPropertiesFromComputeNodeOptions fileGetPropertiesFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var message = CreateGetPropertiesFromComputeNodeRequest(poolId, nodeId, filePath, fileGetPropertiesFromComputeNodeOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileGetPropertiesFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListFromTaskRequest(string jobId, string taskId, bool? recursive, FileListFromTaskOptions fileListFromTaskOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files", false);
            if (fileListFromTaskOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", fileListFromTaskOptions.Filter, true);
            }
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            if (fileListFromTaskOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", fileListFromTaskOptions.MaxResults.Value, true);
            }
            if (fileListFromTaskOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileListFromTaskOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (fileListFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileListFromTaskOptions.ClientRequestId.Value);
            }
            if (fileListFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileListFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileListFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileListFromTaskOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists the files in a Task&apos;s directory on its Compute Node. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of the Task directory. This parameter can be used in combination with the filter parameter to list specific type of files. </param>
        /// <param name="fileListFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public async Task<ResponseWithHeaders<NodeFileListResult, FileListFromTaskHeaders>> ListFromTaskAsync(string jobId, string taskId, bool? recursive = null, FileListFromTaskOptions fileListFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateListFromTaskRequest(jobId, taskId, recursive, fileListFromTaskOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileListFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        NodeFileListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Lists the files in a Task&apos;s directory on its Compute Node. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of the Task directory. This parameter can be used in combination with the filter parameter to list specific type of files. </param>
        /// <param name="fileListFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public ResponseWithHeaders<NodeFileListResult, FileListFromTaskHeaders> ListFromTask(string jobId, string taskId, bool? recursive = null, FileListFromTaskOptions fileListFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateListFromTaskRequest(jobId, taskId, recursive, fileListFromTaskOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileListFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        NodeFileListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListFromComputeNodeRequest(string poolId, string nodeId, bool? recursive, FileListFromComputeNodeOptions fileListFromComputeNodeOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files", false);
            if (fileListFromComputeNodeOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", fileListFromComputeNodeOptions.Filter, true);
            }
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            if (fileListFromComputeNodeOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", fileListFromComputeNodeOptions.MaxResults.Value, true);
            }
            if (fileListFromComputeNodeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileListFromComputeNodeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (fileListFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileListFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileListFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileListFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileListFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileListFromComputeNodeOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="fileListFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        public async Task<ResponseWithHeaders<NodeFileListResult, FileListFromComputeNodeHeaders>> ListFromComputeNodeAsync(string poolId, string nodeId, bool? recursive = null, FileListFromComputeNodeOptions fileListFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateListFromComputeNodeRequest(poolId, nodeId, recursive, fileListFromComputeNodeOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileListFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        NodeFileListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="fileListFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        public ResponseWithHeaders<NodeFileListResult, FileListFromComputeNodeHeaders> ListFromComputeNode(string poolId, string nodeId, bool? recursive = null, FileListFromComputeNodeOptions fileListFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateListFromComputeNodeRequest(poolId, nodeId, recursive, fileListFromComputeNodeOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileListFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        NodeFileListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListFromTaskNextPageRequest(string nextLink, string jobId, string taskId, bool? recursive, FileListFromTaskOptions fileListFromTaskOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (fileListFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileListFromTaskOptions.ClientRequestId.Value);
            }
            if (fileListFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileListFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileListFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileListFromTaskOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists the files in a Task&apos;s directory on its Compute Node. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of the Task directory. This parameter can be used in combination with the filter parameter to list specific type of files. </param>
        /// <param name="fileListFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public async Task<ResponseWithHeaders<NodeFileListResult, FileListFromTaskHeaders>> ListFromTaskNextPageAsync(string nextLink, string jobId, string taskId, bool? recursive = null, FileListFromTaskOptions fileListFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateListFromTaskNextPageRequest(nextLink, jobId, taskId, recursive, fileListFromTaskOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileListFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        NodeFileListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Lists the files in a Task&apos;s directory on its Compute Node. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of the Task directory. This parameter can be used in combination with the filter parameter to list specific type of files. </param>
        /// <param name="fileListFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        public ResponseWithHeaders<NodeFileListResult, FileListFromTaskHeaders> ListFromTaskNextPage(string nextLink, string jobId, string taskId, bool? recursive = null, FileListFromTaskOptions fileListFromTaskOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var message = CreateListFromTaskNextPageRequest(nextLink, jobId, taskId, recursive, fileListFromTaskOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileListFromTaskHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        NodeFileListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateListFromComputeNodeNextPageRequest(string nextLink, string poolId, string nodeId, bool? recursive, FileListFromComputeNodeOptions fileListFromComputeNodeOptions)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (fileListFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileListFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileListFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileListFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileListFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileListFromComputeNodeOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="fileListFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        public async Task<ResponseWithHeaders<NodeFileListResult, FileListFromComputeNodeHeaders>> ListFromComputeNodeNextPageAsync(string nextLink, string poolId, string nodeId, bool? recursive = null, FileListFromComputeNodeOptions fileListFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateListFromComputeNodeNextPageRequest(nextLink, poolId, nodeId, recursive, fileListFromComputeNodeOptions);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new FileListFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        NodeFileListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await ClientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="fileListFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        public ResponseWithHeaders<NodeFileListResult, FileListFromComputeNodeHeaders> ListFromComputeNodeNextPage(string nextLink, string poolId, string nodeId, bool? recursive = null, FileListFromComputeNodeOptions fileListFromComputeNodeOptions = null, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var message = CreateListFromComputeNodeNextPageRequest(nextLink, poolId, nodeId, recursive, fileListFromComputeNodeOptions);
            _pipeline.Send(message, cancellationToken);
            var headers = new FileListFromComputeNodeHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        NodeFileListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw ClientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
