// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Data.Batch
{
    /// <summary> The Task service client. </summary>
    public partial class TaskClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://batch.core.windows.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of TaskClient for mocking. </summary>
        protected TaskClient()
        {
        }

        /// <summary> Initializes a new instance of TaskClient. </summary>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="batchUrl"/> or <paramref name="credential"/> is null. </exception>
        public TaskClient(string batchUrl, TokenCredential credential, AzureBatchClientOptions options = null)
        {
            Argument.AssertNotNull(batchUrl, nameof(batchUrl));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new AzureBatchClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _batchUrl = batchUrl;
            _apiVersion = options.Version;
        }

        /// <summary> The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be added. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   id: string,
        ///   displayName: string,
        ///   url: string,
        ///   eTag: string,
        ///   lastModified: string (ISO 8601 Format),
        ///   creationTime: string (ISO 8601 Format),
        ///   exitConditions: {
        ///     exitCodes: [
        ///       {
        ///         code: number (required),
        ///         exitOptions: {
        ///           jobAction: JobAction,
        ///           dependencyAction: DependencyAction
        ///         } (required)
        ///       }
        ///     ],
        ///     exitCodeRanges: [
        ///       {
        ///         start: number (required),
        ///         end: number (required),
        ///         exitOptions: ExitOptions (required)
        ///       }
        ///     ],
        ///     preProcessingError: ExitOptions,
        ///     fileUploadError: ExitOptions,
        ///     default: ExitOptions
        ///   },
        ///   state: TaskState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   previousState: TaskState,
        ///   previousStateTransitionTime: string (ISO 8601 Format),
        ///   commandLine: string,
        ///   containerSettings: {
        ///     containerRunOptions: string,
        ///     imageName: string (required),
        ///     registry: {
        ///       username: string,
        ///       password: string,
        ///       registryServer: string,
        ///       identityReference: {
        ///         resourceId: string
        ///       }
        ///     },
        ///     workingDirectory: ContainerWorkingDirectory
        ///   },
        ///   resourceFiles: [
        ///     {
        ///       autoStorageContainerName: string,
        ///       storageContainerUrl: string,
        ///       httpUrl: string,
        ///       blobPrefix: string,
        ///       filePath: string,
        ///       fileMode: string,
        ///       identityReference: ComputeNodeIdentityReference
        ///     }
        ///   ],
        ///   outputFiles: [
        ///     {
        ///       filePattern: string (required),
        ///       destination: {
        ///         container: {
        ///           path: string,
        ///           containerUrl: string (required),
        ///           identityReference: ComputeNodeIdentityReference,
        ///           uploadHeaders: [
        ///             {
        ///               name: string (required),
        ///               value: string
        ///             }
        ///           ]
        ///         }
        ///       } (required),
        ///       uploadOptions: {
        ///         uploadCondition: OutputFileUploadCondition (required)
        ///       } (required)
        ///     }
        ///   ],
        ///   environmentSettings: [
        ///     {
        ///       name: string (required),
        ///       value: string
        ///     }
        ///   ],
        ///   affinityInfo: {
        ///     affinityId: string (required)
        ///   },
        ///   constraints: {
        ///     maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///     retentionTime: TaskConstraintsRetentionTime,
        ///     maxTaskRetryCount: number
        ///   },
        ///   requiredSlots: number,
        ///   userIdentity: {
        ///     username: string,
        ///     autoUser: {
        ///       scope: AutoUserScope,
        ///       elevationLevel: ElevationLevel
        ///     }
        ///   },
        ///   executionInfo: {
        ///     startTime: string (ISO 8601 Format),
        ///     endTime: string (ISO 8601 Format),
        ///     exitCode: number,
        ///     containerInfo: {
        ///       containerId: string,
        ///       state: string,
        ///       error: string
        ///     },
        ///     failureInfo: {
        ///       category: ErrorCategory (required),
        ///       code: string,
        ///       message: string,
        ///       details: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ]
        ///     },
        ///     retryCount: number (required),
        ///     lastRetryTime: string (ISO 8601 Format),
        ///     requeueCount: number (required),
        ///     lastRequeueTime: string (ISO 8601 Format),
        ///     result: TaskExecutionResult
        ///   },
        ///   nodeInfo: {
        ///     affinityId: string,
        ///     nodeUrl: string,
        ///     poolId: string,
        ///     nodeId: string,
        ///     taskRootDirectory: string,
        ///     taskRootDirectoryUrl: string
        ///   },
        ///   multiInstanceSettings: {
        ///     numberOfInstances: number,
        ///     coordinationCommandLine: string (required),
        ///     commonResourceFiles: [ResourceFile]
        ///   },
        ///   stats: {
        ///     url: string (required),
        ///     startTime: string (ISO 8601 Format) (required),
        ///     lastUpdateTime: string (ISO 8601 Format) (required),
        ///     userCPUTime: TaskStatisticsUserCPUTime (required),
        ///     kernelCPUTime: TaskStatisticsKernelCPUTime (required),
        ///     wallClockTime: TaskStatisticsWallClockTime (required),
        ///     readIOps: number (required),
        ///     writeIOps: number (required),
        ///     readIOGiB: number (required),
        ///     writeIOGiB: number (required),
        ///     waitTime: TaskStatisticsWaitTime (required)
        ///   },
        ///   dependsOn: {
        ///     taskIds: [string],
        ///     taskIdRanges: [
        ///       {
        ///         start: number (required),
        ///         end: number (required)
        ///       }
        ///     ]
        ///   },
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ],
        ///   authenticationTokenSettings: {
        ///     access: [AccessScope]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AddAsync(string jobId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Add");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddRequest(jobId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be added. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   id: string,
        ///   displayName: string,
        ///   url: string,
        ///   eTag: string,
        ///   lastModified: string (ISO 8601 Format),
        ///   creationTime: string (ISO 8601 Format),
        ///   exitConditions: {
        ///     exitCodes: [
        ///       {
        ///         code: number (required),
        ///         exitOptions: {
        ///           jobAction: JobAction,
        ///           dependencyAction: DependencyAction
        ///         } (required)
        ///       }
        ///     ],
        ///     exitCodeRanges: [
        ///       {
        ///         start: number (required),
        ///         end: number (required),
        ///         exitOptions: ExitOptions (required)
        ///       }
        ///     ],
        ///     preProcessingError: ExitOptions,
        ///     fileUploadError: ExitOptions,
        ///     default: ExitOptions
        ///   },
        ///   state: TaskState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   previousState: TaskState,
        ///   previousStateTransitionTime: string (ISO 8601 Format),
        ///   commandLine: string,
        ///   containerSettings: {
        ///     containerRunOptions: string,
        ///     imageName: string (required),
        ///     registry: {
        ///       username: string,
        ///       password: string,
        ///       registryServer: string,
        ///       identityReference: {
        ///         resourceId: string
        ///       }
        ///     },
        ///     workingDirectory: ContainerWorkingDirectory
        ///   },
        ///   resourceFiles: [
        ///     {
        ///       autoStorageContainerName: string,
        ///       storageContainerUrl: string,
        ///       httpUrl: string,
        ///       blobPrefix: string,
        ///       filePath: string,
        ///       fileMode: string,
        ///       identityReference: ComputeNodeIdentityReference
        ///     }
        ///   ],
        ///   outputFiles: [
        ///     {
        ///       filePattern: string (required),
        ///       destination: {
        ///         container: {
        ///           path: string,
        ///           containerUrl: string (required),
        ///           identityReference: ComputeNodeIdentityReference,
        ///           uploadHeaders: [
        ///             {
        ///               name: string (required),
        ///               value: string
        ///             }
        ///           ]
        ///         }
        ///       } (required),
        ///       uploadOptions: {
        ///         uploadCondition: OutputFileUploadCondition (required)
        ///       } (required)
        ///     }
        ///   ],
        ///   environmentSettings: [
        ///     {
        ///       name: string (required),
        ///       value: string
        ///     }
        ///   ],
        ///   affinityInfo: {
        ///     affinityId: string (required)
        ///   },
        ///   constraints: {
        ///     maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///     retentionTime: TaskConstraintsRetentionTime,
        ///     maxTaskRetryCount: number
        ///   },
        ///   requiredSlots: number,
        ///   userIdentity: {
        ///     username: string,
        ///     autoUser: {
        ///       scope: AutoUserScope,
        ///       elevationLevel: ElevationLevel
        ///     }
        ///   },
        ///   executionInfo: {
        ///     startTime: string (ISO 8601 Format),
        ///     endTime: string (ISO 8601 Format),
        ///     exitCode: number,
        ///     containerInfo: {
        ///       containerId: string,
        ///       state: string,
        ///       error: string
        ///     },
        ///     failureInfo: {
        ///       category: ErrorCategory (required),
        ///       code: string,
        ///       message: string,
        ///       details: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ]
        ///     },
        ///     retryCount: number (required),
        ///     lastRetryTime: string (ISO 8601 Format),
        ///     requeueCount: number (required),
        ///     lastRequeueTime: string (ISO 8601 Format),
        ///     result: TaskExecutionResult
        ///   },
        ///   nodeInfo: {
        ///     affinityId: string,
        ///     nodeUrl: string,
        ///     poolId: string,
        ///     nodeId: string,
        ///     taskRootDirectory: string,
        ///     taskRootDirectoryUrl: string
        ///   },
        ///   multiInstanceSettings: {
        ///     numberOfInstances: number,
        ///     coordinationCommandLine: string (required),
        ///     commonResourceFiles: [ResourceFile]
        ///   },
        ///   stats: {
        ///     url: string (required),
        ///     startTime: string (ISO 8601 Format) (required),
        ///     lastUpdateTime: string (ISO 8601 Format) (required),
        ///     userCPUTime: TaskStatisticsUserCPUTime (required),
        ///     kernelCPUTime: TaskStatisticsKernelCPUTime (required),
        ///     wallClockTime: TaskStatisticsWallClockTime (required),
        ///     readIOps: number (required),
        ///     writeIOps: number (required),
        ///     readIOGiB: number (required),
        ///     writeIOGiB: number (required),
        ///     waitTime: TaskStatisticsWaitTime (required)
        ///   },
        ///   dependsOn: {
        ///     taskIds: [string],
        ///     taskIdRanges: [
        ///       {
        ///         start: number (required),
        ///         end: number (required)
        ///       }
        ///     ]
        ///   },
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ],
        ///   authenticationTokenSettings: {
        ///     access: [AccessScope]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Add(string jobId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Add");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddRequest(jobId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the same order the Tasks were submitted in this request. If the server times out or the connection is closed during the request, the request may have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded, the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: string,
        ///       displayName: string,
        ///       url: string,
        ///       eTag: string,
        ///       lastModified: string (ISO 8601 Format),
        ///       creationTime: string (ISO 8601 Format),
        ///       exitConditions: {
        ///         exitCodes: [
        ///           {
        ///             code: number (required),
        ///             exitOptions: {
        ///               jobAction: JobAction,
        ///               dependencyAction: DependencyAction
        ///             } (required)
        ///           }
        ///         ],
        ///         exitCodeRanges: [
        ///           {
        ///             start: number (required),
        ///             end: number (required),
        ///             exitOptions: ExitOptions (required)
        ///           }
        ///         ],
        ///         preProcessingError: ExitOptions,
        ///         fileUploadError: ExitOptions,
        ///         default: ExitOptions
        ///       },
        ///       state: TaskState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       previousState: TaskState,
        ///       previousStateTransitionTime: string (ISO 8601 Format),
        ///       commandLine: string,
        ///       containerSettings: {
        ///         containerRunOptions: string,
        ///         imageName: string (required),
        ///         registry: {
        ///           username: string,
        ///           password: string,
        ///           registryServer: string,
        ///           identityReference: {
        ///             resourceId: string
        ///           }
        ///         },
        ///         workingDirectory: ContainerWorkingDirectory
        ///       },
        ///       resourceFiles: [
        ///         {
        ///           autoStorageContainerName: string,
        ///           storageContainerUrl: string,
        ///           httpUrl: string,
        ///           blobPrefix: string,
        ///           filePath: string,
        ///           fileMode: string,
        ///           identityReference: ComputeNodeIdentityReference
        ///         }
        ///       ],
        ///       outputFiles: [
        ///         {
        ///           filePattern: string (required),
        ///           destination: {
        ///             container: {
        ///               path: string,
        ///               containerUrl: string (required),
        ///               identityReference: ComputeNodeIdentityReference,
        ///               uploadHeaders: [
        ///                 {
        ///                   name: string (required),
        ///                   value: string
        ///                 }
        ///               ]
        ///             }
        ///           } (required),
        ///           uploadOptions: {
        ///             uploadCondition: OutputFileUploadCondition (required)
        ///           } (required)
        ///         }
        ///       ],
        ///       environmentSettings: [
        ///         {
        ///           name: string (required),
        ///           value: string
        ///         }
        ///       ],
        ///       affinityInfo: {
        ///         affinityId: string (required)
        ///       },
        ///       constraints: {
        ///         maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///         retentionTime: TaskConstraintsRetentionTime,
        ///         maxTaskRetryCount: number
        ///       },
        ///       requiredSlots: number,
        ///       userIdentity: {
        ///         username: string,
        ///         autoUser: {
        ///           scope: AutoUserScope,
        ///           elevationLevel: ElevationLevel
        ///         }
        ///       },
        ///       executionInfo: {
        ///         startTime: string (ISO 8601 Format),
        ///         endTime: string (ISO 8601 Format),
        ///         exitCode: number,
        ///         containerInfo: {
        ///           containerId: string,
        ///           state: string,
        ///           error: string
        ///         },
        ///         failureInfo: {
        ///           category: ErrorCategory (required),
        ///           code: string,
        ///           message: string,
        ///           details: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         },
        ///         retryCount: number (required),
        ///         lastRetryTime: string (ISO 8601 Format),
        ///         requeueCount: number (required),
        ///         lastRequeueTime: string (ISO 8601 Format),
        ///         result: TaskExecutionResult
        ///       },
        ///       nodeInfo: {
        ///         affinityId: string,
        ///         nodeUrl: string,
        ///         poolId: string,
        ///         nodeId: string,
        ///         taskRootDirectory: string,
        ///         taskRootDirectoryUrl: string
        ///       },
        ///       multiInstanceSettings: {
        ///         numberOfInstances: number,
        ///         coordinationCommandLine: string (required),
        ///         commonResourceFiles: [ResourceFile]
        ///       },
        ///       stats: {
        ///         url: string (required),
        ///         startTime: string (ISO 8601 Format) (required),
        ///         lastUpdateTime: string (ISO 8601 Format) (required),
        ///         userCPUTime: TaskStatisticsUserCPUTime (required),
        ///         kernelCPUTime: TaskStatisticsKernelCPUTime (required),
        ///         wallClockTime: TaskStatisticsWallClockTime (required),
        ///         readIOps: number (required),
        ///         writeIOps: number (required),
        ///         readIOGiB: number (required),
        ///         writeIOGiB: number (required),
        ///         waitTime: TaskStatisticsWaitTime (required)
        ///       },
        ///       dependsOn: {
        ///         taskIds: [string],
        ///         taskIdRanges: [
        ///           {
        ///             start: number (required),
        ///             end: number (required)
        ///           }
        ///         ]
        ///       },
        ///       applicationPackageReferences: [
        ///         {
        ///           applicationId: string (required),
        ///           version: string
        ///         }
        ///       ],
        ///       authenticationTokenSettings: {
        ///         access: [AccessScope]
        ///       }
        ///     }
        ///   ] (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       status: TaskAddStatus,
        ///       taskId: string,
        ///       eTag: string,
        ///       lastModified: string (ISO 8601 Format),
        ///       location: string,
        ///       error: {
        ///         code: string,
        ///         message: {
        ///           lang: string,
        ///           value: string
        ///         },
        ///         values: [
        ///           {
        ///             key: string,
        ///             value: string
        ///           }
        ///         ]
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AddCollectionAsync(string jobId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.AddCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddCollectionRequest(jobId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Note that each Task must have a unique ID. The Batch service may not return the results for each Task in the same order the Tasks were submitted in this request. If the server times out or the connection is closed during the request, the request may have been partially or fully processed, or not at all. In such cases, the user should re-issue the request. Note that it is up to the user to correctly handle failures when re-issuing a request. For example, you should use the same Task IDs during a retry so that if the prior operation succeeded, the retry will not create extra Tasks unexpectedly. If the response contains any Tasks which failed to add, a client can retry the request. In a retry, it is most efficient to resubmit only Tasks that failed to add, and to omit Tasks that were successfully added on the first attempt. The maximum lifetime of a Task from addition to completion is 180 days. If a Task has not completed within 180 days of being added it will be terminated by the Batch service and left in whatever state it was in at that time. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: string,
        ///       displayName: string,
        ///       url: string,
        ///       eTag: string,
        ///       lastModified: string (ISO 8601 Format),
        ///       creationTime: string (ISO 8601 Format),
        ///       exitConditions: {
        ///         exitCodes: [
        ///           {
        ///             code: number (required),
        ///             exitOptions: {
        ///               jobAction: JobAction,
        ///               dependencyAction: DependencyAction
        ///             } (required)
        ///           }
        ///         ],
        ///         exitCodeRanges: [
        ///           {
        ///             start: number (required),
        ///             end: number (required),
        ///             exitOptions: ExitOptions (required)
        ///           }
        ///         ],
        ///         preProcessingError: ExitOptions,
        ///         fileUploadError: ExitOptions,
        ///         default: ExitOptions
        ///       },
        ///       state: TaskState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       previousState: TaskState,
        ///       previousStateTransitionTime: string (ISO 8601 Format),
        ///       commandLine: string,
        ///       containerSettings: {
        ///         containerRunOptions: string,
        ///         imageName: string (required),
        ///         registry: {
        ///           username: string,
        ///           password: string,
        ///           registryServer: string,
        ///           identityReference: {
        ///             resourceId: string
        ///           }
        ///         },
        ///         workingDirectory: ContainerWorkingDirectory
        ///       },
        ///       resourceFiles: [
        ///         {
        ///           autoStorageContainerName: string,
        ///           storageContainerUrl: string,
        ///           httpUrl: string,
        ///           blobPrefix: string,
        ///           filePath: string,
        ///           fileMode: string,
        ///           identityReference: ComputeNodeIdentityReference
        ///         }
        ///       ],
        ///       outputFiles: [
        ///         {
        ///           filePattern: string (required),
        ///           destination: {
        ///             container: {
        ///               path: string,
        ///               containerUrl: string (required),
        ///               identityReference: ComputeNodeIdentityReference,
        ///               uploadHeaders: [
        ///                 {
        ///                   name: string (required),
        ///                   value: string
        ///                 }
        ///               ]
        ///             }
        ///           } (required),
        ///           uploadOptions: {
        ///             uploadCondition: OutputFileUploadCondition (required)
        ///           } (required)
        ///         }
        ///       ],
        ///       environmentSettings: [
        ///         {
        ///           name: string (required),
        ///           value: string
        ///         }
        ///       ],
        ///       affinityInfo: {
        ///         affinityId: string (required)
        ///       },
        ///       constraints: {
        ///         maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///         retentionTime: TaskConstraintsRetentionTime,
        ///         maxTaskRetryCount: number
        ///       },
        ///       requiredSlots: number,
        ///       userIdentity: {
        ///         username: string,
        ///         autoUser: {
        ///           scope: AutoUserScope,
        ///           elevationLevel: ElevationLevel
        ///         }
        ///       },
        ///       executionInfo: {
        ///         startTime: string (ISO 8601 Format),
        ///         endTime: string (ISO 8601 Format),
        ///         exitCode: number,
        ///         containerInfo: {
        ///           containerId: string,
        ///           state: string,
        ///           error: string
        ///         },
        ///         failureInfo: {
        ///           category: ErrorCategory (required),
        ///           code: string,
        ///           message: string,
        ///           details: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         },
        ///         retryCount: number (required),
        ///         lastRetryTime: string (ISO 8601 Format),
        ///         requeueCount: number (required),
        ///         lastRequeueTime: string (ISO 8601 Format),
        ///         result: TaskExecutionResult
        ///       },
        ///       nodeInfo: {
        ///         affinityId: string,
        ///         nodeUrl: string,
        ///         poolId: string,
        ///         nodeId: string,
        ///         taskRootDirectory: string,
        ///         taskRootDirectoryUrl: string
        ///       },
        ///       multiInstanceSettings: {
        ///         numberOfInstances: number,
        ///         coordinationCommandLine: string (required),
        ///         commonResourceFiles: [ResourceFile]
        ///       },
        ///       stats: {
        ///         url: string (required),
        ///         startTime: string (ISO 8601 Format) (required),
        ///         lastUpdateTime: string (ISO 8601 Format) (required),
        ///         userCPUTime: TaskStatisticsUserCPUTime (required),
        ///         kernelCPUTime: TaskStatisticsKernelCPUTime (required),
        ///         wallClockTime: TaskStatisticsWallClockTime (required),
        ///         readIOps: number (required),
        ///         writeIOps: number (required),
        ///         readIOGiB: number (required),
        ///         writeIOGiB: number (required),
        ///         waitTime: TaskStatisticsWaitTime (required)
        ///       },
        ///       dependsOn: {
        ///         taskIds: [string],
        ///         taskIdRanges: [
        ///           {
        ///             start: number (required),
        ///             end: number (required)
        ///           }
        ///         ]
        ///       },
        ///       applicationPackageReferences: [
        ///         {
        ///           applicationId: string (required),
        ///           version: string
        ///         }
        ///       ],
        ///       authenticationTokenSettings: {
        ///         access: [AccessScope]
        ///       }
        ///     }
        ///   ] (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       status: TaskAddStatus,
        ///       taskId: string,
        ///       eTag: string,
        ///       lastModified: string (ISO 8601 Format),
        ///       location: string,
        ///       error: {
        ///         code: string,
        ///         message: {
        ///           lang: string,
        ///           value: string
        ///         },
        ///         values: [
        ///           {
        ///             key: string,
        ///             value: string
        ///           }
        ///         ]
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AddCollection(string jobId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.AddCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddCollectionRequest(jobId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to the primary task; subtasks and their files are then deleted asynchronously in the background. </summary>
        /// <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        /// <param name="taskId"> The ID of the Task to delete. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteAsync(string jobId, string taskId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(jobId, taskId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When a Task is deleted, all of the files in its directory on the Compute Node where it ran are also deleted (regardless of the retention time). For multi-instance Tasks, the delete Task operation applies synchronously to the primary task; subtasks and their files are then deleted asynchronously in the background. </summary>
        /// <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        /// <param name="taskId"> The ID of the Task to delete. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Delete(string jobId, string taskId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(jobId, taskId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   id: string,
        ///   displayName: string,
        ///   url: string,
        ///   eTag: string,
        ///   lastModified: string (ISO 8601 Format),
        ///   creationTime: string (ISO 8601 Format),
        ///   exitConditions: {
        ///     exitCodes: [
        ///       {
        ///         code: number,
        ///         exitOptions: {
        ///           jobAction: JobAction,
        ///           dependencyAction: DependencyAction
        ///         }
        ///       }
        ///     ],
        ///     exitCodeRanges: [
        ///       {
        ///         start: number,
        ///         end: number,
        ///         exitOptions: ExitOptions
        ///       }
        ///     ],
        ///     preProcessingError: ExitOptions,
        ///     fileUploadError: ExitOptions,
        ///     default: ExitOptions
        ///   },
        ///   state: TaskState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   previousState: TaskState,
        ///   previousStateTransitionTime: string (ISO 8601 Format),
        ///   commandLine: string,
        ///   containerSettings: {
        ///     containerRunOptions: string,
        ///     imageName: string,
        ///     registry: {
        ///       username: string,
        ///       password: string,
        ///       registryServer: string,
        ///       identityReference: {
        ///         resourceId: string
        ///       }
        ///     },
        ///     workingDirectory: ContainerWorkingDirectory
        ///   },
        ///   resourceFiles: [
        ///     {
        ///       autoStorageContainerName: string,
        ///       storageContainerUrl: string,
        ///       httpUrl: string,
        ///       blobPrefix: string,
        ///       filePath: string,
        ///       fileMode: string,
        ///       identityReference: ComputeNodeIdentityReference
        ///     }
        ///   ],
        ///   outputFiles: [
        ///     {
        ///       filePattern: string,
        ///       destination: {
        ///         container: {
        ///           path: string,
        ///           containerUrl: string,
        ///           identityReference: ComputeNodeIdentityReference,
        ///           uploadHeaders: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         }
        ///       },
        ///       uploadOptions: {
        ///         uploadCondition: OutputFileUploadCondition
        ///       }
        ///     }
        ///   ],
        ///   environmentSettings: [
        ///     {
        ///       name: string,
        ///       value: string
        ///     }
        ///   ],
        ///   affinityInfo: {
        ///     affinityId: string
        ///   },
        ///   constraints: {
        ///     maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///     retentionTime: TaskConstraintsRetentionTime,
        ///     maxTaskRetryCount: number
        ///   },
        ///   requiredSlots: number,
        ///   userIdentity: {
        ///     username: string,
        ///     autoUser: {
        ///       scope: AutoUserScope,
        ///       elevationLevel: ElevationLevel
        ///     }
        ///   },
        ///   executionInfo: {
        ///     startTime: string (ISO 8601 Format),
        ///     endTime: string (ISO 8601 Format),
        ///     exitCode: number,
        ///     containerInfo: {
        ///       containerId: string,
        ///       state: string,
        ///       error: string
        ///     },
        ///     failureInfo: {
        ///       category: ErrorCategory,
        ///       code: string,
        ///       message: string,
        ///       details: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ]
        ///     },
        ///     retryCount: number,
        ///     lastRetryTime: string (ISO 8601 Format),
        ///     requeueCount: number,
        ///     lastRequeueTime: string (ISO 8601 Format),
        ///     result: TaskExecutionResult
        ///   },
        ///   nodeInfo: {
        ///     affinityId: string,
        ///     nodeUrl: string,
        ///     poolId: string,
        ///     nodeId: string,
        ///     taskRootDirectory: string,
        ///     taskRootDirectoryUrl: string
        ///   },
        ///   multiInstanceSettings: {
        ///     numberOfInstances: number,
        ///     coordinationCommandLine: string,
        ///     commonResourceFiles: [ResourceFile]
        ///   },
        ///   stats: {
        ///     url: string,
        ///     startTime: string (ISO 8601 Format),
        ///     lastUpdateTime: string (ISO 8601 Format),
        ///     userCPUTime: TaskStatisticsUserCPUTime,
        ///     kernelCPUTime: TaskStatisticsKernelCPUTime,
        ///     wallClockTime: TaskStatisticsWallClockTime,
        ///     readIOps: number,
        ///     writeIOps: number,
        ///     readIOGiB: number,
        ///     writeIOGiB: number,
        ///     waitTime: TaskStatisticsWaitTime
        ///   },
        ///   dependsOn: {
        ///     taskIds: [string],
        ///     taskIdRanges: [
        ///       {
        ///         start: number,
        ///         end: number
        ///       }
        ///     ]
        ///   },
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string,
        ///       version: string
        ///     }
        ///   ],
        ///   authenticationTokenSettings: {
        ///     access: [AccessScope]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTaskAsync(string jobId, string taskId, string select = null, string expand = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.GetTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskRequest(jobId, taskId, select, expand, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   id: string,
        ///   displayName: string,
        ///   url: string,
        ///   eTag: string,
        ///   lastModified: string (ISO 8601 Format),
        ///   creationTime: string (ISO 8601 Format),
        ///   exitConditions: {
        ///     exitCodes: [
        ///       {
        ///         code: number,
        ///         exitOptions: {
        ///           jobAction: JobAction,
        ///           dependencyAction: DependencyAction
        ///         }
        ///       }
        ///     ],
        ///     exitCodeRanges: [
        ///       {
        ///         start: number,
        ///         end: number,
        ///         exitOptions: ExitOptions
        ///       }
        ///     ],
        ///     preProcessingError: ExitOptions,
        ///     fileUploadError: ExitOptions,
        ///     default: ExitOptions
        ///   },
        ///   state: TaskState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   previousState: TaskState,
        ///   previousStateTransitionTime: string (ISO 8601 Format),
        ///   commandLine: string,
        ///   containerSettings: {
        ///     containerRunOptions: string,
        ///     imageName: string,
        ///     registry: {
        ///       username: string,
        ///       password: string,
        ///       registryServer: string,
        ///       identityReference: {
        ///         resourceId: string
        ///       }
        ///     },
        ///     workingDirectory: ContainerWorkingDirectory
        ///   },
        ///   resourceFiles: [
        ///     {
        ///       autoStorageContainerName: string,
        ///       storageContainerUrl: string,
        ///       httpUrl: string,
        ///       blobPrefix: string,
        ///       filePath: string,
        ///       fileMode: string,
        ///       identityReference: ComputeNodeIdentityReference
        ///     }
        ///   ],
        ///   outputFiles: [
        ///     {
        ///       filePattern: string,
        ///       destination: {
        ///         container: {
        ///           path: string,
        ///           containerUrl: string,
        ///           identityReference: ComputeNodeIdentityReference,
        ///           uploadHeaders: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         }
        ///       },
        ///       uploadOptions: {
        ///         uploadCondition: OutputFileUploadCondition
        ///       }
        ///     }
        ///   ],
        ///   environmentSettings: [
        ///     {
        ///       name: string,
        ///       value: string
        ///     }
        ///   ],
        ///   affinityInfo: {
        ///     affinityId: string
        ///   },
        ///   constraints: {
        ///     maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///     retentionTime: TaskConstraintsRetentionTime,
        ///     maxTaskRetryCount: number
        ///   },
        ///   requiredSlots: number,
        ///   userIdentity: {
        ///     username: string,
        ///     autoUser: {
        ///       scope: AutoUserScope,
        ///       elevationLevel: ElevationLevel
        ///     }
        ///   },
        ///   executionInfo: {
        ///     startTime: string (ISO 8601 Format),
        ///     endTime: string (ISO 8601 Format),
        ///     exitCode: number,
        ///     containerInfo: {
        ///       containerId: string,
        ///       state: string,
        ///       error: string
        ///     },
        ///     failureInfo: {
        ///       category: ErrorCategory,
        ///       code: string,
        ///       message: string,
        ///       details: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ]
        ///     },
        ///     retryCount: number,
        ///     lastRetryTime: string (ISO 8601 Format),
        ///     requeueCount: number,
        ///     lastRequeueTime: string (ISO 8601 Format),
        ///     result: TaskExecutionResult
        ///   },
        ///   nodeInfo: {
        ///     affinityId: string,
        ///     nodeUrl: string,
        ///     poolId: string,
        ///     nodeId: string,
        ///     taskRootDirectory: string,
        ///     taskRootDirectoryUrl: string
        ///   },
        ///   multiInstanceSettings: {
        ///     numberOfInstances: number,
        ///     coordinationCommandLine: string,
        ///     commonResourceFiles: [ResourceFile]
        ///   },
        ///   stats: {
        ///     url: string,
        ///     startTime: string (ISO 8601 Format),
        ///     lastUpdateTime: string (ISO 8601 Format),
        ///     userCPUTime: TaskStatisticsUserCPUTime,
        ///     kernelCPUTime: TaskStatisticsKernelCPUTime,
        ///     wallClockTime: TaskStatisticsWallClockTime,
        ///     readIOps: number,
        ///     writeIOps: number,
        ///     readIOGiB: number,
        ///     writeIOGiB: number,
        ///     waitTime: TaskStatisticsWaitTime
        ///   },
        ///   dependsOn: {
        ///     taskIds: [string],
        ///     taskIdRanges: [
        ///       {
        ///         start: number,
        ///         end: number
        ///       }
        ///     ]
        ///   },
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string,
        ///       version: string
        ///     }
        ///   ],
        ///   authenticationTokenSettings: {
        ///     access: [AccessScope]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTask(string jobId, string taskId, string select = null, string expand = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.GetTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskRequest(jobId, taskId, select, expand, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the properties of the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   id: string,
        ///   displayName: string,
        ///   url: string,
        ///   eTag: string,
        ///   lastModified: string (ISO 8601 Format),
        ///   creationTime: string (ISO 8601 Format),
        ///   exitConditions: {
        ///     exitCodes: [
        ///       {
        ///         code: number (required),
        ///         exitOptions: {
        ///           jobAction: JobAction,
        ///           dependencyAction: DependencyAction
        ///         } (required)
        ///       }
        ///     ],
        ///     exitCodeRanges: [
        ///       {
        ///         start: number (required),
        ///         end: number (required),
        ///         exitOptions: ExitOptions (required)
        ///       }
        ///     ],
        ///     preProcessingError: ExitOptions,
        ///     fileUploadError: ExitOptions,
        ///     default: ExitOptions
        ///   },
        ///   state: TaskState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   previousState: TaskState,
        ///   previousStateTransitionTime: string (ISO 8601 Format),
        ///   commandLine: string,
        ///   containerSettings: {
        ///     containerRunOptions: string,
        ///     imageName: string (required),
        ///     registry: {
        ///       username: string,
        ///       password: string,
        ///       registryServer: string,
        ///       identityReference: {
        ///         resourceId: string
        ///       }
        ///     },
        ///     workingDirectory: ContainerWorkingDirectory
        ///   },
        ///   resourceFiles: [
        ///     {
        ///       autoStorageContainerName: string,
        ///       storageContainerUrl: string,
        ///       httpUrl: string,
        ///       blobPrefix: string,
        ///       filePath: string,
        ///       fileMode: string,
        ///       identityReference: ComputeNodeIdentityReference
        ///     }
        ///   ],
        ///   outputFiles: [
        ///     {
        ///       filePattern: string (required),
        ///       destination: {
        ///         container: {
        ///           path: string,
        ///           containerUrl: string (required),
        ///           identityReference: ComputeNodeIdentityReference,
        ///           uploadHeaders: [
        ///             {
        ///               name: string (required),
        ///               value: string
        ///             }
        ///           ]
        ///         }
        ///       } (required),
        ///       uploadOptions: {
        ///         uploadCondition: OutputFileUploadCondition (required)
        ///       } (required)
        ///     }
        ///   ],
        ///   environmentSettings: [
        ///     {
        ///       name: string (required),
        ///       value: string
        ///     }
        ///   ],
        ///   affinityInfo: {
        ///     affinityId: string (required)
        ///   },
        ///   constraints: {
        ///     maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///     retentionTime: TaskConstraintsRetentionTime,
        ///     maxTaskRetryCount: number
        ///   },
        ///   requiredSlots: number,
        ///   userIdentity: {
        ///     username: string,
        ///     autoUser: {
        ///       scope: AutoUserScope,
        ///       elevationLevel: ElevationLevel
        ///     }
        ///   },
        ///   executionInfo: {
        ///     startTime: string (ISO 8601 Format),
        ///     endTime: string (ISO 8601 Format),
        ///     exitCode: number,
        ///     containerInfo: {
        ///       containerId: string,
        ///       state: string,
        ///       error: string
        ///     },
        ///     failureInfo: {
        ///       category: ErrorCategory (required),
        ///       code: string,
        ///       message: string,
        ///       details: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ]
        ///     },
        ///     retryCount: number (required),
        ///     lastRetryTime: string (ISO 8601 Format),
        ///     requeueCount: number (required),
        ///     lastRequeueTime: string (ISO 8601 Format),
        ///     result: TaskExecutionResult
        ///   },
        ///   nodeInfo: {
        ///     affinityId: string,
        ///     nodeUrl: string,
        ///     poolId: string,
        ///     nodeId: string,
        ///     taskRootDirectory: string,
        ///     taskRootDirectoryUrl: string
        ///   },
        ///   multiInstanceSettings: {
        ///     numberOfInstances: number,
        ///     coordinationCommandLine: string (required),
        ///     commonResourceFiles: [ResourceFile]
        ///   },
        ///   stats: {
        ///     url: string (required),
        ///     startTime: string (ISO 8601 Format) (required),
        ///     lastUpdateTime: string (ISO 8601 Format) (required),
        ///     userCPUTime: TaskStatisticsUserCPUTime (required),
        ///     kernelCPUTime: TaskStatisticsKernelCPUTime (required),
        ///     wallClockTime: TaskStatisticsWallClockTime (required),
        ///     readIOps: number (required),
        ///     writeIOps: number (required),
        ///     readIOGiB: number (required),
        ///     writeIOGiB: number (required),
        ///     waitTime: TaskStatisticsWaitTime (required)
        ///   },
        ///   dependsOn: {
        ///     taskIds: [string],
        ///     taskIdRanges: [
        ///       {
        ///         start: number (required),
        ///         end: number (required)
        ///       }
        ///     ]
        ///   },
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ],
        ///   authenticationTokenSettings: {
        ///     access: [AccessScope]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateAsync(string jobId, string taskId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(jobId, taskId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the properties of the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   id: string,
        ///   displayName: string,
        ///   url: string,
        ///   eTag: string,
        ///   lastModified: string (ISO 8601 Format),
        ///   creationTime: string (ISO 8601 Format),
        ///   exitConditions: {
        ///     exitCodes: [
        ///       {
        ///         code: number (required),
        ///         exitOptions: {
        ///           jobAction: JobAction,
        ///           dependencyAction: DependencyAction
        ///         } (required)
        ///       }
        ///     ],
        ///     exitCodeRanges: [
        ///       {
        ///         start: number (required),
        ///         end: number (required),
        ///         exitOptions: ExitOptions (required)
        ///       }
        ///     ],
        ///     preProcessingError: ExitOptions,
        ///     fileUploadError: ExitOptions,
        ///     default: ExitOptions
        ///   },
        ///   state: TaskState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   previousState: TaskState,
        ///   previousStateTransitionTime: string (ISO 8601 Format),
        ///   commandLine: string,
        ///   containerSettings: {
        ///     containerRunOptions: string,
        ///     imageName: string (required),
        ///     registry: {
        ///       username: string,
        ///       password: string,
        ///       registryServer: string,
        ///       identityReference: {
        ///         resourceId: string
        ///       }
        ///     },
        ///     workingDirectory: ContainerWorkingDirectory
        ///   },
        ///   resourceFiles: [
        ///     {
        ///       autoStorageContainerName: string,
        ///       storageContainerUrl: string,
        ///       httpUrl: string,
        ///       blobPrefix: string,
        ///       filePath: string,
        ///       fileMode: string,
        ///       identityReference: ComputeNodeIdentityReference
        ///     }
        ///   ],
        ///   outputFiles: [
        ///     {
        ///       filePattern: string (required),
        ///       destination: {
        ///         container: {
        ///           path: string,
        ///           containerUrl: string (required),
        ///           identityReference: ComputeNodeIdentityReference,
        ///           uploadHeaders: [
        ///             {
        ///               name: string (required),
        ///               value: string
        ///             }
        ///           ]
        ///         }
        ///       } (required),
        ///       uploadOptions: {
        ///         uploadCondition: OutputFileUploadCondition (required)
        ///       } (required)
        ///     }
        ///   ],
        ///   environmentSettings: [
        ///     {
        ///       name: string (required),
        ///       value: string
        ///     }
        ///   ],
        ///   affinityInfo: {
        ///     affinityId: string (required)
        ///   },
        ///   constraints: {
        ///     maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///     retentionTime: TaskConstraintsRetentionTime,
        ///     maxTaskRetryCount: number
        ///   },
        ///   requiredSlots: number,
        ///   userIdentity: {
        ///     username: string,
        ///     autoUser: {
        ///       scope: AutoUserScope,
        ///       elevationLevel: ElevationLevel
        ///     }
        ///   },
        ///   executionInfo: {
        ///     startTime: string (ISO 8601 Format),
        ///     endTime: string (ISO 8601 Format),
        ///     exitCode: number,
        ///     containerInfo: {
        ///       containerId: string,
        ///       state: string,
        ///       error: string
        ///     },
        ///     failureInfo: {
        ///       category: ErrorCategory (required),
        ///       code: string,
        ///       message: string,
        ///       details: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ]
        ///     },
        ///     retryCount: number (required),
        ///     lastRetryTime: string (ISO 8601 Format),
        ///     requeueCount: number (required),
        ///     lastRequeueTime: string (ISO 8601 Format),
        ///     result: TaskExecutionResult
        ///   },
        ///   nodeInfo: {
        ///     affinityId: string,
        ///     nodeUrl: string,
        ///     poolId: string,
        ///     nodeId: string,
        ///     taskRootDirectory: string,
        ///     taskRootDirectoryUrl: string
        ///   },
        ///   multiInstanceSettings: {
        ///     numberOfInstances: number,
        ///     coordinationCommandLine: string (required),
        ///     commonResourceFiles: [ResourceFile]
        ///   },
        ///   stats: {
        ///     url: string (required),
        ///     startTime: string (ISO 8601 Format) (required),
        ///     lastUpdateTime: string (ISO 8601 Format) (required),
        ///     userCPUTime: TaskStatisticsUserCPUTime (required),
        ///     kernelCPUTime: TaskStatisticsKernelCPUTime (required),
        ///     wallClockTime: TaskStatisticsWallClockTime (required),
        ///     readIOps: number (required),
        ///     writeIOps: number (required),
        ///     readIOGiB: number (required),
        ///     writeIOGiB: number (required),
        ///     waitTime: TaskStatisticsWaitTime (required)
        ///   },
        ///   dependsOn: {
        ///     taskIds: [string],
        ///     taskIdRanges: [
        ///       {
        ///         start: number (required),
        ///         end: number (required)
        ///       }
        ///     ]
        ///   },
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ],
        ///   authenticationTokenSettings: {
        ///     access: [AccessScope]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Update(string jobId, string taskId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(jobId, taskId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> If the Task is not a multi-instance Task then this returns an empty collection. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: number,
        ///       nodeInfo: {
        ///         affinityId: string,
        ///         nodeUrl: string,
        ///         poolId: string,
        ///         nodeId: string,
        ///         taskRootDirectory: string,
        ///         taskRootDirectoryUrl: string
        ///       },
        ///       startTime: string (ISO 8601 Format),
        ///       endTime: string (ISO 8601 Format),
        ///       exitCode: number,
        ///       containerInfo: {
        ///         containerId: string,
        ///         state: string,
        ///         error: string
        ///       },
        ///       failureInfo: {
        ///         category: ErrorCategory,
        ///         code: string,
        ///         message: string,
        ///         details: [
        ///           {
        ///             name: string,
        ///             value: string
        ///           }
        ///         ]
        ///       },
        ///       state: SubtaskState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       previousState: SubtaskState,
        ///       previousStateTransitionTime: string (ISO 8601 Format),
        ///       result: TaskExecutionResult
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSubtasksAsync(string jobId, string taskId, string select = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.GetSubtasks");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSubtasksRequest(jobId, taskId, select, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> If the Task is not a multi-instance Task then this returns an empty collection. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: number,
        ///       nodeInfo: {
        ///         affinityId: string,
        ///         nodeUrl: string,
        ///         poolId: string,
        ///         nodeId: string,
        ///         taskRootDirectory: string,
        ///         taskRootDirectoryUrl: string
        ///       },
        ///       startTime: string (ISO 8601 Format),
        ///       endTime: string (ISO 8601 Format),
        ///       exitCode: number,
        ///       containerInfo: {
        ///         containerId: string,
        ///         state: string,
        ///         error: string
        ///       },
        ///       failureInfo: {
        ///         category: ErrorCategory,
        ///         code: string,
        ///         message: string,
        ///         details: [
        ///           {
        ///             name: string,
        ///             value: string
        ///           }
        ///         ]
        ///       },
        ///       state: SubtaskState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       previousState: SubtaskState,
        ///       previousStateTransitionTime: string (ISO 8601 Format),
        ///       result: TaskExecutionResult
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSubtasks(string jobId, string taskId, string select = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.GetSubtasks");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSubtasksRequest(jobId, taskId, select, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the background. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to terminate. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> TerminateAsync(string jobId, string taskId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Terminate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTerminateRequest(jobId, taskId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When the Task has been terminated, it moves to the completed state. For multi-instance Tasks, the terminate Task operation applies synchronously to the primary task; subtasks are then terminated asynchronously in the background. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to terminate. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Terminate(string jobId, string taskId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Terminate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTerminateRequest(jobId, taskId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task&apos;s state is changed to active. As the Task is no longer in the completed state, any previous exit code or failure information is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0. Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting). </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to reactivate. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> ReactivateAsync(string jobId, string taskId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Reactivate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReactivateRequest(jobId, taskId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Reactivation makes a Task eligible to be retried again up to its maximum retry count. The Task&apos;s state is changed to active. As the Task is no longer in the completed state, any previous exit code or failure information is no longer available after reactivation. Each time a Task is reactivated, its retry count is reset to 0. Reactivation will fail for Tasks that are not completed or that previously completed successfully (with an exit code of 0). Additionally, it will fail if the Job has completed (or is terminating or deleting). </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to reactivate. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Reactivate(string jobId, string taskId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("TaskClient.Reactivate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReactivateRequest(jobId, taskId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Tasks can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: string,
        ///       displayName: string,
        ///       url: string,
        ///       eTag: string,
        ///       lastModified: string (ISO 8601 Format),
        ///       creationTime: string (ISO 8601 Format),
        ///       exitConditions: {
        ///         exitCodes: [
        ///           {
        ///             code: number,
        ///             exitOptions: {
        ///               jobAction: JobAction,
        ///               dependencyAction: DependencyAction
        ///             }
        ///           }
        ///         ],
        ///         exitCodeRanges: [
        ///           {
        ///             start: number,
        ///             end: number,
        ///             exitOptions: ExitOptions
        ///           }
        ///         ],
        ///         preProcessingError: ExitOptions,
        ///         fileUploadError: ExitOptions,
        ///         default: ExitOptions
        ///       },
        ///       state: TaskState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       previousState: TaskState,
        ///       previousStateTransitionTime: string (ISO 8601 Format),
        ///       commandLine: string,
        ///       containerSettings: {
        ///         containerRunOptions: string,
        ///         imageName: string,
        ///         registry: {
        ///           username: string,
        ///           password: string,
        ///           registryServer: string,
        ///           identityReference: {
        ///             resourceId: string
        ///           }
        ///         },
        ///         workingDirectory: ContainerWorkingDirectory
        ///       },
        ///       resourceFiles: [
        ///         {
        ///           autoStorageContainerName: string,
        ///           storageContainerUrl: string,
        ///           httpUrl: string,
        ///           blobPrefix: string,
        ///           filePath: string,
        ///           fileMode: string,
        ///           identityReference: ComputeNodeIdentityReference
        ///         }
        ///       ],
        ///       outputFiles: [
        ///         {
        ///           filePattern: string,
        ///           destination: {
        ///             container: {
        ///               path: string,
        ///               containerUrl: string,
        ///               identityReference: ComputeNodeIdentityReference,
        ///               uploadHeaders: [
        ///                 {
        ///                   name: string,
        ///                   value: string
        ///                 }
        ///               ]
        ///             }
        ///           },
        ///           uploadOptions: {
        ///             uploadCondition: OutputFileUploadCondition
        ///           }
        ///         }
        ///       ],
        ///       environmentSettings: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ],
        ///       affinityInfo: {
        ///         affinityId: string
        ///       },
        ///       constraints: {
        ///         maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///         retentionTime: TaskConstraintsRetentionTime,
        ///         maxTaskRetryCount: number
        ///       },
        ///       requiredSlots: number,
        ///       userIdentity: {
        ///         username: string,
        ///         autoUser: {
        ///           scope: AutoUserScope,
        ///           elevationLevel: ElevationLevel
        ///         }
        ///       },
        ///       executionInfo: {
        ///         startTime: string (ISO 8601 Format),
        ///         endTime: string (ISO 8601 Format),
        ///         exitCode: number,
        ///         containerInfo: {
        ///           containerId: string,
        ///           state: string,
        ///           error: string
        ///         },
        ///         failureInfo: {
        ///           category: ErrorCategory,
        ///           code: string,
        ///           message: string,
        ///           details: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         },
        ///         retryCount: number,
        ///         lastRetryTime: string (ISO 8601 Format),
        ///         requeueCount: number,
        ///         lastRequeueTime: string (ISO 8601 Format),
        ///         result: TaskExecutionResult
        ///       },
        ///       nodeInfo: {
        ///         affinityId: string,
        ///         nodeUrl: string,
        ///         poolId: string,
        ///         nodeId: string,
        ///         taskRootDirectory: string,
        ///         taskRootDirectoryUrl: string
        ///       },
        ///       multiInstanceSettings: {
        ///         numberOfInstances: number,
        ///         coordinationCommandLine: string,
        ///         commonResourceFiles: [ResourceFile]
        ///       },
        ///       stats: {
        ///         url: string,
        ///         startTime: string (ISO 8601 Format),
        ///         lastUpdateTime: string (ISO 8601 Format),
        ///         userCPUTime: TaskStatisticsUserCPUTime,
        ///         kernelCPUTime: TaskStatisticsKernelCPUTime,
        ///         wallClockTime: TaskStatisticsWallClockTime,
        ///         readIOps: number,
        ///         writeIOps: number,
        ///         readIOGiB: number,
        ///         writeIOGiB: number,
        ///         waitTime: TaskStatisticsWaitTime
        ///       },
        ///       dependsOn: {
        ///         taskIds: [string],
        ///         taskIdRanges: [
        ///           {
        ///             start: number,
        ///             end: number
        ///           }
        ///         ]
        ///       },
        ///       applicationPackageReferences: [
        ///         {
        ///           applicationId: string,
        ///           version: string
        ///         }
        ///       ],
        ///       authenticationTokenSettings: {
        ///         access: [AccessScope]
        ///       }
        ///     }
        ///   ],
        ///   odata.nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTasksAsync(string jobId, string filter = null, string select = null, string expand = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, "TaskClient.GetTasks");
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTasksRequest(jobId, filter, select, expand, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetTasksNextPageRequest(nextLink, jobId, filter, select, expand, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "odata.nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> For multi-instance Tasks, information such as affinityId, executionInfo and nodeInfo refer to the primary Task. Use the list subtasks API to retrieve information about subtasks. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Tasks can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: string,
        ///       displayName: string,
        ///       url: string,
        ///       eTag: string,
        ///       lastModified: string (ISO 8601 Format),
        ///       creationTime: string (ISO 8601 Format),
        ///       exitConditions: {
        ///         exitCodes: [
        ///           {
        ///             code: number,
        ///             exitOptions: {
        ///               jobAction: JobAction,
        ///               dependencyAction: DependencyAction
        ///             }
        ///           }
        ///         ],
        ///         exitCodeRanges: [
        ///           {
        ///             start: number,
        ///             end: number,
        ///             exitOptions: ExitOptions
        ///           }
        ///         ],
        ///         preProcessingError: ExitOptions,
        ///         fileUploadError: ExitOptions,
        ///         default: ExitOptions
        ///       },
        ///       state: TaskState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       previousState: TaskState,
        ///       previousStateTransitionTime: string (ISO 8601 Format),
        ///       commandLine: string,
        ///       containerSettings: {
        ///         containerRunOptions: string,
        ///         imageName: string,
        ///         registry: {
        ///           username: string,
        ///           password: string,
        ///           registryServer: string,
        ///           identityReference: {
        ///             resourceId: string
        ///           }
        ///         },
        ///         workingDirectory: ContainerWorkingDirectory
        ///       },
        ///       resourceFiles: [
        ///         {
        ///           autoStorageContainerName: string,
        ///           storageContainerUrl: string,
        ///           httpUrl: string,
        ///           blobPrefix: string,
        ///           filePath: string,
        ///           fileMode: string,
        ///           identityReference: ComputeNodeIdentityReference
        ///         }
        ///       ],
        ///       outputFiles: [
        ///         {
        ///           filePattern: string,
        ///           destination: {
        ///             container: {
        ///               path: string,
        ///               containerUrl: string,
        ///               identityReference: ComputeNodeIdentityReference,
        ///               uploadHeaders: [
        ///                 {
        ///                   name: string,
        ///                   value: string
        ///                 }
        ///               ]
        ///             }
        ///           },
        ///           uploadOptions: {
        ///             uploadCondition: OutputFileUploadCondition
        ///           }
        ///         }
        ///       ],
        ///       environmentSettings: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ],
        ///       affinityInfo: {
        ///         affinityId: string
        ///       },
        ///       constraints: {
        ///         maxWallClockTime: TaskConstraintsMaxWallClockTime,
        ///         retentionTime: TaskConstraintsRetentionTime,
        ///         maxTaskRetryCount: number
        ///       },
        ///       requiredSlots: number,
        ///       userIdentity: {
        ///         username: string,
        ///         autoUser: {
        ///           scope: AutoUserScope,
        ///           elevationLevel: ElevationLevel
        ///         }
        ///       },
        ///       executionInfo: {
        ///         startTime: string (ISO 8601 Format),
        ///         endTime: string (ISO 8601 Format),
        ///         exitCode: number,
        ///         containerInfo: {
        ///           containerId: string,
        ///           state: string,
        ///           error: string
        ///         },
        ///         failureInfo: {
        ///           category: ErrorCategory,
        ///           code: string,
        ///           message: string,
        ///           details: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         },
        ///         retryCount: number,
        ///         lastRetryTime: string (ISO 8601 Format),
        ///         requeueCount: number,
        ///         lastRequeueTime: string (ISO 8601 Format),
        ///         result: TaskExecutionResult
        ///       },
        ///       nodeInfo: {
        ///         affinityId: string,
        ///         nodeUrl: string,
        ///         poolId: string,
        ///         nodeId: string,
        ///         taskRootDirectory: string,
        ///         taskRootDirectoryUrl: string
        ///       },
        ///       multiInstanceSettings: {
        ///         numberOfInstances: number,
        ///         coordinationCommandLine: string,
        ///         commonResourceFiles: [ResourceFile]
        ///       },
        ///       stats: {
        ///         url: string,
        ///         startTime: string (ISO 8601 Format),
        ///         lastUpdateTime: string (ISO 8601 Format),
        ///         userCPUTime: TaskStatisticsUserCPUTime,
        ///         kernelCPUTime: TaskStatisticsKernelCPUTime,
        ///         wallClockTime: TaskStatisticsWallClockTime,
        ///         readIOps: number,
        ///         writeIOps: number,
        ///         readIOGiB: number,
        ///         writeIOGiB: number,
        ///         waitTime: TaskStatisticsWaitTime
        ///       },
        ///       dependsOn: {
        ///         taskIds: [string],
        ///         taskIdRanges: [
        ///           {
        ///             start: number,
        ///             end: number
        ///           }
        ///         ]
        ///       },
        ///       applicationPackageReferences: [
        ///         {
        ///           applicationId: string,
        ///           version: string
        ///         }
        ///       ],
        ///       authenticationTokenSettings: {
        ///         access: [AccessScope]
        ///       }
        ///     }
        ///   ],
        ///   odata.nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTasks(string jobId, string filter = null, string select = null, string expand = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, "TaskClient.GetTasks");
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTasksRequest(jobId, filter, select, expand, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetTasksNextPageRequest(nextLink, jobId, filter, select, expand, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "odata.nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        internal HttpMessage CreateAddRequest(string jobId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTasksRequest(string jobId, string filter, string select, string expand, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks", false);
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (expand != null)
            {
                uri.AppendQuery("$expand", expand, true);
            }
            if (maxResults != null)
            {
                uri.AppendQuery("maxresults", maxResults.Value, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddCollectionRequest(string jobId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/addtaskcollection", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string jobId, string taskId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetTaskRequest(string jobId, string taskId, string select, string expand, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (expand != null)
            {
                uri.AppendQuery("$expand", expand, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateUpdateRequest(string jobId, string taskId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSubtasksRequest(string jobId, string taskId, string select, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/subtasksinfo", false);
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTerminateRequest(string jobId, string taskId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/terminate", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateReactivateRequest(string jobId, string taskId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/reactivate", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetTasksNextPageRequest(string nextLink, string jobId, string filter, string select, string expand, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
