// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using Azure;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.Monitor;

namespace Azure.ResourceManager.Monitor.Models
{
    /// <summary> Model factory for generated models. </summary>
    public static partial class MonitorModelFactory
    {
        /// <summary> Initializes a new instance of AutoscaleSettingData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="profiles"> the collection of automatic scaling profiles that specify different scaling parameters for different time periods. A maximum of 20 profiles can be specified. </param>
        /// <param name="notifications"> the collection of notifications. </param>
        /// <param name="isEnabled"> the enabled flag. Specifies whether automatic scaling is enabled for the resource. The default value is &apos;false&apos;. </param>
        /// <param name="predictiveAutoscalePolicy"> the predictive autoscale policy mode. </param>
        /// <param name="autoscaleSettingName"> the name of the autoscale setting. </param>
        /// <param name="targetResourceId"> the resource identifier of the resource that the autoscale setting should be added to. </param>
        /// <param name="targetResourceLocation"> the location of the resource that the autoscale setting should be added to. </param>
        /// <returns> A new <see cref="Monitor.AutoscaleSettingData"/> instance for mocking. </returns>
        public static AutoscaleSettingData AutoscaleSettingData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, IEnumerable<AutoscaleProfile> profiles = null, IEnumerable<AutoscaleNotification> notifications = null, bool? isEnabled = null, PredictiveAutoscalePolicy predictiveAutoscalePolicy = null, string autoscaleSettingName = null, ResourceIdentifier targetResourceId = null, AzureLocation? targetResourceLocation = null)
        {
            tags ??= new Dictionary<string, string>();
            profiles ??= new List<AutoscaleProfile>();
            notifications ??= new List<AutoscaleNotification>();

            return new AutoscaleSettingData(id, name, resourceType, systemData, tags, location, profiles?.ToList(), notifications?.ToList(), isEnabled, predictiveAutoscalePolicy, autoscaleSettingName, targetResourceId, targetResourceLocation);
        }

        /// <summary> Initializes a new instance of AutoscaleProfile. </summary>
        /// <param name="name"> the name of the profile. </param>
        /// <param name="capacity"> the number of instances that can be used during this profile. </param>
        /// <param name="rules"> the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules can be specified. </param>
        /// <param name="fixedDate"> the specific date-time for the profile. This element is not used if the Recurrence element is used. </param>
        /// <param name="recurrence"> the repeating times at which this profile begins. This element is not used if the FixedDate element is used. </param>
        /// <returns> A new <see cref="Models.AutoscaleProfile"/> instance for mocking. </returns>
        public static AutoscaleProfile AutoscaleProfile(string name = null, MonitorScaleCapacity capacity = null, IEnumerable<AutoscaleRule> rules = null, MonitorTimeWindow fixedDate = null, MonitorRecurrence recurrence = null)
        {
            rules ??= new List<AutoscaleRule>();

            return new AutoscaleProfile(name, capacity, rules?.ToList(), fixedDate, recurrence);
        }

        /// <summary> Initializes a new instance of MetricTrigger. </summary>
        /// <param name="metricName"> the name of the metric that defines what the rule monitors. </param>
        /// <param name="metricNamespace"> the namespace of the metric that defines what the rule monitors. </param>
        /// <param name="metricResourceId"> the resource identifier of the resource the rule monitors. </param>
        /// <param name="metricResourceLocation"> the location of the resource the rule monitors. </param>
        /// <param name="timeGrain"> the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute. </param>
        /// <param name="statistic"> the metric statistic type. How the metrics from multiple instances are combined. </param>
        /// <param name="timeWindow"> the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes. </param>
        /// <param name="timeAggregation"> time aggregation type. How the data that is collected should be combined over time. The default value is Average. </param>
        /// <param name="operator"> the operator that is used to compare the metric data and the threshold. </param>
        /// <param name="threshold"> the threshold of the metric that triggers the scale action. </param>
        /// <param name="dimensions"> List of dimension conditions. For example: [{&quot;DimensionName&quot;:&quot;AppName&quot;,&quot;Operator&quot;:&quot;Equals&quot;,&quot;Values&quot;:[&quot;App1&quot;]},{&quot;DimensionName&quot;:&quot;Deployment&quot;,&quot;Operator&quot;:&quot;Equals&quot;,&quot;Values&quot;:[&quot;default&quot;]}]. </param>
        /// <param name="isDividedPerInstance"> a value indicating whether metric should divide per instance. </param>
        /// <returns> A new <see cref="Models.MetricTrigger"/> instance for mocking. </returns>
        public static MetricTrigger MetricTrigger(string metricName = null, string metricNamespace = null, ResourceIdentifier metricResourceId = null, AzureLocation? metricResourceLocation = null, TimeSpan timeGrain = default, MetricStatisticType statistic = default, TimeSpan timeWindow = default, MetricTriggerTimeAggregationType timeAggregation = default, MetricTriggerComparisonOperation @operator = default, double threshold = default, IEnumerable<AutoscaleRuleMetricDimension> dimensions = null, bool? isDividedPerInstance = null)
        {
            dimensions ??= new List<AutoscaleRuleMetricDimension>();

            return new MetricTrigger(metricName, metricNamespace, metricResourceId, metricResourceLocation, timeGrain, statistic, timeWindow, timeAggregation, @operator, threshold, dimensions?.ToList(), isDividedPerInstance);
        }

        /// <summary> Initializes a new instance of MonitorScaleAction. </summary>
        /// <param name="direction"> the scale direction. Whether the scaling action increases or decreases the number of instances. </param>
        /// <param name="scaleType"> the type of action that should occur when the scale rule fires. </param>
        /// <param name="value"> the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1. </param>
        /// <param name="cooldown"> the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format. </param>
        /// <returns> A new <see cref="Models.MonitorScaleAction"/> instance for mocking. </returns>
        public static MonitorScaleAction MonitorScaleAction(MonitorScaleDirection direction = default, MonitorScaleType scaleType = default, string value = null, TimeSpan cooldown = default)
        {
            return new MonitorScaleAction(direction, scaleType, value, cooldown);
        }

        /// <summary> Initializes a new instance of MonitorTimeWindow. </summary>
        /// <param name="timeZone"> the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3, Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time. </param>
        /// <param name="startOn"> the start time for the profile in ISO 8601 format. </param>
        /// <param name="endOn"> the end time for the profile in ISO 8601 format. </param>
        /// <returns> A new <see cref="Models.MonitorTimeWindow"/> instance for mocking. </returns>
        public static MonitorTimeWindow MonitorTimeWindow(string timeZone = null, DateTimeOffset startOn = default, DateTimeOffset endOn = default)
        {
            return new MonitorTimeWindow(timeZone, startOn, endOn);
        }

        /// <summary> Initializes a new instance of AutoscaleNotification. </summary>
        /// <param name="operation"> the operation associated with the notification and its value must be &quot;scale&quot;. </param>
        /// <param name="email"> the email notification. </param>
        /// <param name="webhooks"> the collection of webhook notifications. </param>
        /// <returns> A new <see cref="Models.AutoscaleNotification"/> instance for mocking. </returns>
        public static AutoscaleNotification AutoscaleNotification(MonitorOperationType operation = default, EmailNotification email = null, IEnumerable<WebhookNotification> webhooks = null)
        {
            webhooks ??= new List<WebhookNotification>();

            return new AutoscaleNotification(operation, email, webhooks?.ToList());
        }

        /// <summary> Initializes a new instance of EmailNotification. </summary>
        /// <param name="sendToSubscriptionAdministrator"> a value indicating whether to send email to subscription administrator. </param>
        /// <param name="sendToSubscriptionCoAdministrators"> a value indicating whether to send email to subscription co-administrators. </param>
        /// <param name="customEmails"> the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored. </param>
        /// <returns> A new <see cref="Models.EmailNotification"/> instance for mocking. </returns>
        public static EmailNotification EmailNotification(bool? sendToSubscriptionAdministrator = null, bool? sendToSubscriptionCoAdministrators = null, IEnumerable<string> customEmails = null)
        {
            customEmails ??= new List<string>();

            return new EmailNotification(sendToSubscriptionAdministrator, sendToSubscriptionCoAdministrators, customEmails?.ToList());
        }

        /// <summary> Initializes a new instance of WebhookNotification. </summary>
        /// <param name="serviceUri"> the service address to receive the notification. </param>
        /// <param name="properties"> a property bag of settings. This value can be empty. </param>
        /// <returns> A new <see cref="Models.WebhookNotification"/> instance for mocking. </returns>
        public static WebhookNotification WebhookNotification(Uri serviceUri = null, IDictionary<string, string> properties = null)
        {
            properties ??= new Dictionary<string, string>();

            return new WebhookNotification(serviceUri, properties);
        }

        /// <summary> Initializes a new instance of PredictiveAutoscalePolicy. </summary>
        /// <param name="scaleMode"> the predictive autoscale mode. </param>
        /// <param name="scaleLookAheadTime"> the amount of time to specify by which instances are launched in advance. It must be between 1 minute and 60 minutes in ISO 8601 format. </param>
        /// <returns> A new <see cref="Models.PredictiveAutoscalePolicy"/> instance for mocking. </returns>
        public static PredictiveAutoscalePolicy PredictiveAutoscalePolicy(PredictiveAutoscalePolicyScaleMode scaleMode = default, TimeSpan? scaleLookAheadTime = null)
        {
            return new PredictiveAutoscalePolicy(scaleMode, scaleLookAheadTime);
        }

        /// <summary> Initializes a new instance of AutoscaleSettingPredicativeResult. </summary>
        /// <param name="timespan"> The timespan for which the data was retrieved. Its value consists of two datetimes concatenated, separated by &apos;/&apos;.  This may be adjusted in the future and returned back from what was originally requested. </param>
        /// <param name="interval"> The interval (window size) for which the metric data was returned in.  This may be adjusted in the future and returned back from what was originally requested.  This is not present if a metadata request was made. </param>
        /// <param name="metricName"> The metrics being queried. </param>
        /// <param name="targetResourceId"> resource of the predictive metric. </param>
        /// <param name="data"> the value of the collection. </param>
        /// <returns> A new <see cref="Models.AutoscaleSettingPredicativeResult"/> instance for mocking. </returns>
        public static AutoscaleSettingPredicativeResult AutoscaleSettingPredicativeResult(string timespan = null, TimeSpan? interval = null, string metricName = null, ResourceIdentifier targetResourceId = null, IEnumerable<PredictiveValue> data = null)
        {
            data ??= new List<PredictiveValue>();

            return new AutoscaleSettingPredicativeResult(timespan, interval, metricName, targetResourceId, data?.ToList());
        }

        /// <summary> Initializes a new instance of PredictiveValue. </summary>
        /// <param name="timeStamp"> the timestamp for the metric value in ISO 8601 format. </param>
        /// <param name="value"> Predictive value in this time bucket. </param>
        /// <returns> A new <see cref="Models.PredictiveValue"/> instance for mocking. </returns>
        public static PredictiveValue PredictiveValue(DateTimeOffset timeStamp = default, double value = default)
        {
            return new PredictiveValue(timeStamp, value);
        }

        /// <summary> Initializes a new instance of MonitorIncident. </summary>
        /// <param name="name"> Incident name. </param>
        /// <param name="ruleName"> Rule name that is associated with the incident. </param>
        /// <param name="isActive"> A boolean to indicate whether the incident is active or resolved. </param>
        /// <param name="activatedOn"> The time at which the incident was activated in ISO8601 format. </param>
        /// <param name="resolvedOn"> The time at which the incident was resolved in ISO8601 format. If null, it means the incident is still active. </param>
        /// <returns> A new <see cref="Models.MonitorIncident"/> instance for mocking. </returns>
        public static MonitorIncident MonitorIncident(string name = null, string ruleName = null, bool? isActive = null, DateTimeOffset? activatedOn = null, DateTimeOffset? resolvedOn = null)
        {
            return new MonitorIncident(name, ruleName, isActive, activatedOn, resolvedOn);
        }

        /// <summary> Initializes a new instance of AlertRuleData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="alertRuleName"> the name of the alert rule. </param>
        /// <param name="description"> the description of the alert rule that will be included in the alert email. </param>
        /// <param name="provisioningState"> the provisioning state. </param>
        /// <param name="isEnabled"> the flag that indicates whether the alert rule is enabled. </param>
        /// <param name="condition">
        /// the condition that results in the alert rule being activated.
        /// Please note <see cref="AlertRuleCondition"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="LocationThresholdRuleCondition"/>, <see cref="ManagementEventRuleCondition"/> and <see cref="ThresholdRuleCondition"/>.
        /// </param>
        /// <param name="action">
        /// action that is performed when the alert rule becomes active, and when an alert condition is resolved.
        /// Please note <see cref="AlertRuleAction"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="RuleEmailAction"/> and <see cref="RuleWebhookAction"/>.
        /// </param>
        /// <param name="actions">
        /// the array of actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
        /// Please note <see cref="AlertRuleAction"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="RuleEmailAction"/> and <see cref="RuleWebhookAction"/>.
        /// </param>
        /// <param name="lastUpdatedOn"> Last time the rule was updated in ISO8601 format. </param>
        /// <returns> A new <see cref="Monitor.AlertRuleData"/> instance for mocking. </returns>
        public static AlertRuleData AlertRuleData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string alertRuleName = null, string description = null, string provisioningState = null, bool isEnabled = default, AlertRuleCondition condition = null, AlertRuleAction action = null, IEnumerable<AlertRuleAction> actions = null, DateTimeOffset? lastUpdatedOn = null)
        {
            tags ??= new Dictionary<string, string>();
            actions ??= new List<AlertRuleAction>();

            return new AlertRuleData(id, name, resourceType, systemData, tags, location, alertRuleName, description, provisioningState, isEnabled, condition, action, actions?.ToList(), lastUpdatedOn);
        }

        /// <summary> Initializes a new instance of AlertRuleCondition. </summary>
        /// <param name="odataType"> specifies the type of condition. This can be one of three types: ManagementEventRuleCondition (occurrences of management events), LocationThresholdRuleCondition (based on the number of failures of a web test), and ThresholdRuleCondition (based on the threshold of a metric). </param>
        /// <param name="dataSource">
        /// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
        /// Please note <see cref="RuleDataSource"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="RuleManagementEventDataSource"/> and <see cref="RuleMetricDataSource"/>.
        /// </param>
        /// <returns> A new <see cref="Models.AlertRuleCondition"/> instance for mocking. </returns>
        public static AlertRuleCondition AlertRuleCondition(string odataType = null, RuleDataSource dataSource = null)
        {
            return new UnknownRuleCondition(odataType, dataSource);
        }

        /// <summary> Initializes a new instance of RuleDataSource. </summary>
        /// <param name="odataType"> specifies the type of data source. There are two types of rule data sources: RuleMetricDataSource and RuleManagementEventDataSource. </param>
        /// <param name="resourceId"> the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule. </param>
        /// <param name="legacyResourceId"> the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule. </param>
        /// <param name="resourceLocation"> the location of the resource. </param>
        /// <param name="metricNamespace"> the namespace of the metric. </param>
        /// <returns> A new <see cref="Models.RuleDataSource"/> instance for mocking. </returns>
        public static RuleDataSource RuleDataSource(string odataType = null, ResourceIdentifier resourceId = null, ResourceIdentifier legacyResourceId = null, string resourceLocation = null, string metricNamespace = null)
        {
            return new UnknownRuleDataSource(odataType, resourceId, legacyResourceId, resourceLocation, metricNamespace);
        }

        /// <summary> Initializes a new instance of AlertRuleAction. </summary>
        /// <param name="odataType"> specifies the type of the action. There are two types of actions: RuleEmailAction and RuleWebhookAction. </param>
        /// <returns> A new <see cref="Models.AlertRuleAction"/> instance for mocking. </returns>
        public static AlertRuleAction AlertRuleAction(string odataType = null)
        {
            return new UnknownRuleAction(odataType);
        }

        /// <summary> Initializes a new instance of LogProfileData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="storageAccountId"> the resource id of the storage account to which you would like to send the Activity Log. </param>
        /// <param name="serviceBusRuleId"> The service bus rule ID of the service bus namespace in which you would like to have Event Hubs created for streaming the Activity Log. The rule ID is of the format: &apos;{service bus resource ID}/authorizationrules/{key name}&apos;. </param>
        /// <param name="locations"> List of regions for which Activity Log events should be stored or streamed. It is a comma separated list of valid ARM locations including the &apos;global&apos; location. </param>
        /// <param name="categories"> the categories of the logs. These categories are created as is convenient to the user. Some values are: &apos;Write&apos;, &apos;Delete&apos;, and/or &apos;Action.&apos;. </param>
        /// <param name="retentionPolicy"> the retention policy for the events in the log. </param>
        /// <returns> A new <see cref="Monitor.LogProfileData"/> instance for mocking. </returns>
        public static LogProfileData LogProfileData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ResourceIdentifier storageAccountId = null, ResourceIdentifier serviceBusRuleId = null, IEnumerable<AzureLocation> locations = null, IEnumerable<string> categories = null, RetentionPolicy retentionPolicy = null)
        {
            tags ??= new Dictionary<string, string>();
            locations ??= new List<AzureLocation>();
            categories ??= new List<string>();

            return new LogProfileData(id, name, resourceType, systemData, tags, location, storageAccountId, serviceBusRuleId, locations?.ToList(), categories?.ToList(), retentionPolicy);
        }

        /// <summary> Initializes a new instance of DiagnosticSettingData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="storageAccountId"> The resource ID of the storage account to which you would like to send Diagnostic Logs. </param>
        /// <param name="serviceBusRuleId"> The service bus rule Id of the diagnostic setting. This is here to maintain backwards compatibility. </param>
        /// <param name="eventHubAuthorizationRuleId"> The resource Id for the event hub authorization rule. </param>
        /// <param name="eventHubName"> The name of the event hub. If none is specified, the default event hub will be selected. </param>
        /// <param name="metrics"> The list of metric settings. </param>
        /// <param name="logs"> The list of logs settings. </param>
        /// <param name="workspaceId"> The full ARM resource ID of the Log Analytics workspace to which you would like to send Diagnostic Logs. Example: /subscriptions/4b9e8510-67ab-4e9a-95a9-e2f1e570ea9c/resourceGroups/insights-integration/providers/Microsoft.OperationalInsights/workspaces/viruela2. </param>
        /// <param name="marketplacePartnerId"> The full ARM resource ID of the Marketplace resource to which you would like to send Diagnostic Logs. </param>
        /// <param name="logAnalyticsDestinationType"> A string indicating whether the export to Log Analytics should use the default destination type, i.e. AzureDiagnostics, or use a destination type constructed as follows: &lt;normalized service identity&gt;_&lt;normalized category name&gt;. Possible values are: Dedicated and null (null is default.). </param>
        /// <returns> A new <see cref="Monitor.DiagnosticSettingData"/> instance for mocking. </returns>
        public static DiagnosticSettingData DiagnosticSettingData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ResourceIdentifier storageAccountId = null, ResourceIdentifier serviceBusRuleId = null, ResourceIdentifier eventHubAuthorizationRuleId = null, string eventHubName = null, IEnumerable<MetricSettings> metrics = null, IEnumerable<LogSettings> logs = null, ResourceIdentifier workspaceId = null, ResourceIdentifier marketplacePartnerId = null, string logAnalyticsDestinationType = null)
        {
            metrics ??= new List<MetricSettings>();
            logs ??= new List<LogSettings>();

            return new DiagnosticSettingData(id, name, resourceType, systemData, storageAccountId, serviceBusRuleId, eventHubAuthorizationRuleId, eventHubName, metrics?.ToList(), logs?.ToList(), workspaceId, marketplacePartnerId, logAnalyticsDestinationType);
        }

        /// <summary> Initializes a new instance of MetricSettings. </summary>
        /// <param name="timeGrain"> the timegrain of the metric in ISO8601 format. </param>
        /// <param name="category"> Name of a Diagnostic Metric category for a resource type this setting is applied to. To obtain the list of Diagnostic metric categories for a resource, first perform a GET diagnostic settings operation. </param>
        /// <param name="isEnabled"> a value indicating whether this category is enabled. </param>
        /// <param name="retentionPolicy"> the retention policy for this category. </param>
        /// <returns> A new <see cref="Models.MetricSettings"/> instance for mocking. </returns>
        public static MetricSettings MetricSettings(TimeSpan? timeGrain = null, string category = null, bool isEnabled = default, RetentionPolicy retentionPolicy = null)
        {
            return new MetricSettings(timeGrain, category, isEnabled, retentionPolicy);
        }

        /// <summary> Initializes a new instance of LogSettings. </summary>
        /// <param name="category"> Name of a Diagnostic Log category for a resource type this setting is applied to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings operation. </param>
        /// <param name="categoryGroup"> Name of a Diagnostic Log category group for a resource type this setting is applied to. To obtain the list of Diagnostic Log categories for a resource, first perform a GET diagnostic settings operation. </param>
        /// <param name="isEnabled"> a value indicating whether this log is enabled. </param>
        /// <param name="retentionPolicy"> the retention policy for this log. </param>
        /// <returns> A new <see cref="Models.LogSettings"/> instance for mocking. </returns>
        public static LogSettings LogSettings(string category = null, string categoryGroup = null, bool isEnabled = default, RetentionPolicy retentionPolicy = null)
        {
            return new LogSettings(category, categoryGroup, isEnabled, retentionPolicy);
        }

        /// <summary> Initializes a new instance of DiagnosticSettingsCategoryData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="categoryType"> The type of the diagnostic settings category. </param>
        /// <param name="categoryGroups"> the collection of what category groups are supported. </param>
        /// <returns> A new <see cref="Monitor.DiagnosticSettingsCategoryData"/> instance for mocking. </returns>
        public static DiagnosticSettingsCategoryData DiagnosticSettingsCategoryData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, MonitorCategoryType? categoryType = null, IEnumerable<string> categoryGroups = null)
        {
            categoryGroups ??= new List<string>();

            return new DiagnosticSettingsCategoryData(id, name, resourceType, systemData, categoryType, categoryGroups?.ToList());
        }

        /// <summary> Initializes a new instance of ActionGroupData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="groupShortName"> The short name of the action group. This will be used in SMS messages. </param>
        /// <param name="isEnabled"> Indicates whether this action group is enabled. If an action group is not enabled, then none of its receivers will receive communications. </param>
        /// <param name="emailReceivers"> The list of email receivers that are part of this action group. </param>
        /// <param name="smsReceivers"> The list of SMS receivers that are part of this action group. </param>
        /// <param name="webhookReceivers"> The list of webhook receivers that are part of this action group. </param>
        /// <param name="itsmReceivers"> The list of ITSM receivers that are part of this action group. </param>
        /// <param name="azureAppPushReceivers"> The list of AzureAppPush receivers that are part of this action group. </param>
        /// <param name="automationRunbookReceivers"> The list of AutomationRunbook receivers that are part of this action group. </param>
        /// <param name="voiceReceivers"> The list of voice receivers that are part of this action group. </param>
        /// <param name="logicAppReceivers"> The list of logic app receivers that are part of this action group. </param>
        /// <param name="azureFunctionReceivers"> The list of azure function receivers that are part of this action group. </param>
        /// <param name="armRoleReceivers"> The list of ARM role receivers that are part of this action group. Roles are Azure RBAC roles and only built-in roles are supported. </param>
        /// <param name="eventHubReceivers"> The list of event hub receivers that are part of this action group. </param>
        /// <returns> A new <see cref="Monitor.ActionGroupData"/> instance for mocking. </returns>
        public static ActionGroupData ActionGroupData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string groupShortName = null, bool? isEnabled = null, IEnumerable<MonitorEmailReceiver> emailReceivers = null, IEnumerable<MonitorSmsReceiver> smsReceivers = null, IEnumerable<MonitorWebhookReceiver> webhookReceivers = null, IEnumerable<MonitorItsmReceiver> itsmReceivers = null, IEnumerable<MonitorAzureAppPushReceiver> azureAppPushReceivers = null, IEnumerable<MonitorAutomationRunbookReceiver> automationRunbookReceivers = null, IEnumerable<MonitorVoiceReceiver> voiceReceivers = null, IEnumerable<MonitorLogicAppReceiver> logicAppReceivers = null, IEnumerable<MonitorAzureFunctionReceiver> azureFunctionReceivers = null, IEnumerable<MonitorArmRoleReceiver> armRoleReceivers = null, IEnumerable<MonitorEventHubReceiver> eventHubReceivers = null)
        {
            tags ??= new Dictionary<string, string>();
            emailReceivers ??= new List<MonitorEmailReceiver>();
            smsReceivers ??= new List<MonitorSmsReceiver>();
            webhookReceivers ??= new List<MonitorWebhookReceiver>();
            itsmReceivers ??= new List<MonitorItsmReceiver>();
            azureAppPushReceivers ??= new List<MonitorAzureAppPushReceiver>();
            automationRunbookReceivers ??= new List<MonitorAutomationRunbookReceiver>();
            voiceReceivers ??= new List<MonitorVoiceReceiver>();
            logicAppReceivers ??= new List<MonitorLogicAppReceiver>();
            azureFunctionReceivers ??= new List<MonitorAzureFunctionReceiver>();
            armRoleReceivers ??= new List<MonitorArmRoleReceiver>();
            eventHubReceivers ??= new List<MonitorEventHubReceiver>();

            return new ActionGroupData(id, name, resourceType, systemData, tags, location, groupShortName, isEnabled, emailReceivers?.ToList(), smsReceivers?.ToList(), webhookReceivers?.ToList(), itsmReceivers?.ToList(), azureAppPushReceivers?.ToList(), automationRunbookReceivers?.ToList(), voiceReceivers?.ToList(), logicAppReceivers?.ToList(), azureFunctionReceivers?.ToList(), armRoleReceivers?.ToList(), eventHubReceivers?.ToList());
        }

        /// <summary> Initializes a new instance of MonitorEmailReceiver. </summary>
        /// <param name="name"> The name of the email receiver. Names must be unique across all receivers within an action group. </param>
        /// <param name="emailAddress"> The email address of this receiver. </param>
        /// <param name="useCommonAlertSchema"> Indicates whether to use common alert schema. </param>
        /// <param name="status"> The receiver status of the e-mail. </param>
        /// <returns> A new <see cref="Models.MonitorEmailReceiver"/> instance for mocking. </returns>
        public static MonitorEmailReceiver MonitorEmailReceiver(string name = null, string emailAddress = null, bool? useCommonAlertSchema = null, MonitorReceiverStatus? status = null)
        {
            return new MonitorEmailReceiver(name, emailAddress, useCommonAlertSchema, status);
        }

        /// <summary> Initializes a new instance of MonitorSmsReceiver. </summary>
        /// <param name="name"> The name of the SMS receiver. Names must be unique across all receivers within an action group. </param>
        /// <param name="countryCode"> The country code of the SMS receiver. </param>
        /// <param name="phoneNumber"> The phone number of the SMS receiver. </param>
        /// <param name="status"> The status of the receiver. </param>
        /// <returns> A new <see cref="Models.MonitorSmsReceiver"/> instance for mocking. </returns>
        public static MonitorSmsReceiver MonitorSmsReceiver(string name = null, string countryCode = null, string phoneNumber = null, MonitorReceiverStatus? status = null)
        {
            return new MonitorSmsReceiver(name, countryCode, phoneNumber, status);
        }

        /// <summary> Initializes a new instance of MonitorWebhookReceiver. </summary>
        /// <param name="name"> The name of the webhook receiver. Names must be unique across all receivers within an action group. </param>
        /// <param name="serviceUri"> The URI where webhooks should be sent. </param>
        /// <param name="useCommonAlertSchema"> Indicates whether to use common alert schema. </param>
        /// <param name="useAadAuth"> Indicates whether or not use AAD authentication. </param>
        /// <param name="objectId"> Indicates the webhook app object Id for aad auth. </param>
        /// <param name="identifierUri"> Indicates the identifier uri for aad auth. </param>
        /// <param name="tenantId"> Indicates the tenant id for aad auth. </param>
        /// <returns> A new <see cref="Models.MonitorWebhookReceiver"/> instance for mocking. </returns>
        public static MonitorWebhookReceiver MonitorWebhookReceiver(string name = null, Uri serviceUri = null, bool? useCommonAlertSchema = null, bool? useAadAuth = null, string objectId = null, Uri identifierUri = null, Guid? tenantId = null)
        {
            return new MonitorWebhookReceiver(name, serviceUri, useCommonAlertSchema, useAadAuth, objectId, identifierUri, tenantId);
        }

        /// <summary> Initializes a new instance of MonitorAutomationRunbookReceiver. </summary>
        /// <param name="automationAccountId"> The Azure automation account Id which holds this runbook and authenticate to Azure resource. </param>
        /// <param name="runbookName"> The name for this runbook. </param>
        /// <param name="webhookResourceId"> The resource id for webhook linked to this runbook. </param>
        /// <param name="isGlobalRunbook"> Indicates whether this instance is global runbook. </param>
        /// <param name="name"> Indicates name of the webhook. </param>
        /// <param name="serviceUri"> The URI where webhooks should be sent. </param>
        /// <param name="useCommonAlertSchema"> Indicates whether to use common alert schema. </param>
        /// <returns> A new <see cref="Models.MonitorAutomationRunbookReceiver"/> instance for mocking. </returns>
        public static MonitorAutomationRunbookReceiver MonitorAutomationRunbookReceiver(ResourceIdentifier automationAccountId = null, string runbookName = null, ResourceIdentifier webhookResourceId = null, bool isGlobalRunbook = default, string name = null, Uri serviceUri = null, bool? useCommonAlertSchema = null)
        {
            return new MonitorAutomationRunbookReceiver(automationAccountId, runbookName, webhookResourceId, isGlobalRunbook, name, serviceUri, useCommonAlertSchema);
        }

        /// <summary> Initializes a new instance of MonitorLogicAppReceiver. </summary>
        /// <param name="name"> The name of the logic app receiver. Names must be unique across all receivers within an action group. </param>
        /// <param name="resourceId"> The azure resource id of the logic app receiver. </param>
        /// <param name="callbackUri"> The callback url where http request sent to. </param>
        /// <param name="useCommonAlertSchema"> Indicates whether to use common alert schema. </param>
        /// <returns> A new <see cref="Models.MonitorLogicAppReceiver"/> instance for mocking. </returns>
        public static MonitorLogicAppReceiver MonitorLogicAppReceiver(string name = null, ResourceIdentifier resourceId = null, Uri callbackUri = null, bool? useCommonAlertSchema = null)
        {
            return new MonitorLogicAppReceiver(name, resourceId, callbackUri, useCommonAlertSchema);
        }

        /// <summary> Initializes a new instance of MonitorAzureFunctionReceiver. </summary>
        /// <param name="name"> The name of the azure function receiver. Names must be unique across all receivers within an action group. </param>
        /// <param name="functionAppResourceId"> The azure resource id of the function app. </param>
        /// <param name="functionName"> The function name in the function app. </param>
        /// <param name="httpTriggerUri"> The http trigger url where http request sent to. </param>
        /// <param name="useCommonAlertSchema"> Indicates whether to use common alert schema. </param>
        /// <returns> A new <see cref="Models.MonitorAzureFunctionReceiver"/> instance for mocking. </returns>
        public static MonitorAzureFunctionReceiver MonitorAzureFunctionReceiver(string name = null, ResourceIdentifier functionAppResourceId = null, string functionName = null, Uri httpTriggerUri = null, bool? useCommonAlertSchema = null)
        {
            return new MonitorAzureFunctionReceiver(name, functionAppResourceId, functionName, httpTriggerUri, useCommonAlertSchema);
        }

        /// <summary> Initializes a new instance of MonitorArmRoleReceiver. </summary>
        /// <param name="name"> The name of the arm role receiver. Names must be unique across all receivers within an action group. </param>
        /// <param name="roleId"> The arm role id. </param>
        /// <param name="useCommonAlertSchema"> Indicates whether to use common alert schema. </param>
        /// <returns> A new <see cref="Models.MonitorArmRoleReceiver"/> instance for mocking. </returns>
        public static MonitorArmRoleReceiver MonitorArmRoleReceiver(string name = null, string roleId = null, bool? useCommonAlertSchema = null)
        {
            return new MonitorArmRoleReceiver(name, roleId, useCommonAlertSchema);
        }

        /// <summary> Initializes a new instance of MonitorEventHubReceiver. </summary>
        /// <param name="name"> The name of the Event hub receiver. Names must be unique across all receivers within an action group. </param>
        /// <param name="eventHubNameSpace"> The Event Hub namespace. </param>
        /// <param name="eventHubName"> The name of the specific Event Hub queue. </param>
        /// <param name="useCommonAlertSchema"> Indicates whether to use common alert schema. </param>
        /// <param name="tenantId"> The tenant Id for the subscription containing this event hub. </param>
        /// <param name="subscriptionId"> The Id for the subscription containing this event hub. </param>
        /// <returns> A new <see cref="Models.MonitorEventHubReceiver"/> instance for mocking. </returns>
        public static MonitorEventHubReceiver MonitorEventHubReceiver(string name = null, string eventHubNameSpace = null, string eventHubName = null, bool? useCommonAlertSchema = null, Guid? tenantId = null, string subscriptionId = null)
        {
            return new MonitorEventHubReceiver(name, eventHubNameSpace, eventHubName, useCommonAlertSchema, tenantId, subscriptionId);
        }

        /// <summary> Initializes a new instance of NotificationStatus. </summary>
        /// <param name="context"> The context info. </param>
        /// <param name="state"> The overall state. </param>
        /// <param name="completedOn"> The completed time. </param>
        /// <param name="createdOn"> The created time. </param>
        /// <param name="actionDetails"> The list of action detail. </param>
        /// <returns> A new <see cref="Models.NotificationStatus"/> instance for mocking. </returns>
        public static NotificationStatus NotificationStatus(NotificationContext context = null, string state = null, DateTimeOffset? completedOn = null, DateTimeOffset? createdOn = null, IEnumerable<NotificationActionDetail> actionDetails = null)
        {
            actionDetails ??= new List<NotificationActionDetail>();

            return new NotificationStatus(context, state, completedOn, createdOn, actionDetails?.ToList());
        }

        /// <summary> Initializes a new instance of NotificationContext. </summary>
        /// <param name="notificationSource"> The source of the notification request. </param>
        /// <param name="contextType"> The context id type. </param>
        /// <returns> A new <see cref="Models.NotificationContext"/> instance for mocking. </returns>
        public static NotificationContext NotificationContext(string notificationSource = null, string contextType = null)
        {
            return new NotificationContext(notificationSource, contextType);
        }

        /// <summary> Initializes a new instance of NotificationActionDetail. </summary>
        /// <param name="mechanismType"> The mechanism type. </param>
        /// <param name="name"> The name of the action. </param>
        /// <param name="status"> The status of the action. </param>
        /// <param name="subState"> The substatus of the action. </param>
        /// <param name="sendOn"> The send time. </param>
        /// <param name="detail"> The detail of the friendly error message. </param>
        /// <returns> A new <see cref="Models.NotificationActionDetail"/> instance for mocking. </returns>
        public static NotificationActionDetail NotificationActionDetail(string mechanismType = null, string name = null, string status = null, string subState = null, DateTimeOffset? sendOn = null, string detail = null)
        {
            return new NotificationActionDetail(mechanismType, name, status, subState, sendOn, detail);
        }

        /// <summary> Initializes a new instance of EventDataInfo. </summary>
        /// <param name="authorization"> The sender authorization information. </param>
        /// <param name="claims"> key value pairs to identify ARM permissions. </param>
        /// <param name="caller"> the email address of the user who has performed the operation, the UPN claim or SPN claim based on availability. </param>
        /// <param name="description"> the description of the event. </param>
        /// <param name="id"> the Id of this event as required by ARM for RBAC. It contains the EventDataID and a timestamp information. </param>
        /// <param name="eventDataId"> the event data Id. This is a unique identifier for an event. </param>
        /// <param name="correlationId"> the correlation Id, usually a GUID in the string format. The correlation Id is shared among the events that belong to the same uber operation. </param>
        /// <param name="eventName"> the event name. This value should not be confused with OperationName. For practical purposes, OperationName might be more appealing to end users. </param>
        /// <param name="category"> the event category. </param>
        /// <param name="httpRequest"> the HTTP request info. Usually includes the &apos;clientRequestId&apos;, &apos;clientIpAddress&apos; (IP address of the user who initiated the event) and &apos;method&apos; (HTTP method e.g. PUT). </param>
        /// <param name="level"> the event level. </param>
        /// <param name="resourceGroupName"> the resource group name of the impacted resource. </param>
        /// <param name="resourceProviderName"> the resource provider name of the impacted resource. </param>
        /// <param name="resourceId"> the resource uri that uniquely identifies the resource that caused this event. </param>
        /// <param name="resourceType"> the resource type. </param>
        /// <param name="operationId"> It is usually a GUID shared among the events corresponding to single operation. This value should not be confused with EventName. </param>
        /// <param name="operationName"> the operation name. </param>
        /// <param name="properties"> the set of &lt;Key, Value&gt; pairs (usually a Dictionary&lt;String, String&gt;) that includes details about the event. </param>
        /// <param name="status"> a string describing the status of the operation. Some typical values are: Started, In progress, Succeeded, Failed, Resolved. </param>
        /// <param name="subStatus"> the event sub status. Most of the time, when included, this captures the HTTP status code of the REST call. Common values are: OK (HTTP Status Code: 200), Created (HTTP Status Code: 201), Accepted (HTTP Status Code: 202), No Content (HTTP Status Code: 204), Bad Request(HTTP Status Code: 400), Not Found (HTTP Status Code: 404), Conflict (HTTP Status Code: 409), Internal Server Error (HTTP Status Code: 500), Service Unavailable (HTTP Status Code:503), Gateway Timeout (HTTP Status Code: 504). </param>
        /// <param name="eventTimestamp"> the timestamp of when the event was generated by the Azure service processing the request corresponding the event. It in ISO 8601 format. </param>
        /// <param name="submissionTimestamp"> the timestamp of when the event became available for querying via this API. It is in ISO 8601 format. This value should not be confused eventTimestamp. As there might be a delay between the occurrence time of the event, and the time that the event is submitted to the Azure logging infrastructure. </param>
        /// <param name="subscriptionId"> the Azure subscription Id usually a GUID. </param>
        /// <param name="tenantId"> the Azure tenant Id. </param>
        /// <returns> A new <see cref="Models.EventDataInfo"/> instance for mocking. </returns>
        public static EventDataInfo EventDataInfo(SenderAuthorization authorization = null, IReadOnlyDictionary<string, string> claims = null, string caller = null, string description = null, string id = null, string eventDataId = null, string correlationId = null, MonitorLocalizableString eventName = null, MonitorLocalizableString category = null, EventDataHttpRequestInfo httpRequest = null, MonitorEventLevel? level = null, string resourceGroupName = null, MonitorLocalizableString resourceProviderName = null, ResourceIdentifier resourceId = null, MonitorLocalizableString resourceType = null, string operationId = null, MonitorLocalizableString operationName = null, IReadOnlyDictionary<string, string> properties = null, MonitorLocalizableString status = null, MonitorLocalizableString subStatus = null, DateTimeOffset? eventTimestamp = null, DateTimeOffset? submissionTimestamp = null, string subscriptionId = null, Guid? tenantId = null)
        {
            claims ??= new Dictionary<string, string>();
            properties ??= new Dictionary<string, string>();

            return new EventDataInfo(authorization, claims, caller, description, id, eventDataId, correlationId, eventName, category, httpRequest, level, resourceGroupName, resourceProviderName, resourceId, resourceType, operationId, operationName, properties, status, subStatus, eventTimestamp, submissionTimestamp, subscriptionId, tenantId);
        }

        /// <summary> Initializes a new instance of SenderAuthorization. </summary>
        /// <param name="action"> the permissible actions. For instance: microsoft.support/supporttickets/write. </param>
        /// <param name="role"> the role of the user. For instance: Subscription Admin. </param>
        /// <param name="scope"> the scope. </param>
        /// <returns> A new <see cref="Models.SenderAuthorization"/> instance for mocking. </returns>
        public static SenderAuthorization SenderAuthorization(string action = null, string role = null, string scope = null)
        {
            return new SenderAuthorization(action, role, scope);
        }

        /// <summary> Initializes a new instance of MonitorLocalizableString. </summary>
        /// <param name="value"> the invariant value. </param>
        /// <param name="localizedValue"> the locale specific value. </param>
        /// <returns> A new <see cref="Models.MonitorLocalizableString"/> instance for mocking. </returns>
        public static MonitorLocalizableString MonitorLocalizableString(string value = null, string localizedValue = null)
        {
            return new MonitorLocalizableString(value, localizedValue);
        }

        /// <summary> Initializes a new instance of EventDataHttpRequestInfo. </summary>
        /// <param name="clientRequestId"> the client request id. </param>
        /// <param name="clientIPAddress"> the client Ip Address. </param>
        /// <param name="method"> the Http request method. </param>
        /// <param name="uri"> the Uri. </param>
        /// <returns> A new <see cref="Models.EventDataHttpRequestInfo"/> instance for mocking. </returns>
        public static EventDataHttpRequestInfo EventDataHttpRequestInfo(string clientRequestId = null, IPAddress clientIPAddress = null, string method = null, Uri uri = null)
        {
            return new EventDataHttpRequestInfo(clientRequestId, clientIPAddress, method, uri);
        }

        /// <summary> Initializes a new instance of MetricAlertData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="description"> the description of the metric alert that will be included in the alert email. </param>
        /// <param name="severity"> Alert severity {0, 1, 2, 3, 4}. </param>
        /// <param name="isEnabled"> the flag that indicates whether the metric alert is enabled. </param>
        /// <param name="scopes"> the list of resource id&apos;s that this metric alert is scoped to. </param>
        /// <param name="evaluationFrequency"> how often the metric alert is evaluated represented in ISO 8601 duration format. </param>
        /// <param name="windowSize"> the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. </param>
        /// <param name="targetResourceType"> the resource type of the target resource(s) on which the alert is created/updated. Mandatory if the scope contains a subscription, resource group, or more than one resource. </param>
        /// <param name="targetResourceRegion"> the region of the target resource(s) on which the alert is created/updated. Mandatory if the scope contains a subscription, resource group, or more than one resource. </param>
        /// <param name="criteria">
        /// defines the specific alert criteria information.
        /// Please note <see cref="MetricAlertCriteria"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="MetricAlertMultipleResourceMultipleMetricCriteria"/>, <see cref="MetricAlertSingleResourceMultipleMetricCriteria"/> and <see cref="WebtestLocationAvailabilityCriteria"/>.
        /// </param>
        /// <param name="isAutoMitigateEnabled"> the flag that indicates whether the alert should be auto resolved or not. The default is true. </param>
        /// <param name="actions"> the array of actions that are performed when the alert rule becomes active, and when an alert condition is resolved. </param>
        /// <param name="lastUpdatedOn"> Last time the rule was updated in ISO8601 format. </param>
        /// <param name="isMigrated"> the value indicating whether this alert rule is migrated. </param>
        /// <returns> A new <see cref="Monitor.MetricAlertData"/> instance for mocking. </returns>
        public static MetricAlertData MetricAlertData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string description = null, int severity = default, bool isEnabled = default, IEnumerable<string> scopes = null, TimeSpan evaluationFrequency = default, TimeSpan windowSize = default, ResourceType? targetResourceType = null, AzureLocation? targetResourceRegion = null, MetricAlertCriteria criteria = null, bool? isAutoMitigateEnabled = null, IEnumerable<MetricAlertAction> actions = null, DateTimeOffset? lastUpdatedOn = null, bool? isMigrated = null)
        {
            tags ??= new Dictionary<string, string>();
            scopes ??= new List<string>();
            actions ??= new List<MetricAlertAction>();

            return new MetricAlertData(id, name, resourceType, systemData, tags, location, description, severity, isEnabled, scopes?.ToList(), evaluationFrequency, windowSize, targetResourceType, targetResourceRegion, criteria, isAutoMitigateEnabled, actions?.ToList(), lastUpdatedOn, isMigrated);
        }

        /// <summary> Initializes a new instance of MetricAlertCriteria. </summary>
        /// <param name="odataType"> specifies the type of the alert criteria. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <returns> A new <see cref="Models.MetricAlertCriteria"/> instance for mocking. </returns>
        public static MetricAlertCriteria MetricAlertCriteria(string odataType = null, IDictionary<string, BinaryData> additionalProperties = null)
        {
            additionalProperties ??= new Dictionary<string, BinaryData>();

            return new MetricAlertCriteria(odataType, additionalProperties);
        }

        /// <summary> Initializes a new instance of MetricAlertAction. </summary>
        /// <param name="actionGroupId"> the id of the action group to use. </param>
        /// <param name="webHookProperties"> This field allows specifying custom properties, which would be appended to the alert payload sent as input to the webhook. </param>
        /// <returns> A new <see cref="Models.MetricAlertAction"/> instance for mocking. </returns>
        public static MetricAlertAction MetricAlertAction(ResourceIdentifier actionGroupId = null, IDictionary<string, string> webHookProperties = null)
        {
            webHookProperties ??= new Dictionary<string, string>();

            return new MetricAlertAction(actionGroupId, webHookProperties);
        }

        /// <summary> Initializes a new instance of MetricAlertStatus. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The alert status properties of the metric alert status. </param>
        /// <returns> A new <see cref="Models.MetricAlertStatus"/> instance for mocking. </returns>
        public static MetricAlertStatus MetricAlertStatus(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, MetricAlertStatusProperties properties = null)
        {
            return new MetricAlertStatus(id, name, resourceType, systemData, properties);
        }

        /// <summary> Initializes a new instance of MetricAlertStatusProperties. </summary>
        /// <param name="dimensions"> An object describing the type of the dimensions. </param>
        /// <param name="status"> status value. </param>
        /// <param name="timestamp"> UTC time when the status was checked. </param>
        /// <returns> A new <see cref="Models.MetricAlertStatusProperties"/> instance for mocking. </returns>
        public static MetricAlertStatusProperties MetricAlertStatusProperties(IReadOnlyDictionary<string, string> dimensions = null, string status = null, DateTimeOffset? timestamp = null)
        {
            dimensions ??= new Dictionary<string, string>();

            return new MetricAlertStatusProperties(dimensions, status, timestamp);
        }

        /// <summary> Initializes a new instance of ScheduledQueryRuleData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="kind"> Indicates the type of scheduled query rule. The default is LogAlert. </param>
        /// <param name="etag"> The etag field is *not* required. If it is provided in the response body, it must also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="createdWithApiVersion"> The api-version used when creating this alert rule. </param>
        /// <param name="isLegacyLogAnalyticsRule"> True if alert rule is legacy Log Analytic rule. </param>
        /// <param name="description"> The description of the scheduled query rule. </param>
        /// <param name="displayName"> The display name of the alert rule. </param>
        /// <param name="severity"> Severity of the alert. Should be an integer between [0-4]. Value of 0 is severest. Relevant and required only for rules of the kind LogAlert. </param>
        /// <param name="isEnabled"> The flag which indicates whether this scheduled query rule is enabled. Value should be true or false. </param>
        /// <param name="scopes"> The list of resource id&apos;s that this scheduled query rule is scoped to. </param>
        /// <param name="evaluationFrequency"> How often the scheduled query rule is evaluated represented in ISO 8601 duration format. Relevant and required only for rules of the kind LogAlert. </param>
        /// <param name="windowSize"> The period of time (in ISO 8601 duration format) on which the Alert query will be executed (bin size). Relevant and required only for rules of the kind LogAlert. </param>
        /// <param name="overrideQueryTimeRange"> If specified then overrides the query time range (default is WindowSize*NumberOfEvaluationPeriods). Relevant only for rules of the kind LogAlert. </param>
        /// <param name="targetResourceTypes"> List of resource type of the target resource(s) on which the alert is created/updated. For example if the scope is a resource group and targetResourceTypes is Microsoft.Compute/virtualMachines, then a different alert will be fired for each virtual machine in the resource group which meet the alert criteria. Relevant only for rules of the kind LogAlert. </param>
        /// <param name="criteriaAllOf"> The rule criteria that defines the conditions of the scheduled query rule. </param>
        /// <param name="muteActionsDuration"> Mute actions for the chosen period of time (in ISO 8601 duration format) after the alert is fired. Relevant only for rules of the kind LogAlert. </param>
        /// <param name="actions"> Actions to invoke when the alert fires. </param>
        /// <param name="isWorkspaceAlertsStorageConfigured"> The flag which indicates whether this scheduled query rule has been configured to be stored in the customer&apos;s storage. The default is false. </param>
        /// <param name="checkWorkspaceAlertsStorageConfigured"> The flag which indicates whether this scheduled query rule should be stored in the customer&apos;s storage. The default is false. Relevant only for rules of the kind LogAlert. </param>
        /// <param name="skipQueryValidation"> The flag which indicates whether the provided query should be validated or not. The default is false. Relevant only for rules of the kind LogAlert. </param>
        /// <param name="autoMitigate"> The flag that indicates whether the alert should be automatically resolved or not. The default is true. Relevant only for rules of the kind LogAlert. </param>
        /// <returns> A new <see cref="Monitor.ScheduledQueryRuleData"/> instance for mocking. </returns>
        public static ScheduledQueryRuleData ScheduledQueryRuleData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ScheduledQueryRuleKind? kind = null, ETag? etag = null, string createdWithApiVersion = null, bool? isLegacyLogAnalyticsRule = null, string description = null, string displayName = null, AlertSeverity? severity = null, bool? isEnabled = null, IEnumerable<string> scopes = null, TimeSpan? evaluationFrequency = null, TimeSpan? windowSize = null, TimeSpan? overrideQueryTimeRange = null, IEnumerable<string> targetResourceTypes = null, IEnumerable<ScheduledQueryRuleCondition> criteriaAllOf = null, TimeSpan? muteActionsDuration = null, ScheduledQueryRuleActions actions = null, bool? isWorkspaceAlertsStorageConfigured = null, bool? checkWorkspaceAlertsStorageConfigured = null, bool? skipQueryValidation = null, bool? autoMitigate = null)
        {
            tags ??= new Dictionary<string, string>();
            scopes ??= new List<string>();
            targetResourceTypes ??= new List<string>();
            criteriaAllOf ??= new List<ScheduledQueryRuleCondition>();

            return new ScheduledQueryRuleData(id, name, resourceType, systemData, tags, location, kind, etag, createdWithApiVersion, isLegacyLogAnalyticsRule, description, displayName, severity, isEnabled, scopes?.ToList(), evaluationFrequency, windowSize, overrideQueryTimeRange, targetResourceTypes?.ToList(), criteriaAllOf != null ? new ScheduledQueryRuleCriteria(criteriaAllOf?.ToList()) : null, muteActionsDuration, actions, isWorkspaceAlertsStorageConfigured, checkWorkspaceAlertsStorageConfigured, skipQueryValidation, autoMitigate);
        }

        /// <summary> Initializes a new instance of ScheduledQueryRuleCondition. </summary>
        /// <param name="query"> Log query alert. </param>
        /// <param name="timeAggregation"> Aggregation type. Relevant and required only for rules of the kind LogAlert. </param>
        /// <param name="metricMeasureColumn"> The column containing the metric measure number. Relevant only for rules of the kind LogAlert. </param>
        /// <param name="resourceIdColumn"> The column containing the resource id. The content of the column must be a uri formatted as resource id. Relevant only for rules of the kind LogAlert. </param>
        /// <param name="dimensions"> List of Dimensions conditions. </param>
        /// <param name="operator"> The criteria operator. Relevant and required only for rules of the kind LogAlert. </param>
        /// <param name="threshold"> the criteria threshold value that activates the alert. Relevant and required only for rules of the kind LogAlert. </param>
        /// <param name="failingPeriods"> The minimum number of violations required within the selected lookback time window required to raise an alert. Relevant only for rules of the kind LogAlert. </param>
        /// <param name="metricName"> The name of the metric to be sent. Relevant and required only for rules of the kind LogToMetric. </param>
        /// <returns> A new <see cref="Models.ScheduledQueryRuleCondition"/> instance for mocking. </returns>
        public static ScheduledQueryRuleCondition ScheduledQueryRuleCondition(string query = null, ScheduledQueryRuleTimeAggregationType? timeAggregation = null, string metricMeasureColumn = null, string resourceIdColumn = null, IEnumerable<MonitorDimension> dimensions = null, MonitorConditionOperator? @operator = null, double? threshold = null, ConditionFailingPeriods failingPeriods = null, string metricName = null)
        {
            dimensions ??= new List<MonitorDimension>();

            return new ScheduledQueryRuleCondition(query, timeAggregation, metricMeasureColumn, resourceIdColumn, dimensions?.ToList(), @operator, threshold, failingPeriods, metricName);
        }

        /// <summary> Initializes a new instance of ConditionFailingPeriods. </summary>
        /// <param name="numberOfEvaluationPeriods"> The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (windowSize) and the selected number of aggregated points. Default value is 1. </param>
        /// <param name="minFailingPeriodsToAlert"> The number of violations to trigger an alert. Should be smaller or equal to numberOfEvaluationPeriods. Default value is 1. </param>
        /// <returns> A new <see cref="Models.ConditionFailingPeriods"/> instance for mocking. </returns>
        public static ConditionFailingPeriods ConditionFailingPeriods(long? numberOfEvaluationPeriods = null, long? minFailingPeriodsToAlert = null)
        {
            return new ConditionFailingPeriods(numberOfEvaluationPeriods, minFailingPeriodsToAlert);
        }

        /// <summary> Initializes a new instance of ScheduledQueryRuleActions. </summary>
        /// <param name="actionGroups"> Action Group resource Ids to invoke when the alert fires. </param>
        /// <param name="customProperties"> The properties of an alert payload. </param>
        /// <returns> A new <see cref="Models.ScheduledQueryRuleActions"/> instance for mocking. </returns>
        public static ScheduledQueryRuleActions ScheduledQueryRuleActions(IEnumerable<string> actionGroups = null, IDictionary<string, string> customProperties = null)
        {
            actionGroups ??= new List<string>();
            customProperties ??= new Dictionary<string, string>();

            return new ScheduledQueryRuleActions(actionGroups?.ToList(), customProperties);
        }

        /// <summary> Initializes a new instance of VmInsightsOnboardingStatusData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="resourceId"> Azure Resource Manager identifier of the resource whose onboarding status is being represented. </param>
        /// <param name="onboardingStatus"> The onboarding status for the resource. Note that, a higher level scope, e.g., resource group or subscription, is considered onboarded if at least one resource under it is onboarded. </param>
        /// <param name="dataStatus"> The status of VM Insights data from the resource. When reported as `present` the data array will contain information about the data containers to which data for the specified resource is being routed. </param>
        /// <param name="data"> Containers that currently store VM Insights data for the specified resource. </param>
        /// <returns> A new <see cref="Monitor.VmInsightsOnboardingStatusData"/> instance for mocking. </returns>
        public static VmInsightsOnboardingStatusData VmInsightsOnboardingStatusData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ResourceIdentifier resourceId = null, OnboardingStatus? onboardingStatus = null, DataStatus? dataStatus = null, IEnumerable<DataContainer> data = null)
        {
            data ??= new List<DataContainer>();

            return new VmInsightsOnboardingStatusData(id, name, resourceType, systemData, resourceId, onboardingStatus, dataStatus, data?.ToList());
        }

        /// <summary> Initializes a new instance of DataContainer. </summary>
        /// <param name="workspace"> Log Analytics workspace information. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="workspace"/> is null. </exception>
        /// <returns> A new <see cref="Models.DataContainer"/> instance for mocking. </returns>
        public static DataContainer DataContainer(DataContainerWorkspace workspace = null)
        {
            if (workspace == null)
            {
                throw new ArgumentNullException(nameof(workspace));
            }

            return new DataContainer(workspace);
        }

        /// <summary> Initializes a new instance of DataContainerWorkspace. </summary>
        /// <param name="id"> Azure Resource Manager identifier of the Log Analytics Workspace. </param>
        /// <param name="location"> Location of the Log Analytics workspace. </param>
        /// <param name="customerId"> Log Analytics workspace identifier. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="id"/> or <paramref name="customerId"/> is null. </exception>
        /// <returns> A new <see cref="Models.DataContainerWorkspace"/> instance for mocking. </returns>
        public static DataContainerWorkspace DataContainerWorkspace(ResourceIdentifier id = null, AzureLocation location = default, string customerId = null)
        {
            if (id == null)
            {
                throw new ArgumentNullException(nameof(id));
            }
            if (customerId == null)
            {
                throw new ArgumentNullException(nameof(customerId));
            }

            return new DataContainerWorkspace(id, location, customerId);
        }

        /// <summary> Initializes a new instance of MonitorPrivateLinkScopeData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="provisioningState"> Current state of this PrivateLinkScope: whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Provisioning ,Succeeded, Canceled and Failed. </param>
        /// <param name="privateEndpointConnections"> List of private endpoint connections. </param>
        /// <param name="accessModeSettings"> Access mode settings. </param>
        /// <returns> A new <see cref="Monitor.MonitorPrivateLinkScopeData"/> instance for mocking. </returns>
        public static MonitorPrivateLinkScopeData MonitorPrivateLinkScopeData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, string provisioningState = null, IEnumerable<MonitorPrivateEndpointConnectionData> privateEndpointConnections = null, MonitorPrivateLinkAccessModeSettings accessModeSettings = null)
        {
            tags ??= new Dictionary<string, string>();
            privateEndpointConnections ??= new List<MonitorPrivateEndpointConnectionData>();

            return new MonitorPrivateLinkScopeData(id, name, resourceType, systemData, tags, location, provisioningState, privateEndpointConnections?.ToList(), accessModeSettings);
        }

        /// <summary> Initializes a new instance of MonitorPrivateEndpointConnectionData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="privateEndpointId"> The resource of private end point. </param>
        /// <param name="connectionState"> A collection of information about the state of the connection between service consumer and provider. </param>
        /// <param name="provisioningState"> The provisioning state of the private endpoint connection resource. </param>
        /// <returns> A new <see cref="Monitor.MonitorPrivateEndpointConnectionData"/> instance for mocking. </returns>
        public static MonitorPrivateEndpointConnectionData MonitorPrivateEndpointConnectionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ResourceIdentifier privateEndpointId = null, MonitorPrivateLinkServiceConnectionState connectionState = null, MonitorPrivateEndpointConnectionProvisioningState? provisioningState = null)
        {
            return new MonitorPrivateEndpointConnectionData(id, name, resourceType, systemData, privateEndpointId != null ? ResourceManagerModelFactory.SubResource(privateEndpointId) : null, connectionState, provisioningState);
        }

        /// <summary> Initializes a new instance of MonitorPrivateLinkServiceConnectionState. </summary>
        /// <param name="status"> Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service. </param>
        /// <param name="description"> The reason for approval/rejection of the connection. </param>
        /// <param name="actionsRequired"> A message indicating if changes on the service provider require any updates on the consumer. </param>
        /// <returns> A new <see cref="Models.MonitorPrivateLinkServiceConnectionState"/> instance for mocking. </returns>
        public static MonitorPrivateLinkServiceConnectionState MonitorPrivateLinkServiceConnectionState(MonitorPrivateEndpointServiceConnectionStatus? status = null, string description = null, string actionsRequired = null)
        {
            return new MonitorPrivateLinkServiceConnectionState(status, description, actionsRequired);
        }

        /// <summary> Initializes a new instance of MonitorPrivateLinkAccessModeSettings. </summary>
        /// <param name="queryAccessMode"> Specifies the default access mode of queries through associated private endpoints in scope. If not specified default value is &apos;Open&apos;. You can override this default setting for a specific private endpoint connection by adding an exclusion in the &apos;exclusions&apos; array. </param>
        /// <param name="ingestionAccessMode"> Specifies the default access mode of ingestion through associated private endpoints in scope. If not specified default value is &apos;Open&apos;. You can override this default setting for a specific private endpoint connection by adding an exclusion in the &apos;exclusions&apos; array. </param>
        /// <param name="exclusions"> List of exclusions that override the default access mode settings for specific private endpoint connections. </param>
        /// <returns> A new <see cref="Models.MonitorPrivateLinkAccessModeSettings"/> instance for mocking. </returns>
        public static MonitorPrivateLinkAccessModeSettings MonitorPrivateLinkAccessModeSettings(MonitorPrivateLinkAccessMode queryAccessMode = default, MonitorPrivateLinkAccessMode ingestionAccessMode = default, IEnumerable<MonitorPrivateLinkAccessModeSettingsExclusion> exclusions = null)
        {
            exclusions ??= new List<MonitorPrivateLinkAccessModeSettingsExclusion>();

            return new MonitorPrivateLinkAccessModeSettings(queryAccessMode, ingestionAccessMode, exclusions?.ToList());
        }

        /// <summary> Initializes a new instance of MonitorPrivateLinkAccessModeSettingsExclusion. </summary>
        /// <param name="privateEndpointConnectionName"> The private endpoint connection name associated to the private endpoint on which we want to apply the specific access mode settings. </param>
        /// <param name="queryAccessMode"> Specifies the access mode of queries through the specified private endpoint connection in the exclusion. </param>
        /// <param name="ingestionAccessMode"> Specifies the access mode of ingestion through the specified private endpoint connection in the exclusion. </param>
        /// <returns> A new <see cref="Models.MonitorPrivateLinkAccessModeSettingsExclusion"/> instance for mocking. </returns>
        public static MonitorPrivateLinkAccessModeSettingsExclusion MonitorPrivateLinkAccessModeSettingsExclusion(string privateEndpointConnectionName = null, MonitorPrivateLinkAccessMode? queryAccessMode = null, MonitorPrivateLinkAccessMode? ingestionAccessMode = null)
        {
            return new MonitorPrivateLinkAccessModeSettingsExclusion(privateEndpointConnectionName, queryAccessMode, ingestionAccessMode);
        }

        /// <summary> Initializes a new instance of MonitorPrivateLinkScopeOperationStatus. </summary>
        /// <param name="id"> The operation Id. </param>
        /// <param name="name"> The operation name. </param>
        /// <param name="startOn"> Start time of the job in standard ISO8601 format. </param>
        /// <param name="endOn"> End time of the job in standard ISO8601 format. </param>
        /// <param name="status"> The status of the operation. </param>
        /// <param name="error"> The error detail of the operation if any. </param>
        /// <returns> A new <see cref="Models.MonitorPrivateLinkScopeOperationStatus"/> instance for mocking. </returns>
        public static MonitorPrivateLinkScopeOperationStatus MonitorPrivateLinkScopeOperationStatus(string id = null, string name = null, DateTimeOffset? startOn = null, DateTimeOffset? endOn = null, string status = null, ResponseError error = null)
        {
            return new MonitorPrivateLinkScopeOperationStatus(id, name, startOn, endOn, status, error);
        }

        /// <summary> Initializes a new instance of MonitorPrivateLinkResourceData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="groupId"> The private link resource group id. </param>
        /// <param name="requiredMembers"> The private link resource required member names. </param>
        /// <param name="requiredZoneNames"> The private link resource Private link DNS zone name. </param>
        /// <returns> A new <see cref="Monitor.MonitorPrivateLinkResourceData"/> instance for mocking. </returns>
        public static MonitorPrivateLinkResourceData MonitorPrivateLinkResourceData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string groupId = null, IEnumerable<string> requiredMembers = null, IEnumerable<string> requiredZoneNames = null)
        {
            requiredMembers ??= new List<string>();
            requiredZoneNames ??= new List<string>();

            return new MonitorPrivateLinkResourceData(id, name, resourceType, systemData, groupId, requiredMembers?.ToList(), requiredZoneNames?.ToList());
        }

        /// <summary> Initializes a new instance of MonitorPrivateLinkScopedResourceData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="linkedResourceId"> The resource id of the scoped Azure monitor resource. </param>
        /// <param name="provisioningState"> State of the private endpoint connection. </param>
        /// <returns> A new <see cref="Monitor.MonitorPrivateLinkScopedResourceData"/> instance for mocking. </returns>
        public static MonitorPrivateLinkScopedResourceData MonitorPrivateLinkScopedResourceData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ResourceIdentifier linkedResourceId = null, string provisioningState = null)
        {
            return new MonitorPrivateLinkScopedResourceData(id, name, resourceType, systemData, linkedResourceId, provisioningState);
        }

        /// <summary> Initializes a new instance of ActivityLogAlertData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="scopes"> A list of resource IDs that will be used as prefixes. The alert will only apply to Activity Log events with resource IDs that fall under one of these prefixes. This list must include at least one item. </param>
        /// <param name="conditionAllOf"> The condition that will cause this alert to activate. </param>
        /// <param name="actionsActionGroups"> The actions that will activate when the condition is met. </param>
        /// <param name="isEnabled"> Indicates whether this Activity Log Alert rule is enabled. If an Activity Log Alert rule is not enabled, then none of its actions will be activated. </param>
        /// <param name="description"> A description of this Activity Log Alert rule. </param>
        /// <returns> A new <see cref="Monitor.ActivityLogAlertData"/> instance for mocking. </returns>
        public static ActivityLogAlertData ActivityLogAlertData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, IEnumerable<string> scopes = null, IEnumerable<ActivityLogAlertAnyOfOrLeafCondition> conditionAllOf = null, IEnumerable<ActivityLogAlertActionGroup> actionsActionGroups = null, bool? isEnabled = null, string description = null)
        {
            tags ??= new Dictionary<string, string>();
            scopes ??= new List<string>();
            conditionAllOf ??= new List<ActivityLogAlertAnyOfOrLeafCondition>();
            actionsActionGroups ??= new List<ActivityLogAlertActionGroup>();

            return new ActivityLogAlertData(id, name, resourceType, systemData, tags, location, scopes?.ToList(), conditionAllOf != null ? new AlertRuleAllOfCondition(conditionAllOf?.ToList()) : null, actionsActionGroups != null ? new ActionList(actionsActionGroups?.ToList()) : null, isEnabled, description);
        }

        /// <summary> Initializes a new instance of ActivityLogAlertAnyOfOrLeafCondition. </summary>
        /// <param name="field">
        /// The name of the Activity Log event&apos;s field that this condition will examine.
        /// The possible values for this field are (case-insensitive): &apos;resourceId&apos;, &apos;category&apos;, &apos;caller&apos;, &apos;level&apos;, &apos;operationName&apos;, &apos;resourceGroup&apos;, &apos;resourceProvider&apos;, &apos;status&apos;, &apos;subStatus&apos;, &apos;resourceType&apos;, or anything beginning with &apos;properties&apos;.
        /// </param>
        /// <param name="equalsValue"> The value of the event&apos;s field will be compared to this value (case-insensitive) to determine if the condition is met. </param>
        /// <param name="containsAny"> The value of the event&apos;s field will be compared to the values in this array (case-insensitive) to determine if the condition is met. </param>
        /// <param name="anyOf"> An Activity Log Alert rule condition that is met when at least one of its member leaf conditions are met. </param>
        /// <returns> A new <see cref="Models.ActivityLogAlertAnyOfOrLeafCondition"/> instance for mocking. </returns>
        public static ActivityLogAlertAnyOfOrLeafCondition ActivityLogAlertAnyOfOrLeafCondition(string field = null, string equalsValue = null, IEnumerable<string> containsAny = null, IEnumerable<AlertRuleLeafCondition> anyOf = null)
        {
            containsAny ??= new List<string>();
            anyOf ??= new List<AlertRuleLeafCondition>();

            return new ActivityLogAlertAnyOfOrLeafCondition(field, equalsValue, containsAny?.ToList(), anyOf?.ToList());
        }

        /// <summary> Initializes a new instance of AlertRuleLeafCondition. </summary>
        /// <param name="field">
        /// The name of the Activity Log event&apos;s field that this condition will examine.
        /// The possible values for this field are (case-insensitive): &apos;resourceId&apos;, &apos;category&apos;, &apos;caller&apos;, &apos;level&apos;, &apos;operationName&apos;, &apos;resourceGroup&apos;, &apos;resourceProvider&apos;, &apos;status&apos;, &apos;subStatus&apos;, &apos;resourceType&apos;, or anything beginning with &apos;properties&apos;.
        /// </param>
        /// <param name="equalsValue"> The value of the event&apos;s field will be compared to this value (case-insensitive) to determine if the condition is met. </param>
        /// <param name="containsAny"> The value of the event&apos;s field will be compared to the values in this array (case-insensitive) to determine if the condition is met. </param>
        /// <returns> A new <see cref="Models.AlertRuleLeafCondition"/> instance for mocking. </returns>
        public static AlertRuleLeafCondition AlertRuleLeafCondition(string field = null, string equalsValue = null, IEnumerable<string> containsAny = null)
        {
            containsAny ??= new List<string>();

            return new AlertRuleLeafCondition(field, equalsValue, containsAny?.ToList());
        }

        /// <summary> Initializes a new instance of ActivityLogAlertActionGroup. </summary>
        /// <param name="actionGroupId"> The resource ID of the Action Group. This cannot be null or empty. </param>
        /// <param name="webhookProperties"> the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload. </param>
        /// <returns> A new <see cref="Models.ActivityLogAlertActionGroup"/> instance for mocking. </returns>
        public static ActivityLogAlertActionGroup ActivityLogAlertActionGroup(ResourceIdentifier actionGroupId = null, IDictionary<string, string> webhookProperties = null)
        {
            webhookProperties ??= new Dictionary<string, string>();

            return new ActivityLogAlertActionGroup(actionGroupId, webhookProperties);
        }

        /// <summary> Initializes a new instance of DataCollectionEndpointData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="kind"> The kind of the resource. </param>
        /// <param name="etag"> Resource entity tag (ETag). </param>
        /// <param name="description"> Description of the data collection endpoint. </param>
        /// <param name="immutableId"> The immutable ID of this data collection endpoint resource. This property is READ-ONLY. </param>
        /// <param name="configurationAccessEndpoint"> The endpoint used by clients to access their configuration. </param>
        /// <param name="logsIngestionEndpoint"> The endpoint used by clients to ingest logs. </param>
        /// <param name="publicNetworkAccess"> Network access control rules for the endpoints. </param>
        /// <param name="provisioningState"> The resource provisioning state. This property is READ-ONLY. </param>
        /// <returns> A new <see cref="Monitor.DataCollectionEndpointData"/> instance for mocking. </returns>
        public static DataCollectionEndpointData DataCollectionEndpointData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, DataCollectionEndpointResourceKind? kind = null, ETag? etag = null, string description = null, string immutableId = null, string configurationAccessEndpoint = null, string logsIngestionEndpoint = null, MonitorPublicNetworkAccess? publicNetworkAccess = null, DataCollectionEndpointProvisioningState? provisioningState = null)
        {
            tags ??= new Dictionary<string, string>();

            return new DataCollectionEndpointData(id, name, resourceType, systemData, tags, location, kind, etag, description, immutableId, configurationAccessEndpoint != null ? new DataCollectionEndpointConfigurationAccess(configurationAccessEndpoint) : null, logsIngestionEndpoint != null ? new DataCollectionEndpointLogsIngestion(logsIngestionEndpoint) : null, publicNetworkAccess != null ? new DataCollectionEndpointNetworkAcls(publicNetworkAccess) : null, provisioningState);
        }

        /// <summary> Initializes a new instance of DataCollectionRuleAssociationData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="etag"> Resource entity tag (ETag). </param>
        /// <param name="description"> Description of the association. </param>
        /// <param name="dataCollectionRuleId"> The resource ID of the data collection rule that is to be associated. </param>
        /// <param name="dataCollectionEndpointId"> The resource ID of the data collection endpoint that is to be associated. </param>
        /// <param name="provisioningState"> The resource provisioning state. </param>
        /// <param name="metadataProvisionedBy"> Metadata about the resource. </param>
        /// <returns> A new <see cref="Monitor.DataCollectionRuleAssociationData"/> instance for mocking. </returns>
        public static DataCollectionRuleAssociationData DataCollectionRuleAssociationData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ETag? etag = null, string description = null, ResourceIdentifier dataCollectionRuleId = null, ResourceIdentifier dataCollectionEndpointId = null, DataCollectionRuleAssociationProvisioningState? provisioningState = null, string metadataProvisionedBy = null)
        {
            return new DataCollectionRuleAssociationData(id, name, resourceType, systemData, etag, description, dataCollectionRuleId, dataCollectionEndpointId, provisioningState, metadataProvisionedBy != null ? new DataCollectionRuleAssociationMetadata(metadataProvisionedBy) : null);
        }

        /// <summary> Initializes a new instance of DataCollectionRuleData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="kind"> The kind of the resource. </param>
        /// <param name="etag"> Resource entity tag (ETag). </param>
        /// <param name="description"> Description of the data collection rule. </param>
        /// <param name="immutableId"> The immutable ID of this data collection rule. This property is READ-ONLY. </param>
        /// <param name="dataCollectionEndpointId"> The resource ID of the data collection endpoint that this rule can be used with. </param>
        /// <param name="metadataProvisionedBy"> Metadata about the resource. </param>
        /// <param name="streamDeclarations"> Declaration of custom streams used in this rule. </param>
        /// <param name="dataSources">
        /// The specification of data sources. 
        /// This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned endpoint.
        /// </param>
        /// <param name="destinations"> The specification of destinations. </param>
        /// <param name="dataFlows"> The specification of data flows. </param>
        /// <param name="provisioningState"> The resource provisioning state. </param>
        /// <returns> A new <see cref="Monitor.DataCollectionRuleData"/> instance for mocking. </returns>
        public static DataCollectionRuleData DataCollectionRuleData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, DataCollectionRuleResourceKind? kind = null, ETag? etag = null, string description = null, string immutableId = null, ResourceIdentifier dataCollectionEndpointId = null, string metadataProvisionedBy = null, IDictionary<string, DataStreamDeclaration> streamDeclarations = null, DataCollectionRuleDataSources dataSources = null, DataCollectionRuleDestinations destinations = null, IEnumerable<DataFlow> dataFlows = null, DataCollectionRuleProvisioningState? provisioningState = null)
        {
            tags ??= new Dictionary<string, string>();
            streamDeclarations ??= new Dictionary<string, DataStreamDeclaration>();
            dataFlows ??= new List<DataFlow>();

            return new DataCollectionRuleData(id, name, resourceType, systemData, tags, location, kind, etag, description, immutableId, dataCollectionEndpointId, metadataProvisionedBy != null ? new DataCollectionRuleMetadata(metadataProvisionedBy) : null, streamDeclarations, dataSources, destinations, dataFlows?.ToList(), provisioningState);
        }

        /// <summary> Initializes a new instance of DataStreamDeclaration. </summary>
        /// <param name="columns"> List of columns used by data in this stream. </param>
        /// <returns> A new <see cref="Models.DataStreamDeclaration"/> instance for mocking. </returns>
        public static DataStreamDeclaration DataStreamDeclaration(IEnumerable<DataColumnDefinition> columns = null)
        {
            columns ??= new List<DataColumnDefinition>();

            return new DataStreamDeclaration(columns?.ToList());
        }

        /// <summary> Initializes a new instance of DataColumnDefinition. </summary>
        /// <param name="name"> The name of the column. </param>
        /// <param name="definitionType"> The type of the column data. </param>
        /// <returns> A new <see cref="Models.DataColumnDefinition"/> instance for mocking. </returns>
        public static DataColumnDefinition DataColumnDefinition(string name = null, DataColumnDefinitionType? definitionType = null)
        {
            return new DataColumnDefinition(name, definitionType);
        }

        /// <summary> Initializes a new instance of DataCollectionRuleDataSources. </summary>
        /// <param name="performanceCounters"> The list of performance counter data source configurations. </param>
        /// <param name="windowsEventLogs"> The list of Windows Event Log data source configurations. </param>
        /// <param name="syslog"> The list of Syslog data source configurations. </param>
        /// <param name="extensions"> The list of Azure VM extension data source configurations. </param>
        /// <param name="logFiles"> The list of Log files source configurations. </param>
        /// <param name="iisLogs"> The list of IIS logs source configurations. </param>
        /// <returns> A new <see cref="Models.DataCollectionRuleDataSources"/> instance for mocking. </returns>
        public static DataCollectionRuleDataSources DataCollectionRuleDataSources(IEnumerable<PerfCounterDataSource> performanceCounters = null, IEnumerable<WindowsEventLogDataSource> windowsEventLogs = null, IEnumerable<SyslogDataSource> syslog = null, IEnumerable<ExtensionDataSource> extensions = null, IEnumerable<LogFilesDataSource> logFiles = null, IEnumerable<IisLogsDataSource> iisLogs = null)
        {
            performanceCounters ??= new List<PerfCounterDataSource>();
            windowsEventLogs ??= new List<WindowsEventLogDataSource>();
            syslog ??= new List<SyslogDataSource>();
            extensions ??= new List<ExtensionDataSource>();
            logFiles ??= new List<LogFilesDataSource>();
            iisLogs ??= new List<IisLogsDataSource>();

            return new DataCollectionRuleDataSources(performanceCounters?.ToList(), windowsEventLogs?.ToList(), syslog?.ToList(), extensions?.ToList(), logFiles?.ToList(), iisLogs?.ToList());
        }

        /// <summary> Initializes a new instance of DataSourcesSpec. </summary>
        /// <param name="performanceCounters"> The list of performance counter data source configurations. </param>
        /// <param name="windowsEventLogs"> The list of Windows Event Log data source configurations. </param>
        /// <param name="syslog"> The list of Syslog data source configurations. </param>
        /// <param name="extensions"> The list of Azure VM extension data source configurations. </param>
        /// <param name="logFiles"> The list of Log files source configurations. </param>
        /// <param name="iisLogs"> The list of IIS logs source configurations. </param>
        /// <returns> A new <see cref="Models.DataSourcesSpec"/> instance for mocking. </returns>
        public static DataSourcesSpec DataSourcesSpec(IEnumerable<PerfCounterDataSource> performanceCounters = null, IEnumerable<WindowsEventLogDataSource> windowsEventLogs = null, IEnumerable<SyslogDataSource> syslog = null, IEnumerable<ExtensionDataSource> extensions = null, IEnumerable<LogFilesDataSource> logFiles = null, IEnumerable<IisLogsDataSource> iisLogs = null)
        {
            performanceCounters ??= new List<PerfCounterDataSource>();
            windowsEventLogs ??= new List<WindowsEventLogDataSource>();
            syslog ??= new List<SyslogDataSource>();
            extensions ??= new List<ExtensionDataSource>();
            logFiles ??= new List<LogFilesDataSource>();
            iisLogs ??= new List<IisLogsDataSource>();

            return new DataSourcesSpec(performanceCounters?.ToList(), windowsEventLogs?.ToList(), syslog?.ToList(), extensions?.ToList(), logFiles?.ToList(), iisLogs?.ToList());
        }

        /// <summary> Initializes a new instance of PerfCounterDataSource. </summary>
        /// <param name="streams">
        /// List of streams that this data source will be sent to.
        /// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        /// </param>
        /// <param name="samplingFrequencyInSeconds"> The number of seconds between consecutive counter measurements (samples). </param>
        /// <param name="counterSpecifiers">
        /// A list of specifier names of the performance counters you want to collect.
        /// Use a wildcard (*) to collect a counter for all instances.
        /// To get a list of performance counters on Windows, run the command &apos;typeperf&apos;.
        /// </param>
        /// <param name="name">
        /// A friendly name for the data source. 
        /// This name should be unique across all data sources (regardless of type) within the data collection rule.
        /// </param>
        /// <returns> A new <see cref="Models.PerfCounterDataSource"/> instance for mocking. </returns>
        public static PerfCounterDataSource PerfCounterDataSource(IEnumerable<PerfCounterDataSourceStream> streams = null, int? samplingFrequencyInSeconds = null, IEnumerable<string> counterSpecifiers = null, string name = null)
        {
            streams ??= new List<PerfCounterDataSourceStream>();
            counterSpecifiers ??= new List<string>();

            return new PerfCounterDataSource(streams?.ToList(), samplingFrequencyInSeconds, counterSpecifiers?.ToList(), name);
        }

        /// <summary> Initializes a new instance of WindowsEventLogDataSource. </summary>
        /// <param name="streams">
        /// List of streams that this data source will be sent to.
        /// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        /// </param>
        /// <param name="xPathQueries"> A list of Windows Event Log queries in XPATH format. </param>
        /// <param name="name">
        /// A friendly name for the data source. 
        /// This name should be unique across all data sources (regardless of type) within the data collection rule.
        /// </param>
        /// <returns> A new <see cref="Models.WindowsEventLogDataSource"/> instance for mocking. </returns>
        public static WindowsEventLogDataSource WindowsEventLogDataSource(IEnumerable<WindowsEventLogDataSourceStream> streams = null, IEnumerable<string> xPathQueries = null, string name = null)
        {
            streams ??= new List<WindowsEventLogDataSourceStream>();
            xPathQueries ??= new List<string>();

            return new WindowsEventLogDataSource(streams?.ToList(), xPathQueries?.ToList(), name);
        }

        /// <summary> Initializes a new instance of SyslogDataSource. </summary>
        /// <param name="streams">
        /// List of streams that this data source will be sent to.
        /// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        /// </param>
        /// <param name="facilityNames"> The list of facility names. </param>
        /// <param name="logLevels"> The log levels to collect. </param>
        /// <param name="name">
        /// A friendly name for the data source. 
        /// This name should be unique across all data sources (regardless of type) within the data collection rule.
        /// </param>
        /// <returns> A new <see cref="Models.SyslogDataSource"/> instance for mocking. </returns>
        public static SyslogDataSource SyslogDataSource(IEnumerable<SyslogDataSourceStream> streams = null, IEnumerable<SyslogDataSourceFacilityName> facilityNames = null, IEnumerable<SyslogDataSourceLogLevel> logLevels = null, string name = null)
        {
            streams ??= new List<SyslogDataSourceStream>();
            facilityNames ??= new List<SyslogDataSourceFacilityName>();
            logLevels ??= new List<SyslogDataSourceLogLevel>();

            return new SyslogDataSource(streams?.ToList(), facilityNames?.ToList(), logLevels?.ToList(), name);
        }

        /// <summary> Initializes a new instance of ExtensionDataSource. </summary>
        /// <param name="streams">
        /// List of streams that this data source will be sent to.
        /// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
        /// </param>
        /// <param name="extensionName"> The name of the VM extension. </param>
        /// <param name="extensionSettings"> The extension settings. The format is specific for particular extension. </param>
        /// <param name="inputDataSources"> The list of data sources this extension needs data from. </param>
        /// <param name="name">
        /// A friendly name for the data source. 
        /// This name should be unique across all data sources (regardless of type) within the data collection rule.
        /// </param>
        /// <returns> A new <see cref="Models.ExtensionDataSource"/> instance for mocking. </returns>
        public static ExtensionDataSource ExtensionDataSource(IEnumerable<ExtensionDataSourceStream> streams = null, string extensionName = null, BinaryData extensionSettings = null, IEnumerable<string> inputDataSources = null, string name = null)
        {
            streams ??= new List<ExtensionDataSourceStream>();
            inputDataSources ??= new List<string>();

            return new ExtensionDataSource(streams?.ToList(), extensionName, extensionSettings, inputDataSources?.ToList(), name);
        }

        /// <summary> Initializes a new instance of LogFilesDataSource. </summary>
        /// <param name="streams">
        /// List of streams that this data source will be sent to.
        /// A stream indicates what schema will be used for this data source
        /// </param>
        /// <param name="filePatterns"> File Patterns where the log files are located. </param>
        /// <param name="format"> The data format of the log files. </param>
        /// <param name="textRecordStartTimestampFormat"> The log files specific settings. </param>
        /// <param name="name">
        /// A friendly name for the data source. 
        /// This name should be unique across all data sources (regardless of type) within the data collection rule.
        /// </param>
        /// <returns> A new <see cref="Models.LogFilesDataSource"/> instance for mocking. </returns>
        public static LogFilesDataSource LogFilesDataSource(IEnumerable<string> streams = null, IEnumerable<string> filePatterns = null, LogFilesDataSourceFormat format = default, LogFileTextSettingsRecordStartTimestampFormat? textRecordStartTimestampFormat = null, string name = null)
        {
            streams ??= new List<string>();
            filePatterns ??= new List<string>();

            return new LogFilesDataSource(streams?.ToList(), filePatterns?.ToList(), format, textRecordStartTimestampFormat.HasValue ? new LogFilesDataSourceSettings(new LogFileSettingsText(textRecordStartTimestampFormat.Value)) : null, name);
        }

        /// <summary> Initializes a new instance of IisLogsDataSource. </summary>
        /// <param name="streams"> IIS streams. </param>
        /// <param name="logDirectories"> Absolute paths file location. </param>
        /// <param name="name">
        /// A friendly name for the data source. 
        /// This name should be unique across all data sources (regardless of type) within the data collection rule.
        /// </param>
        /// <returns> A new <see cref="Models.IisLogsDataSource"/> instance for mocking. </returns>
        public static IisLogsDataSource IisLogsDataSource(IEnumerable<string> streams = null, IEnumerable<string> logDirectories = null, string name = null)
        {
            streams ??= new List<string>();
            logDirectories ??= new List<string>();

            return new IisLogsDataSource(streams?.ToList(), logDirectories?.ToList(), name);
        }

        /// <summary> Initializes a new instance of DataCollectionRuleDestinations. </summary>
        /// <param name="logAnalytics"> List of Log Analytics destinations. </param>
        /// <param name="azureMonitorMetricsName"> Azure Monitor Metrics destination. </param>
        /// <returns> A new <see cref="Models.DataCollectionRuleDestinations"/> instance for mocking. </returns>
        public static DataCollectionRuleDestinations DataCollectionRuleDestinations(IEnumerable<LogAnalyticsDestination> logAnalytics = null, string azureMonitorMetricsName = null)
        {
            logAnalytics ??= new List<LogAnalyticsDestination>();

            return new DataCollectionRuleDestinations(logAnalytics?.ToList(), azureMonitorMetricsName != null ? new DestinationsSpecAzureMonitorMetrics(azureMonitorMetricsName) : null);
        }

        /// <summary> Initializes a new instance of DestinationsSpec. </summary>
        /// <param name="logAnalytics"> List of Log Analytics destinations. </param>
        /// <param name="azureMonitorMetricsName"> Azure Monitor Metrics destination. </param>
        /// <returns> A new <see cref="Models.DestinationsSpec"/> instance for mocking. </returns>
        public static DestinationsSpec DestinationsSpec(IEnumerable<LogAnalyticsDestination> logAnalytics = null, string azureMonitorMetricsName = null)
        {
            logAnalytics ??= new List<LogAnalyticsDestination>();

            return new DestinationsSpec(logAnalytics?.ToList(), azureMonitorMetricsName != null ? new DestinationsSpecAzureMonitorMetrics(azureMonitorMetricsName) : null);
        }

        /// <summary> Initializes a new instance of LogAnalyticsDestination. </summary>
        /// <param name="workspaceResourceId"> The resource ID of the Log Analytics workspace. </param>
        /// <param name="workspaceId"> The Customer ID of the Log Analytics workspace. </param>
        /// <param name="name">
        /// A friendly name for the destination. 
        /// This name should be unique across all destinations (regardless of type) within the data collection rule.
        /// </param>
        /// <returns> A new <see cref="Models.LogAnalyticsDestination"/> instance for mocking. </returns>
        public static LogAnalyticsDestination LogAnalyticsDestination(ResourceIdentifier workspaceResourceId = null, string workspaceId = null, string name = null)
        {
            return new LogAnalyticsDestination(workspaceResourceId, workspaceId, name);
        }

        /// <summary> Initializes a new instance of DataFlow. </summary>
        /// <param name="streams"> List of streams for this data flow. </param>
        /// <param name="destinations"> List of destinations for this data flow. </param>
        /// <param name="transformKql"> The KQL query to transform stream data. </param>
        /// <param name="outputStream"> The output stream of the transform. Only required if the transform changes data to a different stream. </param>
        /// <returns> A new <see cref="Models.DataFlow"/> instance for mocking. </returns>
        public static DataFlow DataFlow(IEnumerable<DataFlowStream> streams = null, IEnumerable<string> destinations = null, string transformKql = null, string outputStream = null)
        {
            streams ??= new List<DataFlowStream>();
            destinations ??= new List<string>();

            return new DataFlow(streams?.ToList(), destinations?.ToList(), transformKql, outputStream);
        }

        /// <summary> Initializes a new instance of RuleMetricDataSource. </summary>
        /// <param name="resourceId"> the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule. </param>
        /// <param name="legacyResourceId"> the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule. </param>
        /// <param name="resourceLocation"> the location of the resource. </param>
        /// <param name="metricNamespace"> the namespace of the metric. </param>
        /// <param name="metricName"> the name of the metric that defines what the rule monitors. </param>
        /// <returns> A new <see cref="Models.RuleMetricDataSource"/> instance for mocking. </returns>
        public static RuleMetricDataSource RuleMetricDataSource(ResourceIdentifier resourceId = null, ResourceIdentifier legacyResourceId = null, string resourceLocation = null, string metricNamespace = null, string metricName = null)
        {
            return new RuleMetricDataSource("Microsoft.Azure.Management.Insights.Models.RuleMetricDataSource", resourceId, legacyResourceId, resourceLocation, metricNamespace, metricName);
        }

        /// <summary> Initializes a new instance of RuleManagementEventDataSource. </summary>
        /// <param name="resourceId"> the resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule. </param>
        /// <param name="legacyResourceId"> the legacy resource identifier of the resource the rule monitors. **NOTE**: this property cannot be updated for an existing rule. </param>
        /// <param name="resourceLocation"> the location of the resource. </param>
        /// <param name="metricNamespace"> the namespace of the metric. </param>
        /// <param name="eventName"> the event name. </param>
        /// <param name="eventSource"> the event source. </param>
        /// <param name="level"> the level. </param>
        /// <param name="operationName"> The name of the operation that should be checked for. If no name is provided, any operation will match. </param>
        /// <param name="resourceGroupName"> the resource group name. </param>
        /// <param name="resourceProviderName"> the resource provider name. </param>
        /// <param name="status"> The status of the operation that should be checked for. If no status is provided, any status will match. </param>
        /// <param name="subStatus"> the substatus. </param>
        /// <param name="claimsEmailAddress"> the claims. </param>
        /// <returns> A new <see cref="Models.RuleManagementEventDataSource"/> instance for mocking. </returns>
        public static RuleManagementEventDataSource RuleManagementEventDataSource(ResourceIdentifier resourceId = null, ResourceIdentifier legacyResourceId = null, string resourceLocation = null, string metricNamespace = null, string eventName = null, string eventSource = null, string level = null, string operationName = null, string resourceGroupName = null, string resourceProviderName = null, string status = null, string subStatus = null, string claimsEmailAddress = null)
        {
            return new RuleManagementEventDataSource("Microsoft.Azure.Management.Insights.Models.RuleManagementEventDataSource", resourceId, legacyResourceId, resourceLocation, metricNamespace, eventName, eventSource, level, operationName, resourceGroupName, resourceProviderName, status, subStatus, claimsEmailAddress != null ? new RuleManagementEventClaimsDataSource(claimsEmailAddress) : null);
        }

        /// <summary> Initializes a new instance of ThresholdRuleCondition. </summary>
        /// <param name="dataSource">
        /// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
        /// Please note <see cref="RuleDataSource"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="RuleManagementEventDataSource"/> and <see cref="RuleMetricDataSource"/>.
        /// </param>
        /// <param name="operator"> the operator used to compare the data and the threshold. </param>
        /// <param name="threshold"> the threshold value that activates the alert. </param>
        /// <param name="windowSize"> the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day. </param>
        /// <param name="timeAggregation"> the time aggregation operator. How the data that are collected should be combined over time. The default value is the PrimaryAggregationType of the Metric. </param>
        /// <returns> A new <see cref="Models.ThresholdRuleCondition"/> instance for mocking. </returns>
        public static ThresholdRuleCondition ThresholdRuleCondition(RuleDataSource dataSource = null, MonitorConditionOperator @operator = default, double threshold = default, TimeSpan? windowSize = null, ThresholdRuleConditionTimeAggregationType? timeAggregation = null)
        {
            return new ThresholdRuleCondition("Microsoft.Azure.Management.Insights.Models.ThresholdRuleCondition", dataSource, @operator, threshold, windowSize, timeAggregation);
        }

        /// <summary> Initializes a new instance of LocationThresholdRuleCondition. </summary>
        /// <param name="dataSource">
        /// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
        /// Please note <see cref="RuleDataSource"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="RuleManagementEventDataSource"/> and <see cref="RuleMetricDataSource"/>.
        /// </param>
        /// <param name="windowSize"> the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day. </param>
        /// <param name="failedLocationCount"> the number of locations that must fail to activate the alert. </param>
        /// <returns> A new <see cref="Models.LocationThresholdRuleCondition"/> instance for mocking. </returns>
        public static LocationThresholdRuleCondition LocationThresholdRuleCondition(RuleDataSource dataSource = null, TimeSpan? windowSize = null, int failedLocationCount = default)
        {
            return new LocationThresholdRuleCondition("Microsoft.Azure.Management.Insights.Models.LocationThresholdRuleCondition", dataSource, windowSize, failedLocationCount);
        }

        /// <summary> Initializes a new instance of ManagementEventAggregationCondition. </summary>
        /// <param name="operator"> the condition operator. </param>
        /// <param name="threshold"> The threshold value that activates the alert. </param>
        /// <param name="windowSize"> the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold. If specified then it must be between 5 minutes and 1 day. </param>
        /// <returns> A new <see cref="Models.ManagementEventAggregationCondition"/> instance for mocking. </returns>
        public static ManagementEventAggregationCondition ManagementEventAggregationCondition(MonitorConditionOperator? @operator = null, double? threshold = null, TimeSpan? windowSize = null)
        {
            return new ManagementEventAggregationCondition(@operator, threshold, windowSize);
        }

        /// <summary> Initializes a new instance of ManagementEventRuleCondition. </summary>
        /// <param name="dataSource">
        /// the resource from which the rule collects its data. For this type dataSource will always be of type RuleMetricDataSource.
        /// Please note <see cref="RuleDataSource"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="RuleManagementEventDataSource"/> and <see cref="RuleMetricDataSource"/>.
        /// </param>
        /// <param name="aggregation"> How the data that is collected should be combined over time and when the alert is activated. Note that for management event alerts aggregation is optional – if it is not provided then any event will cause the alert to activate. </param>
        /// <returns> A new <see cref="Models.ManagementEventRuleCondition"/> instance for mocking. </returns>
        public static ManagementEventRuleCondition ManagementEventRuleCondition(RuleDataSource dataSource = null, ManagementEventAggregationCondition aggregation = null)
        {
            return new ManagementEventRuleCondition("Microsoft.Azure.Management.Insights.Models.ManagementEventRuleCondition", dataSource, aggregation);
        }

        /// <summary> Initializes a new instance of RuleEmailAction. </summary>
        /// <param name="sendToServiceOwners"> Whether the administrators (service and co-administrators) of the service should be notified when the alert is activated. </param>
        /// <param name="customEmails"> the list of administrator&apos;s custom email addresses to notify of the activation of the alert. </param>
        /// <returns> A new <see cref="Models.RuleEmailAction"/> instance for mocking. </returns>
        public static RuleEmailAction RuleEmailAction(bool? sendToServiceOwners = null, IEnumerable<string> customEmails = null)
        {
            customEmails ??= new List<string>();

            return new RuleEmailAction("Microsoft.Azure.Management.Insights.Models.RuleEmailAction", sendToServiceOwners, customEmails?.ToList());
        }

        /// <summary> Initializes a new instance of RuleWebhookAction. </summary>
        /// <param name="serviceUri"> the service uri to Post the notification when the alert activates or resolves. </param>
        /// <param name="properties"> the dictionary of custom properties to include with the post operation. These data are appended to the webhook payload. </param>
        /// <returns> A new <see cref="Models.RuleWebhookAction"/> instance for mocking. </returns>
        public static RuleWebhookAction RuleWebhookAction(Uri serviceUri = null, IDictionary<string, string> properties = null)
        {
            properties ??= new Dictionary<string, string>();

            return new RuleWebhookAction("Microsoft.Azure.Management.Insights.Models.RuleWebhookAction", serviceUri, properties);
        }

        /// <summary> Initializes a new instance of MetricAlertSingleResourceMultipleMetricCriteria. </summary>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <param name="allOf"> The list of metric criteria for this &apos;all of&apos; operation. </param>
        /// <returns> A new <see cref="Models.MetricAlertSingleResourceMultipleMetricCriteria"/> instance for mocking. </returns>
        public static MetricAlertSingleResourceMultipleMetricCriteria MetricAlertSingleResourceMultipleMetricCriteria(IDictionary<string, BinaryData> additionalProperties = null, IEnumerable<MetricCriteria> allOf = null)
        {
            additionalProperties ??= new Dictionary<string, BinaryData>();
            allOf ??= new List<MetricCriteria>();

            return new MetricAlertSingleResourceMultipleMetricCriteria("Microsoft.Azure.Monitor.SingleResourceMultipleMetricCriteria", additionalProperties, allOf?.ToList());
        }

        /// <summary> Initializes a new instance of MetricCriteria. </summary>
        /// <param name="name"> Name of the criteria. </param>
        /// <param name="metricName"> Name of the metric. </param>
        /// <param name="metricNamespace"> Namespace of the metric. </param>
        /// <param name="timeAggregation"> the criteria time aggregation types. </param>
        /// <param name="dimensions"> List of dimension conditions. </param>
        /// <param name="skipMetricValidation"> Allows creating an alert rule on a custom metric that isn&apos;t yet emitted, by causing the metric validation to be skipped. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <param name="operator"> the criteria operator. </param>
        /// <param name="threshold"> the criteria threshold value that activates the alert. </param>
        /// <returns> A new <see cref="Models.MetricCriteria"/> instance for mocking. </returns>
        public static MetricCriteria MetricCriteria(string name = null, string metricName = null, string metricNamespace = null, MetricCriteriaTimeAggregationType timeAggregation = default, IEnumerable<MetricDimension> dimensions = null, bool? skipMetricValidation = null, IDictionary<string, BinaryData> additionalProperties = null, MetricCriteriaOperator @operator = default, double threshold = default)
        {
            dimensions ??= new List<MetricDimension>();
            additionalProperties ??= new Dictionary<string, BinaryData>();

            return new MetricCriteria("StaticThresholdCriterion", name, metricName, metricNamespace, timeAggregation, dimensions?.ToList(), skipMetricValidation, additionalProperties, @operator, threshold);
        }

        /// <summary> Initializes a new instance of MultiMetricCriteria. </summary>
        /// <param name="criterionType"> Specifies the type of threshold criteria. </param>
        /// <param name="name"> Name of the criteria. </param>
        /// <param name="metricName"> Name of the metric. </param>
        /// <param name="metricNamespace"> Namespace of the metric. </param>
        /// <param name="timeAggregation"> the criteria time aggregation types. </param>
        /// <param name="dimensions"> List of dimension conditions. </param>
        /// <param name="skipMetricValidation"> Allows creating an alert rule on a custom metric that isn&apos;t yet emitted, by causing the metric validation to be skipped. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <returns> A new <see cref="Models.MultiMetricCriteria"/> instance for mocking. </returns>
        public static MultiMetricCriteria MultiMetricCriteria(string criterionType = null, string name = null, string metricName = null, string metricNamespace = null, MetricCriteriaTimeAggregationType timeAggregation = default, IEnumerable<MetricDimension> dimensions = null, bool? skipMetricValidation = null, IDictionary<string, BinaryData> additionalProperties = null)
        {
            dimensions ??= new List<MetricDimension>();
            additionalProperties ??= new Dictionary<string, BinaryData>();

            return new MultiMetricCriteria(criterionType, name, metricName, metricNamespace, timeAggregation, dimensions?.ToList(), skipMetricValidation, additionalProperties);
        }

        /// <summary> Initializes a new instance of WebtestLocationAvailabilityCriteria. </summary>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <param name="webTestId"> The Application Insights web test Id. </param>
        /// <param name="componentId"> The Application Insights resource Id. </param>
        /// <param name="failedLocationCount"> The number of failed locations. </param>
        /// <returns> A new <see cref="Models.WebtestLocationAvailabilityCriteria"/> instance for mocking. </returns>
        public static WebtestLocationAvailabilityCriteria WebtestLocationAvailabilityCriteria(IDictionary<string, BinaryData> additionalProperties = null, ResourceIdentifier webTestId = null, ResourceIdentifier componentId = null, float failedLocationCount = default)
        {
            additionalProperties ??= new Dictionary<string, BinaryData>();

            return new WebtestLocationAvailabilityCriteria("Microsoft.Azure.Monitor.WebtestLocationAvailabilityCriteria", additionalProperties, webTestId, componentId, failedLocationCount);
        }

        /// <summary> Initializes a new instance of MetricAlertMultipleResourceMultipleMetricCriteria. </summary>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <param name="allOf">
        /// the list of multiple metric criteria for this &apos;all of&apos; operation. 
        /// Please note <see cref="MultiMetricCriteria"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="DynamicMetricCriteria"/> and <see cref="MetricCriteria"/>.
        /// </param>
        /// <returns> A new <see cref="Models.MetricAlertMultipleResourceMultipleMetricCriteria"/> instance for mocking. </returns>
        public static MetricAlertMultipleResourceMultipleMetricCriteria MetricAlertMultipleResourceMultipleMetricCriteria(IDictionary<string, BinaryData> additionalProperties = null, IEnumerable<MultiMetricCriteria> allOf = null)
        {
            additionalProperties ??= new Dictionary<string, BinaryData>();
            allOf ??= new List<MultiMetricCriteria>();

            return new MetricAlertMultipleResourceMultipleMetricCriteria("Microsoft.Azure.Monitor.MultipleResourceMultipleMetricCriteria", additionalProperties, allOf?.ToList());
        }

        /// <summary> Initializes a new instance of DynamicMetricCriteria. </summary>
        /// <param name="name"> Name of the criteria. </param>
        /// <param name="metricName"> Name of the metric. </param>
        /// <param name="metricNamespace"> Namespace of the metric. </param>
        /// <param name="timeAggregation"> the criteria time aggregation types. </param>
        /// <param name="dimensions"> List of dimension conditions. </param>
        /// <param name="skipMetricValidation"> Allows creating an alert rule on a custom metric that isn&apos;t yet emitted, by causing the metric validation to be skipped. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <param name="operator"> The operator used to compare the metric value against the threshold. </param>
        /// <param name="alertSensitivity"> The extent of deviation required to trigger an alert. This will affect how tight the threshold is to the metric series pattern. </param>
        /// <param name="failingPeriods"> The minimum number of violations required within the selected lookback time window required to raise an alert. </param>
        /// <param name="ignoreDataBefore"> Use this option to set the date from which to start learning the metric historical data and calculate the dynamic thresholds (in ISO8601 format). </param>
        /// <returns> A new <see cref="Models.DynamicMetricCriteria"/> instance for mocking. </returns>
        public static DynamicMetricCriteria DynamicMetricCriteria(string name = null, string metricName = null, string metricNamespace = null, MetricCriteriaTimeAggregationType timeAggregation = default, IEnumerable<MetricDimension> dimensions = null, bool? skipMetricValidation = null, IDictionary<string, BinaryData> additionalProperties = null, DynamicThresholdOperator @operator = default, DynamicThresholdSensitivity alertSensitivity = default, DynamicThresholdFailingPeriods failingPeriods = null, DateTimeOffset? ignoreDataBefore = null)
        {
            dimensions ??= new List<MetricDimension>();
            additionalProperties ??= new Dictionary<string, BinaryData>();

            return new DynamicMetricCriteria("DynamicThresholdCriterion", name, metricName, metricNamespace, timeAggregation, dimensions?.ToList(), skipMetricValidation, additionalProperties, @operator, alertSensitivity, failingPeriods, ignoreDataBefore);
        }
    }
}
