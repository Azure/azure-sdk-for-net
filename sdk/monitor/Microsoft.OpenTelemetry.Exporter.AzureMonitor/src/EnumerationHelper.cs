// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;

namespace Microsoft.OpenTelemetry.Exporter.AzureMonitor
{
    internal class DictionaryEnumerator<TKey, TValue, TState> : Enumerator
        <IEnumerable<KeyValuePair<TKey, TValue>>,
        KeyValuePair<TKey, TValue>,
        TState>
        where TState : struct
    {
        protected DictionaryEnumerator()
        {
        }
    }

    internal class Enumerator<TEnumerable, TItem, TState>
        where TEnumerable : IEnumerable<TItem>
        where TState : struct
    {
        private static readonly MethodInfo GenericGetEnumeratorMethod = typeof(IEnumerable<TItem>).GetMethod("GetEnumerator");
        private static readonly MethodInfo GeneircCurrentGetMethod = typeof(IEnumerator<TItem>).GetProperty("Current").GetMethod;
        private static readonly MethodInfo MoveNextMethod = typeof(IEnumerator).GetMethod("MoveNext");
        private static readonly MethodInfo DisposeMethod = typeof(IDisposable).GetMethod("Dispose");

        public delegate void AllocationFreeForEachDelegate(TEnumerable instance, ref TState state, ForEachDelegate itemCallback);

        public delegate bool ForEachDelegate(ref TState state, TItem item);

        protected Enumerator()
        {
        }

        public static AllocationFreeForEachDelegate BuildAllocationFreeForEachDelegate(Type enumerableType)
        {
            var itemCallbackType = typeof(ForEachDelegate);

            var getEnumeratorMethod = ResolveGetEnumeratorMethodForType(enumerableType);
            if (getEnumeratorMethod == null)
            {
                getEnumeratorMethod = GenericGetEnumeratorMethod;
            }

            var enumeratorType = getEnumeratorMethod.ReturnType;

            var dynamicMethod = new DynamicMethod(
                nameof(AllocationFreeForEachDelegate),
                null,
                new[] { typeof(TEnumerable), typeof(TState).MakeByRefType(), itemCallbackType },
                typeof(AllocationFreeForEachDelegate).Module,
                skipVisibility: true);

            var generator = dynamicMethod.GetILGenerator();

            generator.DeclareLocal(enumeratorType);

            var beginLoopLabel = generator.DefineLabel();
            var processCurrentLabel = generator.DefineLabel();
            var returnLabel = generator.DefineLabel();
            var breakLoopLabel = generator.DefineLabel();

            generator.Emit(OpCodes.Ldarg_0);
            generator.Emit(OpCodes.Callvirt, getEnumeratorMethod);
            generator.Emit(OpCodes.Stloc_0);

            // try
            generator.BeginExceptionBlock();
            {
                generator.Emit(OpCodes.Br_S, beginLoopLabel);

                generator.MarkLabel(processCurrentLabel);

                generator.Emit(OpCodes.Ldarg_2);
                generator.Emit(OpCodes.Ldarg_1);
                generator.Emit(OpCodes.Ldloca_S, 0);
                generator.Emit(OpCodes.Constrained, enumeratorType);
                generator.Emit(OpCodes.Callvirt, GeneircCurrentGetMethod);

                generator.Emit(OpCodes.Callvirt, itemCallbackType.GetMethod("Invoke"));

                generator.Emit(OpCodes.Brtrue_S, beginLoopLabel);

                generator.Emit(OpCodes.Leave_S, returnLabel);

                generator.MarkLabel(beginLoopLabel);

                generator.Emit(OpCodes.Ldloca_S, 0);
                generator.Emit(OpCodes.Constrained, enumeratorType);
                generator.Emit(OpCodes.Callvirt, MoveNextMethod);

                generator.Emit(OpCodes.Brtrue_S, processCurrentLabel);

                generator.MarkLabel(breakLoopLabel);

                generator.Emit(OpCodes.Leave_S, returnLabel);
            }

            // finally
            generator.BeginFinallyBlock();
            {
                if (typeof(IDisposable).IsAssignableFrom(enumeratorType))
                {
                    generator.Emit(OpCodes.Ldloca_S, 0);
                    generator.Emit(OpCodes.Constrained, enumeratorType);
                    generator.Emit(OpCodes.Callvirt, DisposeMethod);
                }
            }

            generator.EndExceptionBlock();

            generator.MarkLabel(returnLabel);

            generator.Emit(OpCodes.Ret);

            return (AllocationFreeForEachDelegate)dynamicMethod.CreateDelegate(typeof(AllocationFreeForEachDelegate));
        }

        private static MethodInfo ResolveGetEnumeratorMethodForType(Type type)
        {
            var methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            foreach (var method in methods)
            {
                if (method.Name == "GetEnumerator" && !method.ReturnType.IsInterface)
                {
                    return method;
                }
            }

            return null;
        }
    }
}
