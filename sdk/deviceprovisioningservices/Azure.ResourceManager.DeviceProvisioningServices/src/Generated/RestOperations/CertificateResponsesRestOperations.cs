// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.DeviceProvisioningServices
{
    internal partial class CertificateResponses
    {
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of CertificateResponses for mocking. </summary>
        protected CertificateResponses()
        {
        }

        /// <summary> Initializes a new instance of CertificateResponses. </summary>
        /// <param name="clientDiagnostics"> The ClientDiagnostics is used to provide tracing support for the client library. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> Service endpoint. </param>
        /// <param name="apiVersion"></param>
        internal CertificateResponses(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _endpoint = endpoint;
            Pipeline = pipeline;
            _apiVersion = apiVersion;
        }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline { get; }

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string provisioningServiceName, string certificateName, ETag? ifMatch, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Devices/provisioningServices/", false);
            uri.AppendPath(provisioningServiceName, true);
            uri.AppendPath("/certificates/", false);
            uri.AppendPath(certificateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage();
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            if (ifMatch != null)
            {
                request.Headers.Add("If-Match", ifMatch.Value);
            }
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string provisioningServiceName, string certificateName, RequestContent content, ETag? ifMatch, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Devices/provisioningServices/", false);
            uri.AppendPath(provisioningServiceName, true);
            uri.AppendPath("/certificates/", false);
            uri.AppendPath(certificateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage();
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Put;
            if (ifMatch != null)
            {
                request.Headers.Add("If-Match", ifMatch.Value);
            }
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string provisioningServiceName, string certificateName, string ifMatch, string certificateCommonName, BinaryData certificateRawBytes, bool? certificateIsVerified, string certificatePurpose, DateTimeOffset? certificateCreatedOn, DateTimeOffset? certificateLastUpdatedOn, bool? certificateHasPrivateKey, string certificateNonce, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Devices/provisioningServices/", false);
            uri.AppendPath(provisioningServiceName, true);
            uri.AppendPath("/certificates/", false);
            uri.AppendPath(certificateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (certificateCommonName != null)
            {
                uri.AppendQuery("certificate.name", certificateCommonName, true);
            }
            if (certificateRawBytes != null)
            {
                uri.AppendQuery("certificate.rawBytes", TypeFormatters.ConvertToString(certificateRawBytes, SerializationFormat.Bytes_Base64), true);
            }
            if (certificateIsVerified != null)
            {
                uri.AppendQuery("certificate.isVerified", TypeFormatters.ConvertToString(certificateIsVerified), true);
            }
            if (certificatePurpose != null)
            {
                uri.AppendQuery("certificate.purpose", certificatePurpose, true);
            }
            if (certificateCreatedOn != null)
            {
                uri.AppendQuery("certificate.created", TypeFormatters.ConvertToString(certificateCreatedOn, SerializationFormat.DateTime_RFC3339), true);
            }
            if (certificateLastUpdatedOn != null)
            {
                uri.AppendQuery("certificate.lastUpdated", TypeFormatters.ConvertToString(certificateLastUpdatedOn, SerializationFormat.DateTime_RFC3339), true);
            }
            if (certificateHasPrivateKey != null)
            {
                uri.AppendQuery("certificate.hasPrivateKey", TypeFormatters.ConvertToString(certificateHasPrivateKey), true);
            }
            if (certificateNonce != null)
            {
                uri.AppendQuery("certificate.nonce", certificateNonce, true);
            }
            HttpMessage message = Pipeline.CreateMessage();
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Delete;
            request.Headers.SetValue("If-Match", ifMatch);
            return message;
        }

        internal HttpMessage CreateGetAllRequest(string subscriptionId, string resourceGroupName, string provisioningServiceName, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Devices/provisioningServices/", false);
            uri.AppendPath(provisioningServiceName, true);
            uri.AppendPath("/certificates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            HttpMessage message = Pipeline.CreateMessage();
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Get;
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGenerateVerificationCodeRequest(string subscriptionId, string resourceGroupName, string provisioningServiceName, string certificateName, string ifMatch, string certificateCommonName, BinaryData certificateRawBytes, bool? certificateIsVerified, string certificatePurpose, DateTimeOffset? certificateCreatedOn, DateTimeOffset? certificateLastUpdatedOn, bool? certificateHasPrivateKey, string certificateNonce, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Devices/provisioningServices/", false);
            uri.AppendPath(provisioningServiceName, true);
            uri.AppendPath("/certificates/", false);
            uri.AppendPath(certificateName, true);
            uri.AppendPath("/generateVerificationCode", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (certificateCommonName != null)
            {
                uri.AppendQuery("certificate.name", certificateCommonName, true);
            }
            if (certificateRawBytes != null)
            {
                uri.AppendQuery("certificate.rawBytes", TypeFormatters.ConvertToString(certificateRawBytes, SerializationFormat.Bytes_Base64), true);
            }
            if (certificateIsVerified != null)
            {
                uri.AppendQuery("certificate.isVerified", TypeFormatters.ConvertToString(certificateIsVerified), true);
            }
            if (certificatePurpose != null)
            {
                uri.AppendQuery("certificate.purpose", certificatePurpose, true);
            }
            if (certificateCreatedOn != null)
            {
                uri.AppendQuery("certificate.created", TypeFormatters.ConvertToString(certificateCreatedOn, SerializationFormat.DateTime_RFC3339), true);
            }
            if (certificateLastUpdatedOn != null)
            {
                uri.AppendQuery("certificate.lastUpdated", TypeFormatters.ConvertToString(certificateLastUpdatedOn, SerializationFormat.DateTime_RFC3339), true);
            }
            if (certificateHasPrivateKey != null)
            {
                uri.AppendQuery("certificate.hasPrivateKey", TypeFormatters.ConvertToString(certificateHasPrivateKey), true);
            }
            if (certificateNonce != null)
            {
                uri.AppendQuery("certificate.nonce", certificateNonce, true);
            }
            HttpMessage message = Pipeline.CreateMessage();
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("If-Match", ifMatch);
            request.Headers.SetValue("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateVerifyCertificateRequest(string subscriptionId, string resourceGroupName, string provisioningServiceName, string certificateName, string ifMatch, RequestContent content, string certificateCommonName, BinaryData certificateRawBytes, bool? certificateIsVerified, string certificatePurpose, DateTimeOffset? certificateCreatedOn, DateTimeOffset? certificateLastUpdatedOn, bool? certificateHasPrivateKey, string certificateNonce, RequestContext context)
        {
            RawRequestUriBuilder uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Devices/provisioningServices/", false);
            uri.AppendPath(provisioningServiceName, true);
            uri.AppendPath("/certificates/", false);
            uri.AppendPath(certificateName, true);
            uri.AppendPath("/verify", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (certificateCommonName != null)
            {
                uri.AppendQuery("certificate.name", certificateCommonName, true);
            }
            if (certificateRawBytes != null)
            {
                uri.AppendQuery("certificate.rawBytes", TypeFormatters.ConvertToString(certificateRawBytes, SerializationFormat.Bytes_Base64), true);
            }
            if (certificateIsVerified != null)
            {
                uri.AppendQuery("certificate.isVerified", TypeFormatters.ConvertToString(certificateIsVerified), true);
            }
            if (certificatePurpose != null)
            {
                uri.AppendQuery("certificate.purpose", certificatePurpose, true);
            }
            if (certificateCreatedOn != null)
            {
                uri.AppendQuery("certificate.created", TypeFormatters.ConvertToString(certificateCreatedOn, SerializationFormat.DateTime_RFC3339), true);
            }
            if (certificateLastUpdatedOn != null)
            {
                uri.AppendQuery("certificate.lastUpdated", TypeFormatters.ConvertToString(certificateLastUpdatedOn, SerializationFormat.DateTime_RFC3339), true);
            }
            if (certificateHasPrivateKey != null)
            {
                uri.AppendQuery("certificate.hasPrivateKey", TypeFormatters.ConvertToString(certificateHasPrivateKey), true);
            }
            if (certificateNonce != null)
            {
                uri.AppendQuery("certificate.nonce", certificateNonce, true);
            }
            HttpMessage message = Pipeline.CreateMessage();
            Request request = message.Request;
            request.Uri = uri;
            request.Method = RequestMethod.Post;
            request.Headers.SetValue("If-Match", ifMatch);
            request.Headers.SetValue("Content-Type", "application/json");
            request.Headers.SetValue("Accept", "application/json");
            request.Content = content;
            return message;
        }
    }
}
