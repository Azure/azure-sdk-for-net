// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace TextAuthoringClient
{
    /// <summary> The TextAuthoring service client. </summary>
    public partial class TextAuthoringClient
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of TextAuthoringClient for mocking. </summary>
        protected TextAuthoringClient()
        {
        }

        /// <summary> Initializes a new instance of TextAuthoringClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoint (e.g., https://&lt;resource-name&gt;.cognitiveservices.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public TextAuthoringClient(Uri endpoint, AzureKeyCredential credential) : this(endpoint, credential, new TextAuthoringClientOptions())
        {
        }

        /// <summary> Initializes a new instance of TextAuthoringClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoint (e.g., https://&lt;resource-name&gt;.cognitiveservices.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public TextAuthoringClient(Uri endpoint, AzureKeyCredential credential, TextAuthoringClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new TextAuthoringClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _keyCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new AzureKeyCredentialPolicy(_keyCredential, AuthorizationHeader) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Creates a new project or updates an existing one. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateProjectAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectKind = "CustomSingleLabelClassification",
        ///     storageInputContainerName = "<storageInputContainerName>",
        ///     projectName = "<projectName>",
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = await client.CreateProjectAsync("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// This sample shows how to call CreateProjectAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectKind = "CustomSingleLabelClassification",
        ///     storageInputContainerName = "<storageInputContainerName>",
        ///     settings = new {},
        ///     projectName = "<projectName>",
        ///     multilingual = true,
        ///     description = "<description>",
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = await client.CreateProjectAsync("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        /// Console.WriteLine(result.GetProperty("settings").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("multilingual").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateProjectOptions</c>:
        /// <code>{
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///   storageInputContainerName: string, # Required. The storage container name.
        ///   settings: AnyObject, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project last modification datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last training datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment datetime.
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///   storageInputContainerName: string, # Required. The storage container name.
        ///   settings: AnyObject, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateProjectAsync(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.CreateProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateProjectRequest(projectName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new project or updates an existing one. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateProject with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectKind = "CustomSingleLabelClassification",
        ///     storageInputContainerName = "<storageInputContainerName>",
        ///     projectName = "<projectName>",
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = client.CreateProject("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// This sample shows how to call CreateProject with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectKind = "CustomSingleLabelClassification",
        ///     storageInputContainerName = "<storageInputContainerName>",
        ///     settings = new {},
        ///     projectName = "<projectName>",
        ///     multilingual = true,
        ///     description = "<description>",
        ///     language = "<language>",
        /// };
        /// 
        /// Response response = client.CreateProject("<projectName>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        /// Console.WriteLine(result.GetProperty("settings").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("multilingual").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateProjectOptions</c>:
        /// <code>{
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///   storageInputContainerName: string, # Required. The storage container name.
        ///   settings: AnyObject, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project last modification datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last training datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment datetime.
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///   storageInputContainerName: string, # Required. The storage container name.
        ///   settings: AnyObject, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateProject(string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.CreateProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateProjectRequest(projectName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetProjectAsync("<projectName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        /// Console.WriteLine(result.GetProperty("settings").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("multilingual").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project last modification datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last training datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment datetime.
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///   storageInputContainerName: string, # Required. The storage container name.
        ///   settings: AnyObject, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetProjectAsync(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectRequest(projectName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProject with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetProject("<projectName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        /// Console.WriteLine(result.GetProperty("settings").ToString());
        /// Console.WriteLine(result.GetProperty("projectName").ToString());
        /// Console.WriteLine(result.GetProperty("multilingual").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("language").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectMetadata</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project last modification datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last training datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment datetime.
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///   storageInputContainerName: string, # Required. The storage container name.
        ///   settings: AnyObject, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetProject(string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectRequest(projectName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a deployment. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetDeploymentAsync("<projectName>", "<deploymentName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentName").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentAsync(string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(projectName, deploymentName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a deployment. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeployment with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetDeployment("<projectName>", "<deploymentName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentName").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeployment(string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(projectName, deploymentName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetDeploymentJobStatusAsync("<projectName>", "<deploymentName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentJobStatusAsync(string projectName, string deploymentName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetDeploymentJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentJobStatusRequest(projectName, deploymentName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetDeploymentJobStatus("<projectName>", "<deploymentName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentJobStatus(string projectName, string deploymentName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetDeploymentJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentJobStatusRequest(projectName, deploymentName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing swap deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSwapDeploymentsJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetSwapDeploymentsJobStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSwapDeploymentsJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetSwapDeploymentsJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSwapDeploymentsJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an existing swap deployment job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSwapDeploymentsJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetSwapDeploymentsJobStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSwapDeploymentsJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetSwapDeploymentsJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSwapDeploymentsJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an export job. Once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetExportProjectJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetExportProjectJobStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("resultUrl").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetExportProjectJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetExportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetExportProjectJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of an export job. Once job completes, returns the project metadata, and assets. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetExportProjectJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetExportProjectJobStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("resultUrl").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetExportProjectJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetExportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetExportProjectJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for an import. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetImportProjectJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetImportProjectJobStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetImportProjectJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetImportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetImportProjectJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for an import. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetImportProjectJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetImportProjectJobStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetImportProjectJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetImportProjectJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetImportProjectJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainedModelAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetTrainedModelAsync("<projectName>", "<trainedModelLabel>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        /// Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectTrainedModel</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: string (date), # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTrainedModelAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainedModelRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the details of a trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainedModel with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetTrainedModel("<projectName>", "<trainedModelLabel>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        /// Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectTrainedModel</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: string (date), # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTrainedModel(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainedModelRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an existing trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTrainedModelAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.DeleteTrainedModelAsync("<projectName>", "<trainedModelLabel>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteTrainedModelAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.DeleteTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTrainedModelRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an existing trained model. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTrainedModel with required parameters.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.DeleteTrainedModel("<projectName>", "<trainedModelLabel>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteTrainedModel(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.DeleteTrainedModel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTrainedModelRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the evaluation summary of a trained model. The summary includes high level performance measurements of the model e.g., F1, Precision, Recall, etc. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetModelEvaluationSummaryAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetModelEvaluationSummaryAsync("<projectName>", "<trainedModelLabel>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("kind").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("trainingSplitPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("testingSplitPercentage").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>CustomEntityRecognitionEvaluationSummary</summary>Schema for <c>CustomEntityRecognitionEvaluationSummary</c>:
        /// <code>{
        ///   customEntityRecognitionEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two entities (the two entities can be the same). The matrix is between the entity that was labelled and the entity that was predicted.
        ///     entities: Dictionary&lt;string, EntityEvaluationSummary&gt;, # Required. Represents the entities evaluation
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to extraction evaluation.
        ///   projectKind: CustomEntityRecognition, # Required. Represents the project type that the evaluation ran on.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Required. Represents the options used running the evaluation.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 2 more JSON objects</summary><details><summary>CustomMultiLabelClassificationEvaluationSummary</summary>Schema for <c>CustomMultiLabelClassificationEvaluationSummary</c>:
        /// <code>{
        ///   customMultiLabelClassificationEvaluation: {
        ///     classes: Dictionary&lt;string, MultiLabelClassEvaluationSummary&gt;, # Required. Represents the classes evaluation
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to multi label classification evaluation.
        ///   projectKind: CustomMultiLabelClassification, # Required. Represents the project type that the evaluation ran on.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Required. Represents the options used running the evaluation.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>CustomSingleLabelClassificationEvaluationSummary</summary>Schema for <c>CustomSingleLabelClassificationEvaluationSummary</c>:
        /// <code>{
        ///   customSingleLabelClassificationEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two classes (the two classes can be the same). The matrix is between the class that was labelled and the class that was predicted.
        ///     classes: Dictionary&lt;string, SingleLabelClassEvaluationSummary&gt;, # Required. Represents the classes evaluation
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to single label classification evaluation.
        ///   projectKind: CustomSingleLabelClassification, # Required. Represents the project type that the evaluation ran on.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Required. Represents the options used running the evaluation.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetModelEvaluationSummaryAsync(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetModelEvaluationSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetModelEvaluationSummaryRequest(projectName, trainedModelLabel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the evaluation summary of a trained model. The summary includes high level performance measurements of the model e.g., F1, Precision, Recall, etc. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetModelEvaluationSummary with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetModelEvaluationSummary("<projectName>", "<trainedModelLabel>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("kind").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("trainingSplitPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("evaluationOptions").GetProperty("testingSplitPercentage").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>CustomEntityRecognitionEvaluationSummary</summary>Schema for <c>CustomEntityRecognitionEvaluationSummary</c>:
        /// <code>{
        ///   customEntityRecognitionEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two entities (the two entities can be the same). The matrix is between the entity that was labelled and the entity that was predicted.
        ///     entities: Dictionary&lt;string, EntityEvaluationSummary&gt;, # Required. Represents the entities evaluation
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to extraction evaluation.
        ///   projectKind: CustomEntityRecognition, # Required. Represents the project type that the evaluation ran on.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Required. Represents the options used running the evaluation.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 2 more JSON objects</summary><details><summary>CustomMultiLabelClassificationEvaluationSummary</summary>Schema for <c>CustomMultiLabelClassificationEvaluationSummary</c>:
        /// <code>{
        ///   customMultiLabelClassificationEvaluation: {
        ///     classes: Dictionary&lt;string, MultiLabelClassEvaluationSummary&gt;, # Required. Represents the classes evaluation
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to multi label classification evaluation.
        ///   projectKind: CustomMultiLabelClassification, # Required. Represents the project type that the evaluation ran on.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Required. Represents the options used running the evaluation.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>CustomSingleLabelClassificationEvaluationSummary</summary>Schema for <c>CustomSingleLabelClassificationEvaluationSummary</c>:
        /// <code>{
        ///   customSingleLabelClassificationEvaluation: {
        ///     confusionMatrix: Dictionary&lt;string, Dictionary&lt;string, ConfusionMatrixCell&gt;&gt;, # Required. Represents the confusion matrix between two classes (the two classes can be the same). The matrix is between the class that was labelled and the class that was predicted.
        ///     classes: Dictionary&lt;string, SingleLabelClassEvaluationSummary&gt;, # Required. Represents the classes evaluation
        ///     microF1: number, # Required. Represents the micro F1
        ///     microPrecision: number, # Required. Represents the micro precision
        ///     microRecall: number, # Required. Represents the micro recall
        ///     macroF1: number, # Required. Represents the macro F1
        ///     macroPrecision: number, # Required. Represents the macro precision
        ///     macroRecall: number, # Required. Represents the macro recall
        ///   }, # Required. Contains the data related to single label classification evaluation.
        ///   projectKind: CustomSingleLabelClassification, # Required. Represents the project type that the evaluation ran on.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Required. Represents the options used running the evaluation.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetModelEvaluationSummary(string projectName, string trainedModelLabel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetModelEvaluationSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetModelEvaluationSummaryRequest(projectName, trainedModelLabel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a training job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetTrainingJobStatusAsync("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents model train status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimate end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTrainingJobStatusAsync(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetTrainingJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainingJobStatusRequest(projectName, jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a training job. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetTrainingJobStatus("<projectName>", "<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents model train status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimate end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTrainingJobStatus(string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetTrainingJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTrainingJobStatusRequest(projectName, jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a project deletion job. </summary>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectDeletionJobStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = await client.GetProjectDeletionJobStatusAsync("<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetProjectDeletionJobStatusAsync(string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetProjectDeletionJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectDeletionJobStatusRequest(jobId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status for a project deletion job. </summary>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectDeletionJobStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// Response response = client.GetProjectDeletionJobStatus("<jobId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetProjectDeletionJobStatus(string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.GetProjectDeletionJobStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetProjectDeletionJobStatusRequest(jobId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the existing projects. </summary>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjectsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetProjectsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        ///     Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        ///     Console.WriteLine(result.GetProperty("projectName").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetProjectsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetProjectsAsync(1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        ///     Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        ///     Console.WriteLine(result.GetProperty("settings").ToString());
        ///     Console.WriteLine(result.GetProperty("projectName").ToString());
        ///     Console.WriteLine(result.GetProperty("multilingual").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringProjectsMetadataValue</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project last modification datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last training datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment datetime.
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///   storageInputContainerName: string, # Required. The storage container name.
        ///   settings: AnyObject, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetProjectsAsync(int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            return GetProjectsImplementationAsync("TextAuthoringClient.GetProjects", top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetProjectsImplementationAsync(string diagnosticsScopeName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetProjectsRequest(top, skip, maxpagesize, context)
                        : CreateGetProjectsNextPageRequest(nextLink, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the existing projects. </summary>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetProjects and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetProjects())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        ///     Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        ///     Console.WriteLine(result.GetProperty("projectName").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetProjects with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetProjects(1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastModifiedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        ///     Console.WriteLine(result.GetProperty("storageInputContainerName").ToString());
        ///     Console.WriteLine(result.GetProperty("settings").ToString());
        ///     Console.WriteLine(result.GetProperty("projectName").ToString());
        ///     Console.WriteLine(result.GetProperty("multilingual").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringProjectsMetadataValue</c>:
        /// <code>{
        ///   createdDateTime: string (ISO 8601 Format), # Required. Represents the project creation datetime.
        ///   lastModifiedDateTime: string (ISO 8601 Format), # Required. Represents the project last modification datetime.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Optional. Represents the project last training datetime.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Optional. Represents the project last deployment datetime.
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///   storageInputContainerName: string, # Required. The storage container name.
        ///   settings: AnyObject, # Optional. The project settings.
        ///   projectName: string, # Required. The new project name.
        ///   multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///   description: string, # Optional. The project description.
        ///   language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetProjects(int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            return GetProjectsImplementation("TextAuthoringClient.GetProjects", top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetProjectsImplementation(string diagnosticsScopeName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetProjectsRequest(top, skip, maxpagesize, context)
                        : CreateGetProjectsNextPageRequest(nextLink, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the deployments belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentName").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeploymentsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsAsync("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentName").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringProjectDeploymentsValue</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsAsync(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetDeploymentsImplementationAsync("TextAuthoringClient.GetDeployments", projectName, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsImplementationAsync(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetDeploymentsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the deployments belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeployments with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetDeployments("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentName").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeployments with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetDeployments("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentName").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringProjectDeploymentsValue</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeployments(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetDeploymentsImplementation("TextAuthoringClient.GetDeployments", projectName, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetDeploymentsImplementation(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetDeploymentsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the trained models belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainedModelsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainedModelsAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("label").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTrainedModelsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainedModelsAsync("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("label").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringProjectTrainedModelsValue</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: string (date), # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainedModelsAsync(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainedModelsImplementationAsync("TextAuthoringClient.GetTrainedModels", projectName, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetTrainedModelsImplementationAsync(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainedModelsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetTrainedModelsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the trained models belonging to a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainedModels with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainedModels("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("label").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTrainedModels with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainedModels("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("label").ToString());
        ///     Console.WriteLine(result.GetProperty("modelId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastTrainingDurationInSeconds").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        ///     Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringProjectTrainedModelsValue</c>:
        /// <code>{
        ///   label: string, # Required. The trained model label.
        ///   modelId: string, # Required. The model ID.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. The last trained date time of the model.
        ///   lastTrainingDurationInSeconds: number, # Required. The duration of the model&apos;s last training request in seconds.
        ///   modelExpirationDate: string (date), # Required. The model expiration date.
        ///   modelTrainingConfigVersion: string, # Required. The model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainedModels(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainedModelsImplementation("TextAuthoringClient.GetTrainedModels", projectName, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetTrainedModelsImplementation(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainedModelsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetTrainedModelsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets the detailed results of the evaluation for a trained model. This includes the raw inference results for the data included in the evaluation process. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="trainedModelLabel"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetModelEvaluationResultsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetModelEvaluationResultsAsync("<projectName>", "<trainedModelLabel>", "<stringIndexType>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("location").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetModelEvaluationResultsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetModelEvaluationResultsAsync("<projectName>", "<trainedModelLabel>", "<stringIndexType>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("location").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringEvaluationResultsValue</c>:
        /// <code>{
        ///   location: string, # Required. Represents the document path.
        ///   language: string, # Required. Represents the document language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. Represents the project kind.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetModelEvaluationResultsAsync(string projectName, string trainedModelLabel, string stringIndexType, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            return GetModelEvaluationResultsImplementationAsync("TextAuthoringClient.GetModelEvaluationResults", projectName, trainedModelLabel, stringIndexType, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetModelEvaluationResultsImplementationAsync(string diagnosticsScopeName, string projectName, string trainedModelLabel, string stringIndexType, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetModelEvaluationResultsRequest(projectName, trainedModelLabel, stringIndexType, top, skip, maxpagesize, context)
                        : CreateGetModelEvaluationResultsNextPageRequest(nextLink, projectName, trainedModelLabel, stringIndexType, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets the detailed results of the evaluation for a trained model. This includes the raw inference results for the data included in the evaluation process. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="trainedModelLabel"> The trained model label. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="trainedModelLabel"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="trainedModelLabel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetModelEvaluationResults with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetModelEvaluationResults("<projectName>", "<trainedModelLabel>", "<stringIndexType>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("location").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetModelEvaluationResults with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetModelEvaluationResults("<projectName>", "<trainedModelLabel>", "<stringIndexType>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("location").ToString());
        ///     Console.WriteLine(result.GetProperty("language").ToString());
        ///     Console.WriteLine(result.GetProperty("projectKind").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringEvaluationResultsValue</c>:
        /// <code>{
        ///   location: string, # Required. Represents the document path.
        ///   language: string, # Required. Represents the document language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. Represents the project kind.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetModelEvaluationResults(string projectName, string trainedModelLabel, string stringIndexType, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(trainedModelLabel, nameof(trainedModelLabel));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            return GetModelEvaluationResultsImplementation("TextAuthoringClient.GetModelEvaluationResults", projectName, trainedModelLabel, stringIndexType, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetModelEvaluationResultsImplementation(string diagnosticsScopeName, string projectName, string trainedModelLabel, string stringIndexType, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetModelEvaluationResultsRequest(projectName, trainedModelLabel, stringIndexType, top, skip, maxpagesize, context)
                        : CreateGetModelEvaluationResultsNextPageRequest(nextLink, projectName, trainedModelLabel, stringIndexType, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the non-expired training jobs created for a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingJobsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainingJobsAsync("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("jobId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTrainingJobsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainingJobsAsync("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("jobId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringTrainingJobsValue</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents model train status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimate end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainingJobsAsync(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainingJobsImplementationAsync("TextAuthoringClient.GetTrainingJobs", projectName, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetTrainingJobsImplementationAsync(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingJobsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetTrainingJobsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the non-expired training jobs created for a project. </summary>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingJobs with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainingJobs("<projectName>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("jobId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTrainingJobs with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainingJobs("<projectName>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("jobId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringTrainingJobsValue</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents model train status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimate end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainingJobs(string projectName, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            return GetTrainingJobsImplementation("TextAuthoringClient.GetTrainingJobs", projectName, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetTrainingJobsImplementation(string diagnosticsScopeName, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingJobsRequest(projectName, top, skip, maxpagesize, context)
                        : CreateGetTrainingJobsNextPageRequest(nextLink, projectName, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported languages. </summary>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedLanguagesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSupportedLanguagesAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("languageName").ToString());
        ///     Console.WriteLine(result.GetProperty("languageCode").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetSupportedLanguagesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetSupportedLanguagesAsync(1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("languageName").ToString());
        ///     Console.WriteLine(result.GetProperty("languageCode").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringSupportedLanguagesValue</c>:
        /// <code>{
        ///   languageName: string, # Required. The language name.
        ///   languageCode: string, # Required. The language code. This is BCP-47 representation of a language. For example, &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetSupportedLanguagesAsync(int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            return GetSupportedLanguagesImplementationAsync("TextAuthoringClient.GetSupportedLanguages", top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetSupportedLanguagesImplementationAsync(string diagnosticsScopeName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedLanguagesRequest(top, skip, maxpagesize, context)
                        : CreateGetSupportedLanguagesNextPageRequest(nextLink, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the supported languages. </summary>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetSupportedLanguages and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSupportedLanguages())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("languageName").ToString());
        ///     Console.WriteLine(result.GetProperty("languageCode").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetSupportedLanguages with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetSupportedLanguages(1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("languageName").ToString());
        ///     Console.WriteLine(result.GetProperty("languageCode").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringSupportedLanguagesValue</c>:
        /// <code>{
        ///   languageName: string, # Required. The language name.
        ///   languageCode: string, # Required. The language code. This is BCP-47 representation of a language. For example, &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetSupportedLanguages(int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            return GetSupportedLanguagesImplementation("TextAuthoringClient.GetSupportedLanguages", top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetSupportedLanguagesImplementation(string diagnosticsScopeName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetSupportedLanguagesRequest(top, skip, maxpagesize, context)
                        : CreateGetSupportedLanguagesNextPageRequest(nextLink, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the support training config version for a given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingConfigVersionsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainingConfigVersionsAsync("<projectKind>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTrainingConfigVersionsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// await foreach (var data in client.GetTrainingConfigVersionsAsync("<projectKind>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringTrainingConfigVersionsValue</c>:
        /// <code>{
        ///   trainingConfigVersion: string, # Required. Represents the version of the config.
        ///   modelExpirationDate: string (date), # Required. Represents the training config version expiration date.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetTrainingConfigVersionsAsync(string projectKind, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetTrainingConfigVersionsImplementationAsync("TextAuthoringClient.GetTrainingConfigVersions", projectKind, top, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetTrainingConfigVersionsImplementationAsync(string diagnosticsScopeName, string projectKind, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingConfigVersionsRequest(projectKind, top, skip, maxpagesize, context)
                        : CreateGetTrainingConfigVersionsNextPageRequest(nextLink, projectKind, top, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the support training config version for a given project type. </summary>
        /// <param name="projectKind"> The project kind. Allowed values: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;. </param>
        /// <param name="top"> The maximum number of resources to return from the collection. </param>
        /// <param name="skip"> An offset into the collection of the first resource to be returned. </param>
        /// <param name="maxpagesize"> The maximum number of resources to include in a single response. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectKind"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTrainingConfigVersions with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainingConfigVersions("<projectKind>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetTrainingConfigVersions with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// foreach (var data in client.GetTrainingConfigVersions("<projectKind>", 1234, 1234, 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("trainingConfigVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("modelExpirationDate").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TextAnalysisAuthoringTrainingConfigVersionsValue</c>:
        /// <code>{
        ///   trainingConfigVersion: string, # Required. Represents the version of the config.
        ///   modelExpirationDate: string (date), # Required. Represents the training config version expiration date.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetTrainingConfigVersions(string projectKind, int? top = null, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(projectKind, nameof(projectKind));

            return GetTrainingConfigVersionsImplementation("TextAuthoringClient.GetTrainingConfigVersions", projectKind, top, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetTrainingConfigVersionsImplementation(string diagnosticsScopeName, string projectKind, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetTrainingConfigVersionsRequest(projectKind, top, skip, maxpagesize, context)
                        : CreateGetTrainingConfigVersionsNextPageRequest(nextLink, projectKind, top, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Deletes a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteProjectAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.DeleteProjectAsync(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeleteProjectAsync(WaitUntil waitUntil, string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.DeleteProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteProjectRequest(projectName, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.DeleteProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteProject with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.DeleteProject(WaitUntil.Completed, "<projectName>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeletionJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeleteProject(WaitUntil waitUntil, string projectName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.DeleteProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteProjectRequest(projectName, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.DeleteProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to export a project&apos;s data. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="assetKind"> Kind of asset to export. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ExportProjectAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.ExportProjectAsync(WaitUntil.Completed, "<projectName>", "<stringIndexType>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call ExportProjectAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.ExportProjectAsync(WaitUntil.Completed, "<projectName>", "<stringIndexType>", "<assetKind>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("resultUrl").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ExportProjectAsync(WaitUntil waitUntil, string projectName, string stringIndexType, string assetKind = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.ExportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExportProjectRequest(projectName, stringIndexType, assetKind, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.ExportProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to export a project&apos;s data. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="stringIndexType"> Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets. Allowed values: &quot;Utf16CodeUnit&quot;. </param>
        /// <param name="assetKind"> Kind of asset to export. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="stringIndexType"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ExportProject with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.ExportProject(WaitUntil.Completed, "<projectName>", "<stringIndexType>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call ExportProject with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.ExportProject(WaitUntil.Completed, "<projectName>", "<stringIndexType>", "<assetKind>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("resultUrl").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ExportProjectJobState</c>:
        /// <code>{
        ///   resultUrl: string, # Optional. The URL to use in order to download the exported project.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> ExportProject(WaitUntil waitUntil, string projectName, string stringIndexType, string assetKind = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(stringIndexType, nameof(stringIndexType));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.ExportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExportProjectRequest(projectName, stringIndexType, assetKind, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.ExportProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to import a project. If a project with the same name already exists, the data of that project is replaced. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ImportProjectAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectFileVersion = "<projectFileVersion>",
        ///     stringIndexType = "Utf16CodeUnit",
        ///     metadata = new {
        ///         projectKind = "CustomSingleLabelClassification",
        ///         storageInputContainerName = "<storageInputContainerName>",
        ///         projectName = "<projectName>",
        ///         language = "<language>",
        ///     },
        /// };
        /// 
        /// var operation = await client.ImportProjectAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call ImportProjectAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectFileVersion = "<projectFileVersion>",
        ///     stringIndexType = "Utf16CodeUnit",
        ///     metadata = new {
        ///         projectKind = "CustomSingleLabelClassification",
        ///         storageInputContainerName = "<storageInputContainerName>",
        ///         settings = new {},
        ///         projectName = "<projectName>",
        ///         multilingual = true,
        ///         description = "<description>",
        ///         language = "<language>",
        ///     },
        ///     assets = new {
        ///         entities = new[] {
        ///             new {
        ///                 category = "<category>",
        ///             }
        ///         },
        ///         documents = new[] {
        ///             new {
        ///                 entities = new[] {
        ///                     new {
        ///                         regionOffset = 1234,
        ///                         regionLength = 1234,
        ///                         labels = new[] {
        ///                             new {
        ///                                 category = "<category>",
        ///                                 offset = 1234,
        ///                                 length = 1234,
        ///                             }
        ///                         },
        ///                     }
        ///                 },
        ///                 location = "<location>",
        ///                 language = "<language>",
        ///                 dataset = "<dataset>",
        ///             }
        ///         },
        ///         projectKind = "CustomEntityRecognition",
        ///     },
        /// };
        /// 
        /// var operation = await client.ImportProjectAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ExportedProject</c>:
        /// <code>{
        ///   projectFileVersion: string, # Required. The version of the exported file.
        ///   stringIndexType: &quot;Utf16CodeUnit&quot;, # Required. Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets.
        ///   metadata: {
        ///     projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///     storageInputContainerName: string, # Required. The storage container name.
        ///     settings: AnyObject, # Optional. The project settings.
        ///     projectName: string, # Required. The new project name.
        ///     multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///     description: string, # Optional. The project description.
        ///     language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   }, # Required. Represents the project metadata.
        ///   assets: {
        ///     projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The type of the project the assets belong to.
        ///   }, # Optional. Represents the project assets.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ImportProjectAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.ImportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportProjectRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.ImportProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a job to import a project. If a project with the same name already exists, the data of that project is replaced. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call ImportProject with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectFileVersion = "<projectFileVersion>",
        ///     stringIndexType = "Utf16CodeUnit",
        ///     metadata = new {
        ///         projectKind = "CustomSingleLabelClassification",
        ///         storageInputContainerName = "<storageInputContainerName>",
        ///         projectName = "<projectName>",
        ///         language = "<language>",
        ///     },
        /// };
        /// 
        /// var operation = client.ImportProject(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call ImportProject with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     projectFileVersion = "<projectFileVersion>",
        ///     stringIndexType = "Utf16CodeUnit",
        ///     metadata = new {
        ///         projectKind = "CustomSingleLabelClassification",
        ///         storageInputContainerName = "<storageInputContainerName>",
        ///         settings = new {},
        ///         projectName = "<projectName>",
        ///         multilingual = true,
        ///         description = "<description>",
        ///         language = "<language>",
        ///     },
        ///     assets = new {
        ///         entities = new[] {
        ///             new {
        ///                 category = "<category>",
        ///             }
        ///         },
        ///         documents = new[] {
        ///             new {
        ///                 entities = new[] {
        ///                     new {
        ///                         regionOffset = 1234,
        ///                         regionLength = 1234,
        ///                         labels = new[] {
        ///                             new {
        ///                                 category = "<category>",
        ///                                 offset = 1234,
        ///                                 length = 1234,
        ///                             }
        ///                         },
        ///                     }
        ///                 },
        ///                 location = "<location>",
        ///                 language = "<language>",
        ///                 dataset = "<dataset>",
        ///             }
        ///         },
        ///         projectKind = "CustomEntityRecognition",
        ///     },
        /// };
        /// 
        /// var operation = client.ImportProject(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>ExportedProject</c>:
        /// <code>{
        ///   projectFileVersion: string, # Required. The version of the exported file.
        ///   stringIndexType: &quot;Utf16CodeUnit&quot;, # Required. Specifies the method used to interpret string offsets. For additional information see https://aka.ms/text-analytics-offsets.
        ///   metadata: {
        ///     projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The project kind.
        ///     storageInputContainerName: string, # Required. The storage container name.
        ///     settings: AnyObject, # Optional. The project settings.
        ///     projectName: string, # Required. The new project name.
        ///     multilingual: boolean, # Optional. Whether the project would be used for multiple languages or not.
        ///     description: string, # Optional. The project description.
        ///     language: string, # Required. The project language. This is BCP-47 representation of a language. For example, use &quot;en&quot; for English, &quot;en-gb&quot; for English (UK), &quot;es&quot; for Spanish etc.
        ///   }, # Required. Represents the project metadata.
        ///   assets: {
        ///     projectKind: &quot;CustomSingleLabelClassification&quot; | &quot;CustomMultiLabelClassification&quot; | &quot;CustomEntityRecognition&quot;, # Required. The type of the project the assets belong to.
        ///   }, # Optional. Represents the project assets.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ImportProjectJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> ImportProject(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.ImportProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportProjectRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.ImportProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a training job for a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call TrainAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     modelLabel = "<modelLabel>",
        ///     trainingConfigVersion = "<trainingConfigVersion>",
        /// };
        /// 
        /// var operation = await client.TrainAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call TrainAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     modelLabel = "<modelLabel>",
        ///     trainingConfigVersion = "<trainingConfigVersion>",
        ///     evaluationOptions = new {
        ///         kind = "percentage",
        ///         trainingSplitPercentage = 1234,
        ///         testingSplitPercentage = 1234,
        ///     },
        /// };
        /// 
        /// var operation = await client.TrainAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TrainingJobOptions</c>:
        /// <code>{
        ///   modelLabel: string, # Required. Represents the output model label.
        ///   trainingConfigVersion: string, # Required. Represents training config version.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. Represents the evaluation options. By default, the evaluation kind is percentage, with training split percentage as 80, and testing split percentage as 20.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents model train status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimate end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> TrainAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.Train");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.Train", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a training job for a project. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call Train with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     modelLabel = "<modelLabel>",
        ///     trainingConfigVersion = "<trainingConfigVersion>",
        /// };
        /// 
        /// var operation = client.Train(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// This sample shows how to call Train with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     modelLabel = "<modelLabel>",
        ///     trainingConfigVersion = "<trainingConfigVersion>",
        ///     evaluationOptions = new {
        ///         kind = "percentage",
        ///         trainingSplitPercentage = 1234,
        ///         testingSplitPercentage = 1234,
        ///     },
        /// };
        /// 
        /// var operation = client.Train(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>TrainingJobOptions</c>:
        /// <code>{
        ///   modelLabel: string, # Required. Represents the output model label.
        ///   trainingConfigVersion: string, # Required. Represents training config version.
        ///   evaluationOptions: {
        ///     kind: &quot;percentage&quot; | &quot;manual&quot;, # Optional. Represents the evaluation kind. By default, the evaluation kind is set to percentage.
        ///     trainingSplitPercentage: number, # Optional. Represents the training dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///     testingSplitPercentage: number, # Optional. Represents the testing dataset split percentage. Only needed in case the evaluation kind is percentage.
        ///   }, # Optional. Represents the evaluation options. By default, the evaluation kind is percentage, with training split percentage as 80, and testing split percentage as 20.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents model train status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimate end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> Train(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.Train");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.Train", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Swaps two existing deployments with each other. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call SwapDeploymentsAsync with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     firstDeploymentName = "<firstDeploymentName>",
        ///     secondDeploymentName = "<secondDeploymentName>",
        /// };
        /// 
        /// var operation = await client.SwapDeploymentsAsync(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SwapDeploymentsOptions</c>:
        /// <code>{
        ///   firstDeploymentName: string, # Required. Represents the first deployment name.
        ///   secondDeploymentName: string, # Required. Represents the second deployment name.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> SwapDeploymentsAsync(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.SwapDeployments");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSwapDeploymentsRequest(projectName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.SwapDeployments", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Swaps two existing deployments with each other. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call SwapDeployments with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     firstDeploymentName = "<firstDeploymentName>",
        ///     secondDeploymentName = "<secondDeploymentName>",
        /// };
        /// 
        /// var operation = client.SwapDeployments(WaitUntil.Completed, "<projectName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>SwapDeploymentsOptions</c>:
        /// <code>{
        ///   firstDeploymentName: string, # Required. Represents the first deployment name.
        ///   secondDeploymentName: string, # Required. Represents the second deployment name.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> SwapDeployments(WaitUntil waitUntil, string projectName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.SwapDeployments");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSwapDeploymentsRequest(projectName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.SwapDeployments", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new deployment or replaces an existing one. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeployProjectAsync with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     trainedModelLabel = "<trainedModelLabel>",
        /// };
        /// 
        /// var operation = await client.DeployProjectAsync(WaitUntil.Completed, "<projectName>", "<deploymentName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentName").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateDeploymentOptions</c>:
        /// <code>{
        ///   trainedModelLabel: string, # Required. Represents the trained model label.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeployProjectAsync(WaitUntil waitUntil, string projectName, string deploymentName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.DeployProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.DeployProject", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new deployment or replaces an existing one. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/>, <paramref name="deploymentName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeployProject with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var data = new {
        ///     trainedModelLabel = "<trainedModelLabel>",
        /// };
        /// 
        /// var operation = client.DeployProject(WaitUntil.Completed, "<projectName>", "<deploymentName>", RequestContent.Create(data));
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentName").ToString());
        /// Console.WriteLine(result.GetProperty("modelId").ToString());
        /// Console.WriteLine(result.GetProperty("lastTrainedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeployedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentExpirationDate").ToString());
        /// Console.WriteLine(result.GetProperty("modelTrainingConfigVersion").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CreateDeploymentOptions</c>:
        /// <code>{
        ///   trainedModelLabel: string, # Required. Represents the trained model label.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ProjectDeployment</c>:
        /// <code>{
        ///   deploymentName: string, # Required. Represents deployment name.
        ///   modelId: string, # Required. Represents deployment modelId.
        ///   lastTrainedDateTime: string (ISO 8601 Format), # Required. Represents deployment last trained time.
        ///   lastDeployedDateTime: string (ISO 8601 Format), # Required. Represents deployment last deployed time.
        ///   deploymentExpirationDate: string (date), # Required. Represents deployment expiration date in the runtime.
        ///   modelTrainingConfigVersion: string, # Required. Represents model training config version.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeployProject(WaitUntil waitUntil, string projectName, string deploymentName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.DeployProject");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeployProjectRequest(projectName, deploymentName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.DeployProject", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project deployment. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeploymentAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.DeleteDeploymentAsync(WaitUntil.Completed, "<projectName>", "<deploymentName>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> DeleteDeploymentAsync(WaitUntil waitUntil, string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(projectName, deploymentName, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.DeleteDeployment", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a project deployment. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="deploymentName"> The name of the specific deployment of the project to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="deploymentName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeployment with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.DeleteDeployment(WaitUntil.Completed, "<projectName>", "<deploymentName>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentJobState</c>:
        /// <code>{
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> DeleteDeployment(WaitUntil waitUntil, string projectName, string deploymentName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(deploymentName, nameof(deploymentName));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(projectName, deploymentName, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.DeleteDeployment", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a cancellation for a running training job. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CancelTrainingJobAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = await client.CancelTrainingJobAsync(WaitUntil.Completed, "<projectName>", "<jobId>");
        /// 
        /// BinaryData data = await operation.WaitForCompletionAsync();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents model train status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimate end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> CancelTrainingJobAsync(WaitUntil waitUntil, string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.CancelTrainingJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelTrainingJobRequest(projectName, jobId, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.CancelTrainingJob", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Triggers a cancellation for a running training job. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="projectName"> The name of the project to use. </param>
        /// <param name="jobId"> The job ID. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="projectName"/> or <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="projectName"/> or <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation{T}"/> from the service that will contain a <see cref="BinaryData"/> object once the asynchronous operation on the service has completed. Details of the body schema for the operation's final value are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CancelTrainingJob with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new AzureKeyCredential("<key>");
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new TextAuthoringClient(endpoint, credential);
        /// 
        /// var operation = client.CancelTrainingJob(WaitUntil.Completed, "<projectName>", "<jobId>");
        /// 
        /// BinaryData data = operation.WaitForCompletion();
        /// JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        /// Console.WriteLine(result.GetProperty("result").GetProperty("modelLabel").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingConfigVersion").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("trainingStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("percentComplete").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("endDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("evaluationStatus").GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("result").GetProperty("estimatedEndDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("jobId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastUpdatedDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("expirationDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("warnings")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("details")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("details").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("errors")[0].GetProperty("innererror").GetProperty("target").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TrainingJobState</c>:
        /// <code>{
        ///   result: {
        ///     modelLabel: string, # Required. Represents trained model label.
        ///     trainingConfigVersion: string, # Required. Represents training config version.
        ///     trainingStatus: {
        ///       percentComplete: number, # Required. Represents progress percentage.
        ///       startDateTime: string (ISO 8601 Format), # Optional. Represents the start date time.
        ///       endDateTime: string (ISO 8601 Format), # Optional. Represents the end date time.
        ///       status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. Represents the status of the sub-operation.
        ///     }, # Required. Represents model train status.
        ///     evaluationStatus: SubTrainingJobState, # Optional. Represents model evaluation status.
        ///     estimatedEndDateTime: string (ISO 8601 Format), # Optional. Represents the estimate end date time for training and evaluation.
        ///   }, # Required. Represents training tasks detailed result.
        ///   jobId: string, # Required. The job ID.
        ///   createdDateTime: string (ISO 8601 Format), # Required. The creation date time of the job.
        ///   lastUpdatedDateTime: string (ISO 8601 Format), # Required. The last date time the job was updated.
        ///   expirationDateTime: string (ISO 8601 Format), # Optional. The expiration date time of the job.
        ///   status: &quot;notStarted&quot; | &quot;running&quot; | &quot;succeeded&quot; | &quot;failed&quot; | &quot;cancelled&quot; | &quot;cancelling&quot; | &quot;partiallyCompleted&quot;, # Required. The job status.
        ///   warnings: [
        ///     {
        ///       code: string, # Required. The warning code.
        ///       message: string, # Required. The warning message.
        ///     }
        ///   ], # Optional. The warnings that were encountered while executing the job.
        ///   errors: [
        ///     {
        ///       code: &quot;InvalidRequest&quot; | &quot;InvalidArgument&quot; | &quot;Unauthorized&quot; | &quot;Forbidden&quot; | &quot;NotFound&quot; | &quot;ProjectNotFound&quot; | &quot;OperationNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchIndexNotFound&quot; | &quot;TooManyRequests&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;AzureCognitiveSearchIndexLimitReached&quot; | &quot;InternalServerError&quot; | &quot;ServiceUnavailable&quot; | &quot;Timeout&quot; | &quot;QuotaExceeded&quot; | &quot;Conflict&quot; | &quot;Warning&quot;, # Required. One of a server-defined set of error codes.
        ///       message: string, # Required. A human-readable representation of the error.
        ///       target: string, # Optional. The target of the error.
        ///       details: [Error], # Optional. An array of details about specific errors that led to this reported error.
        ///       innererror: {
        ///         code: &quot;InvalidRequest&quot; | &quot;InvalidParameterValue&quot; | &quot;KnowledgeBaseNotFound&quot; | &quot;AzureCognitiveSearchNotFound&quot; | &quot;AzureCognitiveSearchThrottling&quot; | &quot;ExtractionFailure&quot; | &quot;InvalidRequestBodyFormat&quot; | &quot;EmptyRequest&quot; | &quot;MissingInputDocuments&quot; | &quot;InvalidDocument&quot; | &quot;ModelVersionIncorrect&quot; | &quot;InvalidDocumentBatch&quot; | &quot;UnsupportedLanguageCode&quot; | &quot;InvalidCountryHint&quot;, # Required. One of a server-defined set of error codes.
        ///         message: string, # Required. Error message.
        ///         details: Dictionary&lt;string, string&gt;, # Optional. Error details.
        ///         target: string, # Optional. Error target.
        ///         innererror: InnerErrorModel, # Optional. An object containing more specific information than the current object about the error.
        ///       }, # Optional. An object containing more specific information than the current object about the error.
        ///     }
        ///   ], # Optional. The errors encountered while executing the job.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> CancelTrainingJob(WaitUntil waitUntil, string projectName, string jobId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(projectName, nameof(projectName));
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("TextAuthoringClient.CancelTrainingJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelTrainingJobRequest(projectName, jobId, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "TextAuthoringClient.CancelTrainingJob", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetProjectsRequest(int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects", false);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateProjectRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetProjectRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteProjectRequest(string projectName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateExportProjectRequest(string projectName, string stringIndexType, string assetKind, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:export", false);
            uri.AppendQuery("stringIndexType", stringIndexType, true);
            if (assetKind != null)
            {
                uri.AppendQuery("assetKind", assetKind, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportProjectRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:import", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateTrainRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/:train", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeploymentsRequest(string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments", false);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateSwapDeploymentsRequest(string projectName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/:swap", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeploymentRequest(string projectName, string deploymentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeployProjectRequest(string projectName, string deploymentName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentRequest(string projectName, string deploymentName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentJobStatusRequest(string projectName, string deploymentName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentName, true);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSwapDeploymentsJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/deployments/swap/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetExportProjectJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/export/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetImportProjectJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/import/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelsRequest(string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models", false);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteTrainedModelRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationResultsRequest(string projectName, string trainedModelLabel, string stringIndexType, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendPath("/evaluation/result", false);
            uri.AppendQuery("stringIndexType", stringIndexType, true);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationSummaryRequest(string projectName, string trainedModelLabel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/models/", false);
            uri.AppendPath(trainedModelLabel, true);
            uri.AppendPath("/evaluation/summary-result", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobsRequest(string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs", false);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobStatusRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCancelTrainingJobRequest(string projectName, string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/", false);
            uri.AppendPath(projectName, true);
            uri.AppendPath("/train/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/:cancel", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetProjectDeletionJobStatusRequest(string jobId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/global/deletion-jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedLanguagesRequest(int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/global/languages", false);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingConfigVersionsRequest(string projectKind, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendPath("/authoring/analyze-text/projects/global/training-config-versions", false);
            uri.AppendQuery("projectKind", projectKind, true);
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("maxpagesize", maxpagesize.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetProjectsNextPageRequest(string nextLink, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsNextPageRequest(string nextLink, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainedModelsNextPageRequest(string nextLink, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetModelEvaluationResultsNextPageRequest(string nextLink, string projectName, string trainedModelLabel, string stringIndexType, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingJobsNextPageRequest(string nextLink, string projectName, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSupportedLanguagesNextPageRequest(string nextLink, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTrainingConfigVersionsNextPageRequest(string nextLink, string projectKind, int? top, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/language", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
