// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Text.Json;
using static Azure.AI.Inference.Telemetry.OpenTelemetryConstants;

namespace Azure.AI.Inference.Telemetry
{
    internal class OpenTelemetryScope : IDisposable
    {
        /// <summary>
        /// The Activity name to be used for creation of actions.
        /// </summary>
        private const string ACTIVITY_NAME = "Azure.AI.Inference.ChatCompletionsClient";
        private const string ENABLE_ENV = "AZURE_TRACING_GEN_AI_CONTENT_RECORDING_ENABLED";

        /// <summary>
        /// Activity source is used to save events and log the tags.
        /// On the ApplicationInsights events are logged to traces table.
        /// The tags are not logged, but are shown in the console.
        /// </summary>
        private static readonly ActivitySource s_chatSource = new ActivitySource(ACTIVITY_NAME);
        /// <summary>
        /// Add histograms to log metrics.
        /// On the ApplicationInsights metrics are logged to customMetrics table.
        /// </summary>
        private static readonly Meter s_meter = new Meter(ACTIVITY_NAME);
        private static readonly Histogram<double> s_duration = s_meter.CreateHistogram<double>(
            GenAiClientOperationDurationMetricName, "s", "Measures GenAI operation duration.");
        private static readonly Histogram<long> s_tokens = s_meter.CreateHistogram<long>(
            GenAiClientTokenUsageMetricName, "{token}", "Measures the number of input and output token used.");

        private Activity m_activity;
        private Stopwatch m_duration;
        private TagList m_commonTags;
        private StreamingRecordedResponse m_recordedStreamingResponse;

        /// <summary>
        /// Return the content of the message.
        /// Content accessor is implemented only on the exact class, but not on the abstract generated class. 
        /// </summary>
        /// <param name="message"></param>
        /// <returns></returns>
        /// <exception cref="NotSupportedException"></exception>
        private string getContent(ChatRequestMessage message)
        {
            if (message.GetType() == typeof(ChatRequestAssistantMessage))
                return ((ChatRequestAssistantMessage)message).Content;
            if (message.GetType() == typeof(ChatRequestSystemMessage))
                return ((ChatRequestSystemMessage)message).Content;
            if (message.GetType() == typeof(ChatRequestToolMessage))
                return ((ChatRequestToolMessage)message).Content;
            if (message.GetType() == typeof(ChatRequestUserMessage))
                return ((ChatRequestUserMessage)message).Content;
            throw new NotSupportedException("The message type is not supported");
        }

        /// <summary>
        /// Get the activity, if the telemetry is enabled. If there is no listeners for
        /// Activity source, null will be returned.
        /// </summary>
        /// <param name="name">The activity name.</param>
        /// <returns>Activity or null.</returns>
        private Activity getActivityMaybe(string name)
        {
            Activity act = null;
            string enable = Environment.GetEnvironmentVariable(ENABLE_ENV);
            if (enable != null && (enable.Equals("true", StringComparison.OrdinalIgnoreCase) || enable.Equals("1")))
                act = s_chatSource.CreateActivity(name, ActivityKind.Client);
            return act;
        }

        /// <summary>
        /// Set the tag on the activity, if the tag is present.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="name">The name of tag to set.</param>
        /// <param name="value">Nullable value to be set.</param>
        private void setTagMaybe<T>(string name, Nullable<T> value) where T: struct
        {
            if (value.HasValue && m_activity != null)
                m_activity.SetTag(name, value.Value);
        }

        /// <summary>
        /// Create the instance of OpenTelemetryScope. This constructor logs request
        /// and starts the execution timer.
        /// </summary>
        /// <param name="requestOptions">The request options used in the call.</param>
        /// <param name="endpoint">The endpoint being called.</param>
        public OpenTelemetryScope(ChatCompletionsOptions requestOptions, Uri endpoint)
        {
            m_recordedStreamingResponse = new();
            Activity m_activity = getActivityMaybe($"Complete_{requestOptions.Model}");
            if (m_activity == null)
                return;
            m_activity.Start();
            // Record the request to telemetry;
            m_commonTags = new TagList{
                { GenAiSystemKey, GenAiSystemValue},
                { GenAiResponseModelKey, requestOptions.Model},
                { ServerAddressKey, endpoint.Host },
                { ServerPortKey, endpoint.Port },
                { GenAiOperationNameKey, "Complete"}
            };
            // Set tags for reporting them to console.
            foreach (KeyValuePair<string, object> kv in m_commonTags)
            {
                m_activity.SetTag(kv.Key, kv.Value);
            }
            setTagMaybe(GenAiRequestMaxTokensKey, requestOptions.MaxTokens);
            setTagMaybe(GenAiRequestTemperatureKey, requestOptions.Temperature);
            if (requestOptions.AdditionalProperties != null && requestOptions.AdditionalProperties.ContainsKey("top_p"))
            {
                setTagMaybe(
                    GenAiRequestTopPKey,
                    JsonSerializer.Deserialize<double?>(requestOptions.AdditionalProperties["top_p"]));
            }
            // Log all messages as the events.
            foreach (ChatRequestMessage message in requestOptions.Messages)
            {
                TagList requestTags = new() {
                    { GenAiSystemKey, GenAiSystemValue},
                    { GenAiEventContent, getContent(message)}
                };
                m_activity.AddEvent(
                    new ActivityEvent(
                        $"gen_ai.{message.Role}.message",
                        DateTimeOffset.Now,
                        new ActivityTagsCollection(requestTags)
                    )
                );
            }
            m_duration = Stopwatch.StartNew();
        }

        public void RecordResponse(ChatCompletions response)
        {
            RecordResponseInternal(new SingleRecordedResponse(response));
        }

        public void UpdateStreamResponse<T>(T item)
        {
            if (typeof(T) != typeof(StreamingChatCompletionsUpdate))
                return;
            StreamingChatCompletionsUpdate castedItem = item as StreamingChatCompletionsUpdate;
            m_recordedStreamingResponse.Update(castedItem);
        }

        public void RecordStreamingResponse()
        {
            RecordResponseInternal(m_recordedStreamingResponse);
        }

        /// <summary>
        /// Log the error.
        /// </summary>
        /// <param name="e">Exception thrown by completion call.</param>
        public void RecordError(Exception e)
        {
            s_duration.Record(m_duration.Elapsed.TotalSeconds, m_commonTags);
            var errorType = e?.GetType()?.FullName;
            if ( e is Azure.RequestFailedException requestFailed)
            {
                errorType = requestFailed.Status.ToString();
            }
            m_activity.SetTag(ErrorTypeKey, errorType);
            m_activity.SetStatus(ActivityStatusCode.Error, e?.Message ?? errorType);
        }

        /// <summary>
        /// Record the events and metrics associated with the response.
        /// </summary>
        /// <param name="recordedResponse"></param>
        private void RecordResponseInternal(AbstractRecordedResponse recordedResponse)
        {
            // Record duration metric
            s_duration.Record(m_duration.Elapsed.TotalSeconds, m_commonTags);

            var tags = m_commonTags;
            tags.Add(GenAiResponseModelKey, recordedResponse.Model);
            // Record input tokens
            var input_tags = tags;
            input_tags.Add(GenAiUsageInputTokensKey, "input");
            s_tokens.Record(recordedResponse.PromptTokens, input_tags);
            // Record output tokens
            var output_tags = tags;
            output_tags.Add(GenAiUsageOutputTokensKey, "output");
            s_tokens.Record(recordedResponse.CompletionTokens, output_tags);

            // Record the event for each response
            string[] choices = recordedResponse.getSerializedCompletions(); 
            foreach (string choice in choices)
            {
                TagList completionTags = new()
                {
                    { GenAiSystemKey, GenAiSystemValue},
                    { GenAiEventContent, JsonSerializer.Serialize(choice) }
                };
                m_activity.AddEvent(new ActivityEvent(
                        GenAiChoice,
                        DateTimeOffset.Now,
                        new ActivityTagsCollection(completionTags)
                ));
            }
        }

        public void Dispose()
        {
            m_activity?.Stop();
        }
    }
}
