// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.Core;
using Azure.ResourceManager.Network.Models;

namespace Azure.ResourceManager.Network
{
    /// <summary> A class to add extension methods to Subscription. </summary>
    internal partial class SubscriptionExtensionClient : ArmResource
    {
        private ClientDiagnostics _applicationGatewayClientDiagnostics;
        private ApplicationGatewaysRestOperations _applicationGatewayRestClient;
        private ClientDiagnostics _applicationGatewaysClientDiagnostics;
        private ApplicationGatewaysRestOperations _applicationGatewaysRestClient;
        private ClientDiagnostics _applicationSecurityGroupClientDiagnostics;
        private ApplicationSecurityGroupsRestOperations _applicationSecurityGroupRestClient;
        private ClientDiagnostics _availableDelegationsClientDiagnostics;
        private AvailableDelegationsRestOperations _availableDelegationsRestClient;
        private ClientDiagnostics _availableServiceAliasesClientDiagnostics;
        private AvailableServiceAliasesRestOperations _availableServiceAliasesRestClient;
        private ClientDiagnostics _azureFirewallClientDiagnostics;
        private AzureFirewallsRestOperations _azureFirewallRestClient;
        private ClientDiagnostics _azureFirewallFqdnTagsClientDiagnostics;
        private AzureFirewallFqdnTagsRestOperations _azureFirewallFqdnTagsRestClient;
        private ClientDiagnostics _bastionHostClientDiagnostics;
        private BastionHostsRestOperations _bastionHostRestClient;
        private ClientDiagnostics _defaultClientDiagnostics;
        private NetworkManagementRestOperations _defaultRestClient;
        private ClientDiagnostics _customIpPrefixCustomIPPrefixesClientDiagnostics;
        private CustomIPPrefixesRestOperations _customIpPrefixCustomIPPrefixesRestClient;
        private ClientDiagnostics _ddosProtectionPlanClientDiagnostics;
        private DdosProtectionPlansRestOperations _ddosProtectionPlanRestClient;
        private ClientDiagnostics _dscpConfigurationClientDiagnostics;
        private DscpConfigurationRestOperations _dscpConfigurationRestClient;
        private ClientDiagnostics _availableEndpointServicesClientDiagnostics;
        private AvailableEndpointServicesRestOperations _availableEndpointServicesRestClient;
        private ClientDiagnostics _expressRouteCircuitClientDiagnostics;
        private ExpressRouteCircuitsRestOperations _expressRouteCircuitRestClient;
        private ClientDiagnostics _expressRouteServiceProvidersClientDiagnostics;
        private ExpressRouteServiceProvidersRestOperations _expressRouteServiceProvidersRestClient;
        private ClientDiagnostics _expressRouteCrossConnectionClientDiagnostics;
        private ExpressRouteCrossConnectionsRestOperations _expressRouteCrossConnectionRestClient;
        private ClientDiagnostics _expressRoutePortClientDiagnostics;
        private ExpressRoutePortsRestOperations _expressRoutePortRestClient;
        private ClientDiagnostics _firewallPolicyClientDiagnostics;
        private FirewallPoliciesRestOperations _firewallPolicyRestClient;
        private ClientDiagnostics _ipAllocationClientDiagnostics;
        private IpAllocationsRestOperations _ipAllocationRestClient;
        private ClientDiagnostics _ipGroupClientDiagnostics;
        private IpGroupsRestOperations _ipGroupRestClient;
        private ClientDiagnostics _loadBalancerClientDiagnostics;
        private LoadBalancersRestOperations _loadBalancerRestClient;
        private ClientDiagnostics _natGatewayClientDiagnostics;
        private NatGatewaysRestOperations _natGatewayRestClient;
        private ClientDiagnostics _networkInterfaceClientDiagnostics;
        private NetworkInterfacesRestOperations _networkInterfaceRestClient;
        private ClientDiagnostics _networkProfileClientDiagnostics;
        private NetworkProfilesRestOperations _networkProfileRestClient;
        private ClientDiagnostics _networkSecurityGroupClientDiagnostics;
        private NetworkSecurityGroupsRestOperations _networkSecurityGroupRestClient;
        private ClientDiagnostics _networkVirtualApplianceClientDiagnostics;
        private NetworkVirtualAppliancesRestOperations _networkVirtualApplianceRestClient;
        private ClientDiagnostics _networkWatcherClientDiagnostics;
        private NetworkWatchersRestOperations _networkWatcherRestClient;
        private ClientDiagnostics _privateEndpointClientDiagnostics;
        private PrivateEndpointsRestOperations _privateEndpointRestClient;
        private ClientDiagnostics _availablePrivateEndpointTypesClientDiagnostics;
        private AvailablePrivateEndpointTypesRestOperations _availablePrivateEndpointTypesRestClient;
        private ClientDiagnostics _privateLinkServiceClientDiagnostics;
        private PrivateLinkServicesRestOperations _privateLinkServiceRestClient;
        private ClientDiagnostics _privateLinkServicesClientDiagnostics;
        private PrivateLinkServicesRestOperations _privateLinkServicesRestClient;
        private ClientDiagnostics _publicIPAddressClientDiagnostics;
        private PublicIPAddressesRestOperations _publicIPAddressRestClient;
        private ClientDiagnostics _publicIPPrefixClientDiagnostics;
        private PublicIPPrefixesRestOperations _publicIPPrefixRestClient;
        private ClientDiagnostics _routeFilterClientDiagnostics;
        private RouteFiltersRestOperations _routeFilterRestClient;
        private ClientDiagnostics _routeTableClientDiagnostics;
        private RouteTablesRestOperations _routeTableRestClient;
        private ClientDiagnostics _securityPartnerProviderClientDiagnostics;
        private SecurityPartnerProvidersRestOperations _securityPartnerProviderRestClient;
        private ClientDiagnostics _bgpServiceCommunitiesClientDiagnostics;
        private BgpServiceCommunitiesRestOperations _bgpServiceCommunitiesRestClient;
        private ClientDiagnostics _serviceEndpointPolicyClientDiagnostics;
        private ServiceEndpointPoliciesRestOperations _serviceEndpointPolicyRestClient;
        private ClientDiagnostics _serviceTagsClientDiagnostics;
        private ServiceTagsRestOperations _serviceTagsRestClient;
        private ClientDiagnostics _usagesClientDiagnostics;
        private UsagesRestOperations _usagesRestClient;
        private ClientDiagnostics _virtualNetworkClientDiagnostics;
        private VirtualNetworksRestOperations _virtualNetworkRestClient;
        private ClientDiagnostics _virtualNetworkTapClientDiagnostics;
        private VirtualNetworkTapsRestOperations _virtualNetworkTapRestClient;
        private ClientDiagnostics _virtualRouterClientDiagnostics;
        private VirtualRoutersRestOperations _virtualRouterRestClient;
        private ClientDiagnostics _virtualWANVirtualWansClientDiagnostics;
        private VirtualWansRestOperations _virtualWANVirtualWansRestClient;
        private ClientDiagnostics _vpnSiteClientDiagnostics;
        private VpnSitesRestOperations _vpnSiteRestClient;
        private ClientDiagnostics _vpnServerConfigurationClientDiagnostics;
        private VpnServerConfigurationsRestOperations _vpnServerConfigurationRestClient;
        private ClientDiagnostics _virtualHubClientDiagnostics;
        private VirtualHubsRestOperations _virtualHubRestClient;
        private ClientDiagnostics _vpnGatewayClientDiagnostics;
        private VpnGatewaysRestOperations _vpnGatewayRestClient;
        private ClientDiagnostics _p2SVpnGatewayP2sVpnGatewaysClientDiagnostics;
        private P2SVpnGatewaysRestOperations _p2SVpnGatewayP2sVpnGatewaysRestClient;
        private ClientDiagnostics _expressRouteGatewayClientDiagnostics;
        private ExpressRouteGatewaysRestOperations _expressRouteGatewayRestClient;
        private ClientDiagnostics _webApplicationFirewallPolicyClientDiagnostics;
        private WebApplicationFirewallPoliciesRestOperations _webApplicationFirewallPolicyRestClient;

        /// <summary> Initializes a new instance of the <see cref="SubscriptionExtensionClient"/> class for mocking. </summary>
        protected SubscriptionExtensionClient()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="SubscriptionExtensionClient"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal SubscriptionExtensionClient(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
        }

        private ClientDiagnostics ApplicationGatewayClientDiagnostics => _applicationGatewayClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ApplicationGateway.ResourceType.Namespace, DiagnosticOptions);
        private ApplicationGatewaysRestOperations ApplicationGatewayRestClient => _applicationGatewayRestClient ??= new ApplicationGatewaysRestOperations(ApplicationGatewayClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(ApplicationGateway.ResourceType));
        private ClientDiagnostics ApplicationGatewaysClientDiagnostics => _applicationGatewaysClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private ApplicationGatewaysRestOperations ApplicationGatewaysRestClient => _applicationGatewaysRestClient ??= new ApplicationGatewaysRestOperations(ApplicationGatewaysClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics ApplicationSecurityGroupClientDiagnostics => _applicationSecurityGroupClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ApplicationSecurityGroup.ResourceType.Namespace, DiagnosticOptions);
        private ApplicationSecurityGroupsRestOperations ApplicationSecurityGroupRestClient => _applicationSecurityGroupRestClient ??= new ApplicationSecurityGroupsRestOperations(ApplicationSecurityGroupClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(ApplicationSecurityGroup.ResourceType));
        private ClientDiagnostics AvailableDelegationsClientDiagnostics => _availableDelegationsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private AvailableDelegationsRestOperations AvailableDelegationsRestClient => _availableDelegationsRestClient ??= new AvailableDelegationsRestOperations(AvailableDelegationsClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics AvailableServiceAliasesClientDiagnostics => _availableServiceAliasesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private AvailableServiceAliasesRestOperations AvailableServiceAliasesRestClient => _availableServiceAliasesRestClient ??= new AvailableServiceAliasesRestOperations(AvailableServiceAliasesClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics AzureFirewallClientDiagnostics => _azureFirewallClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", AzureFirewall.ResourceType.Namespace, DiagnosticOptions);
        private AzureFirewallsRestOperations AzureFirewallRestClient => _azureFirewallRestClient ??= new AzureFirewallsRestOperations(AzureFirewallClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(AzureFirewall.ResourceType));
        private ClientDiagnostics AzureFirewallFqdnTagsClientDiagnostics => _azureFirewallFqdnTagsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private AzureFirewallFqdnTagsRestOperations AzureFirewallFqdnTagsRestClient => _azureFirewallFqdnTagsRestClient ??= new AzureFirewallFqdnTagsRestOperations(AzureFirewallFqdnTagsClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics BastionHostClientDiagnostics => _bastionHostClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", BastionHost.ResourceType.Namespace, DiagnosticOptions);
        private BastionHostsRestOperations BastionHostRestClient => _bastionHostRestClient ??= new BastionHostsRestOperations(BastionHostClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(BastionHost.ResourceType));
        private ClientDiagnostics DefaultClientDiagnostics => _defaultClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private NetworkManagementRestOperations DefaultRestClient => _defaultRestClient ??= new NetworkManagementRestOperations(DefaultClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics CustomIpPrefixCustomIPPrefixesClientDiagnostics => _customIpPrefixCustomIPPrefixesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", CustomIpPrefix.ResourceType.Namespace, DiagnosticOptions);
        private CustomIPPrefixesRestOperations CustomIpPrefixCustomIPPrefixesRestClient => _customIpPrefixCustomIPPrefixesRestClient ??= new CustomIPPrefixesRestOperations(CustomIpPrefixCustomIPPrefixesClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(CustomIpPrefix.ResourceType));
        private ClientDiagnostics DdosProtectionPlanClientDiagnostics => _ddosProtectionPlanClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", DdosProtectionPlan.ResourceType.Namespace, DiagnosticOptions);
        private DdosProtectionPlansRestOperations DdosProtectionPlanRestClient => _ddosProtectionPlanRestClient ??= new DdosProtectionPlansRestOperations(DdosProtectionPlanClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(DdosProtectionPlan.ResourceType));
        private ClientDiagnostics DscpConfigurationClientDiagnostics => _dscpConfigurationClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", DscpConfiguration.ResourceType.Namespace, DiagnosticOptions);
        private DscpConfigurationRestOperations DscpConfigurationRestClient => _dscpConfigurationRestClient ??= new DscpConfigurationRestOperations(DscpConfigurationClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(DscpConfiguration.ResourceType));
        private ClientDiagnostics AvailableEndpointServicesClientDiagnostics => _availableEndpointServicesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private AvailableEndpointServicesRestOperations AvailableEndpointServicesRestClient => _availableEndpointServicesRestClient ??= new AvailableEndpointServicesRestOperations(AvailableEndpointServicesClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics ExpressRouteCircuitClientDiagnostics => _expressRouteCircuitClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ExpressRouteCircuit.ResourceType.Namespace, DiagnosticOptions);
        private ExpressRouteCircuitsRestOperations ExpressRouteCircuitRestClient => _expressRouteCircuitRestClient ??= new ExpressRouteCircuitsRestOperations(ExpressRouteCircuitClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(ExpressRouteCircuit.ResourceType));
        private ClientDiagnostics ExpressRouteServiceProvidersClientDiagnostics => _expressRouteServiceProvidersClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private ExpressRouteServiceProvidersRestOperations ExpressRouteServiceProvidersRestClient => _expressRouteServiceProvidersRestClient ??= new ExpressRouteServiceProvidersRestOperations(ExpressRouteServiceProvidersClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics ExpressRouteCrossConnectionClientDiagnostics => _expressRouteCrossConnectionClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ExpressRouteCrossConnection.ResourceType.Namespace, DiagnosticOptions);
        private ExpressRouteCrossConnectionsRestOperations ExpressRouteCrossConnectionRestClient => _expressRouteCrossConnectionRestClient ??= new ExpressRouteCrossConnectionsRestOperations(ExpressRouteCrossConnectionClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(ExpressRouteCrossConnection.ResourceType));
        private ClientDiagnostics ExpressRoutePortClientDiagnostics => _expressRoutePortClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ExpressRoutePort.ResourceType.Namespace, DiagnosticOptions);
        private ExpressRoutePortsRestOperations ExpressRoutePortRestClient => _expressRoutePortRestClient ??= new ExpressRoutePortsRestOperations(ExpressRoutePortClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(ExpressRoutePort.ResourceType));
        private ClientDiagnostics FirewallPolicyClientDiagnostics => _firewallPolicyClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", FirewallPolicy.ResourceType.Namespace, DiagnosticOptions);
        private FirewallPoliciesRestOperations FirewallPolicyRestClient => _firewallPolicyRestClient ??= new FirewallPoliciesRestOperations(FirewallPolicyClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(FirewallPolicy.ResourceType));
        private ClientDiagnostics IpAllocationClientDiagnostics => _ipAllocationClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", IpAllocation.ResourceType.Namespace, DiagnosticOptions);
        private IpAllocationsRestOperations IpAllocationRestClient => _ipAllocationRestClient ??= new IpAllocationsRestOperations(IpAllocationClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(IpAllocation.ResourceType));
        private ClientDiagnostics IpGroupClientDiagnostics => _ipGroupClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", IpGroup.ResourceType.Namespace, DiagnosticOptions);
        private IpGroupsRestOperations IpGroupRestClient => _ipGroupRestClient ??= new IpGroupsRestOperations(IpGroupClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(IpGroup.ResourceType));
        private ClientDiagnostics LoadBalancerClientDiagnostics => _loadBalancerClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", LoadBalancer.ResourceType.Namespace, DiagnosticOptions);
        private LoadBalancersRestOperations LoadBalancerRestClient => _loadBalancerRestClient ??= new LoadBalancersRestOperations(LoadBalancerClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(LoadBalancer.ResourceType));
        private ClientDiagnostics NatGatewayClientDiagnostics => _natGatewayClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", NatGateway.ResourceType.Namespace, DiagnosticOptions);
        private NatGatewaysRestOperations NatGatewayRestClient => _natGatewayRestClient ??= new NatGatewaysRestOperations(NatGatewayClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(NatGateway.ResourceType));
        private ClientDiagnostics NetworkInterfaceClientDiagnostics => _networkInterfaceClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", NetworkInterface.ResourceType.Namespace, DiagnosticOptions);
        private NetworkInterfacesRestOperations NetworkInterfaceRestClient => _networkInterfaceRestClient ??= new NetworkInterfacesRestOperations(NetworkInterfaceClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(NetworkInterface.ResourceType));
        private ClientDiagnostics NetworkProfileClientDiagnostics => _networkProfileClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", NetworkProfile.ResourceType.Namespace, DiagnosticOptions);
        private NetworkProfilesRestOperations NetworkProfileRestClient => _networkProfileRestClient ??= new NetworkProfilesRestOperations(NetworkProfileClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(NetworkProfile.ResourceType));
        private ClientDiagnostics NetworkSecurityGroupClientDiagnostics => _networkSecurityGroupClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", NetworkSecurityGroup.ResourceType.Namespace, DiagnosticOptions);
        private NetworkSecurityGroupsRestOperations NetworkSecurityGroupRestClient => _networkSecurityGroupRestClient ??= new NetworkSecurityGroupsRestOperations(NetworkSecurityGroupClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(NetworkSecurityGroup.ResourceType));
        private ClientDiagnostics NetworkVirtualApplianceClientDiagnostics => _networkVirtualApplianceClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", NetworkVirtualAppliance.ResourceType.Namespace, DiagnosticOptions);
        private NetworkVirtualAppliancesRestOperations NetworkVirtualApplianceRestClient => _networkVirtualApplianceRestClient ??= new NetworkVirtualAppliancesRestOperations(NetworkVirtualApplianceClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(NetworkVirtualAppliance.ResourceType));
        private ClientDiagnostics NetworkWatcherClientDiagnostics => _networkWatcherClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", NetworkWatcher.ResourceType.Namespace, DiagnosticOptions);
        private NetworkWatchersRestOperations NetworkWatcherRestClient => _networkWatcherRestClient ??= new NetworkWatchersRestOperations(NetworkWatcherClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(NetworkWatcher.ResourceType));
        private ClientDiagnostics PrivateEndpointClientDiagnostics => _privateEndpointClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", PrivateEndpoint.ResourceType.Namespace, DiagnosticOptions);
        private PrivateEndpointsRestOperations PrivateEndpointRestClient => _privateEndpointRestClient ??= new PrivateEndpointsRestOperations(PrivateEndpointClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(PrivateEndpoint.ResourceType));
        private ClientDiagnostics AvailablePrivateEndpointTypesClientDiagnostics => _availablePrivateEndpointTypesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private AvailablePrivateEndpointTypesRestOperations AvailablePrivateEndpointTypesRestClient => _availablePrivateEndpointTypesRestClient ??= new AvailablePrivateEndpointTypesRestOperations(AvailablePrivateEndpointTypesClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics PrivateLinkServiceClientDiagnostics => _privateLinkServiceClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", PrivateLinkService.ResourceType.Namespace, DiagnosticOptions);
        private PrivateLinkServicesRestOperations PrivateLinkServiceRestClient => _privateLinkServiceRestClient ??= new PrivateLinkServicesRestOperations(PrivateLinkServiceClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(PrivateLinkService.ResourceType));
        private ClientDiagnostics PrivateLinkServicesClientDiagnostics => _privateLinkServicesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private PrivateLinkServicesRestOperations PrivateLinkServicesRestClient => _privateLinkServicesRestClient ??= new PrivateLinkServicesRestOperations(PrivateLinkServicesClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics PublicIPAddressClientDiagnostics => _publicIPAddressClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", PublicIPAddress.ResourceType.Namespace, DiagnosticOptions);
        private PublicIPAddressesRestOperations PublicIPAddressRestClient => _publicIPAddressRestClient ??= new PublicIPAddressesRestOperations(PublicIPAddressClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(PublicIPAddress.ResourceType));
        private ClientDiagnostics PublicIPPrefixClientDiagnostics => _publicIPPrefixClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", PublicIPPrefix.ResourceType.Namespace, DiagnosticOptions);
        private PublicIPPrefixesRestOperations PublicIPPrefixRestClient => _publicIPPrefixRestClient ??= new PublicIPPrefixesRestOperations(PublicIPPrefixClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(PublicIPPrefix.ResourceType));
        private ClientDiagnostics RouteFilterClientDiagnostics => _routeFilterClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", RouteFilter.ResourceType.Namespace, DiagnosticOptions);
        private RouteFiltersRestOperations RouteFilterRestClient => _routeFilterRestClient ??= new RouteFiltersRestOperations(RouteFilterClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(RouteFilter.ResourceType));
        private ClientDiagnostics RouteTableClientDiagnostics => _routeTableClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", RouteTable.ResourceType.Namespace, DiagnosticOptions);
        private RouteTablesRestOperations RouteTableRestClient => _routeTableRestClient ??= new RouteTablesRestOperations(RouteTableClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(RouteTable.ResourceType));
        private ClientDiagnostics SecurityPartnerProviderClientDiagnostics => _securityPartnerProviderClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", SecurityPartnerProvider.ResourceType.Namespace, DiagnosticOptions);
        private SecurityPartnerProvidersRestOperations SecurityPartnerProviderRestClient => _securityPartnerProviderRestClient ??= new SecurityPartnerProvidersRestOperations(SecurityPartnerProviderClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(SecurityPartnerProvider.ResourceType));
        private ClientDiagnostics BgpServiceCommunitiesClientDiagnostics => _bgpServiceCommunitiesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private BgpServiceCommunitiesRestOperations BgpServiceCommunitiesRestClient => _bgpServiceCommunitiesRestClient ??= new BgpServiceCommunitiesRestOperations(BgpServiceCommunitiesClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics ServiceEndpointPolicyClientDiagnostics => _serviceEndpointPolicyClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ServiceEndpointPolicy.ResourceType.Namespace, DiagnosticOptions);
        private ServiceEndpointPoliciesRestOperations ServiceEndpointPolicyRestClient => _serviceEndpointPolicyRestClient ??= new ServiceEndpointPoliciesRestOperations(ServiceEndpointPolicyClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(ServiceEndpointPolicy.ResourceType));
        private ClientDiagnostics ServiceTagsClientDiagnostics => _serviceTagsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private ServiceTagsRestOperations ServiceTagsRestClient => _serviceTagsRestClient ??= new ServiceTagsRestOperations(ServiceTagsClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics UsagesClientDiagnostics => _usagesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private UsagesRestOperations UsagesRestClient => _usagesRestClient ??= new UsagesRestOperations(UsagesClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics VirtualNetworkClientDiagnostics => _virtualNetworkClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", VirtualNetwork.ResourceType.Namespace, DiagnosticOptions);
        private VirtualNetworksRestOperations VirtualNetworkRestClient => _virtualNetworkRestClient ??= new VirtualNetworksRestOperations(VirtualNetworkClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VirtualNetwork.ResourceType));
        private ClientDiagnostics VirtualNetworkTapClientDiagnostics => _virtualNetworkTapClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", VirtualNetworkTap.ResourceType.Namespace, DiagnosticOptions);
        private VirtualNetworkTapsRestOperations VirtualNetworkTapRestClient => _virtualNetworkTapRestClient ??= new VirtualNetworkTapsRestOperations(VirtualNetworkTapClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VirtualNetworkTap.ResourceType));
        private ClientDiagnostics VirtualRouterClientDiagnostics => _virtualRouterClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", VirtualRouter.ResourceType.Namespace, DiagnosticOptions);
        private VirtualRoutersRestOperations VirtualRouterRestClient => _virtualRouterRestClient ??= new VirtualRoutersRestOperations(VirtualRouterClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VirtualRouter.ResourceType));
        private ClientDiagnostics VirtualWANVirtualWansClientDiagnostics => _virtualWANVirtualWansClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", VirtualWAN.ResourceType.Namespace, DiagnosticOptions);
        private VirtualWansRestOperations VirtualWANVirtualWansRestClient => _virtualWANVirtualWansRestClient ??= new VirtualWansRestOperations(VirtualWANVirtualWansClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VirtualWAN.ResourceType));
        private ClientDiagnostics VpnSiteClientDiagnostics => _vpnSiteClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", VpnSite.ResourceType.Namespace, DiagnosticOptions);
        private VpnSitesRestOperations VpnSiteRestClient => _vpnSiteRestClient ??= new VpnSitesRestOperations(VpnSiteClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VpnSite.ResourceType));
        private ClientDiagnostics VpnServerConfigurationClientDiagnostics => _vpnServerConfigurationClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", VpnServerConfiguration.ResourceType.Namespace, DiagnosticOptions);
        private VpnServerConfigurationsRestOperations VpnServerConfigurationRestClient => _vpnServerConfigurationRestClient ??= new VpnServerConfigurationsRestOperations(VpnServerConfigurationClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VpnServerConfiguration.ResourceType));
        private ClientDiagnostics VirtualHubClientDiagnostics => _virtualHubClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", VirtualHub.ResourceType.Namespace, DiagnosticOptions);
        private VirtualHubsRestOperations VirtualHubRestClient => _virtualHubRestClient ??= new VirtualHubsRestOperations(VirtualHubClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VirtualHub.ResourceType));
        private ClientDiagnostics VpnGatewayClientDiagnostics => _vpnGatewayClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", VpnGateway.ResourceType.Namespace, DiagnosticOptions);
        private VpnGatewaysRestOperations VpnGatewayRestClient => _vpnGatewayRestClient ??= new VpnGatewaysRestOperations(VpnGatewayClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VpnGateway.ResourceType));
        private ClientDiagnostics P2SVpnGatewayP2sVpnGatewaysClientDiagnostics => _p2SVpnGatewayP2sVpnGatewaysClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", P2SVpnGateway.ResourceType.Namespace, DiagnosticOptions);
        private P2SVpnGatewaysRestOperations P2SVpnGatewayP2sVpnGatewaysRestClient => _p2SVpnGatewayP2sVpnGatewaysRestClient ??= new P2SVpnGatewaysRestOperations(P2SVpnGatewayP2sVpnGatewaysClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(P2SVpnGateway.ResourceType));
        private ClientDiagnostics ExpressRouteGatewayClientDiagnostics => _expressRouteGatewayClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", ExpressRouteGateway.ResourceType.Namespace, DiagnosticOptions);
        private ExpressRouteGatewaysRestOperations ExpressRouteGatewayRestClient => _expressRouteGatewayRestClient ??= new ExpressRouteGatewaysRestOperations(ExpressRouteGatewayClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(ExpressRouteGateway.ResourceType));
        private ClientDiagnostics WebApplicationFirewallPolicyClientDiagnostics => _webApplicationFirewallPolicyClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Network", WebApplicationFirewallPolicy.ResourceType.Namespace, DiagnosticOptions);
        private WebApplicationFirewallPoliciesRestOperations WebApplicationFirewallPolicyRestClient => _webApplicationFirewallPolicyRestClient ??= new WebApplicationFirewallPoliciesRestOperations(WebApplicationFirewallPolicyClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(WebApplicationFirewallPolicy.ResourceType));

        private string GetApiVersionOrNull(ResourceType resourceType)
        {
            Client.TryGetApiVersion(resourceType, out string apiVersion);
            return apiVersion;
        }

        /// <summary> Gets an object representing a ApplicationGatewayAvailableSslOptions along with the instance operations that can be performed on it in the SubscriptionExtensionClient. </summary>
        /// <returns> Returns a <see cref="ApplicationGatewayAvailableSslOptions" /> object. </returns>
        public virtual ApplicationGatewayAvailableSslOptions GetApplicationGatewayAvailableSslOptions()
        {
            return new ApplicationGatewayAvailableSslOptions(Client, new ResourceIdentifier(Id.ToString() + "/providers/Microsoft.Network/applicationGatewayAvailableSslOptions/default"));
        }

        /// <summary> Gets a collection of AzureWebCategories in the AzureWebCategory. </summary>
        /// <returns> An object representing collection of AzureWebCategories and their operations over a AzureWebCategory. </returns>
        public virtual AzureWebCategoryCollection GetAzureWebCategories()
        {
            return new AzureWebCategoryCollection(Client, Id);
        }

        /// <summary> Gets a collection of ExpressRoutePortsLocations in the ExpressRoutePortsLocation. </summary>
        /// <returns> An object representing collection of ExpressRoutePortsLocations and their operations over a ExpressRoutePortsLocation. </returns>
        public virtual ExpressRoutePortsLocationCollection GetExpressRoutePortsLocations()
        {
            return new ExpressRoutePortsLocationCollection(Client, Id);
        }

        /// <summary> Gets a collection of NetworkVirtualApplianceSkus in the NetworkVirtualApplianceSku. </summary>
        /// <returns> An object representing collection of NetworkVirtualApplianceSkus and their operations over a NetworkVirtualApplianceSku. </returns>
        public virtual NetworkVirtualApplianceSkuCollection GetNetworkVirtualApplianceSkus()
        {
            return new NetworkVirtualApplianceSkuCollection(Client, Id);
        }

        /// <summary> Gets all the application gateways in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ApplicationGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ApplicationGateway> GetApplicationGatewaysAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ApplicationGateway>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationGateways");
                scope.Start();
                try
                {
                    var response = await ApplicationGatewayRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ApplicationGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ApplicationGateway>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ApplicationGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationGateways");
                scope.Start();
                try
                {
                    var response = await ApplicationGatewayRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ApplicationGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the application gateways in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ApplicationGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ApplicationGateway> GetApplicationGateways(CancellationToken cancellationToken = default)
        {
            Page<ApplicationGateway> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationGateways");
                scope.Start();
                try
                {
                    var response = ApplicationGatewayRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ApplicationGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ApplicationGateway> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ApplicationGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationGateways");
                scope.Start();
                try
                {
                    var response = ApplicationGatewayRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ApplicationGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all available server variables. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="string" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<string> GetAvailableServerVariablesApplicationGatewaysAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<string>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableServerVariablesApplicationGateways");
                scope.Start();
                try
                {
                    var response = await ApplicationGatewaysRestClient.ListAvailableServerVariablesAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists all available server variables. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="string" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<string> GetAvailableServerVariablesApplicationGateways(CancellationToken cancellationToken = default)
        {
            Page<string> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableServerVariablesApplicationGateways");
                scope.Start();
                try
                {
                    var response = ApplicationGatewaysRestClient.ListAvailableServerVariables(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists all available request headers. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="string" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<string> GetAvailableRequestHeadersApplicationGatewaysAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<string>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableRequestHeadersApplicationGateways");
                scope.Start();
                try
                {
                    var response = await ApplicationGatewaysRestClient.ListAvailableRequestHeadersAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists all available request headers. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="string" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<string> GetAvailableRequestHeadersApplicationGateways(CancellationToken cancellationToken = default)
        {
            Page<string> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableRequestHeadersApplicationGateways");
                scope.Start();
                try
                {
                    var response = ApplicationGatewaysRestClient.ListAvailableRequestHeaders(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists all available response headers. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="string" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<string> GetAvailableResponseHeadersApplicationGatewaysAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<string>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableResponseHeadersApplicationGateways");
                scope.Start();
                try
                {
                    var response = await ApplicationGatewaysRestClient.ListAvailableResponseHeadersAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists all available response headers. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="string" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<string> GetAvailableResponseHeadersApplicationGateways(CancellationToken cancellationToken = default)
        {
            Page<string> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableResponseHeadersApplicationGateways");
                scope.Start();
                try
                {
                    var response = ApplicationGatewaysRestClient.ListAvailableResponseHeaders(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists all available web application firewall rule sets. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ApplicationGatewayFirewallRuleSet" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ApplicationGatewayFirewallRuleSet> GetApplicationGatewayAvailableWafRuleSetsAsyncAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ApplicationGatewayFirewallRuleSet>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationGatewayAvailableWafRuleSetsAsync");
                scope.Start();
                try
                {
                    var response = await ApplicationGatewaysRestClient.ListAvailableWafRuleSetsAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists all available web application firewall rule sets. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ApplicationGatewayFirewallRuleSet" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ApplicationGatewayFirewallRuleSet> GetApplicationGatewayAvailableWafRuleSetsAsync(CancellationToken cancellationToken = default)
        {
            Page<ApplicationGatewayFirewallRuleSet> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationGatewayAvailableWafRuleSetsAsync");
                scope.Start();
                try
                {
                    var response = ApplicationGatewaysRestClient.ListAvailableWafRuleSets(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets all application security groups in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ApplicationSecurityGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ApplicationSecurityGroup> GetApplicationSecurityGroupsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ApplicationSecurityGroup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationSecurityGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationSecurityGroups");
                scope.Start();
                try
                {
                    var response = await ApplicationSecurityGroupRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ApplicationSecurityGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ApplicationSecurityGroup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ApplicationSecurityGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationSecurityGroups");
                scope.Start();
                try
                {
                    var response = await ApplicationSecurityGroupRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ApplicationSecurityGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all application security groups in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ApplicationSecurityGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ApplicationSecurityGroup> GetApplicationSecurityGroups(CancellationToken cancellationToken = default)
        {
            Page<ApplicationSecurityGroup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ApplicationSecurityGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationSecurityGroups");
                scope.Start();
                try
                {
                    var response = ApplicationSecurityGroupRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ApplicationSecurityGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ApplicationSecurityGroup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ApplicationSecurityGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetApplicationSecurityGroups");
                scope.Start();
                try
                {
                    var response = ApplicationSecurityGroupRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ApplicationSecurityGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all of the available subnet delegations for this subscription in this region. </summary>
        /// <param name="location"> The location of the subnet. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="AvailableDelegation" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<AvailableDelegation> GetAvailableDelegationsAsync(string location, CancellationToken cancellationToken = default)
        {
            async Task<Page<AvailableDelegation>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AvailableDelegationsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableDelegations");
                scope.Start();
                try
                {
                    var response = await AvailableDelegationsRestClient.ListAsync(Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<AvailableDelegation>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AvailableDelegationsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableDelegations");
                scope.Start();
                try
                {
                    var response = await AvailableDelegationsRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all of the available subnet delegations for this subscription in this region. </summary>
        /// <param name="location"> The location of the subnet. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="AvailableDelegation" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<AvailableDelegation> GetAvailableDelegations(string location, CancellationToken cancellationToken = default)
        {
            Page<AvailableDelegation> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AvailableDelegationsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableDelegations");
                scope.Start();
                try
                {
                    var response = AvailableDelegationsRestClient.List(Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<AvailableDelegation> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AvailableDelegationsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableDelegations");
                scope.Start();
                try
                {
                    var response = AvailableDelegationsRestClient.ListNextPage(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all available service aliases for this subscription in this region. </summary>
        /// <param name="location"> The location. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="AvailableServiceAlias" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<AvailableServiceAlias> GetAvailableServiceAliasesAsync(string location, CancellationToken cancellationToken = default)
        {
            async Task<Page<AvailableServiceAlias>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AvailableServiceAliasesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableServiceAliases");
                scope.Start();
                try
                {
                    var response = await AvailableServiceAliasesRestClient.ListAsync(Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<AvailableServiceAlias>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AvailableServiceAliasesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableServiceAliases");
                scope.Start();
                try
                {
                    var response = await AvailableServiceAliasesRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all available service aliases for this subscription in this region. </summary>
        /// <param name="location"> The location. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="AvailableServiceAlias" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<AvailableServiceAlias> GetAvailableServiceAliases(string location, CancellationToken cancellationToken = default)
        {
            Page<AvailableServiceAlias> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AvailableServiceAliasesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableServiceAliases");
                scope.Start();
                try
                {
                    var response = AvailableServiceAliasesRestClient.List(Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<AvailableServiceAlias> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AvailableServiceAliasesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableServiceAliases");
                scope.Start();
                try
                {
                    var response = AvailableServiceAliasesRestClient.ListNextPage(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Azure Firewalls in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="AzureFirewall" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<AzureFirewall> GetAzureFirewallsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<AzureFirewall>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AzureFirewallClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAzureFirewalls");
                scope.Start();
                try
                {
                    var response = await AzureFirewallRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new AzureFirewall(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<AzureFirewall>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AzureFirewallClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAzureFirewalls");
                scope.Start();
                try
                {
                    var response = await AzureFirewallRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new AzureFirewall(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Azure Firewalls in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="AzureFirewall" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<AzureFirewall> GetAzureFirewalls(CancellationToken cancellationToken = default)
        {
            Page<AzureFirewall> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AzureFirewallClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAzureFirewalls");
                scope.Start();
                try
                {
                    var response = AzureFirewallRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new AzureFirewall(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<AzureFirewall> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AzureFirewallClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAzureFirewalls");
                scope.Start();
                try
                {
                    var response = AzureFirewallRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new AzureFirewall(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Azure Firewall FQDN Tags in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="AzureFirewallFqdnTag" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<AzureFirewallFqdnTag> GetAzureFirewallFqdnTagsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<AzureFirewallFqdnTag>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AzureFirewallFqdnTagsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAzureFirewallFqdnTags");
                scope.Start();
                try
                {
                    var response = await AzureFirewallFqdnTagsRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<AzureFirewallFqdnTag>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AzureFirewallFqdnTagsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAzureFirewallFqdnTags");
                scope.Start();
                try
                {
                    var response = await AzureFirewallFqdnTagsRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Azure Firewall FQDN Tags in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="AzureFirewallFqdnTag" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<AzureFirewallFqdnTag> GetAzureFirewallFqdnTags(CancellationToken cancellationToken = default)
        {
            Page<AzureFirewallFqdnTag> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AzureFirewallFqdnTagsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAzureFirewallFqdnTags");
                scope.Start();
                try
                {
                    var response = AzureFirewallFqdnTagsRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<AzureFirewallFqdnTag> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AzureFirewallFqdnTagsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAzureFirewallFqdnTags");
                scope.Start();
                try
                {
                    var response = AzureFirewallFqdnTagsRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all Bastion Hosts in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="BastionHost" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<BastionHost> GetBastionHostsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<BastionHost>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = BastionHostClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetBastionHosts");
                scope.Start();
                try
                {
                    var response = await BastionHostRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new BastionHost(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<BastionHost>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = BastionHostClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetBastionHosts");
                scope.Start();
                try
                {
                    var response = await BastionHostRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new BastionHost(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all Bastion Hosts in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="BastionHost" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<BastionHost> GetBastionHosts(CancellationToken cancellationToken = default)
        {
            Page<BastionHost> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = BastionHostClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetBastionHosts");
                scope.Start();
                try
                {
                    var response = BastionHostRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new BastionHost(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<BastionHost> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = BastionHostClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetBastionHosts");
                scope.Start();
                try
                {
                    var response = BastionHostRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new BastionHost(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Checks whether a domain name in the cloudapp.azure.com zone is available for use. </summary>
        /// <param name="location"> The location of the domain name. </param>
        /// <param name="domainNameLabel"> The domain name to be verified. It must conform to the following regular expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<DnsNameAvailabilityResult>> CheckDnsNameAvailabilityAsync(string location, string domainNameLabel, CancellationToken cancellationToken = default)
        {
            using var scope = DefaultClientDiagnostics.CreateScope("SubscriptionExtensionClient.CheckDnsNameAvailability");
            scope.Start();
            try
            {
                var response = await DefaultRestClient.CheckDnsNameAvailabilityAsync(Id.SubscriptionId, location, domainNameLabel, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether a domain name in the cloudapp.azure.com zone is available for use. </summary>
        /// <param name="location"> The location of the domain name. </param>
        /// <param name="domainNameLabel"> The domain name to be verified. It must conform to the following regular expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DnsNameAvailabilityResult> CheckDnsNameAvailability(string location, string domainNameLabel, CancellationToken cancellationToken = default)
        {
            using var scope = DefaultClientDiagnostics.CreateScope("SubscriptionExtensionClient.CheckDnsNameAvailability");
            scope.Start();
            try
            {
                var response = DefaultRestClient.CheckDnsNameAvailability(Id.SubscriptionId, location, domainNameLabel, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets all the custom IP prefixes in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="CustomIpPrefix" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<CustomIpPrefix> GetCustomIpPrefixesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<CustomIpPrefix>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = CustomIpPrefixCustomIPPrefixesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetCustomIpPrefixes");
                scope.Start();
                try
                {
                    var response = await CustomIpPrefixCustomIPPrefixesRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new CustomIpPrefix(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<CustomIpPrefix>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = CustomIpPrefixCustomIPPrefixesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetCustomIpPrefixes");
                scope.Start();
                try
                {
                    var response = await CustomIpPrefixCustomIPPrefixesRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new CustomIpPrefix(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the custom IP prefixes in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="CustomIpPrefix" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<CustomIpPrefix> GetCustomIpPrefixes(CancellationToken cancellationToken = default)
        {
            Page<CustomIpPrefix> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = CustomIpPrefixCustomIPPrefixesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetCustomIpPrefixes");
                scope.Start();
                try
                {
                    var response = CustomIpPrefixCustomIPPrefixesRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new CustomIpPrefix(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<CustomIpPrefix> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = CustomIpPrefixCustomIPPrefixesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetCustomIpPrefixes");
                scope.Start();
                try
                {
                    var response = CustomIpPrefixCustomIPPrefixesRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new CustomIpPrefix(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all DDoS protection plans in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="DdosProtectionPlan" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<DdosProtectionPlan> GetDdosProtectionPlansAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<DdosProtectionPlan>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = DdosProtectionPlanClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDdosProtectionPlans");
                scope.Start();
                try
                {
                    var response = await DdosProtectionPlanRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new DdosProtectionPlan(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DdosProtectionPlan>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = DdosProtectionPlanClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDdosProtectionPlans");
                scope.Start();
                try
                {
                    var response = await DdosProtectionPlanRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new DdosProtectionPlan(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all DDoS protection plans in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="DdosProtectionPlan" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<DdosProtectionPlan> GetDdosProtectionPlans(CancellationToken cancellationToken = default)
        {
            Page<DdosProtectionPlan> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = DdosProtectionPlanClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDdosProtectionPlans");
                scope.Start();
                try
                {
                    var response = DdosProtectionPlanRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new DdosProtectionPlan(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DdosProtectionPlan> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = DdosProtectionPlanClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDdosProtectionPlans");
                scope.Start();
                try
                {
                    var response = DdosProtectionPlanRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new DdosProtectionPlan(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all dscp configurations in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="DscpConfiguration" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<DscpConfiguration> GetDscpConfigurationsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<DscpConfiguration>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = DscpConfigurationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDscpConfigurations");
                scope.Start();
                try
                {
                    var response = await DscpConfigurationRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new DscpConfiguration(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DscpConfiguration>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = DscpConfigurationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDscpConfigurations");
                scope.Start();
                try
                {
                    var response = await DscpConfigurationRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new DscpConfiguration(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all dscp configurations in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="DscpConfiguration" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<DscpConfiguration> GetDscpConfigurations(CancellationToken cancellationToken = default)
        {
            Page<DscpConfiguration> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = DscpConfigurationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDscpConfigurations");
                scope.Start();
                try
                {
                    var response = DscpConfigurationRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new DscpConfiguration(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DscpConfiguration> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = DscpConfigurationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDscpConfigurations");
                scope.Start();
                try
                {
                    var response = DscpConfigurationRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new DscpConfiguration(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List what values of endpoint services are available for use. </summary>
        /// <param name="location"> The location to check available endpoint services. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EndpointServiceResult" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EndpointServiceResult> GetAvailableEndpointServicesAsync(string location, CancellationToken cancellationToken = default)
        {
            async Task<Page<EndpointServiceResult>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AvailableEndpointServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableEndpointServices");
                scope.Start();
                try
                {
                    var response = await AvailableEndpointServicesRestClient.ListAsync(Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<EndpointServiceResult>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AvailableEndpointServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableEndpointServices");
                scope.Start();
                try
                {
                    var response = await AvailableEndpointServicesRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List what values of endpoint services are available for use. </summary>
        /// <param name="location"> The location to check available endpoint services. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EndpointServiceResult" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EndpointServiceResult> GetAvailableEndpointServices(string location, CancellationToken cancellationToken = default)
        {
            Page<EndpointServiceResult> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AvailableEndpointServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableEndpointServices");
                scope.Start();
                try
                {
                    var response = AvailableEndpointServicesRestClient.List(Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<EndpointServiceResult> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AvailableEndpointServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailableEndpointServices");
                scope.Start();
                try
                {
                    var response = AvailableEndpointServicesRestClient.ListNextPage(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the express route circuits in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ExpressRouteCircuit" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ExpressRouteCircuit> GetExpressRouteCircuitsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ExpressRouteCircuit>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRouteCircuitClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteCircuits");
                scope.Start();
                try
                {
                    var response = await ExpressRouteCircuitRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteCircuit(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ExpressRouteCircuit>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ExpressRouteCircuitClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteCircuits");
                scope.Start();
                try
                {
                    var response = await ExpressRouteCircuitRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteCircuit(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the express route circuits in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ExpressRouteCircuit" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ExpressRouteCircuit> GetExpressRouteCircuits(CancellationToken cancellationToken = default)
        {
            Page<ExpressRouteCircuit> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRouteCircuitClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteCircuits");
                scope.Start();
                try
                {
                    var response = ExpressRouteCircuitRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteCircuit(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ExpressRouteCircuit> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ExpressRouteCircuitClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteCircuits");
                scope.Start();
                try
                {
                    var response = ExpressRouteCircuitRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteCircuit(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the available express route service providers. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ExpressRouteServiceProvider" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ExpressRouteServiceProvider> GetExpressRouteServiceProvidersAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ExpressRouteServiceProvider>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRouteServiceProvidersClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteServiceProviders");
                scope.Start();
                try
                {
                    var response = await ExpressRouteServiceProvidersRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ExpressRouteServiceProvider>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ExpressRouteServiceProvidersClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteServiceProviders");
                scope.Start();
                try
                {
                    var response = await ExpressRouteServiceProvidersRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the available express route service providers. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ExpressRouteServiceProvider" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ExpressRouteServiceProvider> GetExpressRouteServiceProviders(CancellationToken cancellationToken = default)
        {
            Page<ExpressRouteServiceProvider> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRouteServiceProvidersClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteServiceProviders");
                scope.Start();
                try
                {
                    var response = ExpressRouteServiceProvidersRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ExpressRouteServiceProvider> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ExpressRouteServiceProvidersClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteServiceProviders");
                scope.Start();
                try
                {
                    var response = ExpressRouteServiceProvidersRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Retrieves all the ExpressRouteCrossConnections in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ExpressRouteCrossConnection" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ExpressRouteCrossConnection> GetExpressRouteCrossConnectionsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ExpressRouteCrossConnection>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRouteCrossConnectionClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteCrossConnections");
                scope.Start();
                try
                {
                    var response = await ExpressRouteCrossConnectionRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteCrossConnection(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ExpressRouteCrossConnection>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ExpressRouteCrossConnectionClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteCrossConnections");
                scope.Start();
                try
                {
                    var response = await ExpressRouteCrossConnectionRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteCrossConnection(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Retrieves all the ExpressRouteCrossConnections in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ExpressRouteCrossConnection" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ExpressRouteCrossConnection> GetExpressRouteCrossConnections(CancellationToken cancellationToken = default)
        {
            Page<ExpressRouteCrossConnection> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRouteCrossConnectionClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteCrossConnections");
                scope.Start();
                try
                {
                    var response = ExpressRouteCrossConnectionRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteCrossConnection(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ExpressRouteCrossConnection> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ExpressRouteCrossConnectionClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteCrossConnections");
                scope.Start();
                try
                {
                    var response = ExpressRouteCrossConnectionRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteCrossConnection(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List all the ExpressRoutePort resources in the specified subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ExpressRoutePort" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ExpressRoutePort> GetExpressRoutePortsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ExpressRoutePort>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRoutePortClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRoutePorts");
                scope.Start();
                try
                {
                    var response = await ExpressRoutePortRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRoutePort(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ExpressRoutePort>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ExpressRoutePortClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRoutePorts");
                scope.Start();
                try
                {
                    var response = await ExpressRoutePortRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRoutePort(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List all the ExpressRoutePort resources in the specified subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ExpressRoutePort" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ExpressRoutePort> GetExpressRoutePorts(CancellationToken cancellationToken = default)
        {
            Page<ExpressRoutePort> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRoutePortClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRoutePorts");
                scope.Start();
                try
                {
                    var response = ExpressRoutePortRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRoutePort(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ExpressRoutePort> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ExpressRoutePortClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRoutePorts");
                scope.Start();
                try
                {
                    var response = ExpressRoutePortRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRoutePort(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Firewall Policies in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="FirewallPolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<FirewallPolicy> GetFirewallPoliciesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<FirewallPolicy>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = FirewallPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetFirewallPolicies");
                scope.Start();
                try
                {
                    var response = await FirewallPolicyRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new FirewallPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<FirewallPolicy>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = FirewallPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetFirewallPolicies");
                scope.Start();
                try
                {
                    var response = await FirewallPolicyRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new FirewallPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Firewall Policies in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="FirewallPolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<FirewallPolicy> GetFirewallPolicies(CancellationToken cancellationToken = default)
        {
            Page<FirewallPolicy> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = FirewallPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetFirewallPolicies");
                scope.Start();
                try
                {
                    var response = FirewallPolicyRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new FirewallPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<FirewallPolicy> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = FirewallPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetFirewallPolicies");
                scope.Start();
                try
                {
                    var response = FirewallPolicyRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new FirewallPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all IpAllocations in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IpAllocation" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IpAllocation> GetIpAllocationsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<IpAllocation>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = IpAllocationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetIpAllocations");
                scope.Start();
                try
                {
                    var response = await IpAllocationRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new IpAllocation(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<IpAllocation>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = IpAllocationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetIpAllocations");
                scope.Start();
                try
                {
                    var response = await IpAllocationRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new IpAllocation(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all IpAllocations in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IpAllocation" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IpAllocation> GetIpAllocations(CancellationToken cancellationToken = default)
        {
            Page<IpAllocation> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = IpAllocationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetIpAllocations");
                scope.Start();
                try
                {
                    var response = IpAllocationRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new IpAllocation(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<IpAllocation> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = IpAllocationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetIpAllocations");
                scope.Start();
                try
                {
                    var response = IpAllocationRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new IpAllocation(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all IpGroups in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IpGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IpGroup> GetIpGroupsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<IpGroup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = IpGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetIpGroups");
                scope.Start();
                try
                {
                    var response = await IpGroupRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new IpGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<IpGroup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = IpGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetIpGroups");
                scope.Start();
                try
                {
                    var response = await IpGroupRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new IpGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all IpGroups in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IpGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IpGroup> GetIpGroups(CancellationToken cancellationToken = default)
        {
            Page<IpGroup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = IpGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetIpGroups");
                scope.Start();
                try
                {
                    var response = IpGroupRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new IpGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<IpGroup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = IpGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetIpGroups");
                scope.Start();
                try
                {
                    var response = IpGroupRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new IpGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the load balancers in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="LoadBalancer" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<LoadBalancer> GetLoadBalancersAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<LoadBalancer>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LoadBalancerClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLoadBalancers");
                scope.Start();
                try
                {
                    var response = await LoadBalancerRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new LoadBalancer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<LoadBalancer>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LoadBalancerClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLoadBalancers");
                scope.Start();
                try
                {
                    var response = await LoadBalancerRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new LoadBalancer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the load balancers in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="LoadBalancer" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<LoadBalancer> GetLoadBalancers(CancellationToken cancellationToken = default)
        {
            Page<LoadBalancer> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LoadBalancerClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLoadBalancers");
                scope.Start();
                try
                {
                    var response = LoadBalancerRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new LoadBalancer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<LoadBalancer> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LoadBalancerClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLoadBalancers");
                scope.Start();
                try
                {
                    var response = LoadBalancerRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new LoadBalancer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Swaps VIPs between two load balancers. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="location"> The region where load balancers are located at. </param>
        /// <param name="parameters"> Parameters that define which VIPs should be swapped. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<SwapPublicIpAddressesLoadBalancerOperation> SwapPublicIpAddressesLoadBalancerAsync(bool waitForCompletion, string location, LoadBalancerVipSwapRequest parameters, CancellationToken cancellationToken = default)
        {
            using var scope = LoadBalancerClientDiagnostics.CreateScope("SubscriptionExtensionClient.SwapPublicIpAddressesLoadBalancer");
            scope.Start();
            try
            {
                var response = await LoadBalancerRestClient.SwapPublicIpAddressesAsync(Id.SubscriptionId, location, parameters, cancellationToken).ConfigureAwait(false);
                var operation = new SwapPublicIpAddressesLoadBalancerOperation(LoadBalancerClientDiagnostics, Pipeline, LoadBalancerRestClient.CreateSwapPublicIpAddressesRequest(Id.SubscriptionId, location, parameters).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Swaps VIPs between two load balancers. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="location"> The region where load balancers are located at. </param>
        /// <param name="parameters"> Parameters that define which VIPs should be swapped. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual SwapPublicIpAddressesLoadBalancerOperation SwapPublicIpAddressesLoadBalancer(bool waitForCompletion, string location, LoadBalancerVipSwapRequest parameters, CancellationToken cancellationToken = default)
        {
            using var scope = LoadBalancerClientDiagnostics.CreateScope("SubscriptionExtensionClient.SwapPublicIpAddressesLoadBalancer");
            scope.Start();
            try
            {
                var response = LoadBalancerRestClient.SwapPublicIpAddresses(Id.SubscriptionId, location, parameters, cancellationToken);
                var operation = new SwapPublicIpAddressesLoadBalancerOperation(LoadBalancerClientDiagnostics, Pipeline, LoadBalancerRestClient.CreateSwapPublicIpAddressesRequest(Id.SubscriptionId, location, parameters).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets all the Nat Gateways in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NatGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NatGateway> GetNatGatewaysAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<NatGateway>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NatGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNatGateways");
                scope.Start();
                try
                {
                    var response = await NatGatewayRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NatGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<NatGateway>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NatGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNatGateways");
                scope.Start();
                try
                {
                    var response = await NatGatewayRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NatGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Nat Gateways in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NatGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NatGateway> GetNatGateways(CancellationToken cancellationToken = default)
        {
            Page<NatGateway> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NatGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNatGateways");
                scope.Start();
                try
                {
                    var response = NatGatewayRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NatGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<NatGateway> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NatGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNatGateways");
                scope.Start();
                try
                {
                    var response = NatGatewayRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NatGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all network interfaces in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkInterface" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkInterface> GetNetworkInterfacesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<NetworkInterface>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkInterfaceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkInterfaces");
                scope.Start();
                try
                {
                    var response = await NetworkInterfaceRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkInterface(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<NetworkInterface>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NetworkInterfaceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkInterfaces");
                scope.Start();
                try
                {
                    var response = await NetworkInterfaceRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkInterface(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all network interfaces in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkInterface" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkInterface> GetNetworkInterfaces(CancellationToken cancellationToken = default)
        {
            Page<NetworkInterface> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkInterfaceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkInterfaces");
                scope.Start();
                try
                {
                    var response = NetworkInterfaceRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkInterface(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<NetworkInterface> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NetworkInterfaceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkInterfaces");
                scope.Start();
                try
                {
                    var response = NetworkInterfaceRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkInterface(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the network profiles in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkProfile" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkProfile> GetNetworkProfilesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<NetworkProfile>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkProfileClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkProfiles");
                scope.Start();
                try
                {
                    var response = await NetworkProfileRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkProfile(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<NetworkProfile>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NetworkProfileClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkProfiles");
                scope.Start();
                try
                {
                    var response = await NetworkProfileRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkProfile(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the network profiles in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkProfile" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkProfile> GetNetworkProfiles(CancellationToken cancellationToken = default)
        {
            Page<NetworkProfile> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkProfileClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkProfiles");
                scope.Start();
                try
                {
                    var response = NetworkProfileRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkProfile(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<NetworkProfile> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NetworkProfileClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkProfiles");
                scope.Start();
                try
                {
                    var response = NetworkProfileRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkProfile(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all network security groups in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkSecurityGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkSecurityGroup> GetNetworkSecurityGroupsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<NetworkSecurityGroup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkSecurityGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkSecurityGroups");
                scope.Start();
                try
                {
                    var response = await NetworkSecurityGroupRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkSecurityGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<NetworkSecurityGroup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NetworkSecurityGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkSecurityGroups");
                scope.Start();
                try
                {
                    var response = await NetworkSecurityGroupRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkSecurityGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all network security groups in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkSecurityGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkSecurityGroup> GetNetworkSecurityGroups(CancellationToken cancellationToken = default)
        {
            Page<NetworkSecurityGroup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkSecurityGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkSecurityGroups");
                scope.Start();
                try
                {
                    var response = NetworkSecurityGroupRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkSecurityGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<NetworkSecurityGroup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NetworkSecurityGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkSecurityGroups");
                scope.Start();
                try
                {
                    var response = NetworkSecurityGroupRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkSecurityGroup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all Network Virtual Appliances in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkVirtualAppliance" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkVirtualAppliance> GetNetworkVirtualAppliancesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<NetworkVirtualAppliance>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkVirtualApplianceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkVirtualAppliances");
                scope.Start();
                try
                {
                    var response = await NetworkVirtualApplianceRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkVirtualAppliance(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<NetworkVirtualAppliance>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NetworkVirtualApplianceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkVirtualAppliances");
                scope.Start();
                try
                {
                    var response = await NetworkVirtualApplianceRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkVirtualAppliance(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all Network Virtual Appliances in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkVirtualAppliance" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkVirtualAppliance> GetNetworkVirtualAppliances(CancellationToken cancellationToken = default)
        {
            Page<NetworkVirtualAppliance> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkVirtualApplianceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkVirtualAppliances");
                scope.Start();
                try
                {
                    var response = NetworkVirtualApplianceRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkVirtualAppliance(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<NetworkVirtualAppliance> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = NetworkVirtualApplianceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkVirtualAppliances");
                scope.Start();
                try
                {
                    var response = NetworkVirtualApplianceRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkVirtualAppliance(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all network watchers by subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkWatcher" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkWatcher> GetNetworkWatchersAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<NetworkWatcher>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkWatcherClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkWatchers");
                scope.Start();
                try
                {
                    var response = await NetworkWatcherRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkWatcher(Client, value)), null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets all network watchers by subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkWatcher" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkWatcher> GetNetworkWatchers(CancellationToken cancellationToken = default)
        {
            Page<NetworkWatcher> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = NetworkWatcherClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetNetworkWatchers");
                scope.Start();
                try
                {
                    var response = NetworkWatcherRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new NetworkWatcher(Client, value)), null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets all private endpoints in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="PrivateEndpoint" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<PrivateEndpoint> GetPrivateEndpointsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<PrivateEndpoint>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PrivateEndpointClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPrivateEndpoints");
                scope.Start();
                try
                {
                    var response = await PrivateEndpointRestClient.ListBySubscriptionAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new PrivateEndpoint(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<PrivateEndpoint>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PrivateEndpointClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPrivateEndpoints");
                scope.Start();
                try
                {
                    var response = await PrivateEndpointRestClient.ListBySubscriptionNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new PrivateEndpoint(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all private endpoints in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="PrivateEndpoint" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<PrivateEndpoint> GetPrivateEndpoints(CancellationToken cancellationToken = default)
        {
            Page<PrivateEndpoint> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PrivateEndpointClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPrivateEndpoints");
                scope.Start();
                try
                {
                    var response = PrivateEndpointRestClient.ListBySubscription(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new PrivateEndpoint(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<PrivateEndpoint> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PrivateEndpointClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPrivateEndpoints");
                scope.Start();
                try
                {
                    var response = PrivateEndpointRestClient.ListBySubscriptionNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new PrivateEndpoint(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Returns all of the resource types that can be linked to a Private Endpoint in this subscription in this region. </summary>
        /// <param name="location"> The location of the domain name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="AvailablePrivateEndpointType" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<AvailablePrivateEndpointType> GetAvailablePrivateEndpointTypesAsync(string location, CancellationToken cancellationToken = default)
        {
            async Task<Page<AvailablePrivateEndpointType>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AvailablePrivateEndpointTypesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailablePrivateEndpointTypes");
                scope.Start();
                try
                {
                    var response = await AvailablePrivateEndpointTypesRestClient.ListAsync(Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<AvailablePrivateEndpointType>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AvailablePrivateEndpointTypesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailablePrivateEndpointTypes");
                scope.Start();
                try
                {
                    var response = await AvailablePrivateEndpointTypesRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Returns all of the resource types that can be linked to a Private Endpoint in this subscription in this region. </summary>
        /// <param name="location"> The location of the domain name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="AvailablePrivateEndpointType" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<AvailablePrivateEndpointType> GetAvailablePrivateEndpointTypes(string location, CancellationToken cancellationToken = default)
        {
            Page<AvailablePrivateEndpointType> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = AvailablePrivateEndpointTypesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailablePrivateEndpointTypes");
                scope.Start();
                try
                {
                    var response = AvailablePrivateEndpointTypesRestClient.List(Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<AvailablePrivateEndpointType> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = AvailablePrivateEndpointTypesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAvailablePrivateEndpointTypes");
                scope.Start();
                try
                {
                    var response = AvailablePrivateEndpointTypesRestClient.ListNextPage(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all private link service in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="PrivateLinkService" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<PrivateLinkService> GetPrivateLinkServicesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<PrivateLinkService>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PrivateLinkServiceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPrivateLinkServices");
                scope.Start();
                try
                {
                    var response = await PrivateLinkServiceRestClient.ListBySubscriptionAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new PrivateLinkService(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<PrivateLinkService>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PrivateLinkServiceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPrivateLinkServices");
                scope.Start();
                try
                {
                    var response = await PrivateLinkServiceRestClient.ListBySubscriptionNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new PrivateLinkService(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all private link service in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="PrivateLinkService" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<PrivateLinkService> GetPrivateLinkServices(CancellationToken cancellationToken = default)
        {
            Page<PrivateLinkService> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PrivateLinkServiceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPrivateLinkServices");
                scope.Start();
                try
                {
                    var response = PrivateLinkServiceRestClient.ListBySubscription(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new PrivateLinkService(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<PrivateLinkService> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PrivateLinkServiceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPrivateLinkServices");
                scope.Start();
                try
                {
                    var response = PrivateLinkServiceRestClient.ListBySubscriptionNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new PrivateLinkService(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Checks whether the subscription is visible to private link service. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="location"> The location of the domain name. </param>
        /// <param name="parameters"> The request body of CheckPrivateLinkService API call. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<CheckPrivateLinkServiceVisibilityPrivateLinkServiceOperation> CheckPrivateLinkServiceVisibilityPrivateLinkServiceAsync(bool waitForCompletion, string location, CheckPrivateLinkServiceVisibilityRequest parameters, CancellationToken cancellationToken = default)
        {
            using var scope = PrivateLinkServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.CheckPrivateLinkServiceVisibilityPrivateLinkService");
            scope.Start();
            try
            {
                var response = await PrivateLinkServicesRestClient.CheckPrivateLinkServiceVisibilityAsync(Id.SubscriptionId, location, parameters, cancellationToken).ConfigureAwait(false);
                var operation = new CheckPrivateLinkServiceVisibilityPrivateLinkServiceOperation(PrivateLinkServicesClientDiagnostics, Pipeline, PrivateLinkServicesRestClient.CreateCheckPrivateLinkServiceVisibilityRequest(Id.SubscriptionId, location, parameters).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the subscription is visible to private link service. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="location"> The location of the domain name. </param>
        /// <param name="parameters"> The request body of CheckPrivateLinkService API call. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual CheckPrivateLinkServiceVisibilityPrivateLinkServiceOperation CheckPrivateLinkServiceVisibilityPrivateLinkService(bool waitForCompletion, string location, CheckPrivateLinkServiceVisibilityRequest parameters, CancellationToken cancellationToken = default)
        {
            using var scope = PrivateLinkServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.CheckPrivateLinkServiceVisibilityPrivateLinkService");
            scope.Start();
            try
            {
                var response = PrivateLinkServicesRestClient.CheckPrivateLinkServiceVisibility(Id.SubscriptionId, location, parameters, cancellationToken);
                var operation = new CheckPrivateLinkServiceVisibilityPrivateLinkServiceOperation(PrivateLinkServicesClientDiagnostics, Pipeline, PrivateLinkServicesRestClient.CreateCheckPrivateLinkServiceVisibilityRequest(Id.SubscriptionId, location, parameters).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns all of the private link service ids that can be linked to a Private Endpoint with auto approved in this subscription in this region. </summary>
        /// <param name="location"> The location of the domain name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="AutoApprovedPrivateLinkService" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<AutoApprovedPrivateLinkService> GetAutoApprovedPrivateLinkServicesPrivateLinkServicesAsync(string location, CancellationToken cancellationToken = default)
        {
            async Task<Page<AutoApprovedPrivateLinkService>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PrivateLinkServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAutoApprovedPrivateLinkServicesPrivateLinkServices");
                scope.Start();
                try
                {
                    var response = await PrivateLinkServicesRestClient.ListAutoApprovedPrivateLinkServicesAsync(Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<AutoApprovedPrivateLinkService>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PrivateLinkServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAutoApprovedPrivateLinkServicesPrivateLinkServices");
                scope.Start();
                try
                {
                    var response = await PrivateLinkServicesRestClient.ListAutoApprovedPrivateLinkServicesNextPageAsync(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Returns all of the private link service ids that can be linked to a Private Endpoint with auto approved in this subscription in this region. </summary>
        /// <param name="location"> The location of the domain name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="AutoApprovedPrivateLinkService" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<AutoApprovedPrivateLinkService> GetAutoApprovedPrivateLinkServicesPrivateLinkServices(string location, CancellationToken cancellationToken = default)
        {
            Page<AutoApprovedPrivateLinkService> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PrivateLinkServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAutoApprovedPrivateLinkServicesPrivateLinkServices");
                scope.Start();
                try
                {
                    var response = PrivateLinkServicesRestClient.ListAutoApprovedPrivateLinkServices(Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<AutoApprovedPrivateLinkService> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PrivateLinkServicesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetAutoApprovedPrivateLinkServicesPrivateLinkServices");
                scope.Start();
                try
                {
                    var response = PrivateLinkServicesRestClient.ListAutoApprovedPrivateLinkServicesNextPage(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the public IP addresses in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="PublicIPAddress" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<PublicIPAddress> GetPublicIPAddressesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<PublicIPAddress>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PublicIPAddressClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPublicIPAddresses");
                scope.Start();
                try
                {
                    var response = await PublicIPAddressRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new PublicIPAddress(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<PublicIPAddress>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PublicIPAddressClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPublicIPAddresses");
                scope.Start();
                try
                {
                    var response = await PublicIPAddressRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new PublicIPAddress(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the public IP addresses in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="PublicIPAddress" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<PublicIPAddress> GetPublicIPAddresses(CancellationToken cancellationToken = default)
        {
            Page<PublicIPAddress> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PublicIPAddressClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPublicIPAddresses");
                scope.Start();
                try
                {
                    var response = PublicIPAddressRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new PublicIPAddress(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<PublicIPAddress> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PublicIPAddressClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPublicIPAddresses");
                scope.Start();
                try
                {
                    var response = PublicIPAddressRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new PublicIPAddress(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the public IP prefixes in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="PublicIPPrefix" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<PublicIPPrefix> GetPublicIPPrefixesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<PublicIPPrefix>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PublicIPPrefixClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPublicIPPrefixes");
                scope.Start();
                try
                {
                    var response = await PublicIPPrefixRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new PublicIPPrefix(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<PublicIPPrefix>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PublicIPPrefixClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPublicIPPrefixes");
                scope.Start();
                try
                {
                    var response = await PublicIPPrefixRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new PublicIPPrefix(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the public IP prefixes in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="PublicIPPrefix" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<PublicIPPrefix> GetPublicIPPrefixes(CancellationToken cancellationToken = default)
        {
            Page<PublicIPPrefix> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = PublicIPPrefixClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPublicIPPrefixes");
                scope.Start();
                try
                {
                    var response = PublicIPPrefixRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new PublicIPPrefix(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<PublicIPPrefix> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = PublicIPPrefixClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetPublicIPPrefixes");
                scope.Start();
                try
                {
                    var response = PublicIPPrefixRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new PublicIPPrefix(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all route filters in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="RouteFilter" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<RouteFilter> GetRouteFiltersAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<RouteFilter>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = RouteFilterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetRouteFilters");
                scope.Start();
                try
                {
                    var response = await RouteFilterRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new RouteFilter(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<RouteFilter>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = RouteFilterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetRouteFilters");
                scope.Start();
                try
                {
                    var response = await RouteFilterRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new RouteFilter(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all route filters in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="RouteFilter" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<RouteFilter> GetRouteFilters(CancellationToken cancellationToken = default)
        {
            Page<RouteFilter> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = RouteFilterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetRouteFilters");
                scope.Start();
                try
                {
                    var response = RouteFilterRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new RouteFilter(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<RouteFilter> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = RouteFilterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetRouteFilters");
                scope.Start();
                try
                {
                    var response = RouteFilterRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new RouteFilter(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all route tables in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="RouteTable" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<RouteTable> GetRouteTablesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<RouteTable>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = RouteTableClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetRouteTables");
                scope.Start();
                try
                {
                    var response = await RouteTableRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new RouteTable(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<RouteTable>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = RouteTableClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetRouteTables");
                scope.Start();
                try
                {
                    var response = await RouteTableRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new RouteTable(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all route tables in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="RouteTable" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<RouteTable> GetRouteTables(CancellationToken cancellationToken = default)
        {
            Page<RouteTable> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = RouteTableClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetRouteTables");
                scope.Start();
                try
                {
                    var response = RouteTableRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new RouteTable(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<RouteTable> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = RouteTableClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetRouteTables");
                scope.Start();
                try
                {
                    var response = RouteTableRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new RouteTable(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Security Partner Providers in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SecurityPartnerProvider" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SecurityPartnerProvider> GetSecurityPartnerProvidersAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<SecurityPartnerProvider>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = SecurityPartnerProviderClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSecurityPartnerProviders");
                scope.Start();
                try
                {
                    var response = await SecurityPartnerProviderRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SecurityPartnerProvider(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<SecurityPartnerProvider>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = SecurityPartnerProviderClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSecurityPartnerProviders");
                scope.Start();
                try
                {
                    var response = await SecurityPartnerProviderRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SecurityPartnerProvider(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Security Partner Providers in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SecurityPartnerProvider" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SecurityPartnerProvider> GetSecurityPartnerProviders(CancellationToken cancellationToken = default)
        {
            Page<SecurityPartnerProvider> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = SecurityPartnerProviderClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSecurityPartnerProviders");
                scope.Start();
                try
                {
                    var response = SecurityPartnerProviderRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SecurityPartnerProvider(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<SecurityPartnerProvider> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = SecurityPartnerProviderClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSecurityPartnerProviders");
                scope.Start();
                try
                {
                    var response = SecurityPartnerProviderRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SecurityPartnerProvider(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the available bgp service communities. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="BgpServiceCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<BgpServiceCommunity> GetBgpServiceCommunitiesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<BgpServiceCommunity>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = BgpServiceCommunitiesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetBgpServiceCommunities");
                scope.Start();
                try
                {
                    var response = await BgpServiceCommunitiesRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<BgpServiceCommunity>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = BgpServiceCommunitiesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetBgpServiceCommunities");
                scope.Start();
                try
                {
                    var response = await BgpServiceCommunitiesRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the available bgp service communities. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="BgpServiceCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<BgpServiceCommunity> GetBgpServiceCommunities(CancellationToken cancellationToken = default)
        {
            Page<BgpServiceCommunity> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = BgpServiceCommunitiesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetBgpServiceCommunities");
                scope.Start();
                try
                {
                    var response = BgpServiceCommunitiesRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<BgpServiceCommunity> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = BgpServiceCommunitiesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetBgpServiceCommunities");
                scope.Start();
                try
                {
                    var response = BgpServiceCommunitiesRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the service endpoint policies in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ServiceEndpointPolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ServiceEndpointPolicy> GetServiceEndpointPoliciesByServiceEndpointPolicyAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ServiceEndpointPolicy>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ServiceEndpointPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetServiceEndpointPoliciesByServiceEndpointPolicy");
                scope.Start();
                try
                {
                    var response = await ServiceEndpointPolicyRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ServiceEndpointPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ServiceEndpointPolicy>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ServiceEndpointPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetServiceEndpointPoliciesByServiceEndpointPolicy");
                scope.Start();
                try
                {
                    var response = await ServiceEndpointPolicyRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ServiceEndpointPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the service endpoint policies in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ServiceEndpointPolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ServiceEndpointPolicy> GetServiceEndpointPoliciesByServiceEndpointPolicy(CancellationToken cancellationToken = default)
        {
            Page<ServiceEndpointPolicy> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ServiceEndpointPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetServiceEndpointPoliciesByServiceEndpointPolicy");
                scope.Start();
                try
                {
                    var response = ServiceEndpointPolicyRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ServiceEndpointPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ServiceEndpointPolicy> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ServiceEndpointPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetServiceEndpointPoliciesByServiceEndpointPolicy");
                scope.Start();
                try
                {
                    var response = ServiceEndpointPolicyRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ServiceEndpointPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets a list of service tag information resources. </summary>
        /// <param name="location"> The location that will be used as a reference for version (not as a filter based on location, you will get the list of service tags with prefix details across all regions but limited to the cloud that your subscription belongs to). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<ServiceTagsListResult>> GetServiceTagAsync(string location, CancellationToken cancellationToken = default)
        {
            using var scope = ServiceTagsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetServiceTag");
            scope.Start();
            try
            {
                var response = await ServiceTagsRestClient.ListAsync(Id.SubscriptionId, location, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of service tag information resources. </summary>
        /// <param name="location"> The location that will be used as a reference for version (not as a filter based on location, you will get the list of service tags with prefix details across all regions but limited to the cloud that your subscription belongs to). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<ServiceTagsListResult> GetServiceTag(string location, CancellationToken cancellationToken = default)
        {
            using var scope = ServiceTagsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetServiceTag");
            scope.Start();
            try
            {
                var response = ServiceTagsRestClient.List(Id.SubscriptionId, location, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List network usages for a subscription. </summary>
        /// <param name="location"> The location where resource usage is queried. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="Usage" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<Usage> GetUsagesAsync(string location, CancellationToken cancellationToken = default)
        {
            async Task<Page<Usage>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = UsagesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetUsages");
                scope.Start();
                try
                {
                    var response = await UsagesRestClient.ListAsync(Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<Usage>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = UsagesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetUsages");
                scope.Start();
                try
                {
                    var response = await UsagesRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> List network usages for a subscription. </summary>
        /// <param name="location"> The location where resource usage is queried. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="Usage" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<Usage> GetUsages(string location, CancellationToken cancellationToken = default)
        {
            Page<Usage> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = UsagesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetUsages");
                scope.Start();
                try
                {
                    var response = UsagesRestClient.List(Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<Usage> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = UsagesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetUsages");
                scope.Start();
                try
                {
                    var response = UsagesRestClient.ListNextPage(nextLink, Id.SubscriptionId, location, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all virtual networks in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VirtualNetwork" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VirtualNetwork> GetVirtualNetworksAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VirtualNetwork>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualNetworkClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualNetworks");
                scope.Start();
                try
                {
                    var response = await VirtualNetworkRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualNetwork(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VirtualNetwork>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualNetworkClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualNetworks");
                scope.Start();
                try
                {
                    var response = await VirtualNetworkRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualNetwork(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all virtual networks in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VirtualNetwork" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VirtualNetwork> GetVirtualNetworks(CancellationToken cancellationToken = default)
        {
            Page<VirtualNetwork> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualNetworkClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualNetworks");
                scope.Start();
                try
                {
                    var response = VirtualNetworkRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualNetwork(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VirtualNetwork> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualNetworkClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualNetworks");
                scope.Start();
                try
                {
                    var response = VirtualNetworkRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualNetwork(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the VirtualNetworkTaps in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VirtualNetworkTap" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VirtualNetworkTap> GetVirtualNetworkTapsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VirtualNetworkTap>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualNetworkTapClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualNetworkTaps");
                scope.Start();
                try
                {
                    var response = await VirtualNetworkTapRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualNetworkTap(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VirtualNetworkTap>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualNetworkTapClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualNetworkTaps");
                scope.Start();
                try
                {
                    var response = await VirtualNetworkTapRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualNetworkTap(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the VirtualNetworkTaps in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VirtualNetworkTap" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VirtualNetworkTap> GetVirtualNetworkTaps(CancellationToken cancellationToken = default)
        {
            Page<VirtualNetworkTap> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualNetworkTapClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualNetworkTaps");
                scope.Start();
                try
                {
                    var response = VirtualNetworkTapRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualNetworkTap(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VirtualNetworkTap> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualNetworkTapClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualNetworkTaps");
                scope.Start();
                try
                {
                    var response = VirtualNetworkTapRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualNetworkTap(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Virtual Routers in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VirtualRouter" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VirtualRouter> GetVirtualRoutersAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VirtualRouter>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualRouterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualRouters");
                scope.Start();
                try
                {
                    var response = await VirtualRouterRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualRouter(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VirtualRouter>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualRouterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualRouters");
                scope.Start();
                try
                {
                    var response = await VirtualRouterRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualRouter(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the Virtual Routers in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VirtualRouter" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VirtualRouter> GetVirtualRouters(CancellationToken cancellationToken = default)
        {
            Page<VirtualRouter> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualRouterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualRouters");
                scope.Start();
                try
                {
                    var response = VirtualRouterRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualRouter(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VirtualRouter> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualRouterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualRouters");
                scope.Start();
                try
                {
                    var response = VirtualRouterRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualRouter(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VirtualWANs in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VirtualWAN" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VirtualWAN> GetVirtualWANsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VirtualWAN>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualWANVirtualWansClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualWANs");
                scope.Start();
                try
                {
                    var response = await VirtualWANVirtualWansRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualWAN(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VirtualWAN>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualWANVirtualWansClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualWANs");
                scope.Start();
                try
                {
                    var response = await VirtualWANVirtualWansRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualWAN(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VirtualWANs in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VirtualWAN" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VirtualWAN> GetVirtualWANs(CancellationToken cancellationToken = default)
        {
            Page<VirtualWAN> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualWANVirtualWansClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualWANs");
                scope.Start();
                try
                {
                    var response = VirtualWANVirtualWansRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualWAN(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VirtualWAN> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualWANVirtualWansClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualWANs");
                scope.Start();
                try
                {
                    var response = VirtualWANVirtualWansRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualWAN(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VpnSites in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VpnSite" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VpnSite> GetVpnSitesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VpnSite>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VpnSiteClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnSites");
                scope.Start();
                try
                {
                    var response = await VpnSiteRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnSite(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VpnSite>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VpnSiteClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnSites");
                scope.Start();
                try
                {
                    var response = await VpnSiteRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnSite(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VpnSites in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VpnSite" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VpnSite> GetVpnSites(CancellationToken cancellationToken = default)
        {
            Page<VpnSite> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VpnSiteClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnSites");
                scope.Start();
                try
                {
                    var response = VpnSiteRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnSite(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VpnSite> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VpnSiteClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnSites");
                scope.Start();
                try
                {
                    var response = VpnSiteRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnSite(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VpnServerConfigurations in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VpnServerConfiguration" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VpnServerConfiguration> GetVpnServerConfigurationsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VpnServerConfiguration>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VpnServerConfigurationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnServerConfigurations");
                scope.Start();
                try
                {
                    var response = await VpnServerConfigurationRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnServerConfiguration(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VpnServerConfiguration>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VpnServerConfigurationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnServerConfigurations");
                scope.Start();
                try
                {
                    var response = await VpnServerConfigurationRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnServerConfiguration(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VpnServerConfigurations in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VpnServerConfiguration" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VpnServerConfiguration> GetVpnServerConfigurations(CancellationToken cancellationToken = default)
        {
            Page<VpnServerConfiguration> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VpnServerConfigurationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnServerConfigurations");
                scope.Start();
                try
                {
                    var response = VpnServerConfigurationRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnServerConfiguration(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VpnServerConfiguration> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VpnServerConfigurationClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnServerConfigurations");
                scope.Start();
                try
                {
                    var response = VpnServerConfigurationRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnServerConfiguration(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VirtualHubs in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VirtualHub" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VirtualHub> GetVirtualHubsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VirtualHub>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualHubClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualHubs");
                scope.Start();
                try
                {
                    var response = await VirtualHubRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualHub(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VirtualHub>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualHubClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualHubs");
                scope.Start();
                try
                {
                    var response = await VirtualHubRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualHub(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VirtualHubs in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VirtualHub" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VirtualHub> GetVirtualHubs(CancellationToken cancellationToken = default)
        {
            Page<VirtualHub> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualHubClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualHubs");
                scope.Start();
                try
                {
                    var response = VirtualHubRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualHub(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VirtualHub> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualHubClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualHubs");
                scope.Start();
                try
                {
                    var response = VirtualHubRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualHub(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VpnGateways in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VpnGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VpnGateway> GetVpnGatewaysAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VpnGateway>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VpnGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnGateways");
                scope.Start();
                try
                {
                    var response = await VpnGatewayRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VpnGateway>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VpnGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnGateways");
                scope.Start();
                try
                {
                    var response = await VpnGatewayRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the VpnGateways in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VpnGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VpnGateway> GetVpnGateways(CancellationToken cancellationToken = default)
        {
            Page<VpnGateway> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VpnGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnGateways");
                scope.Start();
                try
                {
                    var response = VpnGatewayRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VpnGateway> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VpnGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVpnGateways");
                scope.Start();
                try
                {
                    var response = VpnGatewayRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VpnGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the P2SVpnGateways in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="P2SVpnGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<P2SVpnGateway> GetP2SVpnGatewaysAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<P2SVpnGateway>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = P2SVpnGatewayP2sVpnGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetP2SVpnGateways");
                scope.Start();
                try
                {
                    var response = await P2SVpnGatewayP2sVpnGatewaysRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new P2SVpnGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<P2SVpnGateway>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = P2SVpnGatewayP2sVpnGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetP2SVpnGateways");
                scope.Start();
                try
                {
                    var response = await P2SVpnGatewayP2sVpnGatewaysRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new P2SVpnGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists all the P2SVpnGateways in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="P2SVpnGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<P2SVpnGateway> GetP2SVpnGateways(CancellationToken cancellationToken = default)
        {
            Page<P2SVpnGateway> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = P2SVpnGatewayP2sVpnGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetP2SVpnGateways");
                scope.Start();
                try
                {
                    var response = P2SVpnGatewayP2sVpnGatewaysRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new P2SVpnGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<P2SVpnGateway> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = P2SVpnGatewayP2sVpnGatewaysClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetP2SVpnGateways");
                scope.Start();
                try
                {
                    var response = P2SVpnGatewayP2sVpnGatewaysRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new P2SVpnGateway(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Lists ExpressRoute gateways under a given subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ExpressRouteGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ExpressRouteGateway> GetExpressRouteGatewaysAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ExpressRouteGateway>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRouteGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteGateways");
                scope.Start();
                try
                {
                    var response = await ExpressRouteGatewayRestClient.ListBySubscriptionAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteGateway(Client, value)), null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists ExpressRoute gateways under a given subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ExpressRouteGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ExpressRouteGateway> GetExpressRouteGateways(CancellationToken cancellationToken = default)
        {
            Page<ExpressRouteGateway> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ExpressRouteGatewayClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetExpressRouteGateways");
                scope.Start();
                try
                {
                    var response = ExpressRouteGatewayRestClient.ListBySubscription(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ExpressRouteGateway(Client, value)), null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets all the WAF policies in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="WebApplicationFirewallPolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<WebApplicationFirewallPolicy> GetWebApplicationFirewallPoliciesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<WebApplicationFirewallPolicy>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = WebApplicationFirewallPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetWebApplicationFirewallPolicies");
                scope.Start();
                try
                {
                    var response = await WebApplicationFirewallPolicyRestClient.ListAllAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new WebApplicationFirewallPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<WebApplicationFirewallPolicy>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = WebApplicationFirewallPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetWebApplicationFirewallPolicies");
                scope.Start();
                try
                {
                    var response = await WebApplicationFirewallPolicyRestClient.ListAllNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new WebApplicationFirewallPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Gets all the WAF policies in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="WebApplicationFirewallPolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<WebApplicationFirewallPolicy> GetWebApplicationFirewallPolicies(CancellationToken cancellationToken = default)
        {
            Page<WebApplicationFirewallPolicy> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = WebApplicationFirewallPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetWebApplicationFirewallPolicies");
                scope.Start();
                try
                {
                    var response = WebApplicationFirewallPolicyRestClient.ListAll(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new WebApplicationFirewallPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<WebApplicationFirewallPolicy> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = WebApplicationFirewallPolicyClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetWebApplicationFirewallPolicies");
                scope.Start();
                try
                {
                    var response = WebApplicationFirewallPolicyRestClient.ListAllNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new WebApplicationFirewallPolicy(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }
    }
}
