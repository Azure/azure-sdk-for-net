// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using Azure;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.NetApp;

namespace Azure.ResourceManager.NetApp.Models
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class ArmNetAppModelFactory
    {

        /// <param name="name"> Operation name: {provider}/{resource}/{operation}. </param>
        /// <param name="display"> Display metadata associated with the operation. </param>
        /// <param name="origin"> The origin of operations. </param>
        /// <param name="serviceSpecification"> One property of operation, include metric specifications. </param>
        /// <returns> A new <see cref="Models.Operation"/> instance for mocking. </returns>
        public static Operation Operation(string name = default, OperationDisplay display = default, string origin = default, ServiceSpecification serviceSpecification = default)
        {
            return new Operation(name, display, origin, serviceSpecification is null ? default : new OperationProperties(serviceSpecification, new Dictionary<string, BinaryData>()), additionalBinaryDataProperties: null);
        }

        /// <summary> Display metadata associated with the operation. </summary>
        /// <param name="provider"> Service provider: Microsoft NetApp. </param>
        /// <param name="resource"> Resource on which the operation is performed etc. </param>
        /// <param name="operation"> Type of operation: get, read, delete, etc. </param>
        /// <param name="description"> Operation description. </param>
        /// <returns> A new <see cref="Models.OperationDisplay"/> instance for mocking. </returns>
        public static OperationDisplay OperationDisplay(string provider = default, string resource = default, string operation = default, string description = default)
        {
            return new OperationDisplay(provider, resource, operation, description, additionalBinaryDataProperties: null);
        }

        /// <summary> One property of operation, include metric specifications. </summary>
        /// <param name="metricSpecifications"> Metric specifications of operation. </param>
        /// <param name="logSpecifications"> Log specification of operation. </param>
        /// <returns> A new <see cref="Models.ServiceSpecification"/> instance for mocking. </returns>
        public static ServiceSpecification ServiceSpecification(IEnumerable<MetricSpecification> metricSpecifications = default, IEnumerable<LogSpecification> logSpecifications = default)
        {
            metricSpecifications ??= new ChangeTrackingList<MetricSpecification>();
            logSpecifications ??= new ChangeTrackingList<LogSpecification>();

            return new ServiceSpecification(metricSpecifications.ToList(), logSpecifications.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Metric specification of operation. </summary>
        /// <param name="name"> Name of metric specification. </param>
        /// <param name="displayName"> Display name of metric specification. </param>
        /// <param name="displayDescription"> Display description of metric specification. </param>
        /// <param name="unit"> Unit could be Bytes or Count. </param>
        /// <param name="supportedAggregationTypes"> Support metric aggregation type. </param>
        /// <param name="supportedTimeGrainTypes"> The supported time grain types for the metrics. </param>
        /// <param name="internalMetricName"> The internal metric name. </param>
        /// <param name="enableRegionalMdmAccount"> Whether or not the service is using regional MDM accounts. </param>
        /// <param name="sourceMdmAccount"> The source MDM account. </param>
        /// <param name="sourceMdmNamespace"> The source MDM namespace. </param>
        /// <param name="dimensions"> Dimensions of blobs, including blob type and access tier. </param>
        /// <param name="aggregationType"> Aggregation type could be Average. </param>
        /// <param name="fillGapWithZero"> The property to decide fill gap with zero or not. </param>
        /// <param name="category"> The category this metric specification belong to, could be Capacity. </param>
        /// <param name="resourceIdDimensionNameOverride"> Account Resource Id. </param>
        /// <param name="isInternal"> Whether the metric is internal. </param>
        /// <returns> A new <see cref="Models.MetricSpecification"/> instance for mocking. </returns>
        public static MetricSpecification MetricSpecification(string name = default, string displayName = default, string displayDescription = default, string unit = default, IEnumerable<MetricAggregationType> supportedAggregationTypes = default, IEnumerable<string> supportedTimeGrainTypes = default, string internalMetricName = default, bool? enableRegionalMdmAccount = default, string sourceMdmAccount = default, string sourceMdmNamespace = default, IEnumerable<Dimension> dimensions = default, string aggregationType = default, bool? fillGapWithZero = default, string category = default, string resourceIdDimensionNameOverride = default, bool? isInternal = default)
        {
            supportedAggregationTypes ??= new ChangeTrackingList<MetricAggregationType>();
            supportedTimeGrainTypes ??= new ChangeTrackingList<string>();
            dimensions ??= new ChangeTrackingList<Dimension>();

            return new MetricSpecification(
                name,
                displayName,
                displayDescription,
                unit,
                supportedAggregationTypes.ToList(),
                supportedTimeGrainTypes.ToList(),
                internalMetricName,
                enableRegionalMdmAccount,
                sourceMdmAccount,
                sourceMdmNamespace,
                dimensions.ToList(),
                aggregationType,
                fillGapWithZero,
                category,
                resourceIdDimensionNameOverride,
                isInternal,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Dimension of blobs, possibly be blob type or access tier. </summary>
        /// <param name="name"> Display name of dimension. </param>
        /// <param name="displayName"> Display name of dimension. </param>
        /// <returns> A new <see cref="Models.Dimension"/> instance for mocking. </returns>
        public static Dimension Dimension(string name = default, string displayName = default)
        {
            return new Dimension(name, displayName, additionalBinaryDataProperties: null);
        }

        /// <summary> Log Definition of a single resource metric. </summary>
        /// <param name="name"> Name of log specification. </param>
        /// <param name="displayName"> Display name of log specification. </param>
        /// <returns> A new <see cref="Models.LogSpecification"/> instance for mocking. </returns>
        public static LogSpecification LogSpecification(string name = default, string displayName = default)
        {
            return new LogSpecification(name, displayName, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="current"> The current quota value. </param>
        /// <param name="default"> The default quota value. </param>
        /// <param name="usage"> The usage quota value. </param>
        /// <returns> A new <see cref="NetApp.NetAppSubscriptionQuotaItemData"/> instance for mocking. </returns>
        public static NetAppSubscriptionQuotaItemData NetAppSubscriptionQuotaItemData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, int? current = default, int? @default = default, int? usage = default)
        {
            return new NetAppSubscriptionQuotaItemData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                current is null || @default is null || usage is null ? default : new QuotaItemProperties(current, @default, usage, new Dictionary<string, BinaryData>()));
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="groupMetaData"> Volume group details. </param>
        /// <param name="volumes"> List of volumes from group. </param>
        /// <param name="location"> Resource location. </param>
        /// <returns> A new <see cref="NetApp.VolumeGroupDetailsData"/> instance for mocking. </returns>
        public static VolumeGroupDetailsData VolumeGroupDetailsData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string provisioningState = default, VolumeGroupMetaData groupMetaData = default, IList<VolumeGroupVolumeProperties> volumes = default, string location = default)
        {
            return new VolumeGroupDetailsData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                provisioningState is null || groupMetaData is null || volumes is null ? default : new VolumeGroupProperties(provisioningState, groupMetaData, volumes, new Dictionary<string, BinaryData>()),
                location);
        }

        /// <summary> Volume group properties. </summary>
        /// <param name="groupDescription"> Group Description. </param>
        /// <param name="applicationType"> Application Type. </param>
        /// <param name="applicationIdentifier"> Application specific identifier. </param>
        /// <param name="globalPlacementRules"> Application specific placement rules for the volume group. </param>
        /// <param name="volumesCount"> Number of volumes in volume group. </param>
        /// <returns> A new <see cref="Models.VolumeGroupMetaData"/> instance for mocking. </returns>
        public static VolumeGroupMetaData VolumeGroupMetaData(string groupDescription = default, NetAppApplicationType? applicationType = default, string applicationIdentifier = default, IEnumerable<NetAppVolumePlacementRule> globalPlacementRules = default, long? volumesCount = default)
        {
            globalPlacementRules ??= new ChangeTrackingList<NetAppVolumePlacementRule>();

            return new VolumeGroupMetaData(
                groupDescription,
                applicationType,
                applicationIdentifier,
                globalPlacementRules.ToList(),
                volumesCount,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Resource Id. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="type"> Resource type. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="zones"> Availability Zone. </param>
        /// <param name="fileSystemId"> Unique FileSystem Identifier. </param>
        /// <param name="creationToken"> A unique file path for the volume. Used when creating mount targets. </param>
        /// <param name="serviceLevel"> The service level of the file system. </param>
        /// <param name="usageThreshold">
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. For regular volumes, valid values are in the range 50GiB to 100TiB.
        /// For large volumes, valid values are in the range 100TiB to 500TiB, and on an exceptional basis, from to 2400GiB to 2400TiB.
        /// For extra large volumes, valid values are in the range 2400GiB to 7200TiB. Values expressed in bytes as multiples of 1 GiB.
        /// </param>
        /// <param name="protocolTypes"> Set of protocol types, default NFSv3, CIFS for SMB protocol. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="snapshotId"> Resource identifier used to identify the Snapshot. </param>
        /// <param name="deleteBaseSnapshot"> If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false. </param>
        /// <param name="backupId"> Resource identifier used to identify the Backup. </param>
        /// <param name="baremetalTenantId"> Unique Baremetal Tenant Identifier. </param>
        /// <param name="subnetId"> The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. </param>
        /// <param name="networkFeatures"> The original value of the network features type available to the volume at the time it was created. </param>
        /// <param name="effectiveNetworkFeatures"> The effective value of the network features type available to the volume, or current effective state of update. </param>
        /// <param name="networkSiblingSetId"> Network Sibling Set ID for the the group of volumes sharing networking resources. </param>
        /// <param name="storageToNetworkProximity"> Provides storage to network proximity information for the volume. </param>
        /// <param name="mountTargets"> List of mount targets. </param>
        /// <param name="volumeType"> What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating clone volume, set type to ShortTermClone. </param>
        /// <param name="dataProtection"> DataProtection type volumes include an object containing details of the replication. </param>
        /// <param name="acceptGrowCapacityPoolForShortTermCloneSplit"> While auto splitting the short term clone volume, if the parent pool does not have enough space to accommodate the volume after split, it will be automatically resized, which will lead to increased billing. To accept capacity pool size auto grow and create a short term clone volume, set the property as accepted. </param>
        /// <param name="isRestoring"> Restoring. </param>
        /// <param name="snapshotDirectoryVisible"> If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true). </param>
        /// <param name="kerberosEnabled"> Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later. </param>
        /// <param name="securityStyle"> The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol. </param>
        /// <param name="smbEncryption"> Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later. </param>
        /// <param name="smbAccessBasedEnumeration"> Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume. </param>
        /// <param name="smbNonBrowsable"> Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume. </param>
        /// <param name="smbContinuouslyAvailable"> Enables continuously available share property for smb volume. Only applicable for SMB volume. </param>
        /// <param name="throughputMibps"> Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType volume. </param>
        /// <param name="actualThroughputMibps"> Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel. </param>
        /// <param name="encryptionKeySource"> Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </param>
        /// <param name="keyVaultPrivateEndpointResourceId"> The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. </param>
        /// <param name="ldapEnabled"> Specifies whether LDAP is enabled or not for a given NFS volume. </param>
        /// <param name="ldapServerType"> Specifies the type of LDAP server for a given NFS volume. </param>
        /// <param name="coolAccess"> Specifies whether Cool Access(tiering) is enabled for the volume. </param>
        /// <param name="coolnessPeriod"> Specifies the number of days after which data that is not accessed by clients will be tiered. </param>
        /// <param name="coolAccessRetrievalPolicy">
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </param>
        /// <param name="coolAccessTieringPolicy"> coolAccessTieringPolicy determines which cold data blocks are moved to cool tier. The possible values for this field are: Auto - Moves cold user data blocks in both the Snapshot copies and the active file system to the cool tier tier. This policy is the default. SnapshotOnly - Moves user data blocks of the Volume Snapshot copies that are not associated with the active file system to the cool tier. </param>
        /// <param name="unixPermissions"> UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users. </param>
        /// <param name="cloneProgress"> When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning. </param>
        /// <param name="fileAccessLogs"> Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume. </param>
        /// <param name="avsDataStore"> Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose. </param>
        /// <param name="dataStoreResourceId"> Data store resource unique identifier. </param>
        /// <param name="isDefaultQuotaEnabled"> Specifies if default quota is enabled for the volume. </param>
        /// <param name="defaultUserQuotaInKiBs"> Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies . </param>
        /// <param name="defaultGroupQuotaInKiBs"> Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies. </param>
        /// <param name="maximumNumberOfFiles"> Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB. </param>
        /// <param name="volumeGroupName"> Volume Group Name. </param>
        /// <param name="capacityPoolResourceId"> Pool Resource Id used in case of creating a volume through volume group. </param>
        /// <param name="proximityPlacementGroup"> Proximity placement group associated with the volume. </param>
        /// <param name="t2Network"> T2 network information. </param>
        /// <param name="volumeSpecName"> Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log. </param>
        /// <param name="encrypted"> Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01. </param>
        /// <param name="placementRules"> Application specific placement rules for the particular volume. </param>
        /// <param name="enableSubvolumes"> Flag indicating whether subvolume operations are enabled on the volume. </param>
        /// <param name="provisionedAvailabilityZone"> The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides. </param>
        /// <param name="isLargeVolume"> Specifies whether volume is a Large Volume or Regular Volume. </param>
        /// <param name="largeVolumeType">
        /// Specifies the type of the Large Volume. When set to 'LargeVolume', the large volume is created with standard configuration.
        /// If it is set to 'ExtraLargeVolume7Dot2PiB', the extra large volume is created with higher capacity limit 7.2PiB with cool access enabled,
        /// delivering higher capacity limit with lower costs.
        /// </param>
        /// <param name="originatingResourceId"> Id of the snapshot or backup that the volume is restored from. </param>
        /// <param name="inheritedSizeInBytes"> Space shared by short term clone volume with parent volume in bytes. </param>
        /// <param name="language"> Language supported for volume. </param>
        /// <param name="breakthroughMode"> Specifies whether the volume operates in Breakthrough Mode. </param>
        /// <param name="exportRules"> Export policy rule. </param>
        /// <returns> A new <see cref="Models.VolumeGroupVolumeProperties"/> instance for mocking. </returns>
        public static VolumeGroupVolumeProperties VolumeGroupVolumeProperties(string id = default, string name = default, string @type = default, IDictionary<string, string> tags = default, IEnumerable<string> zones = default, string fileSystemId = default, string creationToken = default, NetAppFileServiceLevel? serviceLevel = default, long? usageThreshold = default, IList<string> protocolTypes = default, string provisioningState = default, ResourceIdentifier snapshotId = default, bool? deleteBaseSnapshot = default, ResourceIdentifier backupId = default, string baremetalTenantId = default, string subnetId = default, NetworkFeatures? networkFeatures = default, NetworkFeatures? effectiveNetworkFeatures = default, string networkSiblingSetId = default, VolumeStorageToNetworkProximity? storageToNetworkProximity = default, IReadOnlyList<MountTargetProperties> mountTargets = default, string volumeType = default, VolumePropertiesDataProtection dataProtection = default, AcceptGrowCapacityPoolForShortTermCloneSplit? acceptGrowCapacityPoolForShortTermCloneSplit = default, bool? isRestoring = default, bool? snapshotDirectoryVisible = default, bool? kerberosEnabled = default, SecurityStyle? securityStyle = default, bool? smbEncryption = default, SmbAccessBasedEnumeration? smbAccessBasedEnumeration = default, SmbNonBrowsable? smbNonBrowsable = default, bool? smbContinuouslyAvailable = default, float? throughputMibps = default, float? actualThroughputMibps = default, EncryptionKeySource? encryptionKeySource = default, string keyVaultPrivateEndpointResourceId = default, bool? ldapEnabled = default, LdapServerType? ldapServerType = default, bool? coolAccess = default, int? coolnessPeriod = default, CoolAccessRetrievalPolicy? coolAccessRetrievalPolicy = default, CoolAccessTieringPolicy? coolAccessTieringPolicy = default, string unixPermissions = default, int? cloneProgress = default, FileAccessLogs? fileAccessLogs = default, AvsDataStore? avsDataStore = default, IReadOnlyList<string> dataStoreResourceId = default, bool? isDefaultQuotaEnabled = default, long? defaultUserQuotaInKiBs = default, long? defaultGroupQuotaInKiBs = default, long? maximumNumberOfFiles = default, string volumeGroupName = default, string capacityPoolResourceId = default, string proximityPlacementGroup = default, string t2Network = default, string volumeSpecName = default, bool? encrypted = default, IList<NetAppVolumePlacementRule> placementRules = default, EnableSubvolumes? enableSubvolumes = default, string provisionedAvailabilityZone = default, bool? isLargeVolume = default, LargeVolumeType? largeVolumeType = default, string originatingResourceId = default, long? inheritedSizeInBytes = default, VolumeLanguage? language = default, BreakthroughMode? breakthroughMode = default, IList<ExportPolicyRule> exportRules = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            zones ??= new ChangeTrackingList<string>();

            return new VolumeGroupVolumeProperties(
                id,
                name,
                @type,
                tags,
                zones.ToList(),
                fileSystemId is null || creationToken is null || serviceLevel is null || usageThreshold is null || protocolTypes is null || provisioningState is null || snapshotId is null || deleteBaseSnapshot is null || backupId is null || baremetalTenantId is null || subnetId is null || networkFeatures is null || effectiveNetworkFeatures is null || networkSiblingSetId is null || storageToNetworkProximity is null || mountTargets is null || volumeType is null || dataProtection is null || acceptGrowCapacityPoolForShortTermCloneSplit is null || isRestoring is null || snapshotDirectoryVisible is null || kerberosEnabled is null || securityStyle is null || smbEncryption is null || smbAccessBasedEnumeration is null || smbNonBrowsable is null || smbContinuouslyAvailable is null || throughputMibps is null || actualThroughputMibps is null || encryptionKeySource is null || keyVaultPrivateEndpointResourceId is null || ldapEnabled is null || ldapServerType is null || coolAccess is null || coolnessPeriod is null || coolAccessRetrievalPolicy is null || coolAccessTieringPolicy is null || unixPermissions is null || cloneProgress is null || fileAccessLogs is null || avsDataStore is null || dataStoreResourceId is null || isDefaultQuotaEnabled is null || defaultUserQuotaInKiBs is null || defaultGroupQuotaInKiBs is null || maximumNumberOfFiles is null || volumeGroupName is null || capacityPoolResourceId is null || proximityPlacementGroup is null || t2Network is null || volumeSpecName is null || encrypted is null || placementRules is null || enableSubvolumes is null || provisionedAvailabilityZone is null || isLargeVolume is null || largeVolumeType is null || originatingResourceId is null || inheritedSizeInBytes is null || language is null || breakthroughMode is null || exportRules is null ? default : new VolumeProperties(
                    fileSystemId,
                    creationToken,
                    serviceLevel,
                    usageThreshold.Value,
                    new NetAppVolumeExportPolicyRule(exportRules, new Dictionary<string, BinaryData>()),
                    protocolTypes,
                    provisioningState,
                    snapshotId,
                    deleteBaseSnapshot,
                    backupId,
                    baremetalTenantId,
                    subnetId,
                    networkFeatures,
                    effectiveNetworkFeatures,
                    networkSiblingSetId,
                    storageToNetworkProximity,
                    mountTargets,
                    volumeType,
                    dataProtection,
                    acceptGrowCapacityPoolForShortTermCloneSplit,
                    isRestoring,
                    snapshotDirectoryVisible,
                    kerberosEnabled,
                    securityStyle,
                    smbEncryption,
                    smbAccessBasedEnumeration,
                    smbNonBrowsable,
                    smbContinuouslyAvailable,
                    throughputMibps,
                    actualThroughputMibps,
                    encryptionKeySource,
                    keyVaultPrivateEndpointResourceId,
                    ldapEnabled,
                    ldapServerType,
                    coolAccess,
                    coolnessPeriod,
                    coolAccessRetrievalPolicy,
                    coolAccessTieringPolicy,
                    unixPermissions,
                    cloneProgress,
                    fileAccessLogs,
                    avsDataStore,
                    dataStoreResourceId,
                    isDefaultQuotaEnabled,
                    defaultUserQuotaInKiBs,
                    defaultGroupQuotaInKiBs,
                    maximumNumberOfFiles,
                    volumeGroupName,
                    capacityPoolResourceId,
                    proximityPlacementGroup,
                    t2Network,
                    volumeSpecName,
                    encrypted,
                    placementRules,
                    enableSubvolumes,
                    provisionedAvailabilityZone,
                    isLargeVolume,
                    largeVolumeType,
                    originatingResourceId,
                    inheritedSizeInBytes,
                    language,
                    breakthroughMode,
                    new Dictionary<string, BinaryData>()),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Mount target properties. </summary>
        /// <param name="mountTargetId"> UUID v4 used to identify the MountTarget. </param>
        /// <param name="fileSystemId"> UUID v4 used to identify the MountTarget. </param>
        /// <param name="ipAddress"> The mount target's IPv4 address. </param>
        /// <param name="smbServerFqdn"> The SMB server's Fully Qualified Domain Name, FQDN. </param>
        /// <returns> A new <see cref="Models.MountTargetProperties"/> instance for mocking. </returns>
        public static MountTargetProperties MountTargetProperties(string mountTargetId = default, string fileSystemId = default, string ipAddress = default, string smbServerFqdn = default)
        {
            return new MountTargetProperties(mountTargetId, fileSystemId, ipAddress, smbServerFqdn, additionalBinaryDataProperties: null);
        }

        /// <summary> Replication properties. </summary>
        /// <param name="replicationId"> Id. </param>
        /// <param name="endpointType"> Indicates whether the local volume is the source or destination for the Volume Replication. </param>
        /// <param name="replicationSchedule"> Schedule. </param>
        /// <param name="remoteVolumeResourceId"> The resource ID of the remote volume. Required for cross region and cross zone replication. </param>
        /// <param name="remotePath"> The full path to a volume that is to be migrated into ANF. Required for Migration volumes. </param>
        /// <param name="remoteVolumeRegion"> The remote region for the other end of the Volume Replication. </param>
        /// <param name="destinationReplications"> A list of destination replications. </param>
        /// <param name="externalReplicationSetupStatus"> Property that only applies to external replications. Provides a machine-readable value for the status of the external replication setup. </param>
        /// <param name="externalReplicationSetupInfo"> Contains human-readable instructions on what the next step is to finish the external replication setup. </param>
        /// <param name="mirrorState"> The mirror state property describes the current status of data replication for a replication. It provides insight into whether the data is actively being mirrored, if the replication process has been paused, or if it has yet to be initialized. </param>
        /// <param name="relationshipStatus"> The status of the Volume Replication. </param>
        /// <returns> A new <see cref="Models.ReplicationObject"/> instance for mocking. </returns>
        public static ReplicationObject ReplicationObject(string replicationId = default, NetAppEndpointType? endpointType = default, ReplicationSchedule? replicationSchedule = default, string remoteVolumeResourceId = default, RemotePath remotePath = default, string remoteVolumeRegion = default, IEnumerable<DestinationReplication> destinationReplications = default, ExternalReplicationSetupStatus? externalReplicationSetupStatus = default, string externalReplicationSetupInfo = default, NetAppMirrorState? mirrorState = default, VolumeReplicationRelationshipStatus? relationshipStatus = default)
        {
            destinationReplications ??= new ChangeTrackingList<DestinationReplication>();

            return new ReplicationObject(
                replicationId,
                endpointType,
                replicationSchedule,
                remoteVolumeResourceId,
                remotePath,
                remoteVolumeRegion,
                destinationReplications.ToList(),
                externalReplicationSetupStatus,
                externalReplicationSetupInfo,
                mirrorState,
                relationshipStatus,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Destination replication properties. </summary>
        /// <param name="resourceId"> The resource ID of the remote volume. </param>
        /// <param name="replicationType"> Indicates whether the replication is cross zone or cross region. </param>
        /// <param name="region"> The remote region for the destination volume. </param>
        /// <param name="zone"> The remote zone for the destination volume. </param>
        /// <returns> A new <see cref="Models.DestinationReplication"/> instance for mocking. </returns>
        public static DestinationReplication DestinationReplication(ResourceIdentifier resourceId = default, ReplicationType? replicationType = default, string region = default, string zone = default)
        {
            return new DestinationReplication(resourceId, replicationType, region, zone, additionalBinaryDataProperties: null);
        }

        /// <summary> Volume relocation properties. </summary>
        /// <param name="relocationRequested"> Has relocation been requested for this volume. </param>
        /// <param name="readyToBeFinalized"> Has relocation finished and is ready to be cleaned up. </param>
        /// <returns> A new <see cref="Models.VolumeRelocationProperties"/> instance for mocking. </returns>
        public static VolumeRelocationProperties VolumeRelocationProperties(bool? relocationRequested = default, bool? readyToBeFinalized = default)
        {
            return new VolumeRelocationProperties(relocationRequested, readyToBeFinalized, additionalBinaryDataProperties: null);
        }

        /// <summary> Advanced Ransomware Protection reports (ARP) settings. </summary>
        /// <param name="desiredRansomwareProtectionState"> The desired value of the Advanced Ransomware Protection feature state available to the volume. </param>
        /// <param name="actualRansomwareProtectionState"> The actual state of the Advanced Ransomware Protection feature currently active on the volume. </param>
        /// <returns> A new <see cref="Models.RansomwareProtectionSettings"/> instance for mocking. </returns>
        public static RansomwareProtectionSettings RansomwareProtectionSettings(DesiredRansomwareProtectionState? desiredRansomwareProtectionState = default, ActualRansomwareProtectionState? actualRansomwareProtectionState = default)
        {
            return new RansomwareProtectionSettings(desiredRansomwareProtectionState, actualRansomwareProtectionState, additionalBinaryDataProperties: null);
        }

        /// <param name="location"> Resource location. </param>
        /// <param name="id"> Resource Id. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="type"> Resource type. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="groupMetaData"> Volume group details. </param>
        /// <returns> A new <see cref="Models.VolumeGroup"/> instance for mocking. </returns>
        public static VolumeGroup VolumeGroup(string location = default, string id = default, string name = default, string @type = default, string provisioningState = default, VolumeGroupMetaData groupMetaData = default)
        {
            return new VolumeGroup(
                location,
                id,
                name,
                @type,
                provisioningState is null || groupMetaData is null ? default : new VolumeGroupListProperties(provisioningState, groupMetaData, new Dictionary<string, BinaryData>()),
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="backupId"> UUID v4 used to identify the Backup. </param>
        /// <param name="createdOn"> The creation date of the backup. </param>
        /// <param name="snapshotCreationOn"> The snapshot creation date of the backup. </param>
        /// <param name="completionOn"> The completion date of the backup. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="size"> Size of backup in bytes. </param>
        /// <param name="label"> Label for backup. </param>
        /// <param name="backupType"> Type of backup Manual or Scheduled. </param>
        /// <param name="failureReason"> Failure reason. </param>
        /// <param name="volumeResourceId"> ResourceId used to identify the Volume. </param>
        /// <param name="useExistingSnapshot"> Manual backup an already existing snapshot. This will always be false for scheduled backups and true/false for manual backups. </param>
        /// <param name="snapshotName"> The name of the snapshot. </param>
        /// <param name="backupPolicyResourceId"> ResourceId used to identify the backup policy. </param>
        /// <param name="isLargeVolume"> Specifies if the backup is for a large volume. </param>
        /// <returns> A new <see cref="NetApp.BackupData"/> instance for mocking. </returns>
        public static BackupData BackupData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string backupId = default, DateTimeOffset? createdOn = default, DateTimeOffset? snapshotCreationOn = default, DateTimeOffset? completionOn = default, string provisioningState = default, long? size = default, string label = default, NetAppBackupType? backupType = default, string failureReason = default, ResourceIdentifier volumeResourceId = default, bool? useExistingSnapshot = default, string snapshotName = default, ResourceIdentifier backupPolicyResourceId = default, bool? isLargeVolume = default)
        {
            return new BackupData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                backupId is null || createdOn is null || snapshotCreationOn is null || completionOn is null || provisioningState is null || size is null || label is null || backupType is null || failureReason is null || volumeResourceId is null || useExistingSnapshot is null || snapshotName is null || backupPolicyResourceId is null || isLargeVolume is null ? default : new BackupProperties(
                    backupId,
                    createdOn,
                    snapshotCreationOn,
                    completionOn,
                    provisioningState,
                    size,
                    label,
                    backupType,
                    failureReason,
                    volumeResourceId,
                    useExistingSnapshot,
                    snapshotName,
                    backupPolicyResourceId,
                    isLargeVolume,
                    new Dictionary<string, BinaryData>()));
        }

        /// <summary> Backup status. </summary>
        /// <param name="healthy"> Backup health status. </param>
        /// <param name="relationshipStatus"> Status of the backup mirror relationship. </param>
        /// <param name="mirrorState"> The status of the backup. </param>
        /// <param name="unhealthyReason"> Reason for the unhealthy backup relationship. </param>
        /// <param name="errorMessage"> Displays error message if the backup is in an error state. </param>
        /// <param name="lastTransferSize"> Displays the last transfer size. </param>
        /// <param name="lastTransferType"> Displays the last transfer type. </param>
        /// <param name="totalTransferBytes"> Displays the total bytes transferred. </param>
        /// <param name="transferProgressBytes"> Displays the total number of bytes transferred for the ongoing operation. </param>
        /// <returns> A new <see cref="Models.NetAppVolumeBackupStatus"/> instance for mocking. </returns>
        public static NetAppVolumeBackupStatus NetAppVolumeBackupStatus(bool? healthy = default, VolumeBackupRelationshipStatus? relationshipStatus = default, NetAppMirrorState? mirrorState = default, string unhealthyReason = default, string errorMessage = default, long? lastTransferSize = default, string lastTransferType = default, long? totalTransferBytes = default, long? transferProgressBytes = default)
        {
            return new NetAppVolumeBackupStatus(
                healthy,
                relationshipStatus,
                mirrorState,
                unhealthyReason,
                errorMessage,
                lastTransferSize,
                lastTransferType,
                totalTransferBytes,
                transferProgressBytes,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Restore status. </summary>
        /// <param name="healthy"> Restore health status. </param>
        /// <param name="relationshipStatus"> Status of the restore SnapMirror relationship. </param>
        /// <param name="mirrorState"> The status of the restore. </param>
        /// <param name="unhealthyReason"> Reason for the unhealthy restore relationship. </param>
        /// <param name="errorMessage"> Displays error message if the restore is in an error state. </param>
        /// <param name="totalTransferBytes"> Displays the total bytes transferred. </param>
        /// <returns> A new <see cref="Models.NetAppRestoreStatus"/> instance for mocking. </returns>
        public static NetAppRestoreStatus NetAppRestoreStatus(bool? healthy = default, VolumeRestoreRelationshipStatus? relationshipStatus = default, NetAppMirrorState? mirrorState = default, string unhealthyReason = default, string errorMessage = default, long? totalTransferBytes = default)
        {
            return new NetAppRestoreStatus(
                healthy,
                relationshipStatus,
                mirrorState,
                unhealthyReason,
                errorMessage,
                totalTransferBytes,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="fileSystemId"> Unique FileSystem Identifier. </param>
        /// <param name="creationToken"> A unique file path for the volume. Used when creating mount targets. </param>
        /// <param name="serviceLevel"> The service level of the file system. </param>
        /// <param name="usageThreshold">
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. For regular volumes, valid values are in the range 50GiB to 100TiB.
        /// For large volumes, valid values are in the range 100TiB to 500TiB, and on an exceptional basis, from to 2400GiB to 2400TiB.
        /// For extra large volumes, valid values are in the range 2400GiB to 7200TiB. Values expressed in bytes as multiples of 1 GiB.
        /// </param>
        /// <param name="protocolTypes"> Set of protocol types, default NFSv3, CIFS for SMB protocol. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="snapshotId"> Resource identifier used to identify the Snapshot. </param>
        /// <param name="deleteBaseSnapshot"> If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false. </param>
        /// <param name="backupId"> Resource identifier used to identify the Backup. </param>
        /// <param name="baremetalTenantId"> Unique Baremetal Tenant Identifier. </param>
        /// <param name="subnetId"> The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. </param>
        /// <param name="networkFeatures"> The original value of the network features type available to the volume at the time it was created. </param>
        /// <param name="effectiveNetworkFeatures"> The effective value of the network features type available to the volume, or current effective state of update. </param>
        /// <param name="networkSiblingSetId"> Network Sibling Set ID for the the group of volumes sharing networking resources. </param>
        /// <param name="storageToNetworkProximity"> Provides storage to network proximity information for the volume. </param>
        /// <param name="mountTargets"> List of mount targets. </param>
        /// <param name="volumeType"> What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating clone volume, set type to ShortTermClone. </param>
        /// <param name="dataProtection"> DataProtection type volumes include an object containing details of the replication. </param>
        /// <param name="acceptGrowCapacityPoolForShortTermCloneSplit"> While auto splitting the short term clone volume, if the parent pool does not have enough space to accommodate the volume after split, it will be automatically resized, which will lead to increased billing. To accept capacity pool size auto grow and create a short term clone volume, set the property as accepted. </param>
        /// <param name="isRestoring"> Restoring. </param>
        /// <param name="snapshotDirectoryVisible"> If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true). </param>
        /// <param name="kerberosEnabled"> Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later. </param>
        /// <param name="securityStyle"> The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol. </param>
        /// <param name="smbEncryption"> Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later. </param>
        /// <param name="smbAccessBasedEnumeration"> Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume. </param>
        /// <param name="smbNonBrowsable"> Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume. </param>
        /// <param name="smbContinuouslyAvailable"> Enables continuously available share property for smb volume. Only applicable for SMB volume. </param>
        /// <param name="throughputMibps"> Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType volume. </param>
        /// <param name="actualThroughputMibps"> Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel. </param>
        /// <param name="encryptionKeySource"> Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </param>
        /// <param name="keyVaultPrivateEndpointResourceId"> The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. </param>
        /// <param name="ldapEnabled"> Specifies whether LDAP is enabled or not for a given NFS volume. </param>
        /// <param name="ldapServerType"> Specifies the type of LDAP server for a given NFS volume. </param>
        /// <param name="coolAccess"> Specifies whether Cool Access(tiering) is enabled for the volume. </param>
        /// <param name="coolnessPeriod"> Specifies the number of days after which data that is not accessed by clients will be tiered. </param>
        /// <param name="coolAccessRetrievalPolicy">
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </param>
        /// <param name="coolAccessTieringPolicy"> coolAccessTieringPolicy determines which cold data blocks are moved to cool tier. The possible values for this field are: Auto - Moves cold user data blocks in both the Snapshot copies and the active file system to the cool tier tier. This policy is the default. SnapshotOnly - Moves user data blocks of the Volume Snapshot copies that are not associated with the active file system to the cool tier. </param>
        /// <param name="unixPermissions"> UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users. </param>
        /// <param name="cloneProgress"> When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning. </param>
        /// <param name="fileAccessLogs"> Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume. </param>
        /// <param name="avsDataStore"> Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose. </param>
        /// <param name="dataStoreResourceId"> Data store resource unique identifier. </param>
        /// <param name="isDefaultQuotaEnabled"> Specifies if default quota is enabled for the volume. </param>
        /// <param name="defaultUserQuotaInKiBs"> Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies . </param>
        /// <param name="defaultGroupQuotaInKiBs"> Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies. </param>
        /// <param name="maximumNumberOfFiles"> Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB. </param>
        /// <param name="volumeGroupName"> Volume Group Name. </param>
        /// <param name="capacityPoolResourceId"> Pool Resource Id used in case of creating a volume through volume group. </param>
        /// <param name="proximityPlacementGroup"> Proximity placement group associated with the volume. </param>
        /// <param name="t2Network"> T2 network information. </param>
        /// <param name="volumeSpecName"> Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log. </param>
        /// <param name="encrypted"> Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01. </param>
        /// <param name="placementRules"> Application specific placement rules for the particular volume. </param>
        /// <param name="enableSubvolumes"> Flag indicating whether subvolume operations are enabled on the volume. </param>
        /// <param name="provisionedAvailabilityZone"> The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides. </param>
        /// <param name="isLargeVolume"> Specifies whether volume is a Large Volume or Regular Volume. </param>
        /// <param name="largeVolumeType">
        /// Specifies the type of the Large Volume. When set to 'LargeVolume', the large volume is created with standard configuration.
        /// If it is set to 'ExtraLargeVolume7Dot2PiB', the extra large volume is created with higher capacity limit 7.2PiB with cool access enabled,
        /// delivering higher capacity limit with lower costs.
        /// </param>
        /// <param name="originatingResourceId"> Id of the snapshot or backup that the volume is restored from. </param>
        /// <param name="inheritedSizeInBytes"> Space shared by short term clone volume with parent volume in bytes. </param>
        /// <param name="language"> Language supported for volume. </param>
        /// <param name="breakthroughMode"> Specifies whether the volume operates in Breakthrough Mode. </param>
        /// <param name="exportRules"> Export policy rule. </param>
        /// <param name="etag"> "If etag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."). </param>
        /// <param name="zones"> The availability zones. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="creationToken"/> or <paramref name="subnetId"/> is null. </exception>
        /// <returns> A new <see cref="NetApp.VolumeData"/> instance for mocking. </returns>
        public static VolumeData VolumeData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, string fileSystemId = default, string creationToken = default, NetAppFileServiceLevel? serviceLevel = default, long? usageThreshold = default, IList<string> protocolTypes = default, string provisioningState = default, ResourceIdentifier snapshotId = default, bool? deleteBaseSnapshot = default, ResourceIdentifier backupId = default, string baremetalTenantId = default, string subnetId = default, NetworkFeatures? networkFeatures = default, NetworkFeatures? effectiveNetworkFeatures = default, string networkSiblingSetId = default, VolumeStorageToNetworkProximity? storageToNetworkProximity = default, IReadOnlyList<MountTargetProperties> mountTargets = default, string volumeType = default, VolumePropertiesDataProtection dataProtection = default, AcceptGrowCapacityPoolForShortTermCloneSplit? acceptGrowCapacityPoolForShortTermCloneSplit = default, bool? isRestoring = default, bool? snapshotDirectoryVisible = default, bool? kerberosEnabled = default, SecurityStyle? securityStyle = default, bool? smbEncryption = default, SmbAccessBasedEnumeration? smbAccessBasedEnumeration = default, SmbNonBrowsable? smbNonBrowsable = default, bool? smbContinuouslyAvailable = default, float? throughputMibps = default, float? actualThroughputMibps = default, EncryptionKeySource? encryptionKeySource = default, string keyVaultPrivateEndpointResourceId = default, bool? ldapEnabled = default, LdapServerType? ldapServerType = default, bool? coolAccess = default, int? coolnessPeriod = default, CoolAccessRetrievalPolicy? coolAccessRetrievalPolicy = default, CoolAccessTieringPolicy? coolAccessTieringPolicy = default, string unixPermissions = default, int? cloneProgress = default, FileAccessLogs? fileAccessLogs = default, AvsDataStore? avsDataStore = default, IReadOnlyList<string> dataStoreResourceId = default, bool? isDefaultQuotaEnabled = default, long? defaultUserQuotaInKiBs = default, long? defaultGroupQuotaInKiBs = default, long? maximumNumberOfFiles = default, string volumeGroupName = default, string capacityPoolResourceId = default, string proximityPlacementGroup = default, string t2Network = default, string volumeSpecName = default, bool? encrypted = default, IList<NetAppVolumePlacementRule> placementRules = default, EnableSubvolumes? enableSubvolumes = default, string provisionedAvailabilityZone = default, bool? isLargeVolume = default, LargeVolumeType? largeVolumeType = default, string originatingResourceId = default, long? inheritedSizeInBytes = default, VolumeLanguage? language = default, BreakthroughMode? breakthroughMode = default, IList<ExportPolicyRule> exportRules = default, string etag = default, IEnumerable<string> zones = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            zones ??= new ChangeTrackingList<string>();

            return new VolumeData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                fileSystemId is null || creationToken is null || serviceLevel is null || usageThreshold is null || protocolTypes is null || provisioningState is null || snapshotId is null || deleteBaseSnapshot is null || backupId is null || baremetalTenantId is null || subnetId is null || networkFeatures is null || effectiveNetworkFeatures is null || networkSiblingSetId is null || storageToNetworkProximity is null || mountTargets is null || volumeType is null || dataProtection is null || acceptGrowCapacityPoolForShortTermCloneSplit is null || isRestoring is null || snapshotDirectoryVisible is null || kerberosEnabled is null || securityStyle is null || smbEncryption is null || smbAccessBasedEnumeration is null || smbNonBrowsable is null || smbContinuouslyAvailable is null || throughputMibps is null || actualThroughputMibps is null || encryptionKeySource is null || keyVaultPrivateEndpointResourceId is null || ldapEnabled is null || ldapServerType is null || coolAccess is null || coolnessPeriod is null || coolAccessRetrievalPolicy is null || coolAccessTieringPolicy is null || unixPermissions is null || cloneProgress is null || fileAccessLogs is null || avsDataStore is null || dataStoreResourceId is null || isDefaultQuotaEnabled is null || defaultUserQuotaInKiBs is null || defaultGroupQuotaInKiBs is null || maximumNumberOfFiles is null || volumeGroupName is null || capacityPoolResourceId is null || proximityPlacementGroup is null || t2Network is null || volumeSpecName is null || encrypted is null || placementRules is null || enableSubvolumes is null || provisionedAvailabilityZone is null || isLargeVolume is null || largeVolumeType is null || originatingResourceId is null || inheritedSizeInBytes is null || language is null || breakthroughMode is null || exportRules is null ? default : new VolumeProperties(
                    fileSystemId,
                    creationToken,
                    serviceLevel,
                    usageThreshold.Value,
                    new NetAppVolumeExportPolicyRule(exportRules, new Dictionary<string, BinaryData>()),
                    protocolTypes,
                    provisioningState,
                    snapshotId,
                    deleteBaseSnapshot,
                    backupId,
                    baremetalTenantId,
                    subnetId,
                    networkFeatures,
                    effectiveNetworkFeatures,
                    networkSiblingSetId,
                    storageToNetworkProximity,
                    mountTargets,
                    volumeType,
                    dataProtection,
                    acceptGrowCapacityPoolForShortTermCloneSplit,
                    isRestoring,
                    snapshotDirectoryVisible,
                    kerberosEnabled,
                    securityStyle,
                    smbEncryption,
                    smbAccessBasedEnumeration,
                    smbNonBrowsable,
                    smbContinuouslyAvailable,
                    throughputMibps,
                    actualThroughputMibps,
                    encryptionKeySource,
                    keyVaultPrivateEndpointResourceId,
                    ldapEnabled,
                    ldapServerType,
                    coolAccess,
                    coolnessPeriod,
                    coolAccessRetrievalPolicy,
                    coolAccessTieringPolicy,
                    unixPermissions,
                    cloneProgress,
                    fileAccessLogs,
                    avsDataStore,
                    dataStoreResourceId,
                    isDefaultQuotaEnabled,
                    defaultUserQuotaInKiBs,
                    defaultGroupQuotaInKiBs,
                    maximumNumberOfFiles,
                    volumeGroupName,
                    capacityPoolResourceId,
                    proximityPlacementGroup,
                    t2Network,
                    volumeSpecName,
                    encrypted,
                    placementRules,
                    enableSubvolumes,
                    provisionedAvailabilityZone,
                    isLargeVolume,
                    largeVolumeType,
                    originatingResourceId,
                    inheritedSizeInBytes,
                    language,
                    breakthroughMode,
                    new Dictionary<string, BinaryData>()),
                etag,
                zones.ToList());
        }

        /// <param name="location"> Resource location. </param>
        /// <param name="id"> Resource Id. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="type"> Resource type. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="serviceLevel"> The service level of the file system. </param>
        /// <param name="usageThreshold">
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. For regular volumes, valid values are in the range 50GiB to 100TiB.
        /// For large volumes, valid values are in the range 100TiB to 500TiB, and on an exceptional basis, from to 2400GiB to 2400TiB.
        /// For extra large volumes, valid values are in the range 2400GiB to 7200TiB. Values expressed in bytes as multiples of 1 GiB.
        /// </param>
        /// <param name="protocolTypes"> Set of protocol types, default NFSv3, CIFS for SMB protocol. </param>
        /// <param name="throughputMibps"> Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType volume. </param>
        /// <param name="dataProtection"> DataProtection type volumes include an object containing details of the replication. </param>
        /// <param name="isDefaultQuotaEnabled"> Specifies if default quota is enabled for the volume. </param>
        /// <param name="defaultUserQuotaInKiBs"> Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies . </param>
        /// <param name="defaultGroupQuotaInKiBs"> Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies. </param>
        /// <param name="unixPermissions"> UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users. </param>
        /// <param name="coolAccess"> Specifies whether Cool Access(tiering) is enabled for the volume. </param>
        /// <param name="coolnessPeriod"> Specifies the number of days after which data that is not accessed by clients will be tiered. </param>
        /// <param name="coolAccessRetrievalPolicy">
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </param>
        /// <param name="coolAccessTieringPolicy"> coolAccessTieringPolicy determines which cold data blocks are moved to cool tier. The possible values for this field are: Auto - Moves cold user data blocks in both the Snapshot copies and the active file system to the cool tier tier. This policy is the default. SnapshotOnly - Moves user data blocks of the Volume Snapshot copies that are not associated with the active file system to the cool tier. </param>
        /// <param name="snapshotDirectoryVisible"> If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots. </param>
        /// <param name="smbAccessBasedEnumeration"> Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume. </param>
        /// <param name="smbNonBrowsable"> Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume. </param>
        /// <param name="exportRules"> Export policy rule. </param>
        /// <returns> A new <see cref="Models.VolumePatch"/> instance for mocking. </returns>
        public static VolumePatch VolumePatch(string location = default, string id = default, string name = default, string @type = default, IDictionary<string, string> tags = default, NetAppFileServiceLevel? serviceLevel = default, long? usageThreshold = default, IList<string> protocolTypes = default, float? throughputMibps = default, VolumePatchPropertiesDataProtection dataProtection = default, bool? isDefaultQuotaEnabled = default, long? defaultUserQuotaInKiBs = default, long? defaultGroupQuotaInKiBs = default, string unixPermissions = default, bool? coolAccess = default, int? coolnessPeriod = default, CoolAccessRetrievalPolicy? coolAccessRetrievalPolicy = default, CoolAccessTieringPolicy? coolAccessTieringPolicy = default, bool? snapshotDirectoryVisible = default, SmbAccessBasedEnumeration? smbAccessBasedEnumeration = default, SmbNonBrowsable? smbNonBrowsable = default, IList<ExportPolicyRule> exportRules = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new VolumePatch(
                location,
                id,
                name,
                @type,
                tags,
                serviceLevel is null || usageThreshold is null || protocolTypes is null || throughputMibps is null || dataProtection is null || isDefaultQuotaEnabled is null || defaultUserQuotaInKiBs is null || defaultGroupQuotaInKiBs is null || unixPermissions is null || coolAccess is null || coolnessPeriod is null || coolAccessRetrievalPolicy is null || coolAccessTieringPolicy is null || snapshotDirectoryVisible is null || smbAccessBasedEnumeration is null || smbNonBrowsable is null || exportRules is null ? default : new VolumePatchProperties(
                    serviceLevel,
                    usageThreshold,
                    new VolumePatchPropertiesExportPolicy(exportRules, new Dictionary<string, BinaryData>()),
                    protocolTypes,
                    throughputMibps,
                    dataProtection,
                    isDefaultQuotaEnabled,
                    defaultUserQuotaInKiBs,
                    defaultGroupQuotaInKiBs,
                    unixPermissions,
                    coolAccess,
                    coolnessPeriod,
                    coolAccessRetrievalPolicy,
                    coolAccessTieringPolicy,
                    snapshotDirectoryVisible,
                    smbAccessBasedEnumeration,
                    smbNonBrowsable,
                    new Dictionary<string, BinaryData>()),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Get group Id list for LDAP User request. </summary>
        /// <param name="username"> username is required to fetch the group to which user is part of. </param>
        /// <returns> A new <see cref="Models.GetGroupIdListForLdapUserRequest"/> instance for mocking. </returns>
        public static GetGroupIdListForLdapUserRequest GetGroupIdListForLdapUserRequest(string username = default)
        {
            return new GetGroupIdListForLdapUserRequest(username, additionalBinaryDataProperties: null);
        }

        /// <summary> Group Id list for Ldap user. </summary>
        /// <param name="groupIdsForLdapUser"> Group Id list. </param>
        /// <returns> A new <see cref="Models.GetGroupIdListForLdapUserResponse"/> instance for mocking. </returns>
        public static GetGroupIdListForLdapUserResponse GetGroupIdListForLdapUserResponse(IEnumerable<string> groupIdsForLdapUser = default)
        {
            groupIdsForLdapUser ??= new ChangeTrackingList<string>();

            return new GetGroupIdListForLdapUserResponse(groupIdsForLdapUser.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Replication status. </summary>
        /// <param name="healthy"> Replication health check. </param>
        /// <param name="relationshipStatus"> Status of the mirror relationship. </param>
        /// <param name="mirrorState"> The status of the replication. </param>
        /// <param name="totalProgress"> The progress of the replication. </param>
        /// <param name="errorMessage"> Displays error message if the replication is in an error state. </param>
        /// <returns> A new <see cref="Models.ReplicationStatus"/> instance for mocking. </returns>
        public static ReplicationStatus ReplicationStatus(bool? healthy = default, VolumeReplicationRelationshipStatus? relationshipStatus = default, NetAppMirrorState? mirrorState = default, string totalProgress = default, string errorMessage = default)
        {
            return new ReplicationStatus(
                healthy,
                relationshipStatus,
                mirrorState,
                totalProgress,
                errorMessage,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Replication properties. </summary>
        /// <param name="replicationId"> UUID v4 used to identify the replication. </param>
        /// <param name="endpointType"> Indicates whether the local volume is the source or destination for the Volume Replication. </param>
        /// <param name="replicationSchedule"> Schedule. </param>
        /// <param name="remoteVolumeResourceId"> The resource ID of the remote volume. </param>
        /// <param name="remoteVolumeRegion"> The remote region for the other end of the Volume Replication. </param>
        /// <param name="mirrorState"> The status of the replication. </param>
        /// <param name="replicationCreationOn"> Replication creation time. </param>
        /// <param name="replicationDeletionOn"> Replication deletion time. </param>
        /// <returns> A new <see cref="Models.Replication"/> instance for mocking. </returns>
        public static Replication Replication(string replicationId = default, NetAppEndpointType? endpointType = default, ReplicationSchedule? replicationSchedule = default, string remoteVolumeResourceId = default, string remoteVolumeRegion = default, ReplicationMirrorState? mirrorState = default, DateTimeOffset? replicationCreationOn = default, DateTimeOffset? replicationDeletionOn = default)
        {
            return new Replication(
                replicationId,
                endpointType,
                replicationSchedule,
                remoteVolumeResourceId,
                remoteVolumeRegion,
                mirrorState,
                replicationCreationOn,
                replicationDeletionOn,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Source Cluster properties for a cluster peer request. </summary>
        /// <param name="peerIpAddresses"> A list of IC-LIF IPs that can be used to connect to the On-prem cluster. </param>
        /// <returns> A new <see cref="Models.PeerClusterForVolumeMigrationRequest"/> instance for mocking. </returns>
        public static PeerClusterForVolumeMigrationRequest PeerClusterForVolumeMigrationRequest(IEnumerable<string> peerIpAddresses = default)
        {
            peerIpAddresses ??= new ChangeTrackingList<string>();

            return new PeerClusterForVolumeMigrationRequest(peerIpAddresses.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Information about cluster peering process. </summary>
        /// <param name="peerAcceptCommand"> A command that needs to be run on the external ONTAP to accept cluster peering.  Will only be present if &lt;code&gt;clusterPeeringStatus&lt;/code&gt; is &lt;code&gt;pending&lt;/code&gt;. </param>
        /// <returns> A new <see cref="Models.ClusterPeerCommandResponse"/> instance for mocking. </returns>
        public static ClusterPeerCommandResponse ClusterPeerCommandResponse(string peerAcceptCommand = default)
        {
            return new ClusterPeerCommandResponse(peerAcceptCommand, additionalBinaryDataProperties: null);
        }

        /// <summary> Information about svm peering process. </summary>
        /// <param name="svmPeeringCommand"> A command that needs to be run on the external ONTAP to accept svm peering.  Will only be present if &lt;code&gt;svmPeeringStatus&lt;/code&gt; is &lt;code&gt;pending&lt;/code&gt;. </param>
        /// <returns> A new <see cref="Models.SvmPeerCommandResponse"/> instance for mocking. </returns>
        public static SvmPeerCommandResponse SvmPeerCommandResponse(string svmPeeringCommand = default)
        {
            return new SvmPeerCommandResponse(svmPeeringCommand, additionalBinaryDataProperties: null);
        }

        /// <summary> Pool change request. </summary>
        /// <param name="newPoolResourceId"> Resource id of the pool to move volume to. </param>
        /// <returns> A new <see cref="Models.PoolChangeRequest"/> instance for mocking. </returns>
        public static PoolChangeRequest PoolChangeRequest(string newPoolResourceId = default)
        {
            return new PoolChangeRequest(newPoolResourceId, additionalBinaryDataProperties: null);
        }

        /// <summary> Quota Report for volume. </summary>
        /// <param name="value"> List of quota reports. </param>
        /// <returns> A new <see cref="Models.ListQuotaReportResponse"/> instance for mocking. </returns>
        public static ListQuotaReportResponse ListQuotaReportResponse(IEnumerable<QuotaReport> value = default)
        {
            value ??= new ChangeTrackingList<QuotaReport>();

            return new ListQuotaReportResponse(value.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Quota report record properties. </summary>
        /// <param name="quotaType"> Type of quota. </param>
        /// <param name="quotaTarget"> UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running &lt;wmic useraccount where name='user-name' get sid&gt;. </param>
        /// <param name="quotaLimitUsedInKiBs"> Specifies the current usage in kibibytes for the user/group quota. </param>
        /// <param name="quotaLimitTotalInKiBs"> Specifies the total size limit in kibibytes for the user/group quota. </param>
        /// <param name="percentageUsed"> Percentage of used size compared to total size. </param>
        /// <param name="isDerivedQuota"> Flag to indicate whether the quota is derived from default quota. </param>
        /// <returns> A new <see cref="Models.QuotaReport"/> instance for mocking. </returns>
        public static QuotaReport QuotaReport(Type? quotaType = default, string quotaTarget = default, long? quotaLimitUsedInKiBs = default, long? quotaLimitTotalInKiBs = default, float? percentageUsed = default, bool? isDerivedQuota = default)
        {
            return new QuotaReport(
                quotaType,
                quotaTarget,
                quotaLimitUsedInKiBs,
                quotaLimitTotalInKiBs,
                percentageUsed,
                isDerivedQuota,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="snapshotId"> UUID v4 used to identify the Snapshot. </param>
        /// <param name="created"> The creation date of the snapshot. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="location"> Resource location. </param>
        /// <returns> A new <see cref="NetApp.SnapshotData"/> instance for mocking. </returns>
        public static SnapshotData SnapshotData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string snapshotId = default, DateTimeOffset? created = default, string provisioningState = default, string location = default)
        {
            return new SnapshotData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                snapshotId is null || created is null || provisioningState is null ? default : new SnapshotProperties(snapshotId, created, provisioningState, new Dictionary<string, BinaryData>()),
                location);
        }

        /// <summary> Restore payload for Single File Snapshot Restore. </summary>
        /// <param name="filePaths"> List of files to be restored. </param>
        /// <param name="destinationPath"> Destination folder where the files will be restored. </param>
        /// <returns> A new <see cref="Models.SnapshotRestoreFiles"/> instance for mocking. </returns>
        public static SnapshotRestoreFiles SnapshotRestoreFiles(IEnumerable<string> filePaths = default, string destinationPath = default)
        {
            filePaths ??= new ChangeTrackingList<string>();

            return new SnapshotRestoreFiles(filePaths.ToList(), destinationPath, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="hourlySchedule"> Schedule for hourly snapshots. </param>
        /// <param name="dailySchedule"> Schedule for daily snapshots. </param>
        /// <param name="weeklySchedule"> Schedule for weekly snapshots. </param>
        /// <param name="monthlySchedule"> Schedule for monthly snapshots. </param>
        /// <param name="enabled"> The property to decide policy is enabled or not. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="etag"> "If etag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."). </param>
        /// <returns> A new <see cref="NetApp.SnapshotPolicyData"/> instance for mocking. </returns>
        public static SnapshotPolicyData SnapshotPolicyData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, HourlySchedule hourlySchedule = default, DailySchedule dailySchedule = default, WeeklySchedule weeklySchedule = default, MonthlySchedule monthlySchedule = default, bool? enabled = default, string provisioningState = default, string etag = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new SnapshotPolicyData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                hourlySchedule is null || dailySchedule is null || weeklySchedule is null || monthlySchedule is null || enabled is null || provisioningState is null ? default : new SnapshotPolicyProperties(
                    hourlySchedule,
                    dailySchedule,
                    weeklySchedule,
                    monthlySchedule,
                    enabled,
                    provisioningState,
                    new Dictionary<string, BinaryData>()),
                etag);
        }

        /// <param name="location"> Resource location. </param>
        /// <param name="id"> Resource Id. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="type"> Resource type. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="hourlySchedule"> Schedule for hourly snapshots. </param>
        /// <param name="dailySchedule"> Schedule for daily snapshots. </param>
        /// <param name="weeklySchedule"> Schedule for weekly snapshots. </param>
        /// <param name="monthlySchedule"> Schedule for monthly snapshots. </param>
        /// <param name="enabled"> The property to decide policy is enabled or not. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <returns> A new <see cref="Models.SnapshotPolicyPatch"/> instance for mocking. </returns>
        public static SnapshotPolicyPatch SnapshotPolicyPatch(string location = default, string id = default, string name = default, string @type = default, IDictionary<string, string> tags = default, HourlySchedule hourlySchedule = default, DailySchedule dailySchedule = default, WeeklySchedule weeklySchedule = default, MonthlySchedule monthlySchedule = default, bool? enabled = default, string provisioningState = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new SnapshotPolicyPatch(
                location,
                id,
                name,
                @type,
                tags,
                hourlySchedule is null || dailySchedule is null || weeklySchedule is null || monthlySchedule is null || enabled is null || provisioningState is null ? default : new SnapshotPolicyProperties(
                    hourlySchedule,
                    dailySchedule,
                    weeklySchedule,
                    monthlySchedule,
                    enabled,
                    provisioningState,
                    new Dictionary<string, BinaryData>()),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Volumes associated with snapshot policy. </summary>
        /// <param name="value"> The Volume items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <returns> A new <see cref="Models.SnapshotPolicyVolumeList"/> instance for mocking. </returns>
        public static SnapshotPolicyVolumeList SnapshotPolicyVolumeList(IEnumerable<VolumeData> value = default, Uri nextLink = default)
        {
            value ??= new ChangeTrackingList<VolumeData>();

            return new SnapshotPolicyVolumeList(value.ToList(), nextLink, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="backupPolicyId"> Backup Policy GUID ID. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="dailyBackupsToKeep"> Daily backups count to keep. </param>
        /// <param name="weeklyBackupsToKeep"> Weekly backups count to keep. </param>
        /// <param name="monthlyBackupsToKeep"> Monthly backups count to keep. </param>
        /// <param name="volumesAssigned"> Volumes using current backup policy. </param>
        /// <param name="enabled"> The property to decide policy is enabled or not. </param>
        /// <param name="volumeBackups"> A list of volumes assigned to this policy. </param>
        /// <param name="etag"> "If etag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."). </param>
        /// <returns> A new <see cref="NetApp.BackupPolicyData"/> instance for mocking. </returns>
        public static BackupPolicyData BackupPolicyData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, string backupPolicyId = default, string provisioningState = default, int? dailyBackupsToKeep = default, int? weeklyBackupsToKeep = default, int? monthlyBackupsToKeep = default, int? volumesAssigned = default, bool? enabled = default, IReadOnlyList<VolumeBackups> volumeBackups = default, string etag = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new BackupPolicyData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                backupPolicyId is null || provisioningState is null || dailyBackupsToKeep is null || weeklyBackupsToKeep is null || monthlyBackupsToKeep is null || volumesAssigned is null || enabled is null || volumeBackups is null ? default : new BackupPolicyProperties(
                    backupPolicyId,
                    provisioningState,
                    dailyBackupsToKeep,
                    weeklyBackupsToKeep,
                    monthlyBackupsToKeep,
                    volumesAssigned,
                    enabled,
                    volumeBackups,
                    new Dictionary<string, BinaryData>()),
                etag);
        }

        /// <summary> Volume details using the backup policy. </summary>
        /// <param name="volumeName"> Volume name. </param>
        /// <param name="volumeResourceId"> ResourceId used to identify the Volume. </param>
        /// <param name="backupsCount"> Total count of backups for volume. </param>
        /// <param name="policyEnabled"> Policy enabled. </param>
        /// <returns> A new <see cref="Models.VolumeBackups"/> instance for mocking. </returns>
        public static VolumeBackups VolumeBackups(string volumeName = default, ResourceIdentifier volumeResourceId = default, int? backupsCount = default, bool? policyEnabled = default)
        {
            return new VolumeBackups(volumeName, volumeResourceId, backupsCount, policyEnabled, additionalBinaryDataProperties: null);
        }

        /// <param name="location"> Resource location. </param>
        /// <param name="id"> Resource Id. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="type"> Resource type. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="backupPolicyId"> Backup Policy GUID ID. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="dailyBackupsToKeep"> Daily backups count to keep. </param>
        /// <param name="weeklyBackupsToKeep"> Weekly backups count to keep. </param>
        /// <param name="monthlyBackupsToKeep"> Monthly backups count to keep. </param>
        /// <param name="volumesAssigned"> Volumes using current backup policy. </param>
        /// <param name="enabled"> The property to decide policy is enabled or not. </param>
        /// <param name="volumeBackups"> A list of volumes assigned to this policy. </param>
        /// <returns> A new <see cref="Models.BackupPolicyPatch"/> instance for mocking. </returns>
        public static BackupPolicyPatch BackupPolicyPatch(string location = default, string id = default, string name = default, string @type = default, IDictionary<string, string> tags = default, string backupPolicyId = default, string provisioningState = default, int? dailyBackupsToKeep = default, int? weeklyBackupsToKeep = default, int? monthlyBackupsToKeep = default, int? volumesAssigned = default, bool? enabled = default, IReadOnlyList<VolumeBackups> volumeBackups = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new BackupPolicyPatch(
                location,
                id,
                name,
                @type,
                tags,
                backupPolicyId is null || provisioningState is null || dailyBackupsToKeep is null || weeklyBackupsToKeep is null || monthlyBackupsToKeep is null || volumesAssigned is null || enabled is null || volumeBackups is null ? default : new BackupPolicyProperties(
                    backupPolicyId,
                    provisioningState,
                    dailyBackupsToKeep,
                    weeklyBackupsToKeep,
                    monthlyBackupsToKeep,
                    volumesAssigned,
                    enabled,
                    volumeBackups,
                    new Dictionary<string, BinaryData>()),
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="provisioningState"> Gets the status of the VolumeQuotaRule at the time the operation was called. </param>
        /// <param name="quotaSizeInKiBs"> Size of quota. </param>
        /// <param name="quotaType"> Type of quota. </param>
        /// <param name="quotaTarget"> UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running &lt;wmic useraccount where name='user-name' get sid&gt;. </param>
        /// <returns> A new <see cref="NetApp.VolumeQuotaRuleData"/> instance for mocking. </returns>
        public static VolumeQuotaRuleData VolumeQuotaRuleData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, Models.NetAppProvisioningState? provisioningState = default, long? quotaSizeInKiBs = default, Type? quotaType = default, string quotaTarget = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new VolumeQuotaRuleData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                provisioningState is null || quotaSizeInKiBs is null || quotaType is null || quotaTarget is null ? default : new VolumeQuotaRulesProperties(provisioningState, quotaSizeInKiBs, quotaType, quotaTarget, new Dictionary<string, BinaryData>()));
        }

        /// <param name="tags"> Resource tags. </param>
        /// <param name="provisioningState"> Gets the status of the VolumeQuotaRule at the time the operation was called. </param>
        /// <param name="quotaSizeInKiBs"> Size of quota. </param>
        /// <param name="quotaType"> Type of quota. </param>
        /// <param name="quotaTarget"> UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running &lt;wmic useraccount where name='user-name' get sid&gt;. </param>
        /// <returns> A new <see cref="Models.VolumeQuotaRulePatch"/> instance for mocking. </returns>
        public static VolumeQuotaRulePatch VolumeQuotaRulePatch(IDictionary<string, string> tags = default, Models.NetAppProvisioningState? provisioningState = default, long? quotaSizeInKiBs = default, Type? quotaType = default, string quotaTarget = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new VolumeQuotaRulePatch(tags, provisioningState is null || quotaSizeInKiBs is null || quotaType is null || quotaTarget is null ? default : new VolumeQuotaRulesProperties(provisioningState, quotaSizeInKiBs, quotaType, quotaTarget, new Dictionary<string, BinaryData>()), additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Advanced Ransomware Protection (ARP) report
        /// Get details of the specified Advanced Ransomware Protection report (ARP).
        /// ARP reports are created with a list of suspected files when it detects any combination of high data entropy, abnormal volume activity with data encryption, and unusual file extensions.
        /// ARP creates snapshots named Anti_ransomware_backup when it detects a potential ransomware threat. You can use one of these ARP snapshots or another snapshot of your volume to restore data.
        /// </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> Advanced Ransomware Protection reports Properties. </param>
        /// <returns> A new <see cref="NetApp.RansomwareReportData"/> instance for mocking. </returns>
        public static RansomwareReportData RansomwareReportData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, RansomwareReportProperties properties = default)
        {
            return new RansomwareReportData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary>
        /// Advanced Ransomware Protection (ARP) report properties.
        /// 
        /// Evaluate the report to determine whether the activity is acceptable (false positive) or whether an attack seems malicious using the ClearSuspects operation.
        /// 
        /// Advanced Ransomware Protection (ARP) creates snapshots named Anti_ransomware_backup when it detects a potential ransomware threat. You can use one of the ARP snapshots or another snapshot of your volume to restore data.
        /// </summary>
        /// <param name="eventOn"> The creation date and time of the report. </param>
        /// <param name="state"> State of the Advanced Ransomware Protection (ARP) report. </param>
        /// <param name="severity"> Severity of the Advanced Ransomware Protection (ARP) report. </param>
        /// <param name="clearedCount"> The number of cleared suspects identified by the ARP report. </param>
        /// <param name="reportedCount"> The number of suspects identified by the ARP report. </param>
        /// <param name="suspects"> Suspects identified in an ARP report. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <returns> A new <see cref="Models.RansomwareReportProperties"/> instance for mocking. </returns>
        public static RansomwareReportProperties RansomwareReportProperties(DateTimeOffset? eventOn = default, RansomwareReportState? state = default, RansomwareReportSeverity? severity = default, int? clearedCount = default, int? reportedCount = default, IEnumerable<RansomwareSuspects> suspects = default, string provisioningState = default)
        {
            suspects ??= new ChangeTrackingList<RansomwareSuspects>();

            return new RansomwareReportProperties(
                eventOn,
                state,
                severity,
                clearedCount,
                reportedCount,
                suspects.ToList(),
                provisioningState,
                additionalBinaryDataProperties: null);
        }

        /// <summary> List of suspects identified in an Advanced Ransomware Protection (ARP) report. </summary>
        /// <param name="extension"> Suspect File extension. </param>
        /// <param name="resolution"> ARP report suspect resolution. </param>
        /// <param name="fileCount"> The number of suspect files at the time of ARP report, this number can change as files get created and report status progresses. </param>
        /// <param name="suspectFiles"> Suspect files. </param>
        /// <returns> A new <see cref="Models.RansomwareSuspects"/> instance for mocking. </returns>
        public static RansomwareSuspects RansomwareSuspects(string extension = default, RansomwareSuspectResolution? resolution = default, int? fileCount = default, IEnumerable<SuspectFile> suspectFiles = default)
        {
            suspectFiles ??= new ChangeTrackingList<SuspectFile>();

            return new RansomwareSuspects(extension, resolution, fileCount, suspectFiles.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Suspect file information. </summary>
        /// <param name="suspectFileName"> Suspect filename. </param>
        /// <param name="fileTimestamp"> The creation date and time of the file. </param>
        /// <returns> A new <see cref="Models.SuspectFile"/> instance for mocking. </returns>
        public static SuspectFile SuspectFile(string suspectFileName = default, DateTimeOffset? fileTimestamp = default)
        {
            return new SuspectFile(suspectFileName, fileTimestamp, additionalBinaryDataProperties: null);
        }

        /// <summary> Clear suspects for Advanced Ransomware Protection (ARP) report. </summary>
        /// <param name="resolution"> ARP report suspect resolution. </param>
        /// <param name="extensions"> List of file extensions resolved (PotentialThreat or FalsePositive). </param>
        /// <returns> A new <see cref="Models.RansomwareSuspectsClearRequest"/> instance for mocking. </returns>
        public static RansomwareSuspectsClearRequest RansomwareSuspectsClearRequest(RansomwareSuspectResolution resolution = default, IEnumerable<string> extensions = default)
        {
            extensions ??= new ChangeTrackingList<string>();

            return new RansomwareSuspectsClearRequest(resolution, extensions.ToList(), additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <returns> A new <see cref="NetApp.BackupVaultData"/> instance for mocking. </returns>
        public static BackupVaultData BackupVaultData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, string provisioningState = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new BackupVaultData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                provisioningState is null ? default : new BackupVaultProperties(provisioningState, new Dictionary<string, BinaryData>()));
        }

        /// <summary> Backup Vault information. </summary>
        /// <param name="tags"> Resource tags. </param>
        /// <returns> A new <see cref="Models.BackupVaultPatch"/> instance for mocking. </returns>
        public static BackupVaultPatch BackupVaultPatch(IDictionary<string, string> tags = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new BackupVaultPatch(tags, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="path"> The volume path mounted inside the bucket. The default is the root path '/' if no value is provided when the bucket is created. </param>
        /// <param name="fileSystemUser"> File System user having access to volume data. For Unix, this is the user's uid and gid. For Windows, this is the user's username. Note that the Unix and Windows user details are mutually exclusive, meaning one or other must be supplied, but not both. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="status">
        /// The bucket credentials status. There states:
        /// 
        /// "NoCredentialsSet": Access and Secret key pair have not been generated.
        /// "CredentialsExpired": Access and Secret key pair have expired.
        /// "Active": The certificate has been installed and credentials are unexpired.
        /// </param>
        /// <param name="server"> Properties of the server managing the lifecycle of volume buckets. </param>
        /// <param name="permissions"> Access permissions for the bucket. Either ReadOnly or ReadWrite. The default is ReadOnly if no value is provided during bucket creation. </param>
        /// <returns> A new <see cref="NetApp.BucketData"/> instance for mocking. </returns>
        public static BucketData BucketData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string path = default, FileSystemUser fileSystemUser = default, Models.NetAppProvisioningState? provisioningState = default, CredentialsStatus? status = default, BucketServerProperties server = default, BucketPermissions? permissions = default)
        {
            return new BucketData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                path is null || fileSystemUser is null || provisioningState is null || status is null || server is null || permissions is null ? default : new BucketProperties(
                    path,
                    fileSystemUser,
                    provisioningState,
                    status,
                    server,
                    permissions,
                    new Dictionary<string, BinaryData>()));
        }

        /// <summary> Properties of the server managing the lifecycle of volume buckets. </summary>
        /// <param name="fqdn"> The host part of the bucket URL, resolving to the bucket IP address and allowed by the server certificate. </param>
        /// <param name="certificateCommonName"> Certificate Common Name taken from the certificate installed on the bucket server. </param>
        /// <param name="certificateExpiryOn"> The bucket server's certificate expiry date. </param>
        /// <param name="ipAddress"> The bucket server's IPv4 address. </param>
        /// <param name="certificateObject"> A base64-encoded PEM file, which includes both the bucket server's certificate and private key. It is used to authenticate the user and allows access to volume data in a read-only manner. </param>
        /// <returns> A new <see cref="Models.BucketServerProperties"/> instance for mocking. </returns>
        public static BucketServerProperties BucketServerProperties(string fqdn = default, string certificateCommonName = default, DateTimeOffset? certificateExpiryOn = default, string ipAddress = default, string certificateObject = default)
        {
            return new BucketServerProperties(
                fqdn,
                certificateCommonName,
                certificateExpiryOn,
                ipAddress,
                certificateObject,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="path"> The volume path mounted inside the bucket. </param>
        /// <param name="fileSystemUser"> File System user having access to volume data. For Unix, this is the user's uid and gid. For Windows, this is the user's username. Note that the Unix and Windows user details are mutually exclusive, meaning one or other must be supplied, but not both. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="server"> Properties of the server managing the lifecycle of volume buckets. </param>
        /// <param name="permissions"> Access permissions for the bucket. Either ReadOnly or ReadWrite. </param>
        /// <returns> A new <see cref="Models.BucketPatch"/> instance for mocking. </returns>
        public static BucketPatch BucketPatch(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string path = default, FileSystemUser fileSystemUser = default, Models.NetAppProvisioningState? provisioningState = default, BucketServerPatchProperties server = default, BucketPatchPermissions? permissions = default)
        {
            return new BucketPatch(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                path is null || fileSystemUser is null || provisioningState is null || server is null || permissions is null ? default : new BucketPatchProperties(
                    path,
                    fileSystemUser,
                    provisioningState,
                    server,
                    permissions,
                    new Dictionary<string, BinaryData>()));
        }

        /// <summary> Bucket Access Key, Secret Key, and Expiry date and time of the key pair. </summary>
        /// <param name="accessKey"> The Access Key that is required along with the Secret Key to access the bucket. </param>
        /// <param name="secretKey"> The Secret Key that is required along with the Access Key to access the bucket. </param>
        /// <param name="keyPairExpiry"> The bucket's Access and Secret key pair expiry date and time (in UTC). </param>
        /// <returns> A new <see cref="Models.BucketGenerateCredentials"/> instance for mocking. </returns>
        public static BucketGenerateCredentials BucketGenerateCredentials(string accessKey = default, string secretKey = default, DateTimeOffset? keyPairExpiry = default)
        {
            return new BucketGenerateCredentials(accessKey, secretKey, keyPairExpiry, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> "If etag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."). </param>
        /// <param name="zones"> The availability zones. </param>
        /// <returns> A new <see cref="NetApp.CacheData"/> instance for mocking. </returns>
        public static CacheData CacheData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, CacheProperties properties = default, string etag = default, IEnumerable<string> zones = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            zones ??= new ChangeTrackingList<string>();

            return new CacheData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties,
                etag,
                zones.ToList());
        }

        /// <summary> Cache resource properties. </summary>
        /// <param name="filepath"> The file path of the cache. </param>
        /// <param name="size"> Maximum storage quota allowed for a file system in bytes. Valid values are in the range 50GiB to 1PiB. Values expressed in bytes as multiples of 1GiB. </param>
        /// <param name="exportPolicy"> Set of export policy rules. </param>
        /// <param name="protocolTypes"> Set of protocol types, default NFSv3, CIFS for SMB protocol. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="cacheState"> Azure NetApp Files Cache lifecycle management. </param>
        /// <param name="cacheSubnetResourceId"> The Azure Resource URI for a delegated cache subnet that will be used to allocate data IPs. </param>
        /// <param name="peeringSubnetResourceId"> The Azure Resource URI for a delegated subnet that will be used for ANF Intercluster Interface IP addresses. </param>
        /// <param name="mountTargets"> List of mount targets that can be used to mount this cache. </param>
        /// <param name="kerberos"> Describe if a cache is Kerberos enabled. </param>
        /// <param name="smbSettings"> SMB information for the cache. </param>
        /// <param name="throughputMibps"> Maximum throughput in MiB/s that can be achieved by this cache volume and this will be accepted as input only for manual qosType cache. </param>
        /// <param name="actualThroughputMibps"> Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel. </param>
        /// <param name="encryptionKeySource"> Source of key used to encrypt data in the cache. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </param>
        /// <param name="keyVaultPrivateEndpointResourceId"> The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. </param>
        /// <param name="maximumNumberOfFiles"> Maximum number of files allowed. </param>
        /// <param name="encryption"> Specifies if the cache is encryption or not. </param>
        /// <param name="language"> Language supported for volume. </param>
        /// <param name="ldap"> Specifies whether LDAP is enabled or not for flexcache volume. </param>
        /// <param name="ldapServerType"> Specifies the type of LDAP server for flexcache volume. </param>
        /// <param name="originClusterInformation"> Origin cluster information. </param>
        /// <param name="cifsChangeNotifications"> Flag indicating whether a CIFS change notification is enabled for the cache. </param>
        /// <param name="globalFileLocking"> Flag indicating whether the global file lock is enabled for the cache. </param>
        /// <param name="writeBack"> Flag indicating whether writeback is enabled for the cache. </param>
        /// <returns> A new <see cref="Models.CacheProperties"/> instance for mocking. </returns>
        public static CacheProperties CacheProperties(string filepath = default, long size = default, IEnumerable<ExportPolicyRule> exportPolicy = default, IEnumerable<ProtocolTypes> protocolTypes = default, CacheProvisioningState? provisioningState = default, CacheLifeCycleState? cacheState = default, ResourceIdentifier cacheSubnetResourceId = default, ResourceIdentifier peeringSubnetResourceId = default, IEnumerable<CacheMountTargetProperties> mountTargets = default, KerberosState? kerberos = default, SmbSettings smbSettings = default, float? throughputMibps = default, float? actualThroughputMibps = default, EncryptionKeySource encryptionKeySource = default, ResourceIdentifier keyVaultPrivateEndpointResourceId = default, long? maximumNumberOfFiles = default, EncryptionState? encryption = default, VolumeLanguage? language = default, LdapState? ldap = default, LdapServerType? ldapServerType = default, OriginClusterInformation originClusterInformation = default, CifsChangeNotifyState? cifsChangeNotifications = default, GlobalFileLockingState? globalFileLocking = default, EnableWriteBackState? writeBack = default)
        {
            exportPolicy ??= new ChangeTrackingList<ExportPolicyRule>();
            protocolTypes ??= new ChangeTrackingList<ProtocolTypes>();
            mountTargets ??= new ChangeTrackingList<CacheMountTargetProperties>();

            return new CacheProperties(
                filepath,
                size,
                exportPolicy.ToList(),
                protocolTypes.ToList(),
                provisioningState,
                cacheState,
                cacheSubnetResourceId,
                peeringSubnetResourceId,
                mountTargets.ToList(),
                kerberos,
                smbSettings,
                throughputMibps,
                actualThroughputMibps,
                encryptionKeySource,
                keyVaultPrivateEndpointResourceId,
                maximumNumberOfFiles,
                encryption,
                language,
                ldap,
                ldapServerType,
                originClusterInformation,
                cifsChangeNotifications,
                globalFileLocking,
                writeBack,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains all the information needed to mount a cache. </summary>
        /// <param name="mountTargetId"> UUID v4 used to identify the MountTarget. </param>
        /// <param name="ipAddress"> The mount target's IPv4 address, used to mount the cache. </param>
        /// <param name="smbServerFqdn"> The SMB server's Fully Qualified Domain Name, FQDN. </param>
        /// <returns> A new <see cref="Models.CacheMountTargetProperties"/> instance for mocking. </returns>
        public static CacheMountTargetProperties CacheMountTargetProperties(string mountTargetId = default, IPAddress ipAddress = default, string smbServerFqdn = default)
        {
            return new CacheMountTargetProperties(mountTargetId, ipAddress, smbServerFqdn, additionalBinaryDataProperties: null);
        }

        /// <summary> Stores the origin cluster information associated to a cache. </summary>
        /// <param name="peerClusterName"> ONTAP cluster name of external cluster hosting the origin volume. </param>
        /// <param name="peerAddresses"> ONTAP Intercluster LIF IP addresses. One IP address per cluster node is required. </param>
        /// <param name="peerVserverName"> External Vserver (SVM) name  name of the SVM hosting the origin volume. </param>
        /// <param name="peerVolumeName"> External origin volume name associated to this cache. </param>
        /// <returns> A new <see cref="Models.OriginClusterInformation"/> instance for mocking. </returns>
        public static OriginClusterInformation OriginClusterInformation(string peerClusterName = default, IEnumerable<string> peerAddresses = default, string peerVserverName = default, string peerVolumeName = default)
        {
            peerAddresses ??= new ChangeTrackingList<string>();

            return new OriginClusterInformation(peerClusterName, peerAddresses.ToList(), peerVserverName, peerVolumeName, additionalBinaryDataProperties: null);
        }

        /// <summary> The type used for update operations of the Cache. </summary>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.CachePatch"/> instance for mocking. </returns>
        public static CachePatch CachePatch(IDictionary<string, string> tags = default, CacheUpdateProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new CachePatch(tags, properties, additionalBinaryDataProperties: null);
        }

        /// <summary> The updatable properties of the Cache. </summary>
        /// <param name="size"> Maximum storage quota allowed for a file system in bytes. Valid values are in the range 50GiB to 1PiB. Values expressed in bytes as multiples of 1GiB. </param>
        /// <param name="exportPolicy"> Set of export policy rules. </param>
        /// <param name="protocolTypes"> Set of protocol types, default NFSv3, CIFS for SMB protocol. </param>
        /// <param name="smbSettings"> SMB information for the cache. </param>
        /// <param name="throughputMibps"> Maximum throughput in MiB/s that can be achieved by this cache volume and this will be accepted as input only for manual qosType cache. </param>
        /// <param name="keyVaultPrivateEndpointResourceId"> The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. </param>
        /// <param name="cifsChangeNotifications"> Flag indicating whether a CIFS change notification is enabled for the cache. </param>
        /// <param name="globalFileLocking"> Flag indicating whether the global file lock is enabled for the cache. </param>
        /// <param name="writeBack"> Flag indicating whether writeback is enabled for the cache. </param>
        /// <returns> A new <see cref="Models.CacheUpdateProperties"/> instance for mocking. </returns>
        public static CacheUpdateProperties CacheUpdateProperties(long? size = default, IEnumerable<ExportPolicyRule> exportPolicy = default, IEnumerable<ProtocolTypes> protocolTypes = default, SmbSettings smbSettings = default, float? throughputMibps = default, ResourceIdentifier keyVaultPrivateEndpointResourceId = default, CifsChangeNotifyState? cifsChangeNotifications = default, GlobalFileLockingState? globalFileLocking = default, EnableWriteBackState? writeBack = default)
        {
            exportPolicy ??= new ChangeTrackingList<ExportPolicyRule>();
            protocolTypes ??= new ChangeTrackingList<ProtocolTypes>();

            return new CacheUpdateProperties(
                size,
                exportPolicy.ToList(),
                protocolTypes.ToList(),
                smbSettings,
                throughputMibps,
                keyVaultPrivateEndpointResourceId,
                cifsChangeNotifications,
                globalFileLocking,
                writeBack,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The response containing peering passphrases and commands for cluster and vserver peering. </summary>
        /// <param name="clusterPeeringCommand"> The cluster peering command. </param>
        /// <param name="clusterPeeringPassphrase"> The cluster peering passphrase. </param>
        /// <param name="vserverPeeringCommand"> The vserver peering command. </param>
        /// <returns> A new <see cref="Models.PeeringPassphrases"/> instance for mocking. </returns>
        public static PeeringPassphrases PeeringPassphrases(string clusterPeeringCommand = default, string clusterPeeringPassphrase = default, string vserverPeeringCommand = default)
        {
            return new PeeringPassphrases(clusterPeeringCommand, clusterPeeringPassphrase, vserverPeeringCommand, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="identity"> The managed service identities assigned to this resource. </param>
        /// <returns> A new <see cref="NetApp.ElasticAccountData"/> instance for mocking. </returns>
        public static ElasticAccountData ElasticAccountData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ElasticAccountProperties properties = default, string etag = default, ManagedServiceIdentity identity = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ElasticAccountData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties,
                etag,
                identity);
        }

        /// <summary> NetApp elastic account properties. </summary>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="encryption"> Encryption settings. </param>
        /// <returns> A new <see cref="Models.ElasticAccountProperties"/> instance for mocking. </returns>
        public static ElasticAccountProperties ElasticAccountProperties(Models.NetAppProvisioningState? provisioningState = default, ElasticEncryption encryption = default)
        {
            return new ElasticAccountProperties(provisioningState, encryption, additionalBinaryDataProperties: null);
        }

        /// <summary> Identity used to authenticate with key vault. </summary>
        /// <param name="principalId"> The principal ID (object ID) of the identity used to authenticate with key vault. Read-only. </param>
        /// <param name="userAssignedIdentity"> The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities. </param>
        /// <returns> A new <see cref="Models.ElasticEncryptionIdentity"/> instance for mocking. </returns>
        public static ElasticEncryptionIdentity ElasticEncryptionIdentity(string principalId = default, ResourceIdentifier userAssignedIdentity = default)
        {
            return new ElasticEncryptionIdentity(principalId, userAssignedIdentity, additionalBinaryDataProperties: null);
        }

        /// <param name="identity"> The managed service identities assigned to this resource. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="elasticAccountUpdateEncryption"> Encryption settings. </param>
        /// <returns> A new <see cref="Models.ElasticAccountPatch"/> instance for mocking. </returns>
        public static ElasticAccountPatch ElasticAccountPatch(ManagedServiceIdentity identity = default, IDictionary<string, string> tags = default, ElasticEncryption elasticAccountUpdateEncryption = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ElasticAccountPatch(identity, tags, elasticAccountUpdateEncryption is null ? default : new ElasticAccountUpdateProperties(elasticAccountUpdateEncryption, new Dictionary<string, BinaryData>()), additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="zones"> The availability zones. </param>
        /// <returns> A new <see cref="NetApp.ElasticCapacityPoolData"/> instance for mocking. </returns>
        public static ElasticCapacityPoolData ElasticCapacityPoolData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ElasticCapacityPoolProperties properties = default, string etag = default, IEnumerable<string> zones = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            zones ??= new ChangeTrackingList<string>();

            return new ElasticCapacityPoolData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties,
                etag,
                zones.ToList());
        }

        /// <summary> Elastic capacity pool properties. </summary>
        /// <param name="size"> Provisioned size of the pool (in bytes). For zoneRedundant service level pool, value must be in the range 1TiB to 16TiB or 1TiB to 128TiB for supported region. Values expressed in bytes as multiples of 1TiB till 16TiB and in multiples of 8TiB from 24TiB to 128TiB. Pool size can't be shrunk once it is created. </param>
        /// <param name="serviceLevel"> The service level of the elastic capacity pool. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="encryption"> Encryption settings. </param>
        /// <param name="totalThroughputMibps"> Total throughput of the pool in MiB/s. </param>
        /// <param name="subnetResourceId"> The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/elasticVolumes, this is used by all the volumes within the pool. </param>
        /// <param name="currentZone"> Indicates the current zone of the pool. This can be changed for zoneRedundant service level pool with the changeZone action. </param>
        /// <param name="availabilityStatus"> Current availability status of the resource. </param>
        /// <param name="activeDirectoryConfigResourceId"> The Azure Resource URI for an Active Directory configuration. This is used by all the SMB volumes within the pool. </param>
        /// <returns> A new <see cref="Models.ElasticCapacityPoolProperties"/> instance for mocking. </returns>
        public static ElasticCapacityPoolProperties ElasticCapacityPoolProperties(long size = default, ElasticServiceLevel serviceLevel = default, Models.NetAppProvisioningState? provisioningState = default, ElasticEncryptionConfiguration encryption = default, double? totalThroughputMibps = default, ResourceIdentifier subnetResourceId = default, string currentZone = default, ElasticResourceAvailabilityStatus? availabilityStatus = default, ResourceIdentifier activeDirectoryConfigResourceId = default)
        {
            return new ElasticCapacityPoolProperties(
                size,
                serviceLevel,
                provisioningState,
                encryption,
                totalThroughputMibps,
                subnetResourceId,
                currentZone,
                availabilityStatus,
                activeDirectoryConfigResourceId,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The type used for update operations of the ElasticCapacityPool. </summary>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.ElasticCapacityPoolPatch"/> instance for mocking. </returns>
        public static ElasticCapacityPoolPatch ElasticCapacityPoolPatch(IDictionary<string, string> tags = default, ElasticCapacityPoolUpdateProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ElasticCapacityPoolPatch(tags, properties, additionalBinaryDataProperties: null);
        }

        /// <summary> Changes the zone for the Zone Redundant elastic capacity pool. </summary>
        /// <param name="newZone"> Availability zone to move Zone Redundant elastic capacity pool to. </param>
        /// <returns> A new <see cref="Models.ChangeZoneRequest"/> instance for mocking. </returns>
        public static ChangeZoneRequest ChangeZoneRequest(string newZone = default)
        {
            return new ChangeZoneRequest(newZone, additionalBinaryDataProperties: null);
        }

        /// <summary> File path availability request content - availability is based on the elastic volume filePath within the given elastic capacityPool. </summary>
        /// <param name="filePath"> A unique file path for the volume. Used when creating mount targets. This needs to be unique within the elastic capacity pool. </param>
        /// <returns> A new <see cref="Models.CheckElasticVolumeFilePathAvailabilityRequest"/> instance for mocking. </returns>
        public static CheckElasticVolumeFilePathAvailabilityRequest CheckElasticVolumeFilePathAvailabilityRequest(string filePath = default)
        {
            return new CheckElasticVolumeFilePathAvailabilityRequest(filePath, additionalBinaryDataProperties: null);
        }

        /// <summary> Information regarding availability of a resource. </summary>
        /// <param name="isAvailable"> True indicates name is valid and available. False indicates the name is invalid, unavailable, or both. </param>
        /// <param name="reason"> Invalid indicates the name provided does not match Azure NetApp Files naming requirements. AlreadyExists indicates that the name is already in use and is therefore unavailable. </param>
        /// <param name="message"> If reason == invalid, provide the user with the reason why the given name is invalid, and provide the resource naming requirements so that the user can select a valid name. If reason == AlreadyExists, explain that resource name is already in use, and direct them to select a different name. </param>
        /// <returns> A new <see cref="Models.CheckElasticResourceAvailabilityResult"/> instance for mocking. </returns>
        public static CheckElasticResourceAvailabilityResult CheckElasticResourceAvailabilityResult(CheckElasticResourceAvailabilityStatus? isAvailable = default, CheckElasticResourceAvailabilityReason? reason = default, string message = default)
        {
            return new CheckElasticResourceAvailabilityResult(isAvailable, reason, message, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="zones"> The availability zones. </param>
        /// <returns> A new <see cref="NetApp.ElasticVolumeData"/> instance for mocking. </returns>
        public static ElasticVolumeData ElasticVolumeData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ElasticVolumeProperties properties = default, string etag = default, IEnumerable<string> zones = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();
            zones ??= new ChangeTrackingList<string>();

            return new ElasticVolumeData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties,
                etag,
                zones.ToList());
        }

        /// <param name="filePath"> A unique file path for the volume. Used when creating mount targets. This needs to be unique within the elastic capacity pool. </param>
        /// <param name="size"> Maximum size allowed for a volume in bytes. Valid values are in the range 1GiB to 16TiB. Values expressed in bytes as multiples of 1 GiB. </param>
        /// <param name="exportRules"> Export policy rule. </param>
        /// <param name="protocolTypes"> Set of support protocol types for the elastic volume. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="availabilityStatus"> Current availability status of the resource. </param>
        /// <param name="snapshotResourceId"> Resource identifier used to identify the Elastic Snapshot. </param>
        /// <param name="mountTargets"> List of mount targets that can be used to mount this volume. </param>
        /// <param name="dataProtection"> Data protection configuration option for the volume, including snapshot policies and backup. </param>
        /// <param name="snapshotDirectoryVisibility"> Controls the visibility of the volume's read-only snapshot directory, which provides access to each of the volume's snapshots. </param>
        /// <param name="smbEncryption"> Used to enable or disable encryption for in-flight SMB data volume. This flag can be modified during Elastic volume update operation as well. Only applicable for SMB protocol Elastic volumes. </param>
        /// <param name="backupResourceId"> Resource identifier used to identify the Elastic Backup. </param>
        /// <param name="restorationState"> The current state of the restoration process. </param>
        /// <returns> A new <see cref="Models.ElasticVolumeProperties"/> instance for mocking. </returns>
        public static ElasticVolumeProperties ElasticVolumeProperties(string filePath = default, long size = default, IList<ElasticExportPolicyRule> exportRules = default, IEnumerable<ElasticProtocolType> protocolTypes = default, Models.NetAppProvisioningState? provisioningState = default, ElasticResourceAvailabilityStatus? availabilityStatus = default, ResourceIdentifier snapshotResourceId = default, IEnumerable<ElasticMountTargetProperties> mountTargets = default, ElasticVolumeDataProtectionProperties dataProtection = default, SnapshotDirectoryVisibility? snapshotDirectoryVisibility = default, ElasticSmbEncryption? smbEncryption = default, ResourceIdentifier backupResourceId = default, ElasticVolumeRestorationState? restorationState = default)
        {
            protocolTypes ??= new ChangeTrackingList<ElasticProtocolType>();
            mountTargets ??= new ChangeTrackingList<ElasticMountTargetProperties>();

            return new ElasticVolumeProperties(
                filePath,
                size,
                exportRules is null ? default : new ElasticExportPolicy(exportRules, new Dictionary<string, BinaryData>()),
                protocolTypes.ToList(),
                provisioningState,
                availabilityStatus,
                snapshotResourceId,
                mountTargets.ToList(),
                dataProtection,
                snapshotDirectoryVisibility,
                smbEncryption is null ? default : new ElasticSmbProperties(smbEncryption, new Dictionary<string, BinaryData>()),
                backupResourceId,
                restorationState,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Elastic Volume Export Policy Rule. </summary>
        /// <param name="ruleIndex"> Controls the priority of the export policy rule. When connecting to the volume the rule with the lowest index that applies to the connecting client is used. </param>
        /// <param name="unixAccessRule"> Specifies the Unix file access level for the volume. It encompasses both read-only and read-write permissions. Additionally, NoAccess can be set to block all access to the volume. </param>
        /// <param name="nfsv3"> Allows clients to access the volume with the NFSv3 protocol. Enable only for NFSv3 type volumes. </param>
        /// <param name="nfsv4"> Allows clients to access the volume with at least NFSv4.1 protocol. </param>
        /// <param name="allowedClients"> Client ingress specification for the export policy as list of IPv4 CIDRs, IPv4 host addresses and host names. </param>
        /// <param name="rootAccess"> Indicates whether root access to the volume is granted to clients affected by this rule. </param>
        /// <returns> A new <see cref="Models.ElasticExportPolicyRule"/> instance for mocking. </returns>
        public static ElasticExportPolicyRule ElasticExportPolicyRule(int? ruleIndex = default, ElasticUnixAccessRule? unixAccessRule = default, ElasticNfsv3Access? nfsv3 = default, ElasticNfsv4Access? nfsv4 = default, IEnumerable<string> allowedClients = default, ElasticRootAccess? rootAccess = default)
        {
            allowedClients ??= new ChangeTrackingList<string>();

            return new ElasticExportPolicyRule(
                ruleIndex,
                unixAccessRule,
                nfsv3,
                nfsv4,
                allowedClients.ToList(),
                rootAccess,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Contains all the information needed to mount an elastic volume. </summary>
        /// <param name="ipAddress"> The mount target's IPv4 address, used to mount the volume. </param>
        /// <param name="smbServerFqdn"> The SMB server's Fully Qualified Domain Name, FQDN. </param>
        /// <returns> A new <see cref="Models.ElasticMountTargetProperties"/> instance for mocking. </returns>
        public static ElasticMountTargetProperties ElasticMountTargetProperties(IPAddress ipAddress = default, string smbServerFqdn = default)
        {
            return new ElasticMountTargetProperties(ipAddress, smbServerFqdn, additionalBinaryDataProperties: null);
        }

        /// <summary> The type used for update operations of the ElasticVolume. </summary>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.ElasticVolumePatch"/> instance for mocking. </returns>
        public static ElasticVolumePatch ElasticVolumePatch(IDictionary<string, string> tags = default, ElasticVolumeUpdateProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ElasticVolumePatch(tags, properties, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="elasticSnapshotProvisioningState"> Azure lifecycle management. </param>
        /// <returns> A new <see cref="NetApp.ElasticSnapshotData"/> instance for mocking. </returns>
        public static ElasticSnapshotData ElasticSnapshotData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, Models.NetAppProvisioningState? elasticSnapshotProvisioningState = default)
        {
            return new ElasticSnapshotData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                elasticSnapshotProvisioningState is null ? default : new ElasticSnapshotProperties(elasticSnapshotProvisioningState, new Dictionary<string, BinaryData>()));
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="NetApp.ElasticSnapshotPolicyData"/> instance for mocking. </returns>
        public static ElasticSnapshotPolicyData ElasticSnapshotPolicyData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ElasticSnapshotPolicyProperties properties = default, string etag = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ElasticSnapshotPolicyData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties,
                etag);
        }

        /// <summary> Elastic Snapshot policy properties. </summary>
        /// <param name="hourlySchedule"> Schedule for hourly snapshots. </param>
        /// <param name="dailySchedule"> Schedule for daily snapshots. </param>
        /// <param name="weeklySchedule"> Schedule for weekly snapshots. </param>
        /// <param name="monthlySchedule"> Schedule for monthly snapshots. </param>
        /// <param name="policyStatus"> Configures if the snapshot policy is enabled on the volumes connected to the policy. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <returns> A new <see cref="Models.ElasticSnapshotPolicyProperties"/> instance for mocking. </returns>
        public static ElasticSnapshotPolicyProperties ElasticSnapshotPolicyProperties(ElasticSnapshotPolicyHourlySchedule hourlySchedule = default, ElasticSnapshotPolicyDailySchedule dailySchedule = default, ElasticSnapshotPolicyWeeklySchedule weeklySchedule = default, ElasticSnapshotPolicyMonthlySchedule monthlySchedule = default, PolicyStatus? policyStatus = default, Models.NetAppProvisioningState? provisioningState = default)
        {
            return new ElasticSnapshotPolicyProperties(
                hourlySchedule,
                dailySchedule,
                weeklySchedule,
                monthlySchedule,
                policyStatus,
                provisioningState,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Weekly Schedule properties used to create NetApp snapshot policy. </summary>
        /// <param name="snapshotsToKeep"> Weekly snapshot count to keep. </param>
        /// <param name="days"> Indicates which weekday(s) snapshot(s) should be taken, accepts a list of week day names in english. </param>
        /// <param name="hour"> Indicates which hour in UTC timezone a snapshot should be taken. </param>
        /// <param name="minute"> Indicates which minute snapshot should be taken. </param>
        /// <returns> A new <see cref="Models.ElasticSnapshotPolicyWeeklySchedule"/> instance for mocking. </returns>
        public static ElasticSnapshotPolicyWeeklySchedule ElasticSnapshotPolicyWeeklySchedule(int? snapshotsToKeep = default, IEnumerable<DayOfWeek> days = default, int? hour = default, int? minute = default)
        {
            days ??= new ChangeTrackingList<DayOfWeek>();

            return new ElasticSnapshotPolicyWeeklySchedule(snapshotsToKeep, days.ToList(), hour, minute, additionalBinaryDataProperties: null);
        }

        /// <summary> Monthly Schedule properties used to create NetApp snapshot policy. </summary>
        /// <param name="snapshotsToKeep"> Monthly snapshot count to keep. </param>
        /// <param name="daysOfMonth"> Indicates which days of the month snapshot (1-31) should be taken, accepts a list of integers. </param>
        /// <param name="hour"> Indicates which hour in UTC timezone a snapshot should be taken. </param>
        /// <param name="minute"> Indicates which minute snapshot should be taken. </param>
        /// <returns> A new <see cref="Models.ElasticSnapshotPolicyMonthlySchedule"/> instance for mocking. </returns>
        public static ElasticSnapshotPolicyMonthlySchedule ElasticSnapshotPolicyMonthlySchedule(int? snapshotsToKeep = default, IEnumerable<int> daysOfMonth = default, int? hour = default, int? minute = default)
        {
            daysOfMonth ??= new ChangeTrackingList<int>();

            return new ElasticSnapshotPolicyMonthlySchedule(snapshotsToKeep, daysOfMonth.ToList(), hour, minute, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="elasticBackupVaultProvisioningState"> Azure lifecycle management. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="NetApp.ElasticBackupVaultData"/> instance for mocking. </returns>
        public static ElasticBackupVaultData ElasticBackupVaultData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, Models.NetAppProvisioningState? elasticBackupVaultProvisioningState = default, string etag = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ElasticBackupVaultData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                elasticBackupVaultProvisioningState is null ? default : new ElasticBackupVaultProperties(elasticBackupVaultProvisioningState, new Dictionary<string, BinaryData>()),
                etag);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="NetApp.ElasticBackupPolicyData"/> instance for mocking. </returns>
        public static ElasticBackupPolicyData ElasticBackupPolicyData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ElasticBackupPolicyProperties properties = default, string etag = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ElasticBackupPolicyData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties,
                etag);
        }

        /// <summary> Elastic Backup Policy properties. </summary>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="dailyBackupsToKeep"> Daily backups count to keep. </param>
        /// <param name="weeklyBackupsToKeep"> Weekly backups count to keep. </param>
        /// <param name="monthlyBackupsToKeep"> Monthly backups count to keep. </param>
        /// <param name="assignedVolumesCount"> The number of volumes currently using this backup policy. </param>
        /// <param name="policyState"> The property to identify whether backup policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.ElasticBackupPolicyProperties"/> instance for mocking. </returns>
        public static ElasticBackupPolicyProperties ElasticBackupPolicyProperties(Models.NetAppProvisioningState? provisioningState = default, int? dailyBackupsToKeep = default, int? weeklyBackupsToKeep = default, int? monthlyBackupsToKeep = default, int? assignedVolumesCount = default, PolicyState? policyState = default)
        {
            return new ElasticBackupPolicyProperties(
                provisioningState,
                dailyBackupsToKeep,
                weeklyBackupsToKeep,
                monthlyBackupsToKeep,
                assignedVolumesCount,
                policyState,
                additionalBinaryDataProperties: null);
        }

        /// <summary> NetApp Elastic Backup under an elastic Backup Vault. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="NetApp.ElasticBackupData"/> instance for mocking. </returns>
        public static ElasticBackupData ElasticBackupData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ElasticBackupProperties properties = default)
        {
            return new ElasticBackupData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> Elastic Backup properties. </summary>
        /// <param name="createdOn"> The creation date of the backup. </param>
        /// <param name="snapshotCreationOn"> The snapshot creation date of the backup. </param>
        /// <param name="completionOn"> The completion date of the backup. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="size"> Size of backup in bytes. </param>
        /// <param name="label"> Label for backup. </param>
        /// <param name="backupType"> Type of backup Manual or Scheduled. </param>
        /// <param name="failureReason"> Failure reason. </param>
        /// <param name="elasticVolumeResourceId"> ResourceId used to identify the Elastic Volume. </param>
        /// <param name="snapshotUsage"> Manual backup using an already existing snapshot. This will always be CreateNewSnapshot for scheduled backups and UseExistingSnapshot/CreateNewSnapshot for manual backups. </param>
        /// <param name="elasticSnapshotResourceId"> ResourceId used to identify the elastic snapshot resource. This is required when an existing snapshot needs to be used for creating a manual backup. </param>
        /// <param name="elasticBackupPolicyResourceId"> ResourceId used to identify the elastic backup policy. </param>
        /// <param name="volumeSize"> Specifies if the backup is for a large volume. </param>
        /// <returns> A new <see cref="Models.ElasticBackupProperties"/> instance for mocking. </returns>
        public static ElasticBackupProperties ElasticBackupProperties(DateTimeOffset? createdOn = default, DateTimeOffset? snapshotCreationOn = default, DateTimeOffset? completionOn = default, Models.NetAppProvisioningState? provisioningState = default, long? size = default, string label = default, ElasticBackupType? backupType = default, string failureReason = default, ResourceIdentifier elasticVolumeResourceId = default, SnapshotUsage? snapshotUsage = default, ResourceIdentifier elasticSnapshotResourceId = default, ResourceIdentifier elasticBackupPolicyResourceId = default, VolumeSize? volumeSize = default)
        {
            return new ElasticBackupProperties(
                createdOn,
                snapshotCreationOn,
                completionOn,
                provisioningState,
                size,
                label,
                backupType,
                failureReason,
                elasticVolumeResourceId,
                snapshotUsage,
                elasticSnapshotResourceId,
                elasticBackupPolicyResourceId,
                volumeSize,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> "If etag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."). </param>
        /// <param name="identity"> The managed service identities assigned to this resource. </param>
        /// <returns> A new <see cref="NetApp.ActiveDirectoryConfigData"/> instance for mocking. </returns>
        public static ActiveDirectoryConfigData ActiveDirectoryConfigData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ActiveDirectoryConfigProperties properties = default, string etag = default, ManagedServiceIdentity identity = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ActiveDirectoryConfigData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties,
                etag,
                identity);
        }

        /// <summary> Active Directory Configuration properties. </summary>
        /// <param name="userName"> A domain user account with permission to create machine accounts. </param>
        /// <param name="dns"> An array of DNS server IP addresses(IPv4 only) for the Active Directory. </param>
        /// <param name="smbServerName"> NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes. </param>
        /// <param name="organizationalUnit"> The Organizational Unit (OU) within the Windows Active Directory. </param>
        /// <param name="site"> The Active Directory site the service will limit Domain Controller discovery to. </param>
        /// <param name="backupOperators"> Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier. </param>
        /// <param name="administrators"> Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier. </param>
        /// <param name="securityOperators"> Domain Users in the Active directory to be given SecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier. </param>
        /// <param name="activeDirectoryStatus"> Status of the Active Directory. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="domain"> Name of the Active Directory domain. </param>
        /// <param name="secretPassword"> Access password from Azure KeyVault Secrets to connect Active Directory. </param>
        /// <returns> A new <see cref="Models.ActiveDirectoryConfigProperties"/> instance for mocking. </returns>
        public static ActiveDirectoryConfigProperties ActiveDirectoryConfigProperties(string userName = default, IEnumerable<IPAddress> dns = default, string smbServerName = default, string organizationalUnit = default, string site = default, IEnumerable<string> backupOperators = default, IEnumerable<string> administrators = default, IEnumerable<string> securityOperators = default, ActiveDirectoryStatus? activeDirectoryStatus = default, Models.NetAppProvisioningState? provisioningState = default, string domain = default, SecretPassword secretPassword = default)
        {
            dns ??= new ChangeTrackingList<IPAddress>();
            backupOperators ??= new ChangeTrackingList<string>();
            administrators ??= new ChangeTrackingList<string>();
            securityOperators ??= new ChangeTrackingList<string>();

            return new ActiveDirectoryConfigProperties(
                userName,
                dns.ToList(),
                smbServerName,
                organizationalUnit,
                site,
                backupOperators.ToList(),
                administrators.ToList(),
                securityOperators.ToList(),
                activeDirectoryStatus,
                provisioningState,
                domain,
                secretPassword,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Identity used to authenticate with key vault. </summary>
        /// <param name="principalId"> The principal ID (object ID) of the identity used to authenticate with key vault. Read-only. </param>
        /// <param name="userAssignedIdentity"> The Azure resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities. </param>
        /// <returns> A new <see cref="Models.SecretPasswordIdentity"/> instance for mocking. </returns>
        public static SecretPasswordIdentity SecretPasswordIdentity(string principalId = default, string userAssignedIdentity = default)
        {
            return new SecretPasswordIdentity(principalId, userAssignedIdentity, additionalBinaryDataProperties: null);
        }

        /// <summary> The type used for update operations of the ActiveDirectoryConfig. </summary>
        /// <param name="identity"> The managed service identities assigned to this resource. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.ActiveDirectoryConfigPatch"/> instance for mocking. </returns>
        public static ActiveDirectoryConfigPatch ActiveDirectoryConfigPatch(ManagedServiceIdentity identity = default, IDictionary<string, string> tags = default, ActiveDirectoryConfigUpdateProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ActiveDirectoryConfigPatch(identity, tags, properties, additionalBinaryDataProperties: null);
        }

        /// <summary> The updatable properties of the ActiveDirectoryConfig. </summary>
        /// <param name="userName"> A domain user account with permission to create machine accounts. </param>
        /// <param name="dns"> An array of DNS server IP addresses(IPv4 only) for the Active Directory. </param>
        /// <param name="smbServerName"> NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes. </param>
        /// <param name="organizationalUnit"> The Organizational Unit (OU) within the Windows Active Directory. </param>
        /// <param name="site"> The Active Directory site the service will limit Domain Controller discovery to. </param>
        /// <param name="backupOperators"> Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier. </param>
        /// <param name="administrators"> Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier. </param>
        /// <param name="securityOperators"> Domain Users in the Active directory to be given SecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier. </param>
        /// <param name="domain"> Name of the Active Directory domain. </param>
        /// <param name="secretPassword"> Access password from Azure KeyVault Secrets to connect Active Directory. </param>
        /// <returns> A new <see cref="Models.ActiveDirectoryConfigUpdateProperties"/> instance for mocking. </returns>
        public static ActiveDirectoryConfigUpdateProperties ActiveDirectoryConfigUpdateProperties(string userName = default, IEnumerable<IPAddress> dns = default, string smbServerName = default, string organizationalUnit = default, string site = default, IEnumerable<string> backupOperators = default, IEnumerable<string> administrators = default, IEnumerable<string> securityOperators = default, string domain = default, SecretPassword secretPassword = default)
        {
            dns ??= new ChangeTrackingList<IPAddress>();
            backupOperators ??= new ChangeTrackingList<string>();
            administrators ??= new ChangeTrackingList<string>();
            securityOperators ??= new ChangeTrackingList<string>();

            return new ActiveDirectoryConfigUpdateProperties(
                userName,
                dns.ToList(),
                smbServerName,
                organizationalUnit,
                site,
                backupOperators.ToList(),
                administrators.ToList(),
                securityOperators.ToList(),
                domain,
                secretPassword,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="storageToNetworkProximity"> Provides storage to network proximity information in the region. </param>
        /// <param name="availabilityZoneMappings"> Provides logical availability zone mappings for the subscription for a region. </param>
        /// <returns> A new <see cref="NetApp.RegionInfoResourceData"/> instance for mocking. </returns>
        public static RegionInfoResourceData RegionInfoResourceData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, RegionStorageToNetworkProximity? storageToNetworkProximity = default, IList<AvailabilityZoneMapping> availabilityZoneMappings = default)
        {
            return new RegionInfoResourceData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                storageToNetworkProximity is null || availabilityZoneMappings is null ? default : new RegionInfo(storageToNetworkProximity, availabilityZoneMappings, new Dictionary<string, BinaryData>()));
        }

        /// <summary> Provides region specific information. </summary>
        /// <param name="storageToNetworkProximity"> Provides storage to network proximity information in the region. </param>
        /// <param name="availabilityZoneMappings"> Provides logical availability zone mappings for the subscription for a region. </param>
        /// <returns> A new <see cref="Models.RegionInfo"/> instance for mocking. </returns>
        public static RegionInfo RegionInfo(RegionStorageToNetworkProximity? storageToNetworkProximity = default, IEnumerable<AvailabilityZoneMapping> availabilityZoneMappings = default)
        {
            availabilityZoneMappings ??= new ChangeTrackingList<AvailabilityZoneMapping>();

            return new RegionInfo(storageToNetworkProximity, availabilityZoneMappings.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The AvailabilityZoneMapping. </summary>
        /// <param name="availabilityZone"> Logical availability zone. </param>
        /// <param name="isAvailable"> Available availability zone. </param>
        /// <returns> A new <see cref="Models.AvailabilityZoneMapping"/> instance for mocking. </returns>
        public static AvailabilityZoneMapping AvailabilityZoneMapping(string availabilityZone = default, bool? isAvailable = default)
        {
            return new AvailabilityZoneMapping(availabilityZone, isAvailable, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="activeDirectories"> Active Directories. </param>
        /// <param name="encryption"> Encryption settings. </param>
        /// <param name="disableShowmount"> Shows the status of disableShowmount for all volumes under the subscription, null equals false. </param>
        /// <param name="nfsV4IDDomain"> Domain for NFSv4 user ID mapping. This property will be set for all NetApp accounts in the subscription and region and only affect non ldap NFSv4 volumes. </param>
        /// <param name="multiAdStatus"> MultiAD Status for the account. </param>
        /// <param name="ldapConfiguration"> LDAP Configuration for the account. </param>
        /// <param name="etag"> "If etag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."). </param>
        /// <param name="identity"> The managed service identities assigned to this resource. </param>
        /// <returns> A new <see cref="NetApp.NetAppAccountData"/> instance for mocking. </returns>
        public static NetAppAccountData NetAppAccountData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, string provisioningState = default, IList<ActiveDirectory> activeDirectories = default, AccountEncryption encryption = default, bool? disableShowmount = default, string nfsV4IDDomain = default, MultiAdStatus? multiAdStatus = default, LdapConfiguration ldapConfiguration = default, string etag = default, ManagedServiceIdentity identity = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new NetAppAccountData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                provisioningState is null || activeDirectories is null || encryption is null || disableShowmount is null || nfsV4IDDomain is null || multiAdStatus is null || ldapConfiguration is null ? default : new AccountProperties(
                    provisioningState,
                    activeDirectories,
                    encryption,
                    disableShowmount,
                    nfsV4IDDomain,
                    multiAdStatus,
                    ldapConfiguration,
                    new Dictionary<string, BinaryData>()),
                etag,
                identity);
        }

        /// <summary> Active Directory. </summary>
        /// <param name="activeDirectoryId"> Id of the Active Directory. </param>
        /// <param name="username"> A domain user account with permission to create machine accounts. </param>
        /// <param name="password"> Plain text password of Active Directory domain administrator, value is masked in the response. </param>
        /// <param name="domain"> Name of the Active Directory domain. </param>
        /// <param name="dns"> Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain. </param>
        /// <param name="status"> Status of the Active Directory. </param>
        /// <param name="statusDetails"> Any details in regards to the Status of the Active Directory. </param>
        /// <param name="smbServerName"> NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes. </param>
        /// <param name="organizationalUnit"> The Organizational Unit (OU) within the Windows Active Directory. </param>
        /// <param name="site"> The Active Directory site the service will limit Domain Controller discovery to. </param>
        /// <param name="backupOperators"> Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier. </param>
        /// <param name="administrators"> Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier. </param>
        /// <param name="kdcIP"> kdc server IP address for the active directory machine. This optional parameter is used only while creating kerberos volume. </param>
        /// <param name="adName"> Name of the active directory machine. This optional parameter is used only while creating kerberos volume. </param>
        /// <param name="serverRootCACertificate"> When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes. </param>
        /// <param name="aesEncryption"> If enabled, AES encryption will be enabled for SMB communication. </param>
        /// <param name="ldapSigning"> Specifies whether or not the LDAP traffic needs to be signed. </param>
        /// <param name="securityOperators"> Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier. </param>
        /// <param name="ldapOverTLS"> Specifies whether or not the LDAP traffic needs to be secured via TLS. </param>
        /// <param name="allowLocalNfsUsersWithLdap"> If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes. </param>
        /// <param name="encryptDCConnections"> If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted. </param>
        /// <param name="ldapSearchScope"> LDAP Search scope options. </param>
        /// <param name="preferredServersForLdapClient"> Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed. </param>
        /// <returns> A new <see cref="Models.ActiveDirectory"/> instance for mocking. </returns>
        public static ActiveDirectory ActiveDirectory(string activeDirectoryId = default, string username = default, string password = default, string domain = default, string dns = default, ActiveDirectoryStatus? status = default, string statusDetails = default, string smbServerName = default, string organizationalUnit = default, string site = default, IEnumerable<string> backupOperators = default, IEnumerable<string> administrators = default, string kdcIP = default, string adName = default, string serverRootCACertificate = default, bool? aesEncryption = default, bool? ldapSigning = default, IEnumerable<string> securityOperators = default, bool? ldapOverTLS = default, bool? allowLocalNfsUsersWithLdap = default, bool? encryptDCConnections = default, LdapSearchScopeOpt ldapSearchScope = default, string preferredServersForLdapClient = default)
        {
            backupOperators ??= new ChangeTrackingList<string>();
            administrators ??= new ChangeTrackingList<string>();
            securityOperators ??= new ChangeTrackingList<string>();

            return new ActiveDirectory(
                activeDirectoryId,
                username,
                password,
                domain,
                dns,
                status,
                statusDetails,
                smbServerName,
                organizationalUnit,
                site,
                backupOperators.ToList(),
                administrators.ToList(),
                kdcIP,
                adName,
                serverRootCACertificate,
                aesEncryption,
                ldapSigning,
                securityOperators.ToList(),
                ldapOverTLS,
                allowLocalNfsUsersWithLdap,
                encryptDCConnections,
                ldapSearchScope,
                preferredServersForLdapClient,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Properties of key vault. </summary>
        /// <param name="keyVaultId"> UUID v4 used to identify the Azure Key Vault configuration. </param>
        /// <param name="keyVaultUri"> The Uri of KeyVault. </param>
        /// <param name="keyName"> The name of KeyVault key. </param>
        /// <param name="keyVaultResourceId"> The resource ID of KeyVault. </param>
        /// <param name="status"> Status of the KeyVault connection. </param>
        /// <returns> A new <see cref="Models.KeyVaultProperties"/> instance for mocking. </returns>
        public static KeyVaultProperties KeyVaultProperties(string keyVaultId = default, Uri keyVaultUri = default, string keyName = default, ResourceIdentifier keyVaultResourceId = default, NetAppKeyVaultStatus? status = default)
        {
            return new KeyVaultProperties(
                keyVaultId,
                keyVaultUri,
                keyName,
                keyVaultResourceId,
                status,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Identity used to authenticate with key vault. </summary>
        /// <param name="principalId"> The principal ID (object ID) of the identity used to authenticate with key vault. Read-only. </param>
        /// <param name="userAssignedIdentity"> The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities. </param>
        /// <param name="federatedClientId"> ClientId of the multi-tenant AAD Application. Used to access cross-tenant keyvaults. </param>
        /// <returns> A new <see cref="Models.EncryptionIdentity"/> instance for mocking. </returns>
        public static EncryptionIdentity EncryptionIdentity(string principalId = default, string userAssignedIdentity = default, string federatedClientId = default)
        {
            return new EncryptionIdentity(principalId, userAssignedIdentity, federatedClientId, additionalBinaryDataProperties: null);
        }

        /// <summary> LDAP configuration. </summary>
        /// <param name="domain"> Name of the LDAP configuration domain. </param>
        /// <param name="ldapServers"> List of LDAP server IP addresses (IPv4 only) for the LDAP domain. </param>
        /// <param name="ldapOverTLS"> Specifies whether or not the LDAP traffic needs to be secured via TLS. </param>
        /// <param name="serverCACertificate"> When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded ldap servers CA certificate. </param>
        /// <param name="certificateCNHost"> The CN host name used while generating the certificate, LDAP Over TLS requires the CN host name to create DNS host entry. </param>
        /// <returns> A new <see cref="Models.LdapConfiguration"/> instance for mocking. </returns>
        public static LdapConfiguration LdapConfiguration(string domain = default, IEnumerable<string> ldapServers = default, bool? ldapOverTLS = default, string serverCACertificate = default, string certificateCNHost = default)
        {
            ldapServers ??= new ChangeTrackingList<string>();

            return new LdapConfiguration(
                domain,
                ldapServers.ToList(),
                ldapOverTLS,
                serverCACertificate,
                certificateCNHost,
                additionalBinaryDataProperties: null);
        }

        /// <param name="location"> Resource location. </param>
        /// <param name="id"> Resource Id. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="type"> Resource type. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="activeDirectories"> Active Directories. </param>
        /// <param name="encryption"> Encryption settings. </param>
        /// <param name="disableShowmount"> Shows the status of disableShowmount for all volumes under the subscription, null equals false. </param>
        /// <param name="nfsV4IDDomain"> Domain for NFSv4 user ID mapping. This property will be set for all NetApp accounts in the subscription and region and only affect non ldap NFSv4 volumes. </param>
        /// <param name="multiAdStatus"> MultiAD Status for the account. </param>
        /// <param name="ldapConfiguration"> LDAP Configuration for the account. </param>
        /// <param name="identity"> The identity used for the resource. </param>
        /// <returns> A new <see cref="Models.NetAppAccountPatch"/> instance for mocking. </returns>
        public static NetAppAccountPatch NetAppAccountPatch(string location = default, string id = default, string name = default, string @type = default, IDictionary<string, string> tags = default, string provisioningState = default, IList<ActiveDirectory> activeDirectories = default, AccountEncryption encryption = default, bool? disableShowmount = default, string nfsV4IDDomain = default, MultiAdStatus? multiAdStatus = default, LdapConfiguration ldapConfiguration = default, ManagedServiceIdentity identity = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new NetAppAccountPatch(
                location,
                id,
                name,
                @type,
                tags,
                provisioningState is null || activeDirectories is null || encryption is null || disableShowmount is null || nfsV4IDDomain is null || multiAdStatus is null || ldapConfiguration is null ? default : new AccountProperties(
                    provisioningState,
                    activeDirectories,
                    encryption,
                    disableShowmount,
                    nfsV4IDDomain,
                    multiAdStatus,
                    ldapConfiguration,
                    new Dictionary<string, BinaryData>()),
                identity,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Encryption transition request. </summary>
        /// <param name="virtualNetworkId"> Identifier for the virtual network. </param>
        /// <param name="privateEndpointId"> Identifier of the private endpoint to reach the Azure Key Vault. </param>
        /// <returns> A new <see cref="Models.EncryptionTransitionRequest"/> instance for mocking. </returns>
        public static EncryptionTransitionRequest EncryptionTransitionRequest(ResourceIdentifier virtualNetworkId = default, ResourceIdentifier privateEndpointId = default)
        {
            return new EncryptionTransitionRequest(virtualNetworkId, privateEndpointId, additionalBinaryDataProperties: null);
        }

        /// <param name="keyVaultUri"> The URI of the key vault/managed HSM that should be used for encryption. </param>
        /// <param name="keyName"> The name of the key that should be used for encryption. </param>
        /// <param name="keyVaultResourceId"> Azure resource ID of the key vault/managed HSM that should be used for encryption. </param>
        /// <param name="keyVaultPrivateEndpoints"> Pairs of virtual network ID and private endpoint ID. Every virtual network that has volumes encrypted with customer-managed keys needs its own key vault private endpoint. </param>
        /// <returns> A new <see cref="Models.GetKeyVaultStatusResponse"/> instance for mocking. </returns>
        public static GetKeyVaultStatusResponse GetKeyVaultStatusResponse(Uri keyVaultUri = default, string keyName = default, ResourceIdentifier keyVaultResourceId = default, IList<KeyVaultPrivateEndpoint> keyVaultPrivateEndpoints = default)
        {
            return new GetKeyVaultStatusResponse(keyVaultUri is null || keyName is null || keyVaultResourceId is null || keyVaultPrivateEndpoints is null ? default : new GetKeyVaultStatusResponseProperties(keyVaultUri, keyName, keyVaultResourceId, keyVaultPrivateEndpoints, new Dictionary<string, BinaryData>()), additionalBinaryDataProperties: null);
        }

        /// <summary> Change key vault request. </summary>
        /// <param name="keyVaultUri"> The URI of the key vault/managed HSM that should be used for encryption. </param>
        /// <param name="keyName"> The name of the key that should be used for encryption. </param>
        /// <param name="keyVaultResourceId"> Azure resource ID of the key vault/managed HSM that should be used for encryption. </param>
        /// <param name="keyVaultPrivateEndpoints"> Pairs of virtual network ID and private endpoint ID. Every virtual network that has volumes encrypted with customer-managed keys needs its own key vault private endpoint. </param>
        /// <returns> A new <see cref="Models.ChangeKeyVault"/> instance for mocking. </returns>
        public static ChangeKeyVault ChangeKeyVault(Uri keyVaultUri = default, string keyName = default, ResourceIdentifier keyVaultResourceId = default, IEnumerable<KeyVaultPrivateEndpoint> keyVaultPrivateEndpoints = default)
        {
            keyVaultPrivateEndpoints ??= new ChangeTrackingList<KeyVaultPrivateEndpoint>();

            return new ChangeKeyVault(keyVaultUri, keyName, keyVaultResourceId, keyVaultPrivateEndpoints.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Migrate Backups Request. </summary>
        /// <param name="backupVaultId"> The ResourceId of the Backup Vault. </param>
        /// <returns> A new <see cref="Models.BackupsMigrationRequest"/> instance for mocking. </returns>
        public static BackupsMigrationRequest BackupsMigrationRequest(ResourceIdentifier backupVaultId = default)
        {
            return new BackupsMigrationRequest(backupVaultId, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="poolId"> UUID v4 used to identify the Pool. </param>
        /// <param name="size"> Provisioned size of the pool (in bytes). Allowed values are in 1TiB chunks (value must be multiple of 1099511627776). </param>
        /// <param name="serviceLevel"> The service level of the file system. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="totalThroughputMibps"> Total throughput of pool in MiB/s. </param>
        /// <param name="utilizedThroughputMibps"> Utilized throughput of pool in MiB/s. </param>
        /// <param name="customThroughputMibps"> Maximum throughput in MiB/s that can be achieved by this pool and this will be accepted as input only for manual qosType pool with Flexible service level. </param>
        /// <param name="qosType"> The qos type of the pool. </param>
        /// <param name="coolAccess"> If enabled (true) the pool can contain cool Access enabled volumes. </param>
        /// <param name="encryptionType"> Encryption type of the capacity pool, set encryption type for data at rest for this pool and all volumes in it. This value can only be set when creating new pool. </param>
        /// <param name="etag"> "If etag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields."). </param>
        /// <returns> A new <see cref="NetApp.CapacityPoolData"/> instance for mocking. </returns>
        public static CapacityPoolData CapacityPoolData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, string poolId = default, long? size = default, NetAppFileServiceLevel? serviceLevel = default, string provisioningState = default, float? totalThroughputMibps = default, float? utilizedThroughputMibps = default, int? customThroughputMibps = default, QosType? qosType = default, bool? coolAccess = default, CapacityPoolEncryptionType? encryptionType = default, string etag = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new CapacityPoolData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                poolId is null || size is null || serviceLevel is null || provisioningState is null || totalThroughputMibps is null || utilizedThroughputMibps is null || customThroughputMibps is null || qosType is null || coolAccess is null || encryptionType is null ? default : new PoolProperties(
                    poolId,
                    size.Value,
                    serviceLevel.Value,
                    provisioningState,
                    totalThroughputMibps,
                    utilizedThroughputMibps,
                    customThroughputMibps,
                    qosType,
                    coolAccess,
                    encryptionType,
                    new Dictionary<string, BinaryData>()),
                etag);
        }

        /// <param name="location"> Resource location. </param>
        /// <param name="id"> Resource Id. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="type"> Resource type. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="size"> Provisioned size of the pool (in bytes). Allowed values are in 1TiB chunks (value must be multiple of 1099511627776). </param>
        /// <param name="qosType"> The qos type of the pool. </param>
        /// <param name="coolAccess"> If enabled (true) the pool can contain cool Access enabled volumes. </param>
        /// <param name="customThroughputMibpsInt"> Maximum throughput in MiB/s that can be achieved by this pool and this will be accepted as input only for manual qosType pool with Flexible service level. </param>
        /// <returns> A new <see cref="Models.CapacityPoolPatch"/> instance for mocking. </returns>
        public static CapacityPoolPatch CapacityPoolPatch(string location = default, string id = default, string name = default, string @type = default, IDictionary<string, string> tags = default, long? size = default, QosType? qosType = default, bool? coolAccess = default, int? customThroughputMibpsInt = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new CapacityPoolPatch(
                location,
                id,
                name,
                @type,
                tags,
                size is null || qosType is null || coolAccess is null || customThroughputMibpsInt is null ? default : new PoolPatchProperties(size, qosType, coolAccess, customThroughputMibpsInt, new Dictionary<string, BinaryData>()),
                additionalBinaryDataProperties: null);
        }

        /// <summary> Restore payload for Single File Backup Restore. </summary>
        /// <param name="fileList"> List of files to be restored. </param>
        /// <param name="restoreFilePath"> Destination folder where the files will be restored. The path name should start with a forward slash. If it is omitted from request then restore is done at the root folder of the destination volume by default. </param>
        /// <param name="destinationVolumeId"> Resource Id of the destination volume on which the files need to be restored. </param>
        /// <returns> A new <see cref="Models.BackupRestoreFiles"/> instance for mocking. </returns>
        public static BackupRestoreFiles BackupRestoreFiles(IEnumerable<string> fileList = default, string restoreFilePath = default, string destinationVolumeId = default)
        {
            fileList ??= new ChangeTrackingList<string>();

            return new BackupRestoreFiles(fileList.ToList(), restoreFilePath, destinationVolumeId, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="path"> Path to the subvolume. </param>
        /// <param name="size"> Truncate subvolume to the provided size in bytes. </param>
        /// <param name="parentPath"> parent path to the subvolume. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <returns> A new <see cref="NetApp.SubvolumeInfoData"/> instance for mocking. </returns>
        public static SubvolumeInfoData SubvolumeInfoData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string path = default, long? size = default, string parentPath = default, string provisioningState = default)
        {
            return new SubvolumeInfoData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                path is null || size is null || parentPath is null || provisioningState is null ? default : new SubvolumeProperties(path, size, parentPath, provisioningState, new Dictionary<string, BinaryData>()));
        }

        /// <param name="id"> Resource Id. </param>
        /// <param name="name"> Resource name. </param>
        /// <param name="type"> Resource type. </param>
        /// <param name="path"> Path to the subvolume. </param>
        /// <param name="parentPath"> Path to the parent subvolume. </param>
        /// <param name="size"> Size of subvolume. </param>
        /// <param name="bytesUsed"> Bytes used. </param>
        /// <param name="permissions"> Permissions of the subvolume. </param>
        /// <param name="creationTimeStamp"> Creation time and date. </param>
        /// <param name="accessedTimeStamp"> Most recent access time and date. </param>
        /// <param name="modifiedTimeStamp"> Most recent modification time and date. </param>
        /// <param name="changedTimeStamp"> Most recent change time and date. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <returns> A new <see cref="Models.SubvolumeModel"/> instance for mocking. </returns>
        public static SubvolumeModel SubvolumeModel(string id = default, string name = default, string @type = default, string path = default, string parentPath = default, long? size = default, long? bytesUsed = default, string permissions = default, DateTimeOffset? creationTimeStamp = default, DateTimeOffset? accessedTimeStamp = default, DateTimeOffset? modifiedTimeStamp = default, DateTimeOffset? changedTimeStamp = default, string provisioningState = default)
        {
            return new SubvolumeModel(id, name, @type, path is null || parentPath is null || size is null || bytesUsed is null || permissions is null || creationTimeStamp is null || accessedTimeStamp is null || modifiedTimeStamp is null || changedTimeStamp is null || provisioningState is null ? default : new SubvolumeModelProperties(
                path,
                parentPath,
                size,
                bytesUsed,
                permissions,
                creationTimeStamp,
                accessedTimeStamp,
                modifiedTimeStamp,
                changedTimeStamp,
                provisioningState,
                new Dictionary<string, BinaryData>()), additionalBinaryDataProperties: null);
        }

        /// <summary> Resource name availability request content. </summary>
        /// <param name="name"> Resource name to verify. </param>
        /// <param name="type"> Resource type used for verification. </param>
        /// <param name="resourceGroup"> Resource group name. </param>
        /// <returns> A new <see cref="Models.ResourceNameAvailabilityRequest"/> instance for mocking. </returns>
        public static ResourceNameAvailabilityRequest ResourceNameAvailabilityRequest(string name = default, CheckNameResourceTypes @type = default, string resourceGroup = default)
        {
            return new ResourceNameAvailabilityRequest(name, @type, resourceGroup, additionalBinaryDataProperties: null);
        }

        /// <summary> Information regarding availability of a resource. </summary>
        /// <param name="isAvailable"> &lt;code&gt;true&lt;/code&gt; indicates name is valid and available. &lt;code&gt;false&lt;/code&gt; indicates the name is invalid, unavailable, or both. </param>
        /// <param name="reason"> &lt;code&gt;Invalid&lt;/code&gt; indicates the name provided does not match Azure App Service naming requirements. &lt;code&gt;AlreadyExists&lt;/code&gt; indicates that the name is already in use and is therefore unavailable. </param>
        /// <param name="message"> If reason == invalid, provide the user with the reason why the given name is invalid, and provide the resource naming requirements so that the user can select a valid name. If reason == AlreadyExists, explain that resource name is already in use, and direct them to select a different name. </param>
        /// <returns> A new <see cref="Models.CheckAvailabilityResponse"/> instance for mocking. </returns>
        public static CheckAvailabilityResponse CheckAvailabilityResponse(bool? isAvailable = default, InAvailabilityReasonType? reason = default, string message = default)
        {
            return new CheckAvailabilityResponse(isAvailable, reason, message, additionalBinaryDataProperties: null);
        }

        /// <summary> File path availability request content - availability is based on the name and the subnetId. </summary>
        /// <param name="name"> File path to verify. </param>
        /// <param name="subnetId"> The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. </param>
        /// <param name="availabilityZone"> The Azure Resource logical availability zone which is used within zone mapping lookup for the subscription and region. The lookup will retrieve the physical zone where volume is placed. </param>
        /// <returns> A new <see cref="Models.FilePathAvailabilityRequest"/> instance for mocking. </returns>
        public static FilePathAvailabilityRequest FilePathAvailabilityRequest(string name = default, string subnetId = default, string availabilityZone = default)
        {
            return new FilePathAvailabilityRequest(name, subnetId, availabilityZone, additionalBinaryDataProperties: null);
        }

        /// <summary> Quota availability request content. </summary>
        /// <param name="name"> Name of the resource to verify. </param>
        /// <param name="type"> Resource type used for verification. </param>
        /// <param name="resourceGroup"> Resource group name. </param>
        /// <returns> A new <see cref="Models.QuotaAvailabilityRequest"/> instance for mocking. </returns>
        public static QuotaAvailabilityRequest QuotaAvailabilityRequest(string name = default, CheckQuotaNameResourceTypes @type = default, string resourceGroup = default)
        {
            return new QuotaAvailabilityRequest(name, @type, resourceGroup, additionalBinaryDataProperties: null);
        }

        /// <summary> Network sibling set query. </summary>
        /// <param name="networkSiblingSetId"> Network Sibling Set ID for a group of volumes sharing networking resources in a subnet. </param>
        /// <param name="subnetId"> The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. Example /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}. </param>
        /// <returns> A new <see cref="Models.QueryNetworkSiblingSetRequest"/> instance for mocking. </returns>
        public static QueryNetworkSiblingSetRequest QueryNetworkSiblingSetRequest(string networkSiblingSetId = default, ResourceIdentifier subnetId = default)
        {
            return new QueryNetworkSiblingSetRequest(networkSiblingSetId, subnetId, additionalBinaryDataProperties: null);
        }

        /// <summary> Describes the contents of a network sibling set. </summary>
        /// <param name="networkSiblingSetId"> Network Sibling Set ID for a group of volumes sharing networking resources in a subnet. </param>
        /// <param name="subnetId"> The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. Example /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}. </param>
        /// <param name="networkSiblingSetStateId"> Network sibling set state Id identifying the current state of the sibling set. </param>
        /// <param name="networkFeatures"> Network features available to the volume, or current state of update. </param>
        /// <param name="provisioningState"> Gets the status of the NetworkSiblingSet at the time the operation was called. </param>
        /// <param name="nicInfoList"> List of NIC information. </param>
        /// <returns> A new <see cref="Models.NetworkSiblingSet"/> instance for mocking. </returns>
        public static NetworkSiblingSet NetworkSiblingSet(string networkSiblingSetId = default, ResourceIdentifier subnetId = default, string networkSiblingSetStateId = default, NetworkFeatures? networkFeatures = default, NetworkSiblingSetProvisioningState? provisioningState = default, IEnumerable<NicInfo> nicInfoList = default)
        {
            nicInfoList ??= new ChangeTrackingList<NicInfo>();

            return new NetworkSiblingSet(
                networkSiblingSetId,
                subnetId,
                networkSiblingSetStateId,
                networkFeatures,
                provisioningState,
                nicInfoList.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> NIC information and list of volumes for which the NIC has the primary mount ip address. </summary>
        /// <param name="ipAddress"> ipAddress. </param>
        /// <param name="volumeResourceIds"> Volume resource Ids. </param>
        /// <returns> A new <see cref="Models.NicInfo"/> instance for mocking. </returns>
        public static NicInfo NicInfo(string ipAddress = default, IEnumerable<ResourceIdentifier> volumeResourceIds = default)
        {
            volumeResourceIds ??= new ChangeTrackingList<ResourceIdentifier>();

            return new NicInfo(ipAddress, volumeResourceIds.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Network sibling set update. </summary>
        /// <param name="networkSiblingSetId"> Network Sibling Set ID for a group of volumes sharing networking resources in a subnet. </param>
        /// <param name="subnetId"> The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes. Example /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}. </param>
        /// <param name="networkSiblingSetStateId"> Network sibling set state Id identifying the current state of the sibling set. </param>
        /// <param name="networkFeatures"> Network features available to the volume. </param>
        /// <returns> A new <see cref="Models.UpdateNetworkSiblingSetRequest"/> instance for mocking. </returns>
        public static UpdateNetworkSiblingSetRequest UpdateNetworkSiblingSetRequest(string networkSiblingSetId = default, ResourceIdentifier subnetId = default, string networkSiblingSetStateId = default, NetworkFeatures networkFeatures = default)
        {
            return new UpdateNetworkSiblingSetRequest(networkSiblingSetId, subnetId, networkSiblingSetStateId, networkFeatures, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> The id of the usage. </param>
        /// <param name="name"> The name of the usage. </param>
        /// <param name="currentValue"> The current usage value for the subscription. </param>
        /// <param name="limit"> The limit of the usage. </param>
        /// <param name="unit"> The unit of the usage. </param>
        /// <returns> A new <see cref="Models.UsageResult"/> instance for mocking. </returns>
        public static UsageResult UsageResult(string id = default, UsageName name = default, int? currentValue = default, int? limit = default, string unit = default)
        {
            return new UsageResult(id, name, currentValue is null || limit is null || unit is null ? default : new UsageProperties(currentValue, limit, unit, new Dictionary<string, BinaryData>()), additionalBinaryDataProperties: null);
        }

        /// <summary> The name of the usage. </summary>
        /// <param name="value"> The name of the usage. </param>
        /// <param name="localizedValue"> The localized name of the usage. </param>
        /// <returns> A new <see cref="Models.UsageName"/> instance for mocking. </returns>
        public static UsageName UsageName(string value = default, string localizedValue = default)
        {
            return new UsageName(value, localizedValue, additionalBinaryDataProperties: null);
        }
    }
}
