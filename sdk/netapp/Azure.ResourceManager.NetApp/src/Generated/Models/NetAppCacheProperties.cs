// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;

namespace Azure.ResourceManager.NetApp.Models
{
    /// <summary> Cache resource properties. </summary>
    public partial class NetAppCacheProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="NetAppCacheProperties"/>. </summary>
        /// <param name="filepath"> The file path of the Cache. </param>
        /// <param name="size"> Maximum storage quota allowed for a file system in bytes. Valid values are in the range 50GiB to 1PiB. Values expressed in bytes as multiples of 1GiB. </param>
        /// <param name="cacheSubnetResourceId"> The Azure Resource URI for a delegated cache subnet that will be used to allocate data IPs. </param>
        /// <param name="peeringSubnetResourceId"> The Azure Resource URI for a delegated subnet that will be used for ANF Intercluster Interface IP addresses. </param>
        /// <param name="encryptionKeySource"> Source of key used to encrypt data in the cache. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </param>
        /// <param name="originClusterInformation"> Origin cluster information. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filepath"/>, <paramref name="cacheSubnetResourceId"/>, <paramref name="peeringSubnetResourceId"/> or <paramref name="originClusterInformation"/> is null. </exception>
        public NetAppCacheProperties(string filepath, long size, ResourceIdentifier cacheSubnetResourceId, ResourceIdentifier peeringSubnetResourceId, NetAppEncryptionKeySource encryptionKeySource, OriginClusterInformation originClusterInformation)
        {
            Argument.AssertNotNull(filepath, nameof(filepath));
            Argument.AssertNotNull(cacheSubnetResourceId, nameof(cacheSubnetResourceId));
            Argument.AssertNotNull(peeringSubnetResourceId, nameof(peeringSubnetResourceId));
            Argument.AssertNotNull(originClusterInformation, nameof(originClusterInformation));

            Filepath = filepath;
            Size = size;
            ProtocolTypes = new ChangeTrackingList<ProtocolType>();
            CacheSubnetResourceId = cacheSubnetResourceId;
            PeeringSubnetResourceId = peeringSubnetResourceId;
            MountTargets = new ChangeTrackingList<CacheMountTargetProperties>();
            EncryptionKeySource = encryptionKeySource;
            OriginClusterInformation = originClusterInformation;
        }

        /// <summary> Initializes a new instance of <see cref="NetAppCacheProperties"/>. </summary>
        /// <param name="filepath"> The file path of the Cache. </param>
        /// <param name="size"> Maximum storage quota allowed for a file system in bytes. Valid values are in the range 50GiB to 1PiB. Values expressed in bytes as multiples of 1GiB. </param>
        /// <param name="exportPolicy"> Set of export policy rules. </param>
        /// <param name="protocolTypes"> Set of supported protocol types, which include NFSv3, NFSv4 and SMB protocol. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="cacheState"> Azure NetApp Files Cache lifecycle management. </param>
        /// <param name="cacheSubnetResourceId"> The Azure Resource URI for a delegated cache subnet that will be used to allocate data IPs. </param>
        /// <param name="peeringSubnetResourceId"> The Azure Resource URI for a delegated subnet that will be used for ANF Intercluster Interface IP addresses. </param>
        /// <param name="mountTargets"> List of mount targets that can be used to mount this cache. </param>
        /// <param name="kerberos"> Describe if a cache is Kerberos enabled. </param>
        /// <param name="smbSettings"> SMB information for the cache. </param>
        /// <param name="throughputMibps"> Maximum throughput in MiB/s that can be achieved by this cache volume and this will be accepted as input only for manual qosType cache. </param>
        /// <param name="actualThroughputMibps"> Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel. </param>
        /// <param name="encryptionKeySource"> Source of key used to encrypt data in the cache. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </param>
        /// <param name="keyVaultPrivateEndpointResourceId"> The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. </param>
        /// <param name="maximumNumberOfFiles"> Maximum number of files allowed. </param>
        /// <param name="encryption"> Specifies if the cache is encryption or not. </param>
        /// <param name="language"> Language supported for volume. </param>
        /// <param name="ldap"> Specifies whether LDAP is enabled or not for flexcache volume. </param>
        /// <param name="ldapServerType"> Specifies the type of LDAP server for flexcache volume. </param>
        /// <param name="originClusterInformation"> Origin cluster information. </param>
        /// <param name="cifsChangeNotifications"> Flag indicating whether a CIFS change notification is enabled for the cache. </param>
        /// <param name="globalFileLocking"> Flag indicating whether the global file lock is enabled for the cache. </param>
        /// <param name="writeBack"> Flag indicating whether writeback is enabled for the cache. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal NetAppCacheProperties(string filepath, long size, CachePropertiesExportPolicy exportPolicy, IList<ProtocolType> protocolTypes, CacheProvisioningState? provisioningState, CacheLifeCycleState? cacheState, ResourceIdentifier cacheSubnetResourceId, ResourceIdentifier peeringSubnetResourceId, IReadOnlyList<CacheMountTargetProperties> mountTargets, KerberosState? kerberos, SmbSettings smbSettings, float? throughputMibps, float? actualThroughputMibps, NetAppEncryptionKeySource encryptionKeySource, ResourceIdentifier keyVaultPrivateEndpointResourceId, long? maximumNumberOfFiles, EncryptionState? encryption, NetAppVolumeLanguage? language, LdapState? ldap, LdapServerType? ldapServerType, OriginClusterInformation originClusterInformation, CifsChangeNotifyState? cifsChangeNotifications, GlobalFileLockingState? globalFileLocking, EnableWriteBackState? writeBack, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Filepath = filepath;
            Size = size;
            ExportPolicy = exportPolicy;
            ProtocolTypes = protocolTypes;
            ProvisioningState = provisioningState;
            CacheState = cacheState;
            CacheSubnetResourceId = cacheSubnetResourceId;
            PeeringSubnetResourceId = peeringSubnetResourceId;
            MountTargets = mountTargets;
            Kerberos = kerberos;
            SmbSettings = smbSettings;
            ThroughputMibps = throughputMibps;
            ActualThroughputMibps = actualThroughputMibps;
            EncryptionKeySource = encryptionKeySource;
            KeyVaultPrivateEndpointResourceId = keyVaultPrivateEndpointResourceId;
            MaximumNumberOfFiles = maximumNumberOfFiles;
            Encryption = encryption;
            Language = language;
            Ldap = ldap;
            LdapServerType = ldapServerType;
            OriginClusterInformation = originClusterInformation;
            CifsChangeNotifications = cifsChangeNotifications;
            GlobalFileLocking = globalFileLocking;
            WriteBack = writeBack;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="NetAppCacheProperties"/> for deserialization. </summary>
        internal NetAppCacheProperties()
        {
        }

        /// <summary> The file path of the Cache. </summary>
        public string Filepath { get; set; }
        /// <summary> Maximum storage quota allowed for a file system in bytes. Valid values are in the range 50GiB to 1PiB. Values expressed in bytes as multiples of 1GiB. </summary>
        public long Size { get; set; }
        /// <summary> Set of export policy rules. </summary>
        internal CachePropertiesExportPolicy ExportPolicy { get; set; }
        /// <summary> Export policy rule. </summary>
        public IList<NetAppVolumeExportPolicyRule> ExportRules
        {
            get
            {
                if (ExportPolicy is null)
                    ExportPolicy = new CachePropertiesExportPolicy();
                return ExportPolicy.Rules;
            }
        }

        /// <summary> Set of supported protocol types, which include NFSv3, NFSv4 and SMB protocol. </summary>
        public IList<ProtocolType> ProtocolTypes { get; }
        /// <summary> Azure lifecycle management. </summary>
        public CacheProvisioningState? ProvisioningState { get; }
        /// <summary> Azure NetApp Files Cache lifecycle management. </summary>
        public CacheLifeCycleState? CacheState { get; }
        /// <summary> The Azure Resource URI for a delegated cache subnet that will be used to allocate data IPs. </summary>
        public ResourceIdentifier CacheSubnetResourceId { get; set; }
        /// <summary> The Azure Resource URI for a delegated subnet that will be used for ANF Intercluster Interface IP addresses. </summary>
        public ResourceIdentifier PeeringSubnetResourceId { get; set; }
        /// <summary> List of mount targets that can be used to mount this cache. </summary>
        public IReadOnlyList<CacheMountTargetProperties> MountTargets { get; }
        /// <summary> Describe if a cache is Kerberos enabled. </summary>
        public KerberosState? Kerberos { get; set; }
        /// <summary> SMB information for the cache. </summary>
        public SmbSettings SmbSettings { get; set; }
        /// <summary> Maximum throughput in MiB/s that can be achieved by this cache volume and this will be accepted as input only for manual qosType cache. </summary>
        public float? ThroughputMibps { get; set; }
        /// <summary> Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel. </summary>
        public float? ActualThroughputMibps { get; }
        /// <summary> Source of key used to encrypt data in the cache. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </summary>
        public NetAppEncryptionKeySource EncryptionKeySource { get; set; }
        /// <summary> The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. </summary>
        public ResourceIdentifier KeyVaultPrivateEndpointResourceId { get; set; }
        /// <summary> Maximum number of files allowed. </summary>
        public long? MaximumNumberOfFiles { get; }
        /// <summary> Specifies if the cache is encryption or not. </summary>
        public EncryptionState? Encryption { get; }
        /// <summary> Language supported for volume. </summary>
        public NetAppVolumeLanguage? Language { get; }
        /// <summary> Specifies whether LDAP is enabled or not for flexcache volume. </summary>
        public LdapState? Ldap { get; set; }
        /// <summary> Specifies the type of LDAP server for flexcache volume. </summary>
        public LdapServerType? LdapServerType { get; set; }
        /// <summary> Origin cluster information. </summary>
        public OriginClusterInformation OriginClusterInformation { get; set; }
        /// <summary> Flag indicating whether a CIFS change notification is enabled for the cache. </summary>
        public CifsChangeNotifyState? CifsChangeNotifications { get; set; }
        /// <summary> Flag indicating whether the global file lock is enabled for the cache. </summary>
        public GlobalFileLockingState? GlobalFileLocking { get; set; }
        /// <summary> Flag indicating whether writeback is enabled for the cache. </summary>
        public EnableWriteBackState? WriteBack { get; set; }
    }
}
