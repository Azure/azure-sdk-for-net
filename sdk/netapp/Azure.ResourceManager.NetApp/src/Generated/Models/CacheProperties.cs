// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.NetApp;

namespace Azure.ResourceManager.NetApp.Models
{
    /// <summary> Cache resource properties. </summary>
    public partial class CacheProperties
    {
        /// <summary> Keeps track of any properties unknown to the library. </summary>
        private protected readonly IDictionary<string, BinaryData> _additionalBinaryDataProperties;

        /// <summary> Initializes a new instance of <see cref="CacheProperties"/>. </summary>
        /// <param name="filepath"> The file path of the cache. </param>
        /// <param name="size"> Maximum storage quota allowed for a file system in bytes. Valid values are in the range 50GiB to 1PiB. Values expressed in bytes as multiples of 1GiB. </param>
        /// <param name="cacheSubnetResourceId"> The Azure Resource URI for a delegated cache subnet that will be used to allocate data IPs. </param>
        /// <param name="peeringSubnetResourceId"> The Azure Resource URI for a delegated subnet that will be used for ANF Intercluster Interface IP addresses. </param>
        /// <param name="encryptionKeySource"> Source of key used to encrypt data in the cache. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </param>
        /// <param name="originClusterInformation"> Origin cluster information. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filepath"/>, <paramref name="cacheSubnetResourceId"/>, <paramref name="peeringSubnetResourceId"/> or <paramref name="originClusterInformation"/> is null. </exception>
        public CacheProperties(string filepath, long size, ResourceIdentifier cacheSubnetResourceId, ResourceIdentifier peeringSubnetResourceId, EncryptionKeySource encryptionKeySource, OriginClusterInformation originClusterInformation)
        {
            Argument.AssertNotNull(filepath, nameof(filepath));
            Argument.AssertNotNull(cacheSubnetResourceId, nameof(cacheSubnetResourceId));
            Argument.AssertNotNull(peeringSubnetResourceId, nameof(peeringSubnetResourceId));
            Argument.AssertNotNull(originClusterInformation, nameof(originClusterInformation));

            Filepath = filepath;
            Size = size;
            ExportPolicy = new ChangeTrackingList<ExportPolicyRule>();
            ProtocolTypes = new ChangeTrackingList<ProtocolTypes>();
            CacheSubnetResourceId = cacheSubnetResourceId;
            PeeringSubnetResourceId = peeringSubnetResourceId;
            MountTargets = new ChangeTrackingList<CacheMountTargetProperties>();
            EncryptionKeySource = encryptionKeySource;
            OriginClusterInformation = originClusterInformation;
        }

        /// <summary> Initializes a new instance of <see cref="CacheProperties"/>. </summary>
        /// <param name="filepath"> The file path of the cache. </param>
        /// <param name="size"> Maximum storage quota allowed for a file system in bytes. Valid values are in the range 50GiB to 1PiB. Values expressed in bytes as multiples of 1GiB. </param>
        /// <param name="exportPolicy"> Set of export policy rules. </param>
        /// <param name="protocolTypes"> Set of protocol types, default NFSv3, CIFS for SMB protocol. </param>
        /// <param name="provisioningState"> Azure lifecycle management. </param>
        /// <param name="cacheState"> Azure NetApp Files Cache lifecycle management. </param>
        /// <param name="cacheSubnetResourceId"> The Azure Resource URI for a delegated cache subnet that will be used to allocate data IPs. </param>
        /// <param name="peeringSubnetResourceId"> The Azure Resource URI for a delegated subnet that will be used for ANF Intercluster Interface IP addresses. </param>
        /// <param name="mountTargets"> List of mount targets that can be used to mount this cache. </param>
        /// <param name="kerberos"> Describe if a cache is Kerberos enabled. </param>
        /// <param name="smbSettings"> SMB information for the cache. </param>
        /// <param name="throughputMibps"> Maximum throughput in MiB/s that can be achieved by this cache volume and this will be accepted as input only for manual qosType cache. </param>
        /// <param name="actualThroughputMibps"> Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel. </param>
        /// <param name="encryptionKeySource"> Source of key used to encrypt data in the cache. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </param>
        /// <param name="keyVaultPrivateEndpointResourceId"> The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. </param>
        /// <param name="maximumNumberOfFiles"> Maximum number of files allowed. </param>
        /// <param name="encryption"> Specifies if the cache is encryption or not. </param>
        /// <param name="language"> Language supported for volume. </param>
        /// <param name="ldap"> Specifies whether LDAP is enabled or not for flexcache volume. </param>
        /// <param name="ldapServerType"> Specifies the type of LDAP server for flexcache volume. </param>
        /// <param name="originClusterInformation"> Origin cluster information. </param>
        /// <param name="cifsChangeNotifications"> Flag indicating whether a CIFS change notification is enabled for the cache. </param>
        /// <param name="globalFileLocking"> Flag indicating whether the global file lock is enabled for the cache. </param>
        /// <param name="writeBack"> Flag indicating whether writeback is enabled for the cache. </param>
        /// <param name="additionalBinaryDataProperties"> Keeps track of any properties unknown to the library. </param>
        internal CacheProperties(string filepath, long size, IList<ExportPolicyRule> exportPolicy, IList<ProtocolTypes> protocolTypes, CacheProvisioningState? provisioningState, CacheLifeCycleState? cacheState, ResourceIdentifier cacheSubnetResourceId, ResourceIdentifier peeringSubnetResourceId, IReadOnlyList<CacheMountTargetProperties> mountTargets, KerberosState? kerberos, SmbSettings smbSettings, float? throughputMibps, float? actualThroughputMibps, EncryptionKeySource encryptionKeySource, ResourceIdentifier keyVaultPrivateEndpointResourceId, long? maximumNumberOfFiles, EncryptionState? encryption, VolumeLanguage? language, LdapState? ldap, LdapServerType? ldapServerType, OriginClusterInformation originClusterInformation, CifsChangeNotifyState? cifsChangeNotifications, GlobalFileLockingState? globalFileLocking, EnableWriteBackState? writeBack, IDictionary<string, BinaryData> additionalBinaryDataProperties)
        {
            Filepath = filepath;
            Size = size;
            ExportPolicy = exportPolicy;
            ProtocolTypes = protocolTypes;
            ProvisioningState = provisioningState;
            CacheState = cacheState;
            CacheSubnetResourceId = cacheSubnetResourceId;
            PeeringSubnetResourceId = peeringSubnetResourceId;
            MountTargets = mountTargets;
            Kerberos = kerberos;
            SmbSettings = smbSettings;
            ThroughputMibps = throughputMibps;
            ActualThroughputMibps = actualThroughputMibps;
            EncryptionKeySource = encryptionKeySource;
            KeyVaultPrivateEndpointResourceId = keyVaultPrivateEndpointResourceId;
            MaximumNumberOfFiles = maximumNumberOfFiles;
            Encryption = encryption;
            Language = language;
            Ldap = ldap;
            LdapServerType = ldapServerType;
            OriginClusterInformation = originClusterInformation;
            CifsChangeNotifications = cifsChangeNotifications;
            GlobalFileLocking = globalFileLocking;
            WriteBack = writeBack;
            _additionalBinaryDataProperties = additionalBinaryDataProperties;
        }

        /// <summary> The file path of the cache. </summary>
        public string Filepath { get; set; }

        /// <summary> Maximum storage quota allowed for a file system in bytes. Valid values are in the range 50GiB to 1PiB. Values expressed in bytes as multiples of 1GiB. </summary>
        public long Size { get; set; }

        /// <summary> Set of export policy rules. </summary>
        public IList<ExportPolicyRule> ExportPolicy { get; }

        /// <summary> Set of protocol types, default NFSv3, CIFS for SMB protocol. </summary>
        public IList<ProtocolTypes> ProtocolTypes { get; }

        /// <summary> Azure lifecycle management. </summary>
        public CacheProvisioningState? ProvisioningState { get; }

        /// <summary> Azure NetApp Files Cache lifecycle management. </summary>
        public CacheLifeCycleState? CacheState { get; }

        /// <summary> The Azure Resource URI for a delegated cache subnet that will be used to allocate data IPs. </summary>
        public ResourceIdentifier CacheSubnetResourceId { get; set; }

        /// <summary> The Azure Resource URI for a delegated subnet that will be used for ANF Intercluster Interface IP addresses. </summary>
        public ResourceIdentifier PeeringSubnetResourceId { get; set; }

        /// <summary> List of mount targets that can be used to mount this cache. </summary>
        public IReadOnlyList<CacheMountTargetProperties> MountTargets { get; }

        /// <summary> Describe if a cache is Kerberos enabled. </summary>
        public KerberosState? Kerberos { get; set; }

        /// <summary> SMB information for the cache. </summary>
        public SmbSettings SmbSettings { get; set; }

        /// <summary> Maximum throughput in MiB/s that can be achieved by this cache volume and this will be accepted as input only for manual qosType cache. </summary>
        public float? ThroughputMibps { get; set; }

        /// <summary> Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel. </summary>
        public float? ActualThroughputMibps { get; }

        /// <summary> Source of key used to encrypt data in the cache. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'. </summary>
        public EncryptionKeySource EncryptionKeySource { get; set; }

        /// <summary> The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'. </summary>
        public ResourceIdentifier KeyVaultPrivateEndpointResourceId { get; set; }

        /// <summary> Maximum number of files allowed. </summary>
        public long? MaximumNumberOfFiles { get; }

        /// <summary> Specifies if the cache is encryption or not. </summary>
        public EncryptionState? Encryption { get; }

        /// <summary> Language supported for volume. </summary>
        public VolumeLanguage? Language { get; }

        /// <summary> Specifies whether LDAP is enabled or not for flexcache volume. </summary>
        public LdapState? Ldap { get; set; }

        /// <summary> Specifies the type of LDAP server for flexcache volume. </summary>
        public LdapServerType? LdapServerType { get; set; }

        /// <summary> Origin cluster information. </summary>
        public OriginClusterInformation OriginClusterInformation { get; set; }

        /// <summary> Flag indicating whether a CIFS change notification is enabled for the cache. </summary>
        public CifsChangeNotifyState? CifsChangeNotifications { get; set; }

        /// <summary> Flag indicating whether the global file lock is enabled for the cache. </summary>
        public GlobalFileLockingState? GlobalFileLocking { get; set; }

        /// <summary> Flag indicating whether writeback is enabled for the cache. </summary>
        public EnableWriteBackState? WriteBack { get; set; }
    }
}
