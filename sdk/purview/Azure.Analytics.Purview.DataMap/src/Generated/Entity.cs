// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.Purview.DataMap
{
    /// <summary> The Entity sub-client. </summary>
    public partial class Entity
    {
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of Entity for mocking. </summary>
        protected Entity()
        {
        }

        /// <summary> Initializes a new instance of Entity. </summary>
        /// <param name="clientDiagnostics"> The ClientDiagnostics is used to provide tracing support for the client library. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> Service endpoint. </param>
        /// <param name="apiVersion"></param>
        internal Entity(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _endpoint = endpoint;
            Pipeline = pipeline;
            _apiVersion = apiVersion;
        }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline { get; }

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary>
        /// [Protocol Method] Create or update an entity.
        /// Existing entity is matched using its unique guid if
        /// supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of
        /// collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
        /// int&gt;&gt;.
        /// For each contact type, the maximum number of contacts is 20.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateOrUpdate(RequestContent content, string businessAttributeUpdateBehavior = default, string collectionId = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.CreateOrUpdate");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrUpdateRequest(content, businessAttributeUpdateBehavior, collectionId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create or update an entity.
        /// Existing entity is matched using its unique guid if
        /// supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of
        /// collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
        /// int&gt;&gt;.
        /// For each contact type, the maximum number of contacts is 20.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateOrUpdateAsync(RequestContent content, string businessAttributeUpdateBehavior = default, string collectionId = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.CreateOrUpdate");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateOrUpdateRequest(content, businessAttributeUpdateBehavior, collectionId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update an entity.
        /// Existing entity is matched using its unique guid if
        /// supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of
        /// collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
        /// int&gt;&gt;.
        /// For each contact type, the maximum number of contacts is 20.
        /// </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<EntityMutationResult> CreateOrUpdate(AtlasEntityWithExtInfo body, BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = default, string collectionId = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = CreateOrUpdate(body, businessAttributeUpdateBehavior?.ToString(), collectionId, cancellationToken.ToRequestContext());
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// Create or update an entity.
        /// Existing entity is matched using its unique guid if
        /// supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of
        /// collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
        /// int&gt;&gt;.
        /// For each contact type, the maximum number of contacts is 20.
        /// </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<EntityMutationResult>> CreateOrUpdateAsync(AtlasEntityWithExtInfo body, BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = default, string collectionId = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = await CreateOrUpdateAsync(body, businessAttributeUpdateBehavior?.ToString(), collectionId, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// [Protocol Method] List entities in bulk identified by its GUIDs.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to list. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetByIds(IEnumerable<string> guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetByIds");
            scope.Start();
            try
            {
                Argument.AssertNotNull(guid, nameof(guid));

                using HttpMessage message = CreateGetByIdsRequest(guid, minExtInfo, ignoreRelationships, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List entities in bulk identified by its GUIDs.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to list. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetByIdsAsync(IEnumerable<string> guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetByIds");
            scope.Start();
            try
            {
                Argument.AssertNotNull(guid, nameof(guid));

                using HttpMessage message = CreateGetByIdsRequest(guid, minExtInfo, ignoreRelationships, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List entities in bulk identified by its GUIDs. </summary>
        /// <param name="guid"> An array of GUIDs of entities to list. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasEntitiesWithExtInfo> GetByIds(IEnumerable<string> guid, bool? minExtInfo = default, bool? ignoreRelationships = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            Response result = GetByIds(guid, minExtInfo, ignoreRelationships, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasEntitiesWithExtInfo)result, result);
        }

        /// <summary> List entities in bulk identified by its GUIDs. </summary>
        /// <param name="guid"> An array of GUIDs of entities to list. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasEntitiesWithExtInfo>> GetByIdsAsync(IEnumerable<string> guid, bool? minExtInfo = default, bool? ignoreRelationships = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            Response result = await GetByIdsAsync(guid, minExtInfo, ignoreRelationships, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasEntitiesWithExtInfo)result, result);
        }

        /// <summary>
        /// [Protocol Method] Create or update entities in bulk.
        /// Existing entity is matched using its unique
        /// guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array
        /// of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
        /// array&lt;map&lt;string, int&gt;&gt;.
        /// For each contact type, the maximum number of contacts
        /// is 20.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response BatchCreateOrUpdate(RequestContent content, string collectionId = default, string businessAttributeUpdateBehavior = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.BatchCreateOrUpdate");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateBatchCreateOrUpdateRequest(content, collectionId, businessAttributeUpdateBehavior, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create or update entities in bulk.
        /// Existing entity is matched using its unique
        /// guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array
        /// of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
        /// array&lt;map&lt;string, int&gt;&gt;.
        /// For each contact type, the maximum number of contacts
        /// is 20.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> BatchCreateOrUpdateAsync(RequestContent content, string collectionId = default, string businessAttributeUpdateBehavior = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.BatchCreateOrUpdate");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateBatchCreateOrUpdateRequest(content, collectionId, businessAttributeUpdateBehavior, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update entities in bulk.
        /// Existing entity is matched using its unique
        /// guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array
        /// of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
        /// array&lt;map&lt;string, int&gt;&gt;.
        /// For each contact type, the maximum number of contacts
        /// is 20.
        /// </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<EntityMutationResult> BatchCreateOrUpdate(AtlasEntitiesWithExtInfo body, string collectionId = default, BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = BatchCreateOrUpdate(body, collectionId, businessAttributeUpdateBehavior?.ToString(), cancellationToken.ToRequestContext());
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// Create or update entities in bulk.
        /// Existing entity is matched using its unique
        /// guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array
        /// of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
        /// array&lt;map&lt;string, int&gt;&gt;.
        /// For each contact type, the maximum number of contacts
        /// is 20.
        /// </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<EntityMutationResult>> BatchCreateOrUpdateAsync(AtlasEntitiesWithExtInfo body, string collectionId = default, BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = await BatchCreateOrUpdateAsync(body, collectionId, businessAttributeUpdateBehavior?.ToString(), cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete a list of entities in bulk identified by their GUIDs or unique
        /// attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to delete. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response BatchDelete(IEnumerable<string> guid, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.BatchDelete");
            scope.Start();
            try
            {
                Argument.AssertNotNull(guid, nameof(guid));

                using HttpMessage message = CreateBatchDeleteRequest(guid, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a list of entities in bulk identified by their GUIDs or unique
        /// attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to delete. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> BatchDeleteAsync(IEnumerable<string> guid, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.BatchDelete");
            scope.Start();
            try
            {
                Argument.AssertNotNull(guid, nameof(guid));

                using HttpMessage message = CreateBatchDeleteRequest(guid, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a list of entities in bulk identified by their GUIDs or unique
        /// attributes.
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to delete. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<EntityMutationResult> BatchDelete(IEnumerable<string> guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            Response result = BatchDelete(guid, cancellationToken.ToRequestContext());
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// Delete a list of entities in bulk identified by their GUIDs or unique
        /// attributes.
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to delete. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<EntityMutationResult>> BatchDeleteAsync(IEnumerable<string> guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            Response result = await BatchDeleteAsync(guid, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// [Protocol Method] Associate a classification to multiple entities in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AddClassification(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddClassification");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddClassificationRequest(content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Associate a classification to multiple entities in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AddClassificationAsync(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddClassification");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddClassificationRequest(content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Associate a classification to multiple entities in bulk. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response AddClassification(ClassificationAssociateConfig body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            return AddClassification(body, cancellationToken.ToRequestContext());
        }

        /// <summary> Associate a classification to multiple entities in bulk. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> AddClassificationAsync(ClassificationAssociateConfig body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            return await AddClassificationAsync(body, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get complete definition of an entity given its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetEntity(string guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetEntity");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateGetEntityRequest(guid, minExtInfo, ignoreRelationships, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get complete definition of an entity given its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetEntityAsync(string guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetEntity");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateGetEntityRequest(guid, minExtInfo, ignoreRelationships, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get complete definition of an entity given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasEntityWithExtInfo> GetEntity(string guid, bool? minExtInfo = default, bool? ignoreRelationships = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            Response result = GetEntity(guid, minExtInfo, ignoreRelationships, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasEntityWithExtInfo)result, result);
        }

        /// <summary> Get complete definition of an entity given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasEntityWithExtInfo>> GetEntityAsync(string guid, bool? minExtInfo = default, bool? ignoreRelationships = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            Response result = await GetEntityAsync(guid, minExtInfo, ignoreRelationships, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasEntityWithExtInfo)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update entity partially - create or update entity attribute identified by its
        /// GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not support updating complex types like arrays, and maps.
        /// Null updates are not possible.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response UpdateAttributeById(string guid, string name, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.UpdateAttributeById");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNullOrEmpty(name, nameof(name));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateAttributeByIdRequest(guid, name, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update entity partially - create or update entity attribute identified by its
        /// GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not support updating complex types like arrays, and maps.
        /// Null updates are not possible.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> UpdateAttributeByIdAsync(string guid, string name, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.UpdateAttributeById");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNullOrEmpty(name, nameof(name));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateAttributeByIdRequest(guid, name, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update entity partially - create or update entity attribute identified by its
        /// GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not support updating complex types like arrays, and maps.
        /// Null updates are not possible.
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="body"> The value of the attribute. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<EntityMutationResult> UpdateAttributeById(string guid, string name, BinaryData body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(name, nameof(name));
            Argument.AssertNotNull(body, nameof(body));

            Response result = UpdateAttributeById(guid, name, RequestContent.Create(body), cancellationToken.ToRequestContext());
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// Update entity partially - create or update entity attribute identified by its
        /// GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not support updating complex types like arrays, and maps.
        /// Null updates are not possible.
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="body"> The value of the attribute. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<EntityMutationResult>> UpdateAttributeByIdAsync(string guid, string name, BinaryData body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(name, nameof(name));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await UpdateAttributeByIdAsync(guid, name, RequestContent.Create(body), cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete an entity identified by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response Delete(string guid, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.Delete");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateDeleteRequest(guid, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete an entity identified by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteAsync(string guid, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.Delete");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateDeleteRequest(guid, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete an entity identified by its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<EntityMutationResult> Delete(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            Response result = Delete(guid, cancellationToken.ToRequestContext());
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary> Delete an entity identified by its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<EntityMutationResult>> DeleteAsync(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            Response result = await DeleteAsync(guid, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get classification for a given entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetClassification(string guid, string classificationName, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetClassification");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

                using HttpMessage message = CreateGetClassificationRequest(guid, classificationName, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get classification for a given entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetClassificationAsync(string guid, string classificationName, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetClassification");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

                using HttpMessage message = CreateGetClassificationRequest(guid, classificationName, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get classification for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasClassification> GetClassification(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            Response result = GetClassification(guid, classificationName, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasClassification)result, result);
        }

        /// <summary> Get classification for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasClassification>> GetClassificationAsync(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            Response result = await GetClassificationAsync(guid, classificationName, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasClassification)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete a given classification from an existing entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response RemoveClassification(string guid, string classificationName, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveClassification");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

                using HttpMessage message = CreateRemoveClassificationRequest(guid, classificationName, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a given classification from an existing entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> RemoveClassificationAsync(string guid, string classificationName, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveClassification");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

                using HttpMessage message = CreateRemoveClassificationRequest(guid, classificationName, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a given classification from an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response RemoveClassification(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            return RemoveClassification(guid, classificationName, cancellationToken.ToRequestContext());
        }

        /// <summary> Delete a given classification from an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> RemoveClassificationAsync(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            return await RemoveClassificationAsync(guid, classificationName, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] List classifications for a given entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetClassifications(string guid, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetClassifications");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateGetClassificationsRequest(guid, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List classifications for a given entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetClassificationsAsync(string guid, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetClassifications");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateGetClassificationsRequest(guid, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List classifications for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasClassifications> GetClassifications(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            Response result = GetClassifications(guid, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasClassifications)result, result);
        }

        /// <summary> List classifications for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasClassifications>> GetClassificationsAsync(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            Response result = await GetClassificationsAsync(guid, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasClassifications)result, result);
        }

        /// <summary>
        /// [Protocol Method] Add classifications to an existing entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AddClassifications(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddClassifications");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddClassificationsRequest(guid, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add classifications to an existing entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AddClassificationsAsync(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddClassifications");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddClassificationsRequest(guid, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add classifications to an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> An array of classifications to be added. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response AddClassifications(string guid, IEnumerable<AtlasClassification> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return AddClassifications(guid, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Add classifications to an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> An array of classifications to be added. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> AddClassificationsAsync(string guid, IEnumerable<AtlasClassification> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await AddClassificationsAsync(guid, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Update classifications to an existing entity represented by a guid.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response UpdateClassifications(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.UpdateClassifications");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateClassificationsRequest(guid, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update classifications to an existing entity represented by a guid.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> UpdateClassificationsAsync(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.UpdateClassifications");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateClassificationsRequest(guid, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update classifications to an existing entity represented by a guid. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> An array of classifications to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response UpdateClassifications(string guid, IEnumerable<AtlasClassification> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return UpdateClassifications(guid, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Update classifications to an existing entity represented by a guid. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> An array of classifications to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> UpdateClassificationsAsync(string guid, IEnumerable<AtlasClassification> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await UpdateClassificationsAsync(guid, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get complete definition of an entity given its type and unique attribute.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The
        /// attrName and attrValue should be unique across entities, eg.
        /// qualifiedName.
        /// The REST request would look something like this:
        /// GET
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetByUniqueAttribute(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attribute, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateGetByUniqueAttributeRequest(typeName, minExtInfo, ignoreRelationships, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get complete definition of an entity given its type and unique attribute.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The
        /// attrName and attrValue should be unique across entities, eg.
        /// qualifiedName.
        /// The REST request would look something like this:
        /// GET
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetByUniqueAttributeAsync(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attribute, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateGetByUniqueAttributeRequest(typeName, minExtInfo, ignoreRelationships, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get complete definition of an entity given its type and unique attribute.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The
        /// attrName and attrValue should be unique across entities, eg.
        /// qualifiedName.
        /// The REST request would look something like this:
        /// GET
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasEntityWithExtInfo> GetByUniqueAttribute(string typeName, bool? minExtInfo = default, bool? ignoreRelationships = default, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            Response result = GetByUniqueAttribute(typeName, minExtInfo, ignoreRelationships, attribute, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasEntityWithExtInfo)result, result);
        }

        /// <summary>
        /// Get complete definition of an entity given its type and unique attribute.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The
        /// attrName and attrValue should be unique across entities, eg.
        /// qualifiedName.
        /// The REST request would look something like this:
        /// GET
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasEntityWithExtInfo>> GetByUniqueAttributeAsync(string typeName, bool? minExtInfo = default, bool? ignoreRelationships = default, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            Response result = await GetByUniqueAttributeAsync(typeName, minExtInfo, ignoreRelationships, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasEntityWithExtInfo)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update entity partially - Allow a subset of attributes to be updated on an
        /// entity which is identified by its type and unique attribute eg:
        /// Referenceable.qualifiedName. Null updates are not possible.
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this:
        /// PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response UpdateByUniqueAttribute(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.UpdateByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateByUniqueAttributeRequest(typeName, content, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update entity partially - Allow a subset of attributes to be updated on an
        /// entity which is identified by its type and unique attribute eg:
        /// Referenceable.qualifiedName. Null updates are not possible.
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this:
        /// PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> UpdateByUniqueAttributeAsync(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.UpdateByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateByUniqueAttributeRequest(typeName, content, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update entity partially - Allow a subset of attributes to be updated on an
        /// entity which is identified by its type and unique attribute eg:
        /// Referenceable.qualifiedName. Null updates are not possible.
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this:
        /// PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<EntityMutationResult> UpdateByUniqueAttribute(string typeName, AtlasEntityWithExtInfo body, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            Response result = UpdateByUniqueAttribute(typeName, body, attribute, cancellationToken.ToRequestContext());
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// Update entity partially - Allow a subset of attributes to be updated on an
        /// entity which is identified by its type and unique attribute eg:
        /// Referenceable.qualifiedName. Null updates are not possible.
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this:
        /// PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<EntityMutationResult>> UpdateByUniqueAttributeAsync(string typeName, AtlasEntityWithExtInfo body, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await UpdateByUniqueAttributeAsync(typeName, body, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete an entity identified by its type and unique attributes.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this:
        /// DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteByUniqueAttribute(string typeName, string attribute, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.DeleteByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateDeleteByUniqueAttributeRequest(typeName, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete an entity identified by its type and unique attributes.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this:
        /// DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteByUniqueAttributeAsync(string typeName, string attribute, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.DeleteByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateDeleteByUniqueAttributeRequest(typeName, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete an entity identified by its type and unique attributes.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this:
        /// DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<EntityMutationResult> DeleteByUniqueAttribute(string typeName, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            Response result = DeleteByUniqueAttribute(typeName, attribute, cancellationToken.ToRequestContext());
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// Delete an entity identified by its type and unique attributes.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this:
        /// DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<EntityMutationResult>> DeleteByUniqueAttributeAsync(string typeName, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            Response result = await DeleteByUniqueAttributeAsync(typeName, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete a given classification from an entity identified by its type and unique
        /// attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response RemoveClassificationByUniqueAttribute(string typeName, string classificationName, string attribute, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveClassificationByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
                Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

                using HttpMessage message = CreateRemoveClassificationByUniqueAttributeRequest(typeName, classificationName, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a given classification from an entity identified by its type and unique
        /// attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> RemoveClassificationByUniqueAttributeAsync(string typeName, string classificationName, string attribute, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveClassificationByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
                Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

                using HttpMessage message = CreateRemoveClassificationByUniqueAttributeRequest(typeName, classificationName, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a given classification from an entity identified by its type and unique
        /// attributes.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response RemoveClassificationByUniqueAttribute(string typeName, string classificationName, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            return RemoveClassificationByUniqueAttribute(typeName, classificationName, attribute, cancellationToken.ToRequestContext());
        }

        /// <summary>
        /// Delete a given classification from an entity identified by its type and unique
        /// attributes.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> RemoveClassificationByUniqueAttributeAsync(string typeName, string classificationName, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            return await RemoveClassificationByUniqueAttributeAsync(typeName, classificationName, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Add classification to the entity identified by its type and unique attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AddClassificationsByUniqueAttribute(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddClassificationsByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddClassificationsByUniqueAttributeRequest(typeName, content, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add classification to the entity identified by its type and unique attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AddClassificationsByUniqueAttributeAsync(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddClassificationsByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddClassificationsByUniqueAttributeRequest(typeName, content, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add classification to the entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> An array of classification to be added. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response AddClassificationsByUniqueAttribute(string typeName, IEnumerable<AtlasClassification> body, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return AddClassificationsByUniqueAttribute(typeName, content, attribute, cancellationToken.ToRequestContext());
        }

        /// <summary> Add classification to the entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> An array of classification to be added. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> AddClassificationsByUniqueAttributeAsync(string typeName, IEnumerable<AtlasClassification> body, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await AddClassificationsByUniqueAttributeAsync(typeName, content, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Update classification on an entity identified by its type and unique attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response UpdateClassificationsUniqueByAttribute(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.UpdateClassificationsUniqueByAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateClassificationsUniqueByAttributeRequest(typeName, content, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update classification on an entity identified by its type and unique attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> UpdateClassificationsUniqueByAttributeAsync(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.UpdateClassificationsUniqueByAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateClassificationsUniqueByAttributeRequest(typeName, content, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update classification on an entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> An array of classification to be updated. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response UpdateClassificationsUniqueByAttribute(string typeName, IEnumerable<AtlasClassification> body, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return UpdateClassificationsUniqueByAttribute(typeName, content, attribute, cancellationToken.ToRequestContext());
        }

        /// <summary> Update classification on an entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> An array of classification to be updated. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> UpdateClassificationsUniqueByAttributeAsync(string typeName, IEnumerable<AtlasClassification> body, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await UpdateClassificationsUniqueByAttributeAsync(typeName, content, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Set classifications on entities in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response BatchSetClassifications(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.BatchSetClassifications");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateBatchSetClassificationsRequest(content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Set classifications on entities in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> BatchSetClassificationsAsync(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.BatchSetClassifications");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateBatchSetClassificationsRequest(content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Set classifications on entities in bulk. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<string>> BatchSetClassifications(AtlasEntityHeaders body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = BatchSetClassifications(body, cancellationToken.ToRequestContext());
            List<string> value = new List<string>();
            BinaryData data = result.Content;
            Utf8JsonReader jsonReader = new Utf8JsonReader(data.ToMemory().Span);
            jsonReader.Read();
            while (jsonReader.Read())
            {
                if (jsonReader.TokenType == JsonTokenType.EndArray)
                {
                    break;
                }
                value.Add(jsonReader.GetString());
            }
            return Response.FromValue((IReadOnlyList<string>)value, result);
        }

        /// <summary> Set classifications on entities in bulk. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<string>>> BatchSetClassificationsAsync(AtlasEntityHeaders body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = await BatchSetClassificationsAsync(body, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<string> value = new List<string>();
            BinaryData data = result.Content;
            Utf8JsonReader jsonReader = new Utf8JsonReader(data.ToMemory().Span);
            jsonReader.Read();
            while (jsonReader.Read())
            {
                if (jsonReader.TokenType == JsonTokenType.EndArray)
                {
                    break;
                }
                value.Add(jsonReader.GetString());
            }
            return Response.FromValue((IReadOnlyList<string>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Bulk API to retrieve list of entities identified by its unique attributes.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following
        /// format
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        /// NOTE:
        /// The attrName should be an unique attribute for the given entity-type.
        /// The REST
        /// request would look something like this
        /// GET
        /// /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        /// Note:
        /// at least one unique attribute must be provided.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName">
        /// Qualified name of an entity. E.g. to find 2 entities you can set
        /// attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
        /// example. qualifiedName can be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response BatchGetByUniqueAttributes(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrNQualifiedName, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.BatchGetByUniqueAttributes");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateBatchGetByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Bulk API to retrieve list of entities identified by its unique attributes.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following
        /// format
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        /// NOTE:
        /// The attrName should be an unique attribute for the given entity-type.
        /// The REST
        /// request would look something like this
        /// GET
        /// /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        /// Note:
        /// at least one unique attribute must be provided.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName">
        /// Qualified name of an entity. E.g. to find 2 entities you can set
        /// attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
        /// example. qualifiedName can be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> BatchGetByUniqueAttributesAsync(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrNQualifiedName, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.BatchGetByUniqueAttributes");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateBatchGetByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Bulk API to retrieve list of entities identified by its unique attributes.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following
        /// format
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        /// NOTE:
        /// The attrName should be an unique attribute for the given entity-type.
        /// The REST
        /// request would look something like this
        /// GET
        /// /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        /// Note:
        /// at least one unique attribute must be provided.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName">
        /// Qualified name of an entity. E.g. to find 2 entities you can set
        /// attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
        /// example. qualifiedName can be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasEntitiesWithExtInfo> BatchGetByUniqueAttributes(string typeName, bool? minExtInfo = default, bool? ignoreRelationships = default, string attrNQualifiedName = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            Response result = BatchGetByUniqueAttributes(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasEntitiesWithExtInfo)result, result);
        }

        /// <summary>
        /// Bulk API to retrieve list of entities identified by its unique attributes.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following
        /// format
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        /// NOTE:
        /// The attrName should be an unique attribute for the given entity-type.
        /// The REST
        /// request would look something like this
        /// GET
        /// /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        /// Note:
        /// at least one unique attribute must be provided.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName">
        /// Qualified name of an entity. E.g. to find 2 entities you can set
        /// attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
        /// example. qualifiedName can be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasEntitiesWithExtInfo>> BatchGetByUniqueAttributesAsync(string typeName, bool? minExtInfo = default, bool? ignoreRelationships = default, string attrNQualifiedName = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            Response result = await BatchGetByUniqueAttributesAsync(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasEntitiesWithExtInfo)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get entity header given its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetHeader(string guid, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetHeader");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateGetHeaderRequest(guid, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get entity header given its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetHeaderAsync(string guid, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetHeader");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateGetHeaderRequest(guid, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get entity header given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasEntityHeader> GetHeader(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            Response result = GetHeader(guid, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasEntityHeader)result, result);
        }

        /// <summary> Get entity header given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasEntityHeader>> GetHeaderAsync(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            Response result = await GetHeaderAsync(guid, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasEntityHeader)result, result);
        }

        /// <summary>
        /// [Protocol Method] Remove business metadata from an entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response RemoveBusinessMetadata(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveBusinessMetadata");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateRemoveBusinessMetadataRequest(guid, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Remove business metadata from an entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> RemoveBusinessMetadataAsync(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveBusinessMetadata");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateRemoveBusinessMetadataRequest(guid, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Remove business metadata from an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> Business metadata payload. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response RemoveBusinessMetadata(string guid, IDictionary<string, IDictionary<string, BinaryData>> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            return RemoveBusinessMetadata(guid, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Remove business metadata from an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> Business metadata payload. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> RemoveBusinessMetadataAsync(string guid, IDictionary<string, IDictionary<string, BinaryData>> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            return await RemoveBusinessMetadataAsync(guid, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Add business metadata to an entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="overwrite">
        /// Whether to overwrite the existing business metadata on the entity or not,
        /// default is false.
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AddOrUpdateBusinessMetadata(string guid, RequestContent content, bool? overwrite = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddOrUpdateBusinessMetadata");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddOrUpdateBusinessMetadataRequest(guid, content, overwrite, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add business metadata to an entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="overwrite">
        /// Whether to overwrite the existing business metadata on the entity or not,
        /// default is false.
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AddOrUpdateBusinessMetadataAsync(string guid, RequestContent content, bool? overwrite = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddOrUpdateBusinessMetadata");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddOrUpdateBusinessMetadataRequest(guid, content, overwrite, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add business metadata to an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> BusinessMetadata payload. </param>
        /// <param name="overwrite">
        /// Whether to overwrite the existing business metadata on the entity or not,
        /// default is false.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response AddOrUpdateBusinessMetadata(string guid, IDictionary<string, IDictionary<string, BinaryData>> body, bool? overwrite = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            return AddOrUpdateBusinessMetadata(guid, content, overwrite, cancellationToken.ToRequestContext());
        }

        /// <summary> Add business metadata to an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> BusinessMetadata payload. </param>
        /// <param name="overwrite">
        /// Whether to overwrite the existing business metadata on the entity or not,
        /// default is false.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> AddOrUpdateBusinessMetadataAsync(string guid, IDictionary<string, IDictionary<string, BinaryData>> body, bool? overwrite = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            return await AddOrUpdateBusinessMetadataAsync(guid, content, overwrite, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Delete business metadata attributes from an entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="businessMetadataName"> BusinessMetadata name. </param>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="businessMetadataName"/>, <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="businessMetadataName"/> or <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response RemoveBusinessMetadataAttributes(string businessMetadataName, string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveBusinessMetadataAttributes");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(businessMetadataName, nameof(businessMetadataName));
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateRemoveBusinessMetadataAttributesRequest(businessMetadataName, guid, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete business metadata attributes from an entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="businessMetadataName"> BusinessMetadata name. </param>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="businessMetadataName"/>, <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="businessMetadataName"/> or <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> RemoveBusinessMetadataAttributesAsync(string businessMetadataName, string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveBusinessMetadataAttributes");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(businessMetadataName, nameof(businessMetadataName));
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateRemoveBusinessMetadataAttributesRequest(businessMetadataName, guid, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete business metadata attributes from an entity. </summary>
        /// <param name="businessMetadataName"> BusinessMetadata name. </param>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> Business metadata attribute payload. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="businessMetadataName"/>, <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="businessMetadataName"/> or <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response RemoveBusinessMetadataAttributes(string businessMetadataName, string guid, IDictionary<string, BinaryData> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(businessMetadataName, nameof(businessMetadataName));
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            return RemoveBusinessMetadataAttributes(businessMetadataName, guid, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Delete business metadata attributes from an entity. </summary>
        /// <param name="businessMetadataName"> BusinessMetadata name. </param>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> Business metadata attribute payload. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="businessMetadataName"/>, <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="businessMetadataName"/> or <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> RemoveBusinessMetadataAttributesAsync(string businessMetadataName, string guid, IDictionary<string, BinaryData> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(businessMetadataName, nameof(businessMetadataName));
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            return await RemoveBusinessMetadataAttributesAsync(businessMetadataName, guid, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Add or update business metadata attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="businessMetadataName"> BusinessMetadata name. </param>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="businessMetadataName"/>, <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="businessMetadataName"/> or <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AddOrUpdateBusinessMetadataAttributes(string businessMetadataName, string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddOrUpdateBusinessMetadataAttributes");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(businessMetadataName, nameof(businessMetadataName));
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddOrUpdateBusinessMetadataAttributesRequest(businessMetadataName, guid, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add or update business metadata attributes.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="businessMetadataName"> BusinessMetadata name. </param>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="businessMetadataName"/>, <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="businessMetadataName"/> or <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AddOrUpdateBusinessMetadataAttributesAsync(string businessMetadataName, string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddOrUpdateBusinessMetadataAttributes");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(businessMetadataName, nameof(businessMetadataName));
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAddOrUpdateBusinessMetadataAttributesRequest(businessMetadataName, guid, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add or update business metadata attributes. </summary>
        /// <param name="businessMetadataName"> BusinessMetadata name. </param>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> Business metadata attribute payload. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="businessMetadataName"/>, <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="businessMetadataName"/> or <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response AddOrUpdateBusinessMetadataAttributes(string businessMetadataName, string guid, IDictionary<string, BinaryData> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(businessMetadataName, nameof(businessMetadataName));
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            return AddOrUpdateBusinessMetadataAttributes(businessMetadataName, guid, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Add or update business metadata attributes. </summary>
        /// <param name="businessMetadataName"> BusinessMetadata name. </param>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> Business metadata attribute payload. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="businessMetadataName"/>, <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="businessMetadataName"/> or <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> AddOrUpdateBusinessMetadataAttributesAsync(string businessMetadataName, string guid, IDictionary<string, BinaryData> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(businessMetadataName, nameof(businessMetadataName));
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            return await AddOrUpdateBusinessMetadataAttributesAsync(businessMetadataName, guid, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get the sample Template for uploading/creating bulk BusinessMetaData
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetBusinessMetadataTemplate(RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetBusinessMetadataTemplate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataTemplateRequest(context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the sample Template for uploading/creating bulk BusinessMetaData
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetBusinessMetadataTemplateAsync(RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.GetBusinessMetadataTemplate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataTemplateRequest(context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the sample Template for uploading/creating bulk BusinessMetaData. </summary>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<BinaryData> GetBusinessMetadataTemplate(CancellationToken cancellationToken = default)
        {
            Response result = GetBusinessMetadataTemplate(cancellationToken.ToRequestContext());
            return Response.FromValue(result.Content, result);
        }

        /// <summary> Get the sample Template for uploading/creating bulk BusinessMetaData. </summary>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<BinaryData>> GetBusinessMetadataTemplateAsync(CancellationToken cancellationToken = default)
        {
            Response result = await GetBusinessMetadataTemplateAsync(cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue(result.Content, result);
        }

        /// <summary>
        /// [Protocol Method] Upload the file for creating Business Metadata in BULK
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> The contentType to use which has the multipart/form-data boundary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response ImportBusinessMetadata(RequestContent content, string contentType, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.ImportBusinessMetadata");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateImportBusinessMetadataRequest(content, contentType, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Upload the file for creating Business Metadata in BULK
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> The contentType to use which has the multipart/form-data boundary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> ImportBusinessMetadataAsync(RequestContent content, string contentType, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.ImportBusinessMetadata");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateImportBusinessMetadataRequest(content, contentType, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete given labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response RemoveLabels(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveLabels");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateRemoveLabelsRequest(guid, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete given labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> RemoveLabelsAsync(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveLabels");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateRemoveLabelsRequest(guid, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete given labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be deleted. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response RemoveLabels(string guid, IEnumerable<string> body = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return RemoveLabels(guid, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Delete given labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be deleted. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> RemoveLabelsAsync(string guid, IEnumerable<string> body = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await RemoveLabelsAsync(guid, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Set labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response SetLabels(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.SetLabels");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateSetLabelsRequest(guid, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Set labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> SetLabelsAsync(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.SetLabels");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateSetLabelsRequest(guid, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Set labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be set to the entity. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response SetLabels(string guid, IEnumerable<string> body = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return SetLabels(guid, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Set labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be set to the entity. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> SetLabelsAsync(string guid, IEnumerable<string> body = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await SetLabelsAsync(guid, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Add given labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AddLabel(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddLabel");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateAddLabelRequest(guid, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add given labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AddLabelAsync(string guid, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddLabel");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(guid, nameof(guid));

                using HttpMessage message = CreateAddLabelRequest(guid, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add given labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be added. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response AddLabel(string guid, IEnumerable<string> body = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return AddLabel(guid, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Add given labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be added. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> AddLabelAsync(string guid, IEnumerable<string> body = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await AddLabelAsync(guid, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Delete given labels to a given entity identified by its type and unique
        /// attribute.
        /// If labels is null/empty, no labels will be removed.
        /// If any labels
        /// in labels set are non-existing labels, they will be ignored, only existing
        /// labels will be removed. In addition to the typeName path parameter, attribute
        /// key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
        /// across entities, eg. qualifiedName. The REST request would look something like
        /// this: DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response RemoveLabelsByUniqueAttribute(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateRemoveLabelsByUniqueAttributeRequest(typeName, content, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete given labels to a given entity identified by its type and unique
        /// attribute.
        /// If labels is null/empty, no labels will be removed.
        /// If any labels
        /// in labels set are non-existing labels, they will be ignored, only existing
        /// labels will be removed. In addition to the typeName path parameter, attribute
        /// key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
        /// across entities, eg. qualifiedName. The REST request would look something like
        /// this: DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> RemoveLabelsByUniqueAttributeAsync(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.RemoveLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateRemoveLabelsByUniqueAttributeRequest(typeName, content, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete given labels to a given entity identified by its type and unique
        /// attribute.
        /// If labels is null/empty, no labels will be removed.
        /// If any labels
        /// in labels set are non-existing labels, they will be ignored, only existing
        /// labels will be removed. In addition to the typeName path parameter, attribute
        /// key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
        /// across entities, eg. qualifiedName. The REST request would look something like
        /// this: DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be deleted. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response RemoveLabelsByUniqueAttribute(string typeName, IEnumerable<string> body = default, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return RemoveLabelsByUniqueAttribute(typeName, content, attribute, cancellationToken.ToRequestContext());
        }

        /// <summary>
        /// Delete given labels to a given entity identified by its type and unique
        /// attribute.
        /// If labels is null/empty, no labels will be removed.
        /// If any labels
        /// in labels set are non-existing labels, they will be ignored, only existing
        /// labels will be removed. In addition to the typeName path parameter, attribute
        /// key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
        /// across entities, eg. qualifiedName. The REST request would look something like
        /// this: DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be deleted. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> RemoveLabelsByUniqueAttributeAsync(string typeName, IEnumerable<string> body = default, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await RemoveLabelsByUniqueAttributeAsync(typeName, content, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Set labels to a given entity identified by its type and unique attributes.
        /// If
        /// labels is null/empty, existing labels will all be removed.
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this: POST
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response SetLabelsByUniqueAttribute(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.SetLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateSetLabelsByUniqueAttributeRequest(typeName, content, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Set labels to a given entity identified by its type and unique attributes.
        /// If
        /// labels is null/empty, existing labels will all be removed.
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this: POST
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> SetLabelsByUniqueAttributeAsync(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.SetLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateSetLabelsByUniqueAttributeRequest(typeName, content, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Set labels to a given entity identified by its type and unique attributes.
        /// If
        /// labels is null/empty, existing labels will all be removed.
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this: POST
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be set. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response SetLabelsByUniqueAttribute(string typeName, IEnumerable<string> body = default, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return SetLabelsByUniqueAttribute(typeName, content, attribute, cancellationToken.ToRequestContext());
        }

        /// <summary>
        /// Set labels to a given entity identified by its type and unique attributes.
        /// If
        /// labels is null/empty, existing labels will all be removed.
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this: POST
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be set. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> SetLabelsByUniqueAttributeAsync(string typeName, IEnumerable<string> body = default, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await SetLabelsByUniqueAttributeAsync(typeName, content, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Add given labels to a given entity identified by its type and unique
        /// attributes.
        /// If labels is null/empty, no labels will be added.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this: PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AddLabelsByUniqueAttribute(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateAddLabelsByUniqueAttributeRequest(typeName, content, attribute, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add given labels to a given entity identified by its type and unique
        /// attributes.
        /// If labels is null/empty, no labels will be added.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this: PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AddLabelsByUniqueAttributeAsync(string typeName, RequestContent content, string attribute = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.AddLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

                using HttpMessage message = CreateAddLabelsByUniqueAttributeRequest(typeName, content, attribute, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add given labels to a given entity identified by its type and unique
        /// attributes.
        /// If labels is null/empty, no labels will be added.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this: PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be added. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response AddLabelsByUniqueAttribute(string typeName, IEnumerable<string> body = default, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return AddLabelsByUniqueAttribute(typeName, content, attribute, cancellationToken.ToRequestContext());
        }

        /// <summary>
        /// Add given labels to a given entity identified by its type and unique
        /// attributes.
        /// If labels is null/empty, no labels will be added.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        /// The REST
        /// request would look something like this: PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be added. </param>
        /// <param name="attribute">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> AddLabelsByUniqueAttributeAsync(string typeName, IEnumerable<string> body = default, string attribute = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await AddLabelsByUniqueAttributeAsync(typeName, content, attribute, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Move existing entities to the target collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> The collection where entities will be moved to. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response MoveEntitiesToCollection(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.MoveEntitiesToCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateMoveEntitiesToCollectionRequest(collectionId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Move existing entities to the target collection.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> The collection where entities will be moved to. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> MoveEntitiesToCollectionAsync(string collectionId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Entity.MoveEntitiesToCollection");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateMoveEntitiesToCollectionRequest(collectionId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Move existing entities to the target collection. </summary>
        /// <param name="collectionId"> The collection where entities will be moved to. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<EntityMutationResult> MoveEntitiesToCollection(string collectionId, MoveEntitiesConfig body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = MoveEntitiesToCollection(collectionId, body, cancellationToken.ToRequestContext());
            return Response.FromValue((EntityMutationResult)result, result);
        }

        /// <summary> Move existing entities to the target collection. </summary>
        /// <param name="collectionId"> The collection where entities will be moved to. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="collectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<EntityMutationResult>> MoveEntitiesToCollectionAsync(string collectionId, MoveEntitiesConfig body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(collectionId, nameof(collectionId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await MoveEntitiesToCollectionAsync(collectionId, body, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((EntityMutationResult)result, result);
        }
    }
}
