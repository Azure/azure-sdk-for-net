// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.Purview.DataMap
{
    // Data plane generated sub-client.
    /// <summary> The Entity sub-client. </summary>
    public partial class Entity
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://purview.azure.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of Entity for mocking. </summary>
        protected Entity()
        {
        }

        /// <summary> Initializes a new instance of Entity. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint"> The <see cref="Uri"/> to use. </param>
        /// <param name="apiVersion"> The <see cref="string"/> to use. </param>
        internal Entity(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary>
        /// Create or update an entity.
        /// Existing entity is matched using its unique guid if
        /// supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of
        /// collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
        /// int&gt;&gt;.
        /// For each contact type, the maximum number of contacts is 20.
        /// </summary>
        /// <param name="entity"> Atlas entity with extended information. </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entity"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='CreateOrUpdateAsync(AtlasEntityWithExtInfo,BusinessAttributeUpdateBehavior?,string,CancellationToken)']/*" />
        public virtual async Task<Response<EntityMutationResponse>> CreateOrUpdateAsync(AtlasEntityWithExtInfo entity, BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = null, string collectionId = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(entity, nameof(entity));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = entity.ToRequestContent();
            Response response = await CreateOrUpdateAsync(content, businessAttributeUpdateBehavior?.ToString(), collectionId, context).ConfigureAwait(false);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// Create or update an entity.
        /// Existing entity is matched using its unique guid if
        /// supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of
        /// collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
        /// int&gt;&gt;.
        /// For each contact type, the maximum number of contacts is 20.
        /// </summary>
        /// <param name="entity"> Atlas entity with extended information. </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entity"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='CreateOrUpdate(AtlasEntityWithExtInfo,BusinessAttributeUpdateBehavior?,string,CancellationToken)']/*" />
        public virtual Response<EntityMutationResponse> CreateOrUpdate(AtlasEntityWithExtInfo entity, BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = null, string collectionId = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(entity, nameof(entity));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = entity.ToRequestContent();
            Response response = CreateOrUpdate(content, businessAttributeUpdateBehavior?.ToString(), collectionId, context);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create or update an entity.
        /// Existing entity is matched using its unique guid if
        /// supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of
        /// collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
        /// int&gt;&gt;.
        /// For each contact type, the maximum number of contacts is 20.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateOrUpdateAsync(AtlasEntityWithExtInfo,BusinessAttributeUpdateBehavior?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities. Allowed values: "ignore" | "replace" | "merge"
        /// </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='CreateOrUpdateAsync(RequestContent,string,string,RequestContext)']/*" />
        public virtual async Task<Response> CreateOrUpdateAsync(RequestContent content, string businessAttributeUpdateBehavior = null, string collectionId = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(content, businessAttributeUpdateBehavior, collectionId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create or update an entity.
        /// Existing entity is matched using its unique guid if
        /// supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of
        /// collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string,
        /// int&gt;&gt;.
        /// For each contact type, the maximum number of contacts is 20.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateOrUpdate(AtlasEntityWithExtInfo,BusinessAttributeUpdateBehavior?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities. Allowed values: "ignore" | "replace" | "merge"
        /// </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='CreateOrUpdate(RequestContent,string,string,RequestContext)']/*" />
        public virtual Response CreateOrUpdate(RequestContent content, string businessAttributeUpdateBehavior = null, string collectionId = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.CreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateRequest(content, businessAttributeUpdateBehavior, collectionId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List entities in bulk identified by its GUIDs. </summary>
        /// <param name="guid"> An array of GUIDs of entities to list. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntitiesByGuidsAsync(IEnumerable{string},bool?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasEntitiesWithExtInfo>> GetEntitiesByGuidsAsync(IEnumerable<string> guid, bool? minExtInfo = null, bool? ignoreRelationships = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetEntitiesByGuidsAsync(guid, minExtInfo, ignoreRelationships, context).ConfigureAwait(false);
            return Response.FromValue(AtlasEntitiesWithExtInfo.FromResponse(response), response);
        }

        /// <summary> List entities in bulk identified by its GUIDs. </summary>
        /// <param name="guid"> An array of GUIDs of entities to list. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntitiesByGuids(IEnumerable{string},bool?,bool?,CancellationToken)']/*" />
        public virtual Response<AtlasEntitiesWithExtInfo> GetEntitiesByGuids(IEnumerable<string> guid, bool? minExtInfo = null, bool? ignoreRelationships = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetEntitiesByGuids(guid, minExtInfo, ignoreRelationships, context);
            return Response.FromValue(AtlasEntitiesWithExtInfo.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] List entities in bulk identified by its GUIDs.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetEntitiesByGuidsAsync(IEnumerable{string},bool?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to list. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntitiesByGuidsAsync(IEnumerable{string},bool?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetEntitiesByGuidsAsync(IEnumerable<string> guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetEntitiesByGuids");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntitiesByGuidsRequest(guid, minExtInfo, ignoreRelationships, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List entities in bulk identified by its GUIDs.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetEntitiesByGuids(IEnumerable{string},bool?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to list. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntitiesByGuids(IEnumerable{string},bool?,bool?,RequestContext)']/*" />
        public virtual Response GetEntitiesByGuids(IEnumerable<string> guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetEntitiesByGuids");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntitiesByGuidsRequest(guid, minExtInfo, ignoreRelationships, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update entities in bulk.
        /// Existing entity is matched using its unique
        /// guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array
        /// of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
        /// array&lt;map&lt;string, int&gt;&gt;.
        /// For each contact type, the maximum number of contacts
        /// is 20.
        /// </summary>
        /// <param name="entities"> An array of entities to create or update. </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entities"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkCreateOrUpdateAsync(AtlasEntitiesWithExtInfo,string,BusinessAttributeUpdateBehavior?,CancellationToken)']/*" />
        public virtual async Task<Response<EntityMutationResponse>> BulkCreateOrUpdateAsync(AtlasEntitiesWithExtInfo entities, string collectionId = null, BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(entities, nameof(entities));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = entities.ToRequestContent();
            Response response = await BulkCreateOrUpdateAsync(content, collectionId, businessAttributeUpdateBehavior?.ToString(), context).ConfigureAwait(false);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// Create or update entities in bulk.
        /// Existing entity is matched using its unique
        /// guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array
        /// of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
        /// array&lt;map&lt;string, int&gt;&gt;.
        /// For each contact type, the maximum number of contacts
        /// is 20.
        /// </summary>
        /// <param name="entities"> An array of entities to create or update. </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entities"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkCreateOrUpdate(AtlasEntitiesWithExtInfo,string,BusinessAttributeUpdateBehavior?,CancellationToken)']/*" />
        public virtual Response<EntityMutationResponse> BulkCreateOrUpdate(AtlasEntitiesWithExtInfo entities, string collectionId = null, BusinessAttributeUpdateBehavior? businessAttributeUpdateBehavior = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(entities, nameof(entities));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = entities.ToRequestContent();
            Response response = BulkCreateOrUpdate(content, collectionId, businessAttributeUpdateBehavior?.ToString(), context);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create or update entities in bulk.
        /// Existing entity is matched using its unique
        /// guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array
        /// of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
        /// array&lt;map&lt;string, int&gt;&gt;.
        /// For each contact type, the maximum number of contacts
        /// is 20.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="BulkCreateOrUpdateAsync(AtlasEntitiesWithExtInfo,string,BusinessAttributeUpdateBehavior?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities. Allowed values: "ignore" | "replace" | "merge"
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkCreateOrUpdateAsync(RequestContent,string,string,RequestContext)']/*" />
        public virtual async Task<Response> BulkCreateOrUpdateAsync(RequestContent content, string collectionId = null, string businessAttributeUpdateBehavior = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.BulkCreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBulkCreateOrUpdateRequest(content, collectionId, businessAttributeUpdateBehavior, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create or update entities in bulk.
        /// Existing entity is matched using its unique
        /// guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array
        /// of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;,
        /// array&lt;map&lt;string, int&gt;&gt;.
        /// For each contact type, the maximum number of contacts
        /// is 20.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="BulkCreateOrUpdate(AtlasEntitiesWithExtInfo,string,BusinessAttributeUpdateBehavior?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="collectionId">
        /// The collection where entities will be moved to. Only specify a value if you
        /// need to move an entity to another collection.
        /// </param>
        /// <param name="businessAttributeUpdateBehavior">
        /// Used to define the update behavior for business attributes when updating
        /// entities. Allowed values: "ignore" | "replace" | "merge"
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkCreateOrUpdate(RequestContent,string,string,RequestContext)']/*" />
        public virtual Response BulkCreateOrUpdate(RequestContent content, string collectionId = null, string businessAttributeUpdateBehavior = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.BulkCreateOrUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBulkCreateOrUpdateRequest(content, collectionId, businessAttributeUpdateBehavior, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a list of entities in bulk identified by their GUIDs or unique
        /// attributes.
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkDeleteAsync(IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<EntityMutationResponse>> BulkDeleteAsync(IEnumerable<string> guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await BulkDeleteAsync(guid, context).ConfigureAwait(false);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// Delete a list of entities in bulk identified by their GUIDs or unique
        /// attributes.
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkDelete(IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<EntityMutationResponse> BulkDelete(IEnumerable<string> guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = BulkDelete(guid, context);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Delete a list of entities in bulk identified by their GUIDs or unique
        /// attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="BulkDeleteAsync(IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to delete. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkDeleteAsync(IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> BulkDeleteAsync(IEnumerable<string> guid, RequestContext context)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.BulkDelete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBulkDeleteRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a list of entities in bulk identified by their GUIDs or unique
        /// attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="BulkDelete(IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> An array of GUIDs of entities to delete. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkDelete(IEnumerable{string},RequestContext)']/*" />
        public virtual Response BulkDelete(IEnumerable<string> guid, RequestContext context)
        {
            Argument.AssertNotNull(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.BulkDelete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBulkDeleteRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Associate a classification to multiple entities in bulk. </summary>
        /// <param name="request"> The request to associate a classification to multiple entities. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="request"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassificationAsync(ClassificationAssociateRequest,CancellationToken)']/*" />
        public virtual async Task<Response> AddClassificationAsync(ClassificationAssociateRequest request, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(request, nameof(request));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = request.ToRequestContent();
            Response response = await AddClassificationAsync(content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Associate a classification to multiple entities in bulk. </summary>
        /// <param name="request"> The request to associate a classification to multiple entities. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="request"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassification(ClassificationAssociateRequest,CancellationToken)']/*" />
        public virtual Response AddClassification(ClassificationAssociateRequest request, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(request, nameof(request));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = request.ToRequestContent();
            Response response = AddClassification(content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Associate a classification to multiple entities in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddClassificationAsync(ClassificationAssociateRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassificationAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> AddClassificationAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddClassificationRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Associate a classification to multiple entities in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddClassification(ClassificationAssociateRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassification(RequestContent,RequestContext)']/*" />
        public virtual Response AddClassification(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddClassificationRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get complete definition of an entity given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntityAsync(string,bool?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasEntityWithExtInfo>> GetEntityAsync(string guid, bool? minExtInfo = null, bool? ignoreRelationships = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetEntityAsync(guid, minExtInfo, ignoreRelationships, context).ConfigureAwait(false);
            return Response.FromValue(AtlasEntityWithExtInfo.FromResponse(response), response);
        }

        /// <summary> Get complete definition of an entity given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntity(string,bool?,bool?,CancellationToken)']/*" />
        public virtual Response<AtlasEntityWithExtInfo> GetEntity(string guid, bool? minExtInfo = null, bool? ignoreRelationships = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetEntity(guid, minExtInfo, ignoreRelationships, context);
            return Response.FromValue(AtlasEntityWithExtInfo.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get complete definition of an entity given its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetEntityAsync(string,bool?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntityAsync(string,bool?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetEntityAsync(string guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetEntity");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityRequest(guid, minExtInfo, ignoreRelationships, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get complete definition of an entity given its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetEntity(string,bool?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntity(string,bool?,bool?,RequestContext)']/*" />
        public virtual Response GetEntity(string guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetEntity");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityRequest(guid, minExtInfo, ignoreRelationships, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update entity partially - create or update entity attribute identified by its
        /// GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not
        /// support updating complex types like arrays, and maps.
        /// Null updates are not
        /// possible.
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="body"> The value of the attribute. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='PartialUpdateAttributeByGuidAsync(string,string,BinaryData,CancellationToken)']/*" />
        public virtual async Task<Response<EntityMutationResponse>> PartialUpdateAttributeByGuidAsync(string guid, string name, BinaryData body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromObject(body);
            Response response = await PartialUpdateAttributeByGuidAsync(guid, name, content, context).ConfigureAwait(false);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// Update entity partially - create or update entity attribute identified by its
        /// GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not
        /// support updating complex types like arrays, and maps.
        /// Null updates are not
        /// possible.
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="body"> The value of the attribute. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='PartialUpdateAttributeByGuid(string,string,BinaryData,CancellationToken)']/*" />
        public virtual Response<EntityMutationResponse> PartialUpdateAttributeByGuid(string guid, string name, BinaryData body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromObject(body);
            Response response = PartialUpdateAttributeByGuid(guid, name, content, context);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Update entity partially - create or update entity attribute identified by its
        /// GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not
        /// support updating complex types like arrays, and maps.
        /// Null updates are not
        /// possible.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateAttributeByGuidAsync(string,string,BinaryData,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='PartialUpdateAttributeByGuidAsync(string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> PartialUpdateAttributeByGuidAsync(string guid, string name, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.PartialUpdateAttributeByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateAttributeByGuidRequest(guid, name, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update entity partially - create or update entity attribute identified by its
        /// GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not
        /// support updating complex types like arrays, and maps.
        /// Null updates are not
        /// possible.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateAttributeByGuid(string,string,BinaryData,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='PartialUpdateAttributeByGuid(string,string,RequestContent,RequestContext)']/*" />
        public virtual Response PartialUpdateAttributeByGuid(string guid, string name, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.PartialUpdateAttributeByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateAttributeByGuidRequest(guid, name, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete an entity identified by its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='DeleteAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<EntityMutationResponse>> DeleteAsync(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await DeleteAsync(guid, context).ConfigureAwait(false);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary> Delete an entity identified by its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='Delete(string,CancellationToken)']/*" />
        public virtual Response<EntityMutationResponse> Delete(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = Delete(guid, context);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Delete an entity identified by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='DeleteAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteAsync(string guid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete an entity identified by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Delete(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='Delete(string,RequestContext)']/*" />
        public virtual Response Delete(string guid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get classification for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetClassificationAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasClassification>> GetClassificationAsync(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetClassificationAsync(guid, classificationName, context).ConfigureAwait(false);
            return Response.FromValue(AtlasClassification.FromResponse(response), response);
        }

        /// <summary> Get classification for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetClassification(string,string,CancellationToken)']/*" />
        public virtual Response<AtlasClassification> GetClassification(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetClassification(guid, classificationName, context);
            return Response.FromValue(AtlasClassification.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get classification for a given entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetClassificationAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetClassificationAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetClassificationAsync(string guid, string classificationName, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationRequest(guid, classificationName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get classification for a given entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetClassification(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetClassification(string,string,RequestContext)']/*" />
        public virtual Response GetClassification(string guid, string classificationName, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationRequest(guid, classificationName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a given classification from an existing entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveClassificationAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> RemoveClassificationAsync(string guid, string classificationName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveClassificationRequest(guid, classificationName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a given classification from an existing entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveClassification(string,string,RequestContext)']/*" />
        public virtual Response RemoveClassification(string guid, string classificationName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveClassification");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveClassificationRequest(guid, classificationName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List classifications for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetClassificationsAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasClassifications>> GetClassificationsAsync(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetClassificationsAsync(guid, context).ConfigureAwait(false);
            return Response.FromValue(AtlasClassifications.FromResponse(response), response);
        }

        /// <summary> List classifications for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetClassifications(string,CancellationToken)']/*" />
        public virtual Response<AtlasClassifications> GetClassifications(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetClassifications(guid, context);
            return Response.FromValue(AtlasClassifications.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] List classifications for a given entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetClassificationsAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetClassificationsAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetClassificationsAsync(string guid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetClassifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationsRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List classifications for a given entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetClassifications(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetClassifications(string,RequestContext)']/*" />
        public virtual Response GetClassifications(string guid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetClassifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationsRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add classifications to an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classifications"> An array of classifications to be added. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classifications"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassificationsAsync(string,IEnumerable{AtlasClassification},CancellationToken)']/*" />
        public virtual async Task<Response> AddClassificationsAsync(string guid, IEnumerable<AtlasClassification> classifications, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(classifications, nameof(classifications));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(classifications);
            Response response = await AddClassificationsAsync(guid, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Add classifications to an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classifications"> An array of classifications to be added. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classifications"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassifications(string,IEnumerable{AtlasClassification},CancellationToken)']/*" />
        public virtual Response AddClassifications(string guid, IEnumerable<AtlasClassification> classifications, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(classifications, nameof(classifications));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(classifications);
            Response response = AddClassifications(guid, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Add classifications to an existing entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddClassificationsAsync(string,IEnumerable{AtlasClassification},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassificationsAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> AddClassificationsAsync(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddClassifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddClassificationsRequest(guid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add classifications to an existing entity represented by a GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddClassifications(string,IEnumerable{AtlasClassification},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassifications(string,RequestContent,RequestContext)']/*" />
        public virtual Response AddClassifications(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddClassifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddClassificationsRequest(guid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update classifications to an existing entity represented by a guid. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classifications"> An array of classifications to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classifications"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='UpdateClassificationsAsync(string,IEnumerable{AtlasClassification},CancellationToken)']/*" />
        public virtual async Task<Response> UpdateClassificationsAsync(string guid, IEnumerable<AtlasClassification> classifications, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(classifications, nameof(classifications));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(classifications);
            Response response = await UpdateClassificationsAsync(guid, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Update classifications to an existing entity represented by a guid. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classifications"> An array of classifications to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classifications"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='UpdateClassifications(string,IEnumerable{AtlasClassification},CancellationToken)']/*" />
        public virtual Response UpdateClassifications(string guid, IEnumerable<AtlasClassification> classifications, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(classifications, nameof(classifications));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(classifications);
            Response response = UpdateClassifications(guid, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Update classifications to an existing entity represented by a guid.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateClassificationsAsync(string,IEnumerable{AtlasClassification},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='UpdateClassificationsAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateClassificationsAsync(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.UpdateClassifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateClassificationsRequest(guid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update classifications to an existing entity represented by a guid.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateClassifications(string,IEnumerable{AtlasClassification},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='UpdateClassifications(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateClassifications(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.UpdateClassifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateClassificationsRequest(guid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get complete definition of an entity given its type and unique attribute.
        ///
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The
        /// attrName and attrValue should be unique across entities, eg.
        /// qualifiedName.
        ///
        /// The REST request would look something like this:
        /// GET
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetByUniqueAttributesAsync(string,bool?,bool?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasEntityWithExtInfo>> GetByUniqueAttributesAsync(string typeName, bool? minExtInfo = null, bool? ignoreRelationships = null, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetByUniqueAttributesAsync(typeName, minExtInfo, ignoreRelationships, attr, context).ConfigureAwait(false);
            return Response.FromValue(AtlasEntityWithExtInfo.FromResponse(response), response);
        }

        /// <summary>
        /// Get complete definition of an entity given its type and unique attribute.
        ///
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The
        /// attrName and attrValue should be unique across entities, eg.
        /// qualifiedName.
        ///
        /// The REST request would look something like this:
        /// GET
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetByUniqueAttributes(string,bool?,bool?,string,CancellationToken)']/*" />
        public virtual Response<AtlasEntityWithExtInfo> GetByUniqueAttributes(string typeName, bool? minExtInfo = null, bool? ignoreRelationships = null, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetByUniqueAttributes(typeName, minExtInfo, ignoreRelationships, attr, context);
            return Response.FromValue(AtlasEntityWithExtInfo.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get complete definition of an entity given its type and unique attribute.
        ///
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The
        /// attrName and attrValue should be unique across entities, eg.
        /// qualifiedName.
        ///
        /// The REST request would look something like this:
        /// GET
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetByUniqueAttributesAsync(string,bool?,bool?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetByUniqueAttributesAsync(string,bool?,bool?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetByUniqueAttributesAsync(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attr, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetByUniqueAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get complete definition of an entity given its type and unique attribute.
        ///
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The
        /// attrName and attrValue should be unique across entities, eg.
        /// qualifiedName.
        ///
        /// The REST request would look something like this:
        /// GET
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetByUniqueAttributes(string,bool?,bool?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetByUniqueAttributes(string,bool?,bool?,string,RequestContext)']/*" />
        public virtual Response GetByUniqueAttributes(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attr, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetByUniqueAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update entity partially - Allow a subset of attributes to be updated on an
        /// entity which is identified by its type and unique attribute eg:
        /// Referenceable.qualifiedName. Null updates are not possible.
        ///
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        ///
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this:
        /// PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasEntityWithExtInfo"> Atlas entity with extended information. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasEntityWithExtInfo"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='PartialUpdateByUniqueAttributesAsync(string,AtlasEntityWithExtInfo,string,CancellationToken)']/*" />
        public virtual async Task<Response<EntityMutationResponse>> PartialUpdateByUniqueAttributesAsync(string typeName, AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(atlasEntityWithExtInfo, nameof(atlasEntityWithExtInfo));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = atlasEntityWithExtInfo.ToRequestContent();
            Response response = await PartialUpdateByUniqueAttributesAsync(typeName, content, attr, context).ConfigureAwait(false);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// Update entity partially - Allow a subset of attributes to be updated on an
        /// entity which is identified by its type and unique attribute eg:
        /// Referenceable.qualifiedName. Null updates are not possible.
        ///
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        ///
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this:
        /// PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasEntityWithExtInfo"> Atlas entity with extended information. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasEntityWithExtInfo"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='PartialUpdateByUniqueAttributes(string,AtlasEntityWithExtInfo,string,CancellationToken)']/*" />
        public virtual Response<EntityMutationResponse> PartialUpdateByUniqueAttributes(string typeName, AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(atlasEntityWithExtInfo, nameof(atlasEntityWithExtInfo));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = atlasEntityWithExtInfo.ToRequestContent();
            Response response = PartialUpdateByUniqueAttributes(typeName, content, attr, context);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Update entity partially - Allow a subset of attributes to be updated on an
        /// entity which is identified by its type and unique attribute eg:
        /// Referenceable.qualifiedName. Null updates are not possible.
        ///
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        ///
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this:
        /// PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateByUniqueAttributesAsync(string,AtlasEntityWithExtInfo,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='PartialUpdateByUniqueAttributesAsync(string,RequestContent,string,RequestContext)']/*" />
        public virtual async Task<Response> PartialUpdateByUniqueAttributesAsync(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.PartialUpdateByUniqueAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateByUniqueAttributesRequest(typeName, content, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update entity partially - Allow a subset of attributes to be updated on an
        /// entity which is identified by its type and unique attribute eg:
        /// Referenceable.qualifiedName. Null updates are not possible.
        ///
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        ///
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this:
        /// PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateByUniqueAttributes(string,AtlasEntityWithExtInfo,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='PartialUpdateByUniqueAttributes(string,RequestContent,string,RequestContext)']/*" />
        public virtual Response PartialUpdateByUniqueAttributes(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.PartialUpdateByUniqueAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateByUniqueAttributesRequest(typeName, content, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete an entity identified by its type and unique attributes.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this:
        /// DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='DeleteByUniqueAttributeAsync(string,string,CancellationToken)']/*" />
        public virtual async Task<Response<EntityMutationResponse>> DeleteByUniqueAttributeAsync(string typeName, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await DeleteByUniqueAttributeAsync(typeName, attr, context).ConfigureAwait(false);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// Delete an entity identified by its type and unique attributes.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this:
        /// DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='DeleteByUniqueAttribute(string,string,CancellationToken)']/*" />
        public virtual Response<EntityMutationResponse> DeleteByUniqueAttribute(string typeName, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = DeleteByUniqueAttribute(typeName, attr, context);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Delete an entity identified by its type and unique attributes.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this:
        /// DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteByUniqueAttributeAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='DeleteByUniqueAttributeAsync(string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteByUniqueAttributeAsync(string typeName, string attr, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using var scope = ClientDiagnostics.CreateScope("Entity.DeleteByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteByUniqueAttributeRequest(typeName, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete an entity identified by its type and unique attributes.
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this:
        /// DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteByUniqueAttribute(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='DeleteByUniqueAttribute(string,string,RequestContext)']/*" />
        public virtual Response DeleteByUniqueAttribute(string typeName, string attr, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using var scope = ClientDiagnostics.CreateScope("Entity.DeleteByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteByUniqueAttributeRequest(typeName, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a given classification from an entity identified by its type and unique
        /// attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveClassificationByUniqueAttributeAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> RemoveClassificationByUniqueAttributeAsync(string typeName, string classificationName, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveClassificationByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveClassificationByUniqueAttributeRequest(typeName, classificationName, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a given classification from an entity identified by its type and unique
        /// attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveClassificationByUniqueAttribute(string,string,string,RequestContext)']/*" />
        public virtual Response RemoveClassificationByUniqueAttribute(string typeName, string classificationName, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNullOrEmpty(classificationName, nameof(classificationName));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveClassificationByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveClassificationByUniqueAttributeRequest(typeName, classificationName, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add classification to the entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasClassificationArray"> An array of classification to be added. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasClassificationArray"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassificationsByUniqueAttributeAsync(string,IEnumerable{AtlasClassification},string,CancellationToken)']/*" />
        public virtual async Task<Response> AddClassificationsByUniqueAttributeAsync(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(atlasClassificationArray, nameof(atlasClassificationArray));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(atlasClassificationArray);
            Response response = await AddClassificationsByUniqueAttributeAsync(typeName, content, attr, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Add classification to the entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasClassificationArray"> An array of classification to be added. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasClassificationArray"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassificationsByUniqueAttribute(string,IEnumerable{AtlasClassification},string,CancellationToken)']/*" />
        public virtual Response AddClassificationsByUniqueAttribute(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(atlasClassificationArray, nameof(atlasClassificationArray));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(atlasClassificationArray);
            Response response = AddClassificationsByUniqueAttribute(typeName, content, attr, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Add classification to the entity identified by its type and unique attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddClassificationsByUniqueAttributeAsync(string,IEnumerable{AtlasClassification},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassificationsByUniqueAttributeAsync(string,RequestContent,string,RequestContext)']/*" />
        public virtual async Task<Response> AddClassificationsByUniqueAttributeAsync(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddClassificationsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddClassificationsByUniqueAttributeRequest(typeName, content, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add classification to the entity identified by its type and unique attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddClassificationsByUniqueAttribute(string,IEnumerable{AtlasClassification},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddClassificationsByUniqueAttribute(string,RequestContent,string,RequestContext)']/*" />
        public virtual Response AddClassificationsByUniqueAttribute(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddClassificationsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddClassificationsByUniqueAttributeRequest(typeName, content, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update classification on an entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasClassificationArray"> An array of classification to be updated. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasClassificationArray"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='UpdateClassificationsByUniqueAttributeAsync(string,IEnumerable{AtlasClassification},string,CancellationToken)']/*" />
        public virtual async Task<Response> UpdateClassificationsByUniqueAttributeAsync(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(atlasClassificationArray, nameof(atlasClassificationArray));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(atlasClassificationArray);
            Response response = await UpdateClassificationsByUniqueAttributeAsync(typeName, content, attr, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Update classification on an entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasClassificationArray"> An array of classification to be updated. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasClassificationArray"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='UpdateClassificationsByUniqueAttribute(string,IEnumerable{AtlasClassification},string,CancellationToken)']/*" />
        public virtual Response UpdateClassificationsByUniqueAttribute(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(atlasClassificationArray, nameof(atlasClassificationArray));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(atlasClassificationArray);
            Response response = UpdateClassificationsByUniqueAttribute(typeName, content, attr, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Update classification on an entity identified by its type and unique attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateClassificationsByUniqueAttributeAsync(string,IEnumerable{AtlasClassification},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='UpdateClassificationsByUniqueAttributeAsync(string,RequestContent,string,RequestContext)']/*" />
        public virtual async Task<Response> UpdateClassificationsByUniqueAttributeAsync(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.UpdateClassificationsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateClassificationsByUniqueAttributeRequest(typeName, content, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update classification on an entity identified by its type and unique attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateClassificationsByUniqueAttribute(string,IEnumerable{AtlasClassification},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='UpdateClassificationsByUniqueAttribute(string,RequestContent,string,RequestContext)']/*" />
        public virtual Response UpdateClassificationsByUniqueAttribute(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.UpdateClassificationsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateClassificationsByUniqueAttributeRequest(typeName, content, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Set classifications on entities in bulk. </summary>
        /// <param name="entityHeaders"> Atlas entity headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entityHeaders"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkSetClassificationsAsync(AtlasEntityHeaders,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<string>>> BulkSetClassificationsAsync(AtlasEntityHeaders entityHeaders, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(entityHeaders, nameof(entityHeaders));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = entityHeaders.ToRequestContent();
            Response response = await BulkSetClassificationsAsync(content, context).ConfigureAwait(false);
            IReadOnlyList<string> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<string> array = new List<string>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(item.GetString());
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Set classifications on entities in bulk. </summary>
        /// <param name="entityHeaders"> Atlas entity headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entityHeaders"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkSetClassifications(AtlasEntityHeaders,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<string>> BulkSetClassifications(AtlasEntityHeaders entityHeaders, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(entityHeaders, nameof(entityHeaders));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = entityHeaders.ToRequestContent();
            Response response = BulkSetClassifications(content, context);
            IReadOnlyList<string> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<string> array = new List<string>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(item.GetString());
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Set classifications on entities in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="BulkSetClassificationsAsync(AtlasEntityHeaders,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkSetClassificationsAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> BulkSetClassificationsAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.BulkSetClassifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBulkSetClassificationsRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Set classifications on entities in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="BulkSetClassifications(AtlasEntityHeaders,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='BulkSetClassifications(RequestContent,RequestContext)']/*" />
        public virtual Response BulkSetClassifications(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.BulkSetClassifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBulkSetClassificationsRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Bulk API to retrieve list of entities identified by its unique attributes.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following
        /// format
        ///
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        ///
        /// NOTE:
        /// The attrName should be an unique attribute for the given entity-type.
        /// The REST
        /// request would look something like this
        ///
        /// GET
        /// /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        ///
        /// Note:
        /// at least one unique attribute must be provided.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName">
        /// Qualified name of an entity. E.g. to find 2 entities you can set
        /// attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
        /// example. qualifiedName can be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntitiesByUniqueAttributesAsync(string,bool?,bool?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasEntitiesWithExtInfo>> GetEntitiesByUniqueAttributesAsync(string typeName, bool? minExtInfo = null, bool? ignoreRelationships = null, string attrNQualifiedName = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetEntitiesByUniqueAttributesAsync(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, context).ConfigureAwait(false);
            return Response.FromValue(AtlasEntitiesWithExtInfo.FromResponse(response), response);
        }

        /// <summary>
        /// Bulk API to retrieve list of entities identified by its unique attributes.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following
        /// format
        ///
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        ///
        /// NOTE:
        /// The attrName should be an unique attribute for the given entity-type.
        /// The REST
        /// request would look something like this
        ///
        /// GET
        /// /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        ///
        /// Note:
        /// at least one unique attribute must be provided.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName">
        /// Qualified name of an entity. E.g. to find 2 entities you can set
        /// attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
        /// example. qualifiedName can be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntitiesByUniqueAttributes(string,bool?,bool?,string,CancellationToken)']/*" />
        public virtual Response<AtlasEntitiesWithExtInfo> GetEntitiesByUniqueAttributes(string typeName, bool? minExtInfo = null, bool? ignoreRelationships = null, string attrNQualifiedName = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetEntitiesByUniqueAttributes(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, context);
            return Response.FromValue(AtlasEntitiesWithExtInfo.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Bulk API to retrieve list of entities identified by its unique attributes.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following
        /// format
        ///
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        ///
        /// NOTE:
        /// The attrName should be an unique attribute for the given entity-type.
        /// The REST
        /// request would look something like this
        ///
        /// GET
        /// /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        ///
        /// Note:
        /// at least one unique attribute must be provided.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetEntitiesByUniqueAttributesAsync(string,bool?,bool?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName">
        /// Qualified name of an entity. E.g. to find 2 entities you can set
        /// attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
        /// example. qualifiedName can be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntitiesByUniqueAttributesAsync(string,bool?,bool?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetEntitiesByUniqueAttributesAsync(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrNQualifiedName, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetEntitiesByUniqueAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntitiesByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Bulk API to retrieve list of entities identified by its unique attributes.
        /// In
        /// addition to the typeName path parameter, attribute key-value pair(s) can be
        /// provided in the following
        /// format
        ///
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        ///
        /// NOTE:
        /// The attrName should be an unique attribute for the given entity-type.
        /// The REST
        /// request would look something like this
        ///
        /// GET
        /// /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        ///
        /// Note:
        /// at least one unique attribute must be provided.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetEntitiesByUniqueAttributes(string,bool?,bool?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName">
        /// Qualified name of an entity. E.g. to find 2 entities you can set
        /// attrs_1:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. (This is only an
        /// example. qualifiedName can be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetEntitiesByUniqueAttributes(string,bool?,bool?,string,RequestContext)']/*" />
        public virtual Response GetEntitiesByUniqueAttributes(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrNQualifiedName, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetEntitiesByUniqueAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntitiesByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get entity header given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetHeaderAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasEntityHeader>> GetHeaderAsync(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetHeaderAsync(guid, context).ConfigureAwait(false);
            return Response.FromValue(AtlasEntityHeader.FromResponse(response), response);
        }

        /// <summary> Get entity header given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetHeader(string,CancellationToken)']/*" />
        public virtual Response<AtlasEntityHeader> GetHeader(string guid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetHeader(guid, context);
            return Response.FromValue(AtlasEntityHeader.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get entity header given its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetHeaderAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetHeaderAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetHeaderAsync(string guid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetHeader");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetHeaderRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get entity header given its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetHeader(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetHeader(string,RequestContext)']/*" />
        public virtual Response GetHeader(string guid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("Entity.GetHeader");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetHeaderRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Remove business metadata from an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="businessMetadata"> Business metadata payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="businessMetadata"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveBusinessMetadataAsync(string,IDictionary{string,IDictionary{string,BinaryData}},CancellationToken)']/*" />
        public virtual async Task<Response> RemoveBusinessMetadataAsync(string guid, IDictionary<string, IDictionary<string, BinaryData>> businessMetadata, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(businessMetadata, nameof(businessMetadata));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromDictionary(businessMetadata);
            Response response = await RemoveBusinessMetadataAsync(guid, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Remove business metadata from an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="businessMetadata"> Business metadata payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="businessMetadata"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveBusinessMetadata(string,IDictionary{string,IDictionary{string,BinaryData}},CancellationToken)']/*" />
        public virtual Response RemoveBusinessMetadata(string guid, IDictionary<string, IDictionary<string, BinaryData>> businessMetadata, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(businessMetadata, nameof(businessMetadata));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromDictionary(businessMetadata);
            Response response = RemoveBusinessMetadata(guid, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Remove business metadata from an entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveBusinessMetadataAsync(string,IDictionary{string,IDictionary{string,BinaryData}},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveBusinessMetadataAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> RemoveBusinessMetadataAsync(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveBusinessMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveBusinessMetadataRequest(guid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Remove business metadata from an entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveBusinessMetadata(string,IDictionary{string,IDictionary{string,BinaryData}},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveBusinessMetadata(string,RequestContent,RequestContext)']/*" />
        public virtual Response RemoveBusinessMetadata(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveBusinessMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveBusinessMetadataRequest(guid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add business metadata to an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="businessMetadata"> BusinessMetadata payload. </param>
        /// <param name="isOverwrite">
        /// Whether to overwrite the existing business metadata on the entity or not,
        /// default is false.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="businessMetadata"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddOrUpdateBusinessMetadataAsync(string,IDictionary{string,IDictionary{string,BinaryData}},bool?,CancellationToken)']/*" />
        public virtual async Task<Response> AddOrUpdateBusinessMetadataAsync(string guid, IDictionary<string, IDictionary<string, BinaryData>> businessMetadata, bool? isOverwrite = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(businessMetadata, nameof(businessMetadata));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromDictionary(businessMetadata);
            Response response = await AddOrUpdateBusinessMetadataAsync(guid, content, isOverwrite, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Add business metadata to an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="businessMetadata"> BusinessMetadata payload. </param>
        /// <param name="isOverwrite">
        /// Whether to overwrite the existing business metadata on the entity or not,
        /// default is false.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="businessMetadata"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddOrUpdateBusinessMetadata(string,IDictionary{string,IDictionary{string,BinaryData}},bool?,CancellationToken)']/*" />
        public virtual Response AddOrUpdateBusinessMetadata(string guid, IDictionary<string, IDictionary<string, BinaryData>> businessMetadata, bool? isOverwrite = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(businessMetadata, nameof(businessMetadata));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromDictionary(businessMetadata);
            Response response = AddOrUpdateBusinessMetadata(guid, content, isOverwrite, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Add business metadata to an entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddOrUpdateBusinessMetadataAsync(string,IDictionary{string,IDictionary{string,BinaryData}},bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="isOverwrite">
        /// Whether to overwrite the existing business metadata on the entity or not,
        /// default is false.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddOrUpdateBusinessMetadataAsync(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual async Task<Response> AddOrUpdateBusinessMetadataAsync(string guid, RequestContent content, bool? isOverwrite = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddOrUpdateBusinessMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddOrUpdateBusinessMetadataRequest(guid, content, isOverwrite, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add business metadata to an entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddOrUpdateBusinessMetadata(string,IDictionary{string,IDictionary{string,BinaryData}},bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="isOverwrite">
        /// Whether to overwrite the existing business metadata on the entity or not,
        /// default is false.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddOrUpdateBusinessMetadata(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual Response AddOrUpdateBusinessMetadata(string guid, RequestContent content, bool? isOverwrite = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddOrUpdateBusinessMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddOrUpdateBusinessMetadataRequest(guid, content, isOverwrite, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete business metadata attributes from an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="bmName"> BusinessMetadata name. </param>
        /// <param name="businessMetadataAttributes"> Business metadata attribute payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="bmName"/> or <paramref name="businessMetadataAttributes"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="bmName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveBusinessMetadataAttributesAsync(string,string,IDictionary{string,BinaryData},CancellationToken)']/*" />
        public virtual async Task<Response> RemoveBusinessMetadataAttributesAsync(string guid, string bmName, IDictionary<string, BinaryData> businessMetadataAttributes, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(bmName, nameof(bmName));
            Argument.AssertNotNull(businessMetadataAttributes, nameof(businessMetadataAttributes));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromDictionary(businessMetadataAttributes);
            Response response = await RemoveBusinessMetadataAttributesAsync(guid, bmName, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Delete business metadata attributes from an entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="bmName"> BusinessMetadata name. </param>
        /// <param name="businessMetadataAttributes"> Business metadata attribute payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="bmName"/> or <paramref name="businessMetadataAttributes"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="bmName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveBusinessMetadataAttributes(string,string,IDictionary{string,BinaryData},CancellationToken)']/*" />
        public virtual Response RemoveBusinessMetadataAttributes(string guid, string bmName, IDictionary<string, BinaryData> businessMetadataAttributes, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(bmName, nameof(bmName));
            Argument.AssertNotNull(businessMetadataAttributes, nameof(businessMetadataAttributes));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromDictionary(businessMetadataAttributes);
            Response response = RemoveBusinessMetadataAttributes(guid, bmName, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Delete business metadata attributes from an entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveBusinessMetadataAttributesAsync(string,string,IDictionary{string,BinaryData},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="bmName"> BusinessMetadata name. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="bmName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="bmName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveBusinessMetadataAttributesAsync(string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> RemoveBusinessMetadataAttributesAsync(string guid, string bmName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(bmName, nameof(bmName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveBusinessMetadataAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveBusinessMetadataAttributesRequest(guid, bmName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete business metadata attributes from an entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveBusinessMetadataAttributes(string,string,IDictionary{string,BinaryData},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="bmName"> BusinessMetadata name. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="bmName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="bmName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveBusinessMetadataAttributes(string,string,RequestContent,RequestContext)']/*" />
        public virtual Response RemoveBusinessMetadataAttributes(string guid, string bmName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(bmName, nameof(bmName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveBusinessMetadataAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveBusinessMetadataAttributesRequest(guid, bmName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add or update business metadata attributes. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="bmName"> BusinessMetadata name. </param>
        /// <param name="businessMetadataAttributes"> Business metadata attribute payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="bmName"/> or <paramref name="businessMetadataAttributes"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="bmName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddOrUpdateBusinessMetadataAttributesAsync(string,string,IDictionary{string,BinaryData},CancellationToken)']/*" />
        public virtual async Task<Response> AddOrUpdateBusinessMetadataAttributesAsync(string guid, string bmName, IDictionary<string, BinaryData> businessMetadataAttributes, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(bmName, nameof(bmName));
            Argument.AssertNotNull(businessMetadataAttributes, nameof(businessMetadataAttributes));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromDictionary(businessMetadataAttributes);
            Response response = await AddOrUpdateBusinessMetadataAttributesAsync(guid, bmName, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Add or update business metadata attributes. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="bmName"> BusinessMetadata name. </param>
        /// <param name="businessMetadataAttributes"> Business metadata attribute payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="bmName"/> or <paramref name="businessMetadataAttributes"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="bmName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddOrUpdateBusinessMetadataAttributes(string,string,IDictionary{string,BinaryData},CancellationToken)']/*" />
        public virtual Response AddOrUpdateBusinessMetadataAttributes(string guid, string bmName, IDictionary<string, BinaryData> businessMetadataAttributes, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(bmName, nameof(bmName));
            Argument.AssertNotNull(businessMetadataAttributes, nameof(businessMetadataAttributes));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromDictionary(businessMetadataAttributes);
            Response response = AddOrUpdateBusinessMetadataAttributes(guid, bmName, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Add or update business metadata attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddOrUpdateBusinessMetadataAttributesAsync(string,string,IDictionary{string,BinaryData},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="bmName"> BusinessMetadata name. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="bmName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="bmName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddOrUpdateBusinessMetadataAttributesAsync(string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> AddOrUpdateBusinessMetadataAttributesAsync(string guid, string bmName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(bmName, nameof(bmName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddOrUpdateBusinessMetadataAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddOrUpdateBusinessMetadataAttributesRequest(guid, bmName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add or update business metadata attributes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddOrUpdateBusinessMetadataAttributes(string,string,IDictionary{string,BinaryData},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="bmName"> BusinessMetadata name. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="bmName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> or <paramref name="bmName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddOrUpdateBusinessMetadataAttributes(string,string,RequestContent,RequestContext)']/*" />
        public virtual Response AddOrUpdateBusinessMetadataAttributes(string guid, string bmName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNullOrEmpty(bmName, nameof(bmName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddOrUpdateBusinessMetadataAttributes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddOrUpdateBusinessMetadataAttributesRequest(guid, bmName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the sample Template for uploading/creating bulk BusinessMetaData. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetSampleBusinessMetadataTemplateAsync(CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetSampleBusinessMetadataTemplateAsync(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetSampleBusinessMetadataTemplateAsync(context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Get the sample Template for uploading/creating bulk BusinessMetaData. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetSampleBusinessMetadataTemplate(CancellationToken)']/*" />
        public virtual Response<BinaryData> GetSampleBusinessMetadataTemplate(CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetSampleBusinessMetadataTemplate(context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Get the sample Template for uploading/creating bulk BusinessMetaData
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetSampleBusinessMetadataTemplateAsync(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetSampleBusinessMetadataTemplateAsync(RequestContext)']/*" />
        public virtual async Task<Response> GetSampleBusinessMetadataTemplateAsync(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("Entity.GetSampleBusinessMetadataTemplate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSampleBusinessMetadataTemplateRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the sample Template for uploading/creating bulk BusinessMetaData
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetSampleBusinessMetadataTemplate(CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='GetSampleBusinessMetadataTemplate(RequestContext)']/*" />
        public virtual Response GetSampleBusinessMetadataTemplate(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("Entity.GetSampleBusinessMetadataTemplate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSampleBusinessMetadataTemplateRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upload the file for creating Business Metadata in BULK. </summary>
        /// <param name="uploadedInputStream"> InputStream of file. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadedInputStream"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='ImportBusinessMetadataAsync(BinaryData,CancellationToken)']/*" />
        public virtual async Task<Response<BulkImportResponse>> ImportBusinessMetadataAsync(BinaryData uploadedInputStream, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(uploadedInputStream, nameof(uploadedInputStream));

            RequestContext context = FromCancellationToken(cancellationToken);
            ImportBusinessMetadataRequest importBusinessMetadataRequest = new ImportBusinessMetadataRequest(uploadedInputStream);
            Response response = await ImportBusinessMetadataAsync(importBusinessMetadataRequest.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(BulkImportResponse.FromResponse(response), response);
        }

        /// <summary> Upload the file for creating Business Metadata in BULK. </summary>
        /// <param name="uploadedInputStream"> InputStream of file. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uploadedInputStream"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='ImportBusinessMetadata(BinaryData,CancellationToken)']/*" />
        public virtual Response<BulkImportResponse> ImportBusinessMetadata(BinaryData uploadedInputStream, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(uploadedInputStream, nameof(uploadedInputStream));

            RequestContext context = FromCancellationToken(cancellationToken);
            ImportBusinessMetadataRequest importBusinessMetadataRequest = new ImportBusinessMetadataRequest(uploadedInputStream);
            Response response = ImportBusinessMetadata(importBusinessMetadataRequest.ToRequestContent(), context);
            return Response.FromValue(BulkImportResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Upload the file for creating Business Metadata in BULK
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ImportBusinessMetadataAsync(BinaryData,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='ImportBusinessMetadataAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> ImportBusinessMetadataAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.ImportBusinessMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportBusinessMetadataRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Upload the file for creating Business Metadata in BULK
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ImportBusinessMetadata(BinaryData,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='ImportBusinessMetadata(RequestContent,RequestContext)']/*" />
        public virtual Response ImportBusinessMetadata(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.ImportBusinessMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportBusinessMetadataRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete given labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be deleted. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveLabelsAsync(string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response> RemoveLabelsAsync(string guid, IEnumerable<string> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = await RemoveLabelsAsync(guid, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Delete given labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be deleted. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveLabels(string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response RemoveLabels(string guid, IEnumerable<string> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = RemoveLabels(guid, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Delete given labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveLabelsAsync(string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveLabelsAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> RemoveLabelsAsync(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveLabels");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveLabelsRequest(guid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete given labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveLabels(string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveLabels(string,RequestContent,RequestContext)']/*" />
        public virtual Response RemoveLabels(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveLabels");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveLabelsRequest(guid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Set labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be set to the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='SetLabelsAsync(string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response> SetLabelsAsync(string guid, IEnumerable<string> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = await SetLabelsAsync(guid, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Set labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be set to the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='SetLabels(string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response SetLabels(string guid, IEnumerable<string> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = SetLabels(guid, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Set labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SetLabelsAsync(string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='SetLabelsAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> SetLabelsAsync(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.SetLabels");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSetLabelsRequest(guid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Set labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SetLabels(string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='SetLabels(string,RequestContent,RequestContext)']/*" />
        public virtual Response SetLabels(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.SetLabels");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSetLabelsRequest(guid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add given labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be added. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddLabelAsync(string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response> AddLabelAsync(string guid, IEnumerable<string> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = await AddLabelAsync(guid, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Add given labels to a given entity. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="body"> set of labels to be added. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddLabel(string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response AddLabel(string guid, IEnumerable<string> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = AddLabel(guid, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Add given labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLabelAsync(string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddLabelAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> AddLabelAsync(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddLabel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLabelRequest(guid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add given labels to a given entity.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLabel(string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddLabel(string,RequestContent,RequestContext)']/*" />
        public virtual Response AddLabel(string guid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddLabel");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLabelRequest(guid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete given labels to a given entity identified by its type and unique
        /// attribute.
        ///
        /// If labels is null/empty, no labels will be removed.
        ///
        /// If any labels
        /// in labels set are non-existing labels, they will be ignored, only existing
        /// labels will be removed. In addition to the typeName path parameter, attribute
        /// key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
        /// across entities, eg. qualifiedName. The REST request would look something like
        /// this: DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be deleted. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveLabelsByUniqueAttributeAsync(string,IEnumerable{string},string,CancellationToken)']/*" />
        public virtual async Task<Response> RemoveLabelsByUniqueAttributeAsync(string typeName, IEnumerable<string> body, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = await RemoveLabelsByUniqueAttributeAsync(typeName, content, attr, context).ConfigureAwait(false);
            return response;
        }

        /// <summary>
        /// Delete given labels to a given entity identified by its type and unique
        /// attribute.
        ///
        /// If labels is null/empty, no labels will be removed.
        ///
        /// If any labels
        /// in labels set are non-existing labels, they will be ignored, only existing
        /// labels will be removed. In addition to the typeName path parameter, attribute
        /// key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
        /// across entities, eg. qualifiedName. The REST request would look something like
        /// this: DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be deleted. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveLabelsByUniqueAttribute(string,IEnumerable{string},string,CancellationToken)']/*" />
        public virtual Response RemoveLabelsByUniqueAttribute(string typeName, IEnumerable<string> body, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = RemoveLabelsByUniqueAttribute(typeName, content, attr, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Delete given labels to a given entity identified by its type and unique
        /// attribute.
        ///
        /// If labels is null/empty, no labels will be removed.
        ///
        /// If any labels
        /// in labels set are non-existing labels, they will be ignored, only existing
        /// labels will be removed. In addition to the typeName path parameter, attribute
        /// key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
        /// across entities, eg. qualifiedName. The REST request would look something like
        /// this: DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveLabelsByUniqueAttributeAsync(string,IEnumerable{string},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveLabelsByUniqueAttributeAsync(string,RequestContent,string,RequestContext)']/*" />
        public virtual async Task<Response> RemoveLabelsByUniqueAttributeAsync(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveLabelsByUniqueAttributeRequest(typeName, content, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete given labels to a given entity identified by its type and unique
        /// attribute.
        ///
        /// If labels is null/empty, no labels will be removed.
        ///
        /// If any labels
        /// in labels set are non-existing labels, they will be ignored, only existing
        /// labels will be removed. In addition to the typeName path parameter, attribute
        /// key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;. NOTE: The attrName and attrValue should be unique
        /// across entities, eg. qualifiedName. The REST request would look something like
        /// this: DELETE
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveLabelsByUniqueAttribute(string,IEnumerable{string},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='RemoveLabelsByUniqueAttribute(string,RequestContent,string,RequestContext)']/*" />
        public virtual Response RemoveLabelsByUniqueAttribute(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.RemoveLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveLabelsByUniqueAttributeRequest(typeName, content, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Set labels to a given entity identified by its type and unique attributes.
        ///
        /// If
        /// labels is null/empty, existing labels will all be removed.
        ///
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this: POST
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be set. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='SetLabelsByUniqueAttributeAsync(string,IEnumerable{string},string,CancellationToken)']/*" />
        public virtual async Task<Response> SetLabelsByUniqueAttributeAsync(string typeName, IEnumerable<string> body, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = await SetLabelsByUniqueAttributeAsync(typeName, content, attr, context).ConfigureAwait(false);
            return response;
        }

        /// <summary>
        /// Set labels to a given entity identified by its type and unique attributes.
        ///
        /// If
        /// labels is null/empty, existing labels will all be removed.
        ///
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this: POST
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be set. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='SetLabelsByUniqueAttribute(string,IEnumerable{string},string,CancellationToken)']/*" />
        public virtual Response SetLabelsByUniqueAttribute(string typeName, IEnumerable<string> body, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = SetLabelsByUniqueAttribute(typeName, content, attr, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Set labels to a given entity identified by its type and unique attributes.
        ///
        /// If
        /// labels is null/empty, existing labels will all be removed.
        ///
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this: POST
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SetLabelsByUniqueAttributeAsync(string,IEnumerable{string},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='SetLabelsByUniqueAttributeAsync(string,RequestContent,string,RequestContext)']/*" />
        public virtual async Task<Response> SetLabelsByUniqueAttributeAsync(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.SetLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSetLabelsByUniqueAttributeRequest(typeName, content, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Set labels to a given entity identified by its type and unique attributes.
        ///
        /// If
        /// labels is null/empty, existing labels will all be removed.
        ///
        /// In addition to the
        /// typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this: POST
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SetLabelsByUniqueAttribute(string,IEnumerable{string},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='SetLabelsByUniqueAttribute(string,RequestContent,string,RequestContext)']/*" />
        public virtual Response SetLabelsByUniqueAttribute(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.SetLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSetLabelsByUniqueAttributeRequest(typeName, content, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add given labels to a given entity identified by its type and unique
        /// attributes.
        ///
        /// If labels is null/empty, no labels will be added.
        ///
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this: PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be added. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddLabelsByUniqueAttributeAsync(string,IEnumerable{string},string,CancellationToken)']/*" />
        public virtual async Task<Response> AddLabelsByUniqueAttributeAsync(string typeName, IEnumerable<string> body, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = await AddLabelsByUniqueAttributeAsync(typeName, content, attr, context).ConfigureAwait(false);
            return response;
        }

        /// <summary>
        /// Add given labels to a given entity identified by its type and unique
        /// attributes.
        ///
        /// If labels is null/empty, no labels will be added.
        ///
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this: PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="body"> set of labels to be added. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddLabelsByUniqueAttribute(string,IEnumerable{string},string,CancellationToken)']/*" />
        public virtual Response AddLabelsByUniqueAttribute(string typeName, IEnumerable<string> body, string attr = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(body);
            Response response = AddLabelsByUniqueAttribute(typeName, content, attr, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Add given labels to a given entity identified by its type and unique
        /// attributes.
        ///
        /// If labels is null/empty, no labels will be added.
        ///
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this: PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLabelsByUniqueAttributeAsync(string,IEnumerable{string},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddLabelsByUniqueAttributeAsync(string,RequestContent,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLabelsByUniqueAttributeAsync(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLabelsByUniqueAttributeRequest(typeName, content, attr, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add given labels to a given entity identified by its type and unique
        /// attributes.
        ///
        /// If labels is null/empty, no labels will be added.
        ///
        /// In addition to
        /// the typeName path parameter, attribute key-value pair(s) can be provided in the
        /// following format: attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        ///
        /// NOTE: The attrName and
        /// attrValue should be unique across entities, eg. qualifiedName.
        ///
        /// The REST
        /// request would look something like this: PUT
        /// /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLabelsByUniqueAttribute(string,IEnumerable{string},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="attr">
        /// The qualified name of the entity. (This is only an example. qualifiedName can
        /// be changed to other unique attributes)
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="typeName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='AddLabelsByUniqueAttribute(string,RequestContent,string,RequestContext)']/*" />
        public virtual Response AddLabelsByUniqueAttribute(string typeName, RequestContent content, string attr = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(typeName, nameof(typeName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.AddLabelsByUniqueAttribute");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLabelsByUniqueAttributeRequest(typeName, content, attr, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Move existing entities to the target collection. </summary>
        /// <param name="collectionId"> The collection where entities will be moved to. </param>
        /// <param name="moveEntitiesRequest"> Entity guids to be moved to target collection. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="moveEntitiesRequest"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='MoveEntitiesToCollectionAsync(string,MoveEntitiesRequest,CancellationToken)']/*" />
        public virtual async Task<Response<EntityMutationResponse>> MoveEntitiesToCollectionAsync(string collectionId, MoveEntitiesRequest moveEntitiesRequest, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(collectionId, nameof(collectionId));
            Argument.AssertNotNull(moveEntitiesRequest, nameof(moveEntitiesRequest));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = moveEntitiesRequest.ToRequestContent();
            Response response = await MoveEntitiesToCollectionAsync(collectionId, content, context).ConfigureAwait(false);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary> Move existing entities to the target collection. </summary>
        /// <param name="collectionId"> The collection where entities will be moved to. </param>
        /// <param name="moveEntitiesRequest"> Entity guids to be moved to target collection. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="moveEntitiesRequest"/> is null. </exception>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='MoveEntitiesToCollection(string,MoveEntitiesRequest,CancellationToken)']/*" />
        public virtual Response<EntityMutationResponse> MoveEntitiesToCollection(string collectionId, MoveEntitiesRequest moveEntitiesRequest, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(collectionId, nameof(collectionId));
            Argument.AssertNotNull(moveEntitiesRequest, nameof(moveEntitiesRequest));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = moveEntitiesRequest.ToRequestContent();
            Response response = MoveEntitiesToCollection(collectionId, content, context);
            return Response.FromValue(EntityMutationResponse.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Move existing entities to the target collection.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="MoveEntitiesToCollectionAsync(string,MoveEntitiesRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> The collection where entities will be moved to. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='MoveEntitiesToCollectionAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> MoveEntitiesToCollectionAsync(string collectionId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(collectionId, nameof(collectionId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.MoveEntitiesToCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMoveEntitiesToCollectionRequest(collectionId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Move existing entities to the target collection.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="MoveEntitiesToCollection(string,MoveEntitiesRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="collectionId"> The collection where entities will be moved to. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="collectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Entity.xml" path="doc/members/member[@name='MoveEntitiesToCollection(string,RequestContent,RequestContext)']/*" />
        public virtual Response MoveEntitiesToCollection(string collectionId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(collectionId, nameof(collectionId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Entity.MoveEntitiesToCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMoveEntitiesToCollectionRequest(collectionId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateOrUpdateRequest(RequestContent content, string businessAttributeUpdateBehavior, string collectionId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (businessAttributeUpdateBehavior != null)
            {
                uri.AppendQuery("businessAttributeUpdateBehavior", businessAttributeUpdateBehavior, true);
            }
            if (collectionId != null)
            {
                uri.AppendQuery("collectionId", collectionId, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetEntitiesByGuidsRequest(IEnumerable<string> guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk", false);
            if (guid != null && Optional.IsCollectionDefined(guid))
            {
                foreach (var param in guid)
                {
                    uri.AppendQuery("guid", param, true);
                }
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            if (minExtInfo != null)
            {
                uri.AppendQuery("minExtInfo", minExtInfo.Value, true);
            }
            if (ignoreRelationships != null)
            {
                uri.AppendQuery("ignoreRelationships", ignoreRelationships.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateBulkCreateOrUpdateRequest(RequestContent content, string collectionId, string businessAttributeUpdateBehavior, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (collectionId != null)
            {
                uri.AppendQuery("collectionId", collectionId, true);
            }
            if (businessAttributeUpdateBehavior != null)
            {
                uri.AppendQuery("businessAttributeUpdateBehavior", businessAttributeUpdateBehavior, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateBulkDeleteRequest(IEnumerable<string> guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk", false);
            if (guid != null && Optional.IsCollectionDefined(guid))
            {
                foreach (var param in guid)
                {
                    uri.AppendQuery("guid", param, true);
                }
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddClassificationRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk/classification", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetEntityRequest(string guid, bool? minExtInfo, bool? ignoreRelationships, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (minExtInfo != null)
            {
                uri.AppendQuery("minExtInfo", minExtInfo.Value, true);
            }
            if (ignoreRelationships != null)
            {
                uri.AppendQuery("ignoreRelationships", ignoreRelationships.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreatePartialUpdateAttributeByGuidRequest(string guid, string name, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendQuery("name", name, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationRequest(string guid, string classificationName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classification/", false);
            uri.AppendPath(classificationName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRemoveClassificationRequest(string guid, string classificationName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classification/", false);
            uri.AppendPath(classificationName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationsRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classifications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddClassificationsRequest(string guid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classifications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateClassificationsRequest(string guid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classifications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetByUniqueAttributesRequest(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (minExtInfo != null)
            {
                uri.AppendQuery("minExtInfo", minExtInfo.Value, true);
            }
            if (ignoreRelationships != null)
            {
                uri.AppendQuery("ignoreRelationships", ignoreRelationships.Value, true);
            }
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreatePartialUpdateByUniqueAttributesRequest(string typeName, RequestContent content, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteByUniqueAttributeRequest(string typeName, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRemoveClassificationByUniqueAttributeRequest(string typeName, string classificationName, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/classification/", false);
            uri.AppendPath(classificationName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddClassificationsByUniqueAttributeRequest(string typeName, RequestContent content, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/classifications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateClassificationsByUniqueAttributeRequest(string typeName, RequestContent content, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/classifications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateBulkSetClassificationsRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk/setClassifications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetEntitiesByUniqueAttributesRequest(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrNQualifiedName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (minExtInfo != null)
            {
                uri.AppendQuery("minExtInfo", minExtInfo.Value, true);
            }
            if (ignoreRelationships != null)
            {
                uri.AppendQuery("ignoreRelationships", ignoreRelationships.Value, true);
            }
            if (attrNQualifiedName != null)
            {
                uri.AppendQuery("attr_N:qualifiedName", attrNQualifiedName, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetHeaderRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/header", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRemoveBusinessMetadataRequest(string guid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/businessmetadata", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddOrUpdateBusinessMetadataRequest(string guid, RequestContent content, bool? isOverwrite, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/businessmetadata", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (isOverwrite != null)
            {
                uri.AppendQuery("isOverwrite", isOverwrite.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateRemoveBusinessMetadataAttributesRequest(string guid, string bmName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/businessmetadata/", false);
            uri.AppendPath(bmName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddOrUpdateBusinessMetadataAttributesRequest(string guid, string bmName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/businessmetadata/", false);
            uri.AppendPath(bmName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSampleBusinessMetadataTemplateRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/businessmetadata/import/template", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportBusinessMetadataRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/businessmetadata/import", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateRemoveLabelsRequest(string guid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/labels", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateSetLabelsRequest(string guid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/labels", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddLabelRequest(string guid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/labels", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateRemoveLabelsByUniqueAttributeRequest(string typeName, RequestContent content, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/labels", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateSetLabelsByUniqueAttributeRequest(string typeName, RequestContent content, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/labels", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddLabelsByUniqueAttributeRequest(string typeName, RequestContent content, string attr, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/labels", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (attr != null)
            {
                uri.AppendQuery("attr:qualifiedName", attr, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateMoveEntitiesToCollectionRequest(string collectionId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/entity/moveTo", false);
            uri.AppendQuery("collectionId", collectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
