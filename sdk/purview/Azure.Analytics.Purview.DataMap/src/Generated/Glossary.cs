// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.Purview.DataMap
{
    // Data plane generated sub-client.
    /// <summary> The Glossary sub-client. </summary>
    public partial class Glossary
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://purview.azure.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of Glossary for mocking. </summary>
        protected Glossary()
        {
        }

        /// <summary> Initializes a new instance of Glossary. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint"> The <see cref="Uri"/> to use. </param>
        /// <param name="apiVersion"> The <see cref="string"/> to use. </param>
        internal Glossary(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary>
        /// Get all glossaries. Recommend using limit/offset to get pagination result.
        /// Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        /// separately using
        ///
        ///  'GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms'
        /// and
        ///
        ///  'GET '/datamap/api/atlas/v2/glossary/{glossaryGuid}/categories'.
        /// </summary>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetGlossariesAsync(int?,int?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasGlossary>>> GetGlossariesAsync(int? limit = null, int? offset = null, string sort = null, bool? ignoreTermsAndCategories = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetGlossariesAsync(limit, offset, sort, ignoreTermsAndCategories, context).ConfigureAwait(false);
            IReadOnlyList<AtlasGlossary> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasGlossary> array = new List<AtlasGlossary>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossary.DeserializeAtlasGlossary(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// Get all glossaries. Recommend using limit/offset to get pagination result.
        /// Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        /// separately using
        ///
        ///  'GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms'
        /// and
        ///
        ///  'GET '/datamap/api/atlas/v2/glossary/{glossaryGuid}/categories'.
        /// </summary>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetGlossaries(int?,int?,string,bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasGlossary>> GetGlossaries(int? limit = null, int? offset = null, string sort = null, bool? ignoreTermsAndCategories = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetGlossaries(limit, offset, sort, ignoreTermsAndCategories, context);
            IReadOnlyList<AtlasGlossary> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasGlossary> array = new List<AtlasGlossary>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossary.DeserializeAtlasGlossary(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Get all glossaries. Recommend using limit/offset to get pagination result.
        /// Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        /// separately using
        ///
        ///  'GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms'
        /// and
        ///
        ///  'GET '/datamap/api/atlas/v2/glossary/{glossaryGuid}/categories'.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGlossariesAsync(int?,int?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetGlossariesAsync(int?,int?,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetGlossariesAsync(int? limit, int? offset, string sort, bool? ignoreTermsAndCategories, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("Glossary.GetGlossaries");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGlossariesRequest(limit, offset, sort, ignoreTermsAndCategories, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all glossaries. Recommend using limit/offset to get pagination result.
        /// Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        /// separately using
        ///
        ///  'GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms'
        /// and
        ///
        ///  'GET '/datamap/api/atlas/v2/glossary/{glossaryGuid}/categories'.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGlossaries(int?,int?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetGlossaries(int?,int?,string,bool?,RequestContext)']/*" />
        public virtual Response GetGlossaries(int? limit, int? offset, string sort, bool? ignoreTermsAndCategories, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("Glossary.GetGlossaries");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGlossariesRequest(limit, offset, sort, ignoreTermsAndCategories, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a glossary. </summary>
        /// <param name="atlasGlossary">
        /// Glossary definition, terms &amp; categories can be anchored to a glossary.
        /// Using
        /// the anchor attribute when creating the Term/Category.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="atlasGlossary"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateAsync(AtlasGlossary,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossary>> CreateAsync(AtlasGlossary atlasGlossary, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(atlasGlossary, nameof(atlasGlossary));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = atlasGlossary.ToRequestContent();
            Response response = await CreateAsync(content, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossary.FromResponse(response), response);
        }

        /// <summary> Create a glossary. </summary>
        /// <param name="atlasGlossary">
        /// Glossary definition, terms &amp; categories can be anchored to a glossary.
        /// Using
        /// the anchor attribute when creating the Term/Category.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="atlasGlossary"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='Create(AtlasGlossary,CancellationToken)']/*" />
        public virtual Response<AtlasGlossary> Create(AtlasGlossary atlasGlossary, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(atlasGlossary, nameof(atlasGlossary));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = atlasGlossary.ToRequestContent();
            Response response = Create(content, context);
            return Response.FromValue(AtlasGlossary.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create a glossary.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateAsync(AtlasGlossary,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.Create");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a glossary.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Create(AtlasGlossary,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='Create(RequestContent,RequestContext)']/*" />
        public virtual Response Create(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.Create");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create glossary category in bulk. </summary>
        /// <param name="glossaryCategory"> An array of glossary category definitions to be created. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryCategory"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateCategoriesAsync(IEnumerable{AtlasGlossaryCategory},CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasGlossaryCategory>>> CreateCategoriesAsync(IEnumerable<AtlasGlossaryCategory> glossaryCategory, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(glossaryCategory, nameof(glossaryCategory));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(glossaryCategory);
            Response response = await CreateCategoriesAsync(content, context).ConfigureAwait(false);
            IReadOnlyList<AtlasGlossaryCategory> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasGlossaryCategory> array = new List<AtlasGlossaryCategory>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossaryCategory.DeserializeAtlasGlossaryCategory(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Create glossary category in bulk. </summary>
        /// <param name="glossaryCategory"> An array of glossary category definitions to be created. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryCategory"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateCategories(IEnumerable{AtlasGlossaryCategory},CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasGlossaryCategory>> CreateCategories(IEnumerable<AtlasGlossaryCategory> glossaryCategory, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(glossaryCategory, nameof(glossaryCategory));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(glossaryCategory);
            Response response = CreateCategories(content, context);
            IReadOnlyList<AtlasGlossaryCategory> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasGlossaryCategory> array = new List<AtlasGlossaryCategory>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossaryCategory.DeserializeAtlasGlossaryCategory(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Create glossary category in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateCategoriesAsync(IEnumerable{AtlasGlossaryCategory},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateCategoriesAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateCategoriesAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.CreateCategories");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateCategoriesRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create glossary category in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateCategories(IEnumerable{AtlasGlossaryCategory},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateCategories(RequestContent,RequestContext)']/*" />
        public virtual Response CreateCategories(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.CreateCategories");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateCategoriesRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a glossary category. </summary>
        /// <param name="glossaryCategory">
        /// The glossary category definition. A category must be anchored to a Glossary
        /// when creating.
        /// Optionally, terms belonging to the category and the hierarchy
        /// can also be defined during creation.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryCategory"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateCategoryAsync(AtlasGlossaryCategory,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryCategory>> CreateCategoryAsync(AtlasGlossaryCategory glossaryCategory, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(glossaryCategory, nameof(glossaryCategory));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = glossaryCategory.ToRequestContent();
            Response response = await CreateCategoryAsync(content, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryCategory.FromResponse(response), response);
        }

        /// <summary> Create a glossary category. </summary>
        /// <param name="glossaryCategory">
        /// The glossary category definition. A category must be anchored to a Glossary
        /// when creating.
        /// Optionally, terms belonging to the category and the hierarchy
        /// can also be defined during creation.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryCategory"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateCategory(AtlasGlossaryCategory,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryCategory> CreateCategory(AtlasGlossaryCategory glossaryCategory, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(glossaryCategory, nameof(glossaryCategory));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = glossaryCategory.ToRequestContent();
            Response response = CreateCategory(content, context);
            return Response.FromValue(AtlasGlossaryCategory.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create a glossary category.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateCategoryAsync(AtlasGlossaryCategory,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateCategoryAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateCategoryAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.CreateCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateCategoryRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a glossary category.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateCategory(AtlasGlossaryCategory,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateCategory(RequestContent,RequestContext)']/*" />
        public virtual Response CreateCategory(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.CreateCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateCategoryRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get specific glossary category by its GUID. </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoryAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryCategory>> GetCategoryAsync(string categoryGuid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetCategoryAsync(categoryGuid, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryCategory.FromResponse(response), response);
        }

        /// <summary> Get specific glossary category by its GUID. </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategory(string,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryCategory> GetCategory(string categoryGuid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetCategory(categoryGuid, context);
            return Response.FromValue(AtlasGlossaryCategory.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get specific glossary category by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCategoryAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoryAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetCategoryAsync(string categoryGuid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCategoryRequest(categoryGuid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get specific glossary category by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCategory(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategory(string,RequestContext)']/*" />
        public virtual Response GetCategory(string categoryGuid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCategoryRequest(categoryGuid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update the given glossary category by its GUID. </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="glossaryCategory"> The glossary category to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> or <paramref name="glossaryCategory"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateCategoryAsync(string,AtlasGlossaryCategory,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryCategory>> UpdateCategoryAsync(string categoryGuid, AtlasGlossaryCategory glossaryCategory, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));
            Argument.AssertNotNull(glossaryCategory, nameof(glossaryCategory));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = glossaryCategory.ToRequestContent();
            Response response = await UpdateCategoryAsync(categoryGuid, content, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryCategory.FromResponse(response), response);
        }

        /// <summary> Update the given glossary category by its GUID. </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="glossaryCategory"> The glossary category to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> or <paramref name="glossaryCategory"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateCategory(string,AtlasGlossaryCategory,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryCategory> UpdateCategory(string categoryGuid, AtlasGlossaryCategory glossaryCategory, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));
            Argument.AssertNotNull(glossaryCategory, nameof(glossaryCategory));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = glossaryCategory.ToRequestContent();
            Response response = UpdateCategory(categoryGuid, content, context);
            return Response.FromValue(AtlasGlossaryCategory.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary category by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateCategoryAsync(string,AtlasGlossaryCategory,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateCategoryAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateCategoryAsync(string categoryGuid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.UpdateCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateCategoryRequest(categoryGuid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary category by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateCategory(string,AtlasGlossaryCategory,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateCategory(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateCategory(string categoryGuid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.UpdateCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateCategoryRequest(categoryGuid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a glossary category.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteCategoryAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteCategoryAsync(string categoryGuid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.DeleteCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteCategoryRequest(categoryGuid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a glossary category.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteCategory(string,RequestContext)']/*" />
        public virtual Response DeleteCategory(string categoryGuid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.DeleteCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteCategoryRequest(categoryGuid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update the glossary category partially. So far we only supports partial
        /// updating shortDescription and longDescription for category.
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="partialUpdates">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values for partial update.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> or <paramref name="partialUpdates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateCategoryAsync(string,BinaryData,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryCategory>> PartialUpdateCategoryAsync(string categoryGuid, BinaryData partialUpdates, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));
            Argument.AssertNotNull(partialUpdates, nameof(partialUpdates));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromObject(partialUpdates);
            Response response = await PartialUpdateCategoryAsync(categoryGuid, content, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryCategory.FromResponse(response), response);
        }

        /// <summary>
        /// Update the glossary category partially. So far we only supports partial
        /// updating shortDescription and longDescription for category.
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="partialUpdates">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values for partial update.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> or <paramref name="partialUpdates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateCategory(string,BinaryData,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryCategory> PartialUpdateCategory(string categoryGuid, BinaryData partialUpdates, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));
            Argument.AssertNotNull(partialUpdates, nameof(partialUpdates));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromObject(partialUpdates);
            Response response = PartialUpdateCategory(categoryGuid, content, context);
            return Response.FromValue(AtlasGlossaryCategory.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Update the glossary category partially. So far we only supports partial
        /// updating shortDescription and longDescription for category.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateCategoryAsync(string,BinaryData,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateCategoryAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> PartialUpdateCategoryAsync(string categoryGuid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdateCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateCategoryRequest(categoryGuid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the glossary category partially. So far we only supports partial
        /// updating shortDescription and longDescription for category.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateCategory(string,BinaryData,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateCategory(string,RequestContent,RequestContext)']/*" />
        public virtual Response PartialUpdateCategory(string categoryGuid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdateCategory");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateCategoryRequest(categoryGuid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get all related categories (parent and children). Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetRelatedCategoriesAsync(string,int?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyDictionary<string, IList<AtlasRelatedCategoryHeader>>>> GetRelatedCategoriesAsync(string categoryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetRelatedCategoriesAsync(categoryGuid, limit, offset, sort, context).ConfigureAwait(false);
            IReadOnlyDictionary<string, IList<AtlasRelatedCategoryHeader>> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            Dictionary<string, IList<AtlasRelatedCategoryHeader>> dictionary = new Dictionary<string, IList<AtlasRelatedCategoryHeader>>();
            foreach (var property in document.RootElement.EnumerateObject())
            {
                if (property.Value.ValueKind == JsonValueKind.Null)
                {
                    dictionary.Add(property.Name, null);
                }
                else
                {
                    List<AtlasRelatedCategoryHeader> array = new List<AtlasRelatedCategoryHeader>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(AtlasRelatedCategoryHeader.DeserializeAtlasRelatedCategoryHeader(item));
                    }
                    dictionary.Add(property.Name, array);
                }
            }
            value = dictionary;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// Get all related categories (parent and children). Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetRelatedCategories(string,int?,int?,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyDictionary<string, IList<AtlasRelatedCategoryHeader>>> GetRelatedCategories(string categoryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetRelatedCategories(categoryGuid, limit, offset, sort, context);
            IReadOnlyDictionary<string, IList<AtlasRelatedCategoryHeader>> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            Dictionary<string, IList<AtlasRelatedCategoryHeader>> dictionary = new Dictionary<string, IList<AtlasRelatedCategoryHeader>>();
            foreach (var property in document.RootElement.EnumerateObject())
            {
                if (property.Value.ValueKind == JsonValueKind.Null)
                {
                    dictionary.Add(property.Name, null);
                }
                else
                {
                    List<AtlasRelatedCategoryHeader> array = new List<AtlasRelatedCategoryHeader>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(AtlasRelatedCategoryHeader.DeserializeAtlasRelatedCategoryHeader(item));
                    }
                    dictionary.Add(property.Name, array);
                }
            }
            value = dictionary;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Get all related categories (parent and children). Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRelatedCategoriesAsync(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetRelatedCategoriesAsync(string,int?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetRelatedCategoriesAsync(string categoryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetRelatedCategories");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelatedCategoriesRequest(categoryGuid, limit, offset, sort, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all related categories (parent and children). Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRelatedCategories(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetRelatedCategories(string,int?,int?,string,RequestContext)']/*" />
        public virtual Response GetRelatedCategories(string categoryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetRelatedCategories");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelatedCategoriesRequest(categoryGuid, limit, offset, sort, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all terms associated with the specific category. </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoryTermsAsync(string,int?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasRelatedTermHeader>>> GetCategoryTermsAsync(string categoryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetCategoryTermsAsync(categoryGuid, limit, offset, sort, context).ConfigureAwait(false);
            IReadOnlyList<AtlasRelatedTermHeader> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasRelatedTermHeader> array = new List<AtlasRelatedTermHeader>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Get all terms associated with the specific category. </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoryTerms(string,int?,int?,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasRelatedTermHeader>> GetCategoryTerms(string categoryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetCategoryTerms(categoryGuid, limit, offset, sort, context);
            IReadOnlyList<AtlasRelatedTermHeader> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasRelatedTermHeader> array = new List<AtlasRelatedTermHeader>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Get all terms associated with the specific category.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCategoryTermsAsync(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoryTermsAsync(string,int?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetCategoryTermsAsync(string categoryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetCategoryTerms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCategoryTermsRequest(categoryGuid, limit, offset, sort, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all terms associated with the specific category.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCategoryTerms(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryGuid"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoryTerms(string,int?,int?,string,RequestContext)']/*" />
        public virtual Response GetCategoryTerms(string categoryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(categoryGuid, nameof(categoryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetCategoryTerms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCategoryTermsRequest(categoryGuid, limit, offset, sort, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a glossary term. </summary>
        /// <param name="glossaryTerm">
        /// The glossary term definition. A term must be anchored to a Glossary at the time
        /// of creation.
        /// Optionally it can be categorized as well.
        /// </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryTerm"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateTermAsync(AtlasGlossaryTerm,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryTerm>> CreateTermAsync(AtlasGlossaryTerm glossaryTerm, bool? includeTermHierarchy = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(glossaryTerm, nameof(glossaryTerm));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = glossaryTerm.ToRequestContent();
            Response response = await CreateTermAsync(content, includeTermHierarchy, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryTerm.FromResponse(response), response);
        }

        /// <summary> Create a glossary term. </summary>
        /// <param name="glossaryTerm">
        /// The glossary term definition. A term must be anchored to a Glossary at the time
        /// of creation.
        /// Optionally it can be categorized as well.
        /// </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryTerm"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateTerm(AtlasGlossaryTerm,bool?,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryTerm> CreateTerm(AtlasGlossaryTerm glossaryTerm, bool? includeTermHierarchy = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(glossaryTerm, nameof(glossaryTerm));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = glossaryTerm.ToRequestContent();
            Response response = CreateTerm(content, includeTermHierarchy, context);
            return Response.FromValue(AtlasGlossaryTerm.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create a glossary term.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTermAsync(AtlasGlossaryTerm,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateTermAsync(RequestContent,bool?,RequestContext)']/*" />
        public virtual async Task<Response> CreateTermAsync(RequestContent content, bool? includeTermHierarchy = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.CreateTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTermRequest(content, includeTermHierarchy, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a glossary term.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTerm(AtlasGlossaryTerm,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateTerm(RequestContent,bool?,RequestContext)']/*" />
        public virtual Response CreateTerm(RequestContent content, bool? includeTermHierarchy = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.CreateTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTermRequest(content, includeTermHierarchy, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a specific glossary term by its GUID. </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTermAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryTerm>> GetTermAsync(string termGuid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTermAsync(termGuid, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryTerm.FromResponse(response), response);
        }

        /// <summary> Get a specific glossary term by its GUID. </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTerm(string,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryTerm> GetTerm(string termGuid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTerm(termGuid, context);
            return Response.FromValue(AtlasGlossaryTerm.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get a specific glossary term by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTermAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTermAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetTermAsync(string termGuid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermRequest(termGuid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a specific glossary term by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTerm(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTerm(string,RequestContext)']/*" />
        public virtual Response GetTerm(string termGuid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermRequest(termGuid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update the given glossary term by its GUID. </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="glossaryTerm"> The glossary term to be updated. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="glossaryTerm"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateTermAsync(string,AtlasGlossaryTerm,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryTerm>> UpdateTermAsync(string termGuid, AtlasGlossaryTerm glossaryTerm, bool? includeTermHierarchy = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(glossaryTerm, nameof(glossaryTerm));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = glossaryTerm.ToRequestContent();
            Response response = await UpdateTermAsync(termGuid, content, includeTermHierarchy, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryTerm.FromResponse(response), response);
        }

        /// <summary> Update the given glossary term by its GUID. </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="glossaryTerm"> The glossary term to be updated. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="glossaryTerm"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateTerm(string,AtlasGlossaryTerm,bool?,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryTerm> UpdateTerm(string termGuid, AtlasGlossaryTerm glossaryTerm, bool? includeTermHierarchy = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(glossaryTerm, nameof(glossaryTerm));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = glossaryTerm.ToRequestContent();
            Response response = UpdateTerm(termGuid, content, includeTermHierarchy, context);
            return Response.FromValue(AtlasGlossaryTerm.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary term by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateTermAsync(string,AtlasGlossaryTerm,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateTermAsync(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual async Task<Response> UpdateTermAsync(string termGuid, RequestContent content, bool? includeTermHierarchy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.UpdateTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateTermRequest(termGuid, content, includeTermHierarchy, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary term by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateTerm(string,AtlasGlossaryTerm,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateTerm(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual Response UpdateTerm(string termGuid, RequestContent content, bool? includeTermHierarchy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.UpdateTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateTermRequest(termGuid, content, includeTermHierarchy, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a glossary term.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteTermAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteTermAsync(string termGuid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.DeleteTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTermRequest(termGuid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a glossary term.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteTerm(string,RequestContext)']/*" />
        public virtual Response DeleteTerm(string termGuid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.DeleteTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTermRequest(termGuid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update the glossary term partially. So far we only supports partial updating
        /// shortDescription, longDescription, abbreviation, usage and status for term.
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="partialUpdates">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values to be updated.
        /// </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="partialUpdates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateTermAsync(string,BinaryData,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryTerm>> PartialUpdateTermAsync(string termGuid, BinaryData partialUpdates, bool? includeTermHierarchy = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(partialUpdates, nameof(partialUpdates));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromObject(partialUpdates);
            Response response = await PartialUpdateTermAsync(termGuid, content, includeTermHierarchy, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryTerm.FromResponse(response), response);
        }

        /// <summary>
        /// Update the glossary term partially. So far we only supports partial updating
        /// shortDescription, longDescription, abbreviation, usage and status for term.
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="partialUpdates">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values to be updated.
        /// </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="partialUpdates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateTerm(string,BinaryData,bool?,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryTerm> PartialUpdateTerm(string termGuid, BinaryData partialUpdates, bool? includeTermHierarchy = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(partialUpdates, nameof(partialUpdates));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromObject(partialUpdates);
            Response response = PartialUpdateTerm(termGuid, content, includeTermHierarchy, context);
            return Response.FromValue(AtlasGlossaryTerm.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Update the glossary term partially. So far we only supports partial updating
        /// shortDescription, longDescription, abbreviation, usage and status for term.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateTermAsync(string,BinaryData,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateTermAsync(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual async Task<Response> PartialUpdateTermAsync(string termGuid, RequestContent content, bool? includeTermHierarchy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdateTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateTermRequest(termGuid, content, includeTermHierarchy, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the glossary term partially. So far we only supports partial updating
        /// shortDescription, longDescription, abbreviation, usage and status for term.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateTerm(string,BinaryData,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateTerm(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual Response PartialUpdateTerm(string termGuid, RequestContent content, bool? includeTermHierarchy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdateTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateTermRequest(termGuid, content, includeTermHierarchy, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create glossary terms in bulk. </summary>
        /// <param name="glossaryTerm"> An array of glossary term definitions to be created in bulk. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryTerm"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateTermsAsync(IEnumerable{AtlasGlossaryTerm},bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasGlossaryTerm>>> CreateTermsAsync(IEnumerable<AtlasGlossaryTerm> glossaryTerm, bool? includeTermHierarchy = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(glossaryTerm, nameof(glossaryTerm));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(glossaryTerm);
            Response response = await CreateTermsAsync(content, includeTermHierarchy, context).ConfigureAwait(false);
            IReadOnlyList<AtlasGlossaryTerm> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasGlossaryTerm> array = new List<AtlasGlossaryTerm>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossaryTerm.DeserializeAtlasGlossaryTerm(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> Create glossary terms in bulk. </summary>
        /// <param name="glossaryTerm"> An array of glossary term definitions to be created in bulk. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryTerm"/> is null. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateTerms(IEnumerable{AtlasGlossaryTerm},bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasGlossaryTerm>> CreateTerms(IEnumerable<AtlasGlossaryTerm> glossaryTerm, bool? includeTermHierarchy = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(glossaryTerm, nameof(glossaryTerm));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(glossaryTerm);
            Response response = CreateTerms(content, includeTermHierarchy, context);
            IReadOnlyList<AtlasGlossaryTerm> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasGlossaryTerm> array = new List<AtlasGlossaryTerm>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossaryTerm.DeserializeAtlasGlossaryTerm(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Create glossary terms in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTermsAsync(IEnumerable{AtlasGlossaryTerm},bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateTermsAsync(RequestContent,bool?,RequestContext)']/*" />
        public virtual async Task<Response> CreateTermsAsync(RequestContent content, bool? includeTermHierarchy = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.CreateTerms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTermsRequest(content, includeTermHierarchy, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create glossary terms in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTerms(IEnumerable{AtlasGlossaryTerm},bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='CreateTerms(RequestContent,bool?,RequestContext)']/*" />
        public virtual Response CreateTerms(RequestContent content, bool? includeTermHierarchy = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.CreateTerms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTermsRequest(content, includeTermHierarchy, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List all related objects assigned with the specified term. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetEntitiesAssignedWithTermAsync(string,int?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasRelatedObjectId>>> GetEntitiesAssignedWithTermAsync(string termGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetEntitiesAssignedWithTermAsync(termGuid, limit, offset, sort, context).ConfigureAwait(false);
            IReadOnlyList<AtlasRelatedObjectId> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasRelatedObjectId> array = new List<AtlasRelatedObjectId>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasRelatedObjectId.DeserializeAtlasRelatedObjectId(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// List all related objects assigned with the specified term. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetEntitiesAssignedWithTerm(string,int?,int?,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasRelatedObjectId>> GetEntitiesAssignedWithTerm(string termGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetEntitiesAssignedWithTerm(termGuid, limit, offset, sort, context);
            IReadOnlyList<AtlasRelatedObjectId> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasRelatedObjectId> array = new List<AtlasRelatedObjectId>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasRelatedObjectId.DeserializeAtlasRelatedObjectId(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all related objects assigned with the specified term. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetEntitiesAssignedWithTermAsync(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetEntitiesAssignedWithTermAsync(string,int?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetEntitiesAssignedWithTermAsync(string termGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetEntitiesAssignedWithTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntitiesAssignedWithTermRequest(termGuid, limit, offset, sort, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all related objects assigned with the specified term. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetEntitiesAssignedWithTerm(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetEntitiesAssignedWithTerm(string,int?,int?,string,RequestContext)']/*" />
        public virtual Response GetEntitiesAssignedWithTerm(string termGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetEntitiesAssignedWithTerm");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntitiesAssignedWithTermRequest(termGuid, limit, offset, sort, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Assign the given term to the provided list of related objects. Recommend using
        /// small batches with multiple API calls.
        ///
        /// [Entities Create Or Update
        /// operation](https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP)
        /// is an alternative to assign a term to multiple entities.
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="relatedObjectIds"> An array of related object IDs to which the term has to be associated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="relatedObjectIds"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='AssignTermToEntitiesAsync(string,IEnumerable{AtlasRelatedObjectId},CancellationToken)']/*" />
        public virtual async Task<Response> AssignTermToEntitiesAsync(string termGuid, IEnumerable<AtlasRelatedObjectId> relatedObjectIds, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(relatedObjectIds, nameof(relatedObjectIds));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(relatedObjectIds);
            Response response = await AssignTermToEntitiesAsync(termGuid, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary>
        /// Assign the given term to the provided list of related objects. Recommend using
        /// small batches with multiple API calls.
        ///
        /// [Entities Create Or Update
        /// operation](https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP)
        /// is an alternative to assign a term to multiple entities.
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="relatedObjectIds"> An array of related object IDs to which the term has to be associated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="relatedObjectIds"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='AssignTermToEntities(string,IEnumerable{AtlasRelatedObjectId},CancellationToken)']/*" />
        public virtual Response AssignTermToEntities(string termGuid, IEnumerable<AtlasRelatedObjectId> relatedObjectIds, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(relatedObjectIds, nameof(relatedObjectIds));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(relatedObjectIds);
            Response response = AssignTermToEntities(termGuid, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Assign the given term to the provided list of related objects. Recommend using
        /// small batches with multiple API calls.
        ///
        /// [Entities Create Or Update
        /// operation](https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP)
        /// is an alternative to assign a term to multiple entities.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AssignTermToEntitiesAsync(string,IEnumerable{AtlasRelatedObjectId},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='AssignTermToEntitiesAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> AssignTermToEntitiesAsync(string termGuid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.AssignTermToEntities");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAssignTermToEntitiesRequest(termGuid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Assign the given term to the provided list of related objects. Recommend using
        /// small batches with multiple API calls.
        ///
        /// [Entities Create Or Update
        /// operation](https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP)
        /// is an alternative to assign a term to multiple entities.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AssignTermToEntities(string,IEnumerable{AtlasRelatedObjectId},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='AssignTermToEntities(string,RequestContent,RequestContext)']/*" />
        public virtual Response AssignTermToEntities(string termGuid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.AssignTermToEntities");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAssignTermToEntitiesRequest(termGuid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete the term assignment for the given list of related objects. </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="relatedObjectIds"> An array of related object IDs from which the term has to be dissociated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="relatedObjectIds"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteTermAssignmentFromEntitiesAsync(string,IEnumerable{AtlasRelatedObjectId},CancellationToken)']/*" />
        public virtual async Task<Response> DeleteTermAssignmentFromEntitiesAsync(string termGuid, IEnumerable<AtlasRelatedObjectId> relatedObjectIds, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(relatedObjectIds, nameof(relatedObjectIds));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(relatedObjectIds);
            Response response = await DeleteTermAssignmentFromEntitiesAsync(termGuid, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Delete the term assignment for the given list of related objects. </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="relatedObjectIds"> An array of related object IDs from which the term has to be dissociated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="relatedObjectIds"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteTermAssignmentFromEntities(string,IEnumerable{AtlasRelatedObjectId},CancellationToken)']/*" />
        public virtual Response DeleteTermAssignmentFromEntities(string termGuid, IEnumerable<AtlasRelatedObjectId> relatedObjectIds, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(relatedObjectIds, nameof(relatedObjectIds));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromEnumerable(relatedObjectIds);
            Response response = DeleteTermAssignmentFromEntities(termGuid, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Delete the term assignment for the given list of related objects.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteTermAssignmentFromEntitiesAsync(string,IEnumerable{AtlasRelatedObjectId},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteTermAssignmentFromEntitiesAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> DeleteTermAssignmentFromEntitiesAsync(string termGuid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.DeleteTermAssignmentFromEntities");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTermAssignmentFromEntitiesRequest(termGuid, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete the term assignment for the given list of related objects.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteTermAssignmentFromEntities(string,IEnumerable{AtlasRelatedObjectId},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteTermAssignmentFromEntities(string,RequestContent,RequestContext)']/*" />
        public virtual Response DeleteTermAssignmentFromEntities(string termGuid, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.DeleteTermAssignmentFromEntities");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTermAssignmentFromEntitiesRequest(termGuid, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get all related terms for a specific term by its GUID. Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetRelatedTermsAsync(string,int?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyDictionary<string, IList<AtlasRelatedTermHeader>>>> GetRelatedTermsAsync(string termGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetRelatedTermsAsync(termGuid, limit, offset, sort, context).ConfigureAwait(false);
            IReadOnlyDictionary<string, IList<AtlasRelatedTermHeader>> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            Dictionary<string, IList<AtlasRelatedTermHeader>> dictionary = new Dictionary<string, IList<AtlasRelatedTermHeader>>();
            foreach (var property in document.RootElement.EnumerateObject())
            {
                if (property.Value.ValueKind == JsonValueKind.Null)
                {
                    dictionary.Add(property.Name, null);
                }
                else
                {
                    List<AtlasRelatedTermHeader> array = new List<AtlasRelatedTermHeader>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item));
                    }
                    dictionary.Add(property.Name, array);
                }
            }
            value = dictionary;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// Get all related terms for a specific term by its GUID. Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetRelatedTerms(string,int?,int?,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyDictionary<string, IList<AtlasRelatedTermHeader>>> GetRelatedTerms(string termGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetRelatedTerms(termGuid, limit, offset, sort, context);
            IReadOnlyDictionary<string, IList<AtlasRelatedTermHeader>> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            Dictionary<string, IList<AtlasRelatedTermHeader>> dictionary = new Dictionary<string, IList<AtlasRelatedTermHeader>>();
            foreach (var property in document.RootElement.EnumerateObject())
            {
                if (property.Value.ValueKind == JsonValueKind.Null)
                {
                    dictionary.Add(property.Name, null);
                }
                else
                {
                    List<AtlasRelatedTermHeader> array = new List<AtlasRelatedTermHeader>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item));
                    }
                    dictionary.Add(property.Name, array);
                }
            }
            value = dictionary;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Get all related terms for a specific term by its GUID. Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRelatedTermsAsync(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetRelatedTermsAsync(string,int?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetRelatedTermsAsync(string termGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetRelatedTerms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelatedTermsRequest(termGuid, limit, offset, sort, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all related terms for a specific term by its GUID. Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRelatedTerms(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termGuid"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetRelatedTerms(string,int?,int?,string,RequestContext)']/*" />
        public virtual Response GetRelatedTerms(string termGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(termGuid, nameof(termGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetRelatedTerms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelatedTermsRequest(termGuid, limit, offset, sort, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a specific Glossary by its GUID. </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetGlossaryAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossary>> GetGlossaryAsync(string glossaryGuid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetGlossaryAsync(glossaryGuid, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossary.FromResponse(response), response);
        }

        /// <summary> Get a specific Glossary by its GUID. </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetGlossary(string,CancellationToken)']/*" />
        public virtual Response<AtlasGlossary> GetGlossary(string glossaryGuid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetGlossary(glossaryGuid, context);
            return Response.FromValue(AtlasGlossary.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get a specific Glossary by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGlossaryAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetGlossaryAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetGlossaryAsync(string glossaryGuid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetGlossary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGlossaryRequest(glossaryGuid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a specific Glossary by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetGlossary(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetGlossary(string,RequestContext)']/*" />
        public virtual Response GetGlossary(string glossaryGuid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetGlossary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGlossaryRequest(glossaryGuid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update the given glossary. </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="updatedGlossary"> The glossary definition to be updated. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> or <paramref name="updatedGlossary"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateAsync(string,AtlasGlossary,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossary>> UpdateAsync(string glossaryGuid, AtlasGlossary updatedGlossary, bool? ignoreTermsAndCategories = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));
            Argument.AssertNotNull(updatedGlossary, nameof(updatedGlossary));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = updatedGlossary.ToRequestContent();
            Response response = await UpdateAsync(glossaryGuid, content, ignoreTermsAndCategories, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossary.FromResponse(response), response);
        }

        /// <summary> Update the given glossary. </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="updatedGlossary"> The glossary definition to be updated. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> or <paramref name="updatedGlossary"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='Update(string,AtlasGlossary,bool?,CancellationToken)']/*" />
        public virtual Response<AtlasGlossary> Update(string glossaryGuid, AtlasGlossary updatedGlossary, bool? ignoreTermsAndCategories = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));
            Argument.AssertNotNull(updatedGlossary, nameof(updatedGlossary));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = updatedGlossary.ToRequestContent();
            Response response = Update(glossaryGuid, content, ignoreTermsAndCategories, context);
            return Response.FromValue(AtlasGlossary.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UpdateAsync(string,AtlasGlossary,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='UpdateAsync(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual async Task<Response> UpdateAsync(string glossaryGuid, RequestContent content, bool? ignoreTermsAndCategories = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(glossaryGuid, content, ignoreTermsAndCategories, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Update(string,AtlasGlossary,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='Update(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual Response Update(string glossaryGuid, RequestContent content, bool? ignoreTermsAndCategories = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(glossaryGuid, content, ignoreTermsAndCategories, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a glossary. Will delete underlying terms/categories together. Recommend
        /// separate delete terms and categories.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='DeleteAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteAsync(string glossaryGuid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(glossaryGuid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a glossary. Will delete underlying terms/categories together. Recommend
        /// separate delete terms and categories.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='Delete(string,RequestContext)']/*" />
        public virtual Response Delete(string glossaryGuid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(glossaryGuid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the categories belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoriesAsync(string,int?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasGlossaryCategory>>> GetCategoriesAsync(string glossaryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetCategoriesAsync(glossaryGuid, limit, offset, sort, context).ConfigureAwait(false);
            IReadOnlyList<AtlasGlossaryCategory> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasGlossaryCategory> array = new List<AtlasGlossaryCategory>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossaryCategory.DeserializeAtlasGlossaryCategory(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// Get the categories belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategories(string,int?,int?,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasGlossaryCategory>> GetCategories(string glossaryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetCategories(glossaryGuid, limit, offset, sort, context);
            IReadOnlyList<AtlasGlossaryCategory> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasGlossaryCategory> array = new List<AtlasGlossaryCategory>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossaryCategory.DeserializeAtlasGlossaryCategory(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Get the categories belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCategoriesAsync(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoriesAsync(string,int?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetCategoriesAsync(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetCategories");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCategoriesRequest(glossaryGuid, limit, offset, sort, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the categories belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCategories(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategories(string,int?,int?,string,RequestContext)']/*" />
        public virtual Response GetCategories(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetCategories");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCategoriesRequest(glossaryGuid, limit, offset, sort, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the category headers belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoriesHeadersAsync(string,int?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasRelatedCategoryHeader>>> GetCategoriesHeadersAsync(string glossaryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetCategoriesHeadersAsync(glossaryGuid, limit, offset, sort, context).ConfigureAwait(false);
            IReadOnlyList<AtlasRelatedCategoryHeader> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasRelatedCategoryHeader> array = new List<AtlasRelatedCategoryHeader>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasRelatedCategoryHeader.DeserializeAtlasRelatedCategoryHeader(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// Get the category headers belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoriesHeaders(string,int?,int?,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasRelatedCategoryHeader>> GetCategoriesHeaders(string glossaryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetCategoriesHeaders(glossaryGuid, limit, offset, sort, context);
            IReadOnlyList<AtlasRelatedCategoryHeader> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasRelatedCategoryHeader> array = new List<AtlasRelatedCategoryHeader>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasRelatedCategoryHeader.DeserializeAtlasRelatedCategoryHeader(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Get the category headers belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCategoriesHeadersAsync(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoriesHeadersAsync(string,int?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetCategoriesHeadersAsync(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetCategoriesHeaders");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCategoriesHeadersRequest(glossaryGuid, limit, offset, sort, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the category headers belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCategoriesHeaders(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetCategoriesHeaders(string,int?,int?,string,RequestContext)']/*" />
        public virtual Response GetCategoriesHeaders(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetCategoriesHeaders");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCategoriesHeadersRequest(glossaryGuid, limit, offset, sort, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a specific glossary with detailed information. This API is not
        /// recommend.
        ///
        /// Recommend to fetch terms/categories details separately using
        ///
        /// GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms and
        ///
        /// GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/categories.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetDetailedAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossaryExtInfo>> GetDetailedAsync(string glossaryGuid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDetailedAsync(glossaryGuid, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossaryExtInfo.FromResponse(response), response);
        }

        /// <summary>
        /// Get a specific glossary with detailed information. This API is not
        /// recommend.
        ///
        /// Recommend to fetch terms/categories details separately using
        ///
        /// GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms and
        ///
        /// GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/categories.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetDetailed(string,CancellationToken)']/*" />
        public virtual Response<AtlasGlossaryExtInfo> GetDetailed(string glossaryGuid, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDetailed(glossaryGuid, context);
            return Response.FromValue(AtlasGlossaryExtInfo.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Get a specific glossary with detailed information. This API is not
        /// recommend.
        ///
        /// Recommend to fetch terms/categories details separately using
        ///
        /// GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms and
        ///
        /// GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/categories.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDetailedAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetDetailedAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetDetailedAsync(string glossaryGuid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetDetailed");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDetailedRequest(glossaryGuid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a specific glossary with detailed information. This API is not
        /// recommend.
        ///
        /// Recommend to fetch terms/categories details separately using
        ///
        /// GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms and
        ///
        /// GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/categories.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDetailed(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetDetailed(string,RequestContext)']/*" />
        public virtual Response GetDetailed(string glossaryGuid, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetDetailed");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDetailedRequest(glossaryGuid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update the glossary partially. Some properties such as qualifiedName are not
        /// allowed to be updated.
        ///
        /// So far we only supports partial updating
        /// shortDescription, longDescription, language and usage for glossary.
        ///
        /// Recommend
        /// using 'ignoreTermsAndCategories=true' to reduce response body size.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="partialUpdates">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values.
        /// </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> or <paramref name="partialUpdates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateAsync(string,BinaryData,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<AtlasGlossary>> PartialUpdateAsync(string glossaryGuid, BinaryData partialUpdates, bool? ignoreTermsAndCategories = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));
            Argument.AssertNotNull(partialUpdates, nameof(partialUpdates));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromObject(partialUpdates);
            Response response = await PartialUpdateAsync(glossaryGuid, content, ignoreTermsAndCategories, context).ConfigureAwait(false);
            return Response.FromValue(AtlasGlossary.FromResponse(response), response);
        }

        /// <summary>
        /// Update the glossary partially. Some properties such as qualifiedName are not
        /// allowed to be updated.
        ///
        /// So far we only supports partial updating
        /// shortDescription, longDescription, language and usage for glossary.
        ///
        /// Recommend
        /// using 'ignoreTermsAndCategories=true' to reduce response body size.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="partialUpdates">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values.
        /// </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> or <paramref name="partialUpdates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdate(string,BinaryData,bool?,CancellationToken)']/*" />
        public virtual Response<AtlasGlossary> PartialUpdate(string glossaryGuid, BinaryData partialUpdates, bool? ignoreTermsAndCategories = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));
            Argument.AssertNotNull(partialUpdates, nameof(partialUpdates));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = RequestContentHelper.FromObject(partialUpdates);
            Response response = PartialUpdate(glossaryGuid, content, ignoreTermsAndCategories, context);
            return Response.FromValue(AtlasGlossary.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Update the glossary partially. Some properties such as qualifiedName are not
        /// allowed to be updated.
        ///
        /// So far we only supports partial updating
        /// shortDescription, longDescription, language and usage for glossary.
        ///
        /// Recommend
        /// using 'ignoreTermsAndCategories=true' to reduce response body size.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdateAsync(string,BinaryData,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdateAsync(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual async Task<Response> PartialUpdateAsync(string glossaryGuid, RequestContent content, bool? ignoreTermsAndCategories = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateRequest(glossaryGuid, content, ignoreTermsAndCategories, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the glossary partially. Some properties such as qualifiedName are not
        /// allowed to be updated.
        ///
        /// So far we only supports partial updating
        /// shortDescription, longDescription, language and usage for glossary.
        ///
        /// Recommend
        /// using 'ignoreTermsAndCategories=true' to reduce response body size.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="PartialUpdate(string,BinaryData,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='PartialUpdate(string,RequestContent,bool?,RequestContext)']/*" />
        public virtual Response PartialUpdate(string glossaryGuid, RequestContent content, bool? ignoreTermsAndCategories = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdate");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePartialUpdateRequest(glossaryGuid, content, ignoreTermsAndCategories, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get terms belonging to a specific glossary. Recommend using limit/offset to get
        /// pagination result.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTermsAsync(string,int?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasGlossaryTerm>>> GetTermsAsync(string glossaryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTermsAsync(glossaryGuid, limit, offset, sort, context).ConfigureAwait(false);
            IReadOnlyList<AtlasGlossaryTerm> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasGlossaryTerm> array = new List<AtlasGlossaryTerm>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossaryTerm.DeserializeAtlasGlossaryTerm(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// Get terms belonging to a specific glossary. Recommend using limit/offset to get
        /// pagination result.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTerms(string,int?,int?,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasGlossaryTerm>> GetTerms(string glossaryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTerms(glossaryGuid, limit, offset, sort, context);
            IReadOnlyList<AtlasGlossaryTerm> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasGlossaryTerm> array = new List<AtlasGlossaryTerm>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasGlossaryTerm.DeserializeAtlasGlossaryTerm(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Get terms belonging to a specific glossary. Recommend using limit/offset to get
        /// pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTermsAsync(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTermsAsync(string,int?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetTermsAsync(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetTerms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermsRequest(glossaryGuid, limit, offset, sort, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get terms belonging to a specific glossary. Recommend using limit/offset to get
        /// pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTerms(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTerms(string,int?,int?,string,RequestContext)']/*" />
        public virtual Response GetTerms(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetTerms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermsRequest(glossaryGuid, limit, offset, sort, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get term headers belonging to a specific glossary. Recommend using limit/offset
        /// to get pagination result.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTermHeadersAsync(string,int?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<AtlasRelatedTermHeader>>> GetTermHeadersAsync(string glossaryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTermHeadersAsync(glossaryGuid, limit, offset, sort, context).ConfigureAwait(false);
            IReadOnlyList<AtlasRelatedTermHeader> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<AtlasRelatedTermHeader> array = new List<AtlasRelatedTermHeader>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// Get term headers belonging to a specific glossary. Recommend using limit/offset
        /// to get pagination result.
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTermHeaders(string,int?,int?,string,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<AtlasRelatedTermHeader>> GetTermHeaders(string glossaryGuid, int? limit = null, int? offset = null, string sort = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTermHeaders(glossaryGuid, limit, offset, sort, context);
            IReadOnlyList<AtlasRelatedTermHeader> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<AtlasRelatedTermHeader> array = new List<AtlasRelatedTermHeader>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] Get term headers belonging to a specific glossary. Recommend using limit/offset
        /// to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTermHeadersAsync(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTermHeadersAsync(string,int?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetTermHeadersAsync(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetTermHeaders");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermHeadersRequest(glossaryGuid, limit, offset, sort, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get term headers belonging to a specific glossary. Recommend using limit/offset
        /// to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTermHeaders(string,int?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryGuid"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryGuid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryGuid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/Glossary.xml" path="doc/members/member[@name='GetTermHeaders(string,int?,int?,string,RequestContext)']/*" />
        public virtual Response GetTermHeaders(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(glossaryGuid, nameof(glossaryGuid));

            using var scope = ClientDiagnostics.CreateScope("Glossary.GetTermHeaders");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermHeadersRequest(glossaryGuid, limit, offset, sort, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetGlossariesRequest(int? limit, int? offset, string sort, bool? ignoreTermsAndCategories, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            if (ignoreTermsAndCategories != null)
            {
                uri.AppendQuery("ignoreTermsAndCategories", ignoreTermsAndCategories.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateCategoriesRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/categories", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateCategoryRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/category", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetCategoryRequest(string categoryGuid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/category/", false);
            uri.AppendPath(categoryGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateCategoryRequest(string categoryGuid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/category/", false);
            uri.AppendPath(categoryGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteCategoryRequest(string categoryGuid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/category/", false);
            uri.AppendPath(categoryGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreatePartialUpdateCategoryRequest(string categoryGuid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/category/", false);
            uri.AppendPath(categoryGuid, true);
            uri.AppendPath("/partial", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetRelatedCategoriesRequest(string categoryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/category/", false);
            uri.AppendPath(categoryGuid, true);
            uri.AppendPath("/related", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCategoryTermsRequest(string categoryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/category/", false);
            uri.AppendPath(categoryGuid, true);
            uri.AppendPath("/terms", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateTermRequest(RequestContent content, bool? includeTermHierarchy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/term", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (includeTermHierarchy != null)
            {
                uri.AppendQuery("includeTermHierarchy", includeTermHierarchy.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTermRequest(string termGuid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/term/", false);
            uri.AppendPath(termGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateTermRequest(string termGuid, RequestContent content, bool? includeTermHierarchy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/term/", false);
            uri.AppendPath(termGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (includeTermHierarchy != null)
            {
                uri.AppendQuery("includeTermHierarchy", includeTermHierarchy.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteTermRequest(string termGuid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/term/", false);
            uri.AppendPath(termGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreatePartialUpdateTermRequest(string termGuid, RequestContent content, bool? includeTermHierarchy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/term/", false);
            uri.AppendPath(termGuid, true);
            uri.AppendPath("/partial", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (includeTermHierarchy != null)
            {
                uri.AppendQuery("includeTermHierarchy", includeTermHierarchy.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateTermsRequest(RequestContent content, bool? includeTermHierarchy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/terms", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (includeTermHierarchy != null)
            {
                uri.AppendQuery("includeTermHierarchy", includeTermHierarchy.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetEntitiesAssignedWithTermRequest(string termGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/terms/", false);
            uri.AppendPath(termGuid, true);
            uri.AppendPath("/assignedEntities", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAssignTermToEntitiesRequest(string termGuid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/terms/", false);
            uri.AppendPath(termGuid, true);
            uri.AppendPath("/assignedEntities", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteTermAssignmentFromEntitiesRequest(string termGuid, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/terms/", false);
            uri.AppendPath(termGuid, true);
            uri.AppendPath("/assignedEntities", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetRelatedTermsRequest(string termGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/terms/", false);
            uri.AppendPath(termGuid, true);
            uri.AppendPath("/related", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGlossaryRequest(string glossaryGuid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateRequest(string glossaryGuid, RequestContent content, bool? ignoreTermsAndCategories, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (ignoreTermsAndCategories != null)
            {
                uri.AppendQuery("ignoreTermsAndCategories", ignoreTermsAndCategories.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string glossaryGuid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCategoriesRequest(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendPath("/categories", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCategoriesHeadersRequest(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendPath("/categories/headers", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDetailedRequest(string glossaryGuid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendPath("/detailed", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreatePartialUpdateRequest(string glossaryGuid, RequestContent content, bool? ignoreTermsAndCategories, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendPath("/partial", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (ignoreTermsAndCategories != null)
            {
                uri.AppendQuery("ignoreTermsAndCategories", ignoreTermsAndCategories.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTermsRequest(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendPath("/terms", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTermHeadersRequest(string glossaryGuid, int? limit, int? offset, string sort, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/datamap/api", false);
            uri.AppendPath("/atlas/v2/glossary/", false);
            uri.AppendPath(glossaryGuid, true);
            uri.AppendPath("/terms/headers", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (offset != null)
            {
                uri.AppendQuery("offset", offset.Value, true);
            }
            if (sort != null)
            {
                uri.AppendQuery("sort", sort, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
