// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.Purview.DataMap
{
    /// <summary> The Glossary sub-client. </summary>
    public partial class Glossary
    {
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of Glossary for mocking. </summary>
        protected Glossary()
        {
        }

        /// <summary> Initializes a new instance of Glossary. </summary>
        /// <param name="clientDiagnostics"> The ClientDiagnostics is used to provide tracing support for the client library. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> Service endpoint. </param>
        /// <param name="apiVersion"></param>
        internal Glossary(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _endpoint = endpoint;
            Pipeline = pipeline;
            _apiVersion = apiVersion;
        }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline { get; }

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary>
        /// [Protocol Method] Get all glossaries. Recommend using limit/offset to get pagination result.
        /// Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        /// separately using 'GET /datamap/api/atlas/v2/glossary/{glossaryId}/terms'
        /// and 'GET '/datamap/api/atlas/v2/glossary/{glossaryId}/categories'.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response BatchGet(int? limit, int? offset, string sort, bool? ignoreTermsAndCategories, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.BatchGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBatchGetRequest(limit, offset, sort, ignoreTermsAndCategories, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all glossaries. Recommend using limit/offset to get pagination result.
        /// Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        /// separately using 'GET /datamap/api/atlas/v2/glossary/{glossaryId}/terms'
        /// and 'GET '/datamap/api/atlas/v2/glossary/{glossaryId}/categories'.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> BatchGetAsync(int? limit, int? offset, string sort, bool? ignoreTermsAndCategories, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.BatchGet");
            scope.Start();
            try
            {
                using HttpMessage message = CreateBatchGetRequest(limit, offset, sort, ignoreTermsAndCategories, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get all glossaries. Recommend using limit/offset to get pagination result.
        /// Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        /// separately using 'GET /datamap/api/atlas/v2/glossary/{glossaryId}/terms'
        /// and 'GET '/datamap/api/atlas/v2/glossary/{glossaryId}/categories'.
        /// </summary>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasGlossary>> BatchGet(int? limit = default, int? offset = default, string sort = default, bool? ignoreTermsAndCategories = default, CancellationToken cancellationToken = default)
        {
            Response result = BatchGet(limit, offset, sort, ignoreTermsAndCategories, cancellationToken.ToRequestContext());
            List<AtlasGlossary> value = new List<AtlasGlossary>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossary.DeserializeAtlasGlossary(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossary>)value, result);
        }

        /// <summary>
        /// Get all glossaries. Recommend using limit/offset to get pagination result.
        /// Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        /// separately using 'GET /datamap/api/atlas/v2/glossary/{glossaryId}/terms'
        /// and 'GET '/datamap/api/atlas/v2/glossary/{glossaryId}/categories'.
        /// </summary>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasGlossary>>> BatchGetAsync(int? limit = default, int? offset = default, string sort = default, bool? ignoreTermsAndCategories = default, CancellationToken cancellationToken = default)
        {
            Response result = await BatchGetAsync(limit, offset, sort, ignoreTermsAndCategories, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasGlossary> value = new List<AtlasGlossary>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossary.DeserializeAtlasGlossary(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossary>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Create a glossary.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response Create(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.Create");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateRequest(content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a glossary.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateAsync(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.Create");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateRequest(content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a glossary. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossary> Create(AtlasGlossary body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = Create(body, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossary)result, result);
        }

        /// <summary> Create a glossary. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossary>> CreateAsync(AtlasGlossary body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = await CreateAsync(body, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossary)result, result);
        }

        /// <summary>
        /// [Protocol Method] Create glossary category in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateCategories(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.CreateCategories");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateCategoriesRequest(content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create glossary category in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateCategoriesAsync(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.CreateCategories");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateCategoriesRequest(content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create glossary category in bulk. </summary>
        /// <param name="body"> An array of glossary category definitions to be created. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasGlossaryCategory>> CreateCategories(IEnumerable<AtlasGlossaryCategory> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            Response result = CreateCategories(content, cancellationToken.ToRequestContext());
            List<AtlasGlossaryCategory> value = new List<AtlasGlossaryCategory>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossaryCategory.DeserializeAtlasGlossaryCategory(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossaryCategory>)value, result);
        }

        /// <summary> Create glossary category in bulk. </summary>
        /// <param name="body"> An array of glossary category definitions to be created. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasGlossaryCategory>>> CreateCategoriesAsync(IEnumerable<AtlasGlossaryCategory> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            Response result = await CreateCategoriesAsync(content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasGlossaryCategory> value = new List<AtlasGlossaryCategory>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossaryCategory.DeserializeAtlasGlossaryCategory(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossaryCategory>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Create a glossary category.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateCategory(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.CreateCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateCategoryRequest(content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a glossary category.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateCategoryAsync(RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.CreateCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateCategoryRequest(content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a glossary category. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryCategory> CreateCategory(AtlasGlossaryCategory body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = CreateCategory(body, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryCategory)result, result);
        }

        /// <summary> Create a glossary category. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryCategory>> CreateCategoryAsync(AtlasGlossaryCategory body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = await CreateCategoryAsync(body, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryCategory)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get specific glossary category by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCategory(string categoryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

                using HttpMessage message = CreateGetCategoryRequest(categoryId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get specific glossary category by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCategoryAsync(string categoryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

                using HttpMessage message = CreateGetCategoryRequest(categoryId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get specific glossary category by its GUID. </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryCategory> GetCategory(string categoryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

            Response result = GetCategory(categoryId, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryCategory)result, result);
        }

        /// <summary> Get specific glossary category by its GUID. </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryCategory>> GetCategoryAsync(string categoryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

            Response result = await GetCategoryAsync(categoryId, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryCategory)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary category by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response UpdateCategory(string categoryId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.UpdateCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateCategoryRequest(categoryId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary category by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> UpdateCategoryAsync(string categoryId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.UpdateCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateCategoryRequest(categoryId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update the given glossary category by its GUID. </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryCategory> UpdateCategory(string categoryId, AtlasGlossaryCategory body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = UpdateCategory(categoryId, body, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryCategory)result, result);
        }

        /// <summary> Update the given glossary category by its GUID. </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryCategory>> UpdateCategoryAsync(string categoryId, AtlasGlossaryCategory body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await UpdateCategoryAsync(categoryId, body, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryCategory)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete a glossary category.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteCategory(string categoryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.DeleteCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

                using HttpMessage message = CreateDeleteCategoryRequest(categoryId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a glossary category.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteCategoryAsync(string categoryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.DeleteCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

                using HttpMessage message = CreateDeleteCategoryRequest(categoryId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a glossary category. </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response DeleteCategory(string categoryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

            return DeleteCategory(categoryId, cancellationToken.ToRequestContext());
        }

        /// <summary> Delete a glossary category. </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> DeleteCategoryAsync(string categoryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

            return await DeleteCategoryAsync(categoryId, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Update the glossary category partially. So far we only supports partial
        /// updating shortDescription and longDescription for category.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response PartialUpdateCategory(string categoryId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdateCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreatePartialUpdateCategoryRequest(categoryId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the glossary category partially. So far we only supports partial
        /// updating shortDescription and longDescription for category.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> PartialUpdateCategoryAsync(string categoryId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdateCategory");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreatePartialUpdateCategoryRequest(categoryId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update the glossary category partially. So far we only supports partial
        /// updating shortDescription and longDescription for category.
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="body">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values for partial update.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryCategory> PartialUpdateCategory(string categoryId, IDictionary<string, string> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            Response result = PartialUpdateCategory(categoryId, content, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryCategory)result, result);
        }

        /// <summary>
        /// Update the glossary category partially. So far we only supports partial
        /// updating shortDescription and longDescription for category.
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="body">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values for partial update.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryCategory>> PartialUpdateCategoryAsync(string categoryId, IDictionary<string, string> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            Response result = await PartialUpdateCategoryAsync(categoryId, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryCategory)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get all related categories (parent and children). Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetRelatedCategories(string categoryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetRelatedCategories");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

                using HttpMessage message = CreateGetRelatedCategoriesRequest(categoryId, limit, offset, sort, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all related categories (parent and children). Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetRelatedCategoriesAsync(string categoryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetRelatedCategories");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

                using HttpMessage message = CreateGetRelatedCategoriesRequest(categoryId, limit, offset, sort, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get all related categories (parent and children). Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyDictionary<string, IList<AtlasRelatedCategoryHeader>>> GetRelatedCategories(string categoryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

            Response result = GetRelatedCategories(categoryId, limit, offset, sort, cancellationToken.ToRequestContext());
            IDictionary<string, IList<AtlasRelatedCategoryHeader>> value = new Dictionary<string, IList<AtlasRelatedCategoryHeader>>();
            BinaryData data = result.Content;
            return Response.FromValue((IReadOnlyDictionary<string, IList<AtlasRelatedCategoryHeader>>)value, result);
        }

        /// <summary>
        /// Get all related categories (parent and children). Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyDictionary<string, IList<AtlasRelatedCategoryHeader>>>> GetRelatedCategoriesAsync(string categoryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

            Response result = await GetRelatedCategoriesAsync(categoryId, limit, offset, sort, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            IDictionary<string, IList<AtlasRelatedCategoryHeader>> value = new Dictionary<string, IList<AtlasRelatedCategoryHeader>>();
            BinaryData data = result.Content;
            return Response.FromValue((IReadOnlyDictionary<string, IList<AtlasRelatedCategoryHeader>>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Get all terms associated with the specific category.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCategoryTerms(string categoryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetCategoryTerms");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

                using HttpMessage message = CreateGetCategoryTermsRequest(categoryId, limit, offset, sort, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all terms associated with the specific category.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCategoryTermsAsync(string categoryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetCategoryTerms");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

                using HttpMessage message = CreateGetCategoryTermsRequest(categoryId, limit, offset, sort, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all terms associated with the specific category. </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasRelatedTermHeader>> GetCategoryTerms(string categoryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

            Response result = GetCategoryTerms(categoryId, limit, offset, sort, cancellationToken.ToRequestContext());
            List<AtlasRelatedTermHeader> value = new List<AtlasRelatedTermHeader>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasRelatedTermHeader>)value, result);
        }

        /// <summary> Get all terms associated with the specific category. </summary>
        /// <param name="categoryId"> The globally unique identifier of the category. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="categoryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="categoryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasRelatedTermHeader>>> GetCategoryTermsAsync(string categoryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(categoryId, nameof(categoryId));

            Response result = await GetCategoryTermsAsync(categoryId, limit, offset, sort, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasRelatedTermHeader> value = new List<AtlasRelatedTermHeader>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasRelatedTermHeader>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Create a glossary term.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateTerm(RequestContent content, bool? includeTermHierarchy = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.CreateTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateTermRequest(content, includeTermHierarchy, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a glossary term.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateTermAsync(RequestContent content, bool? includeTermHierarchy = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.CreateTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateTermRequest(content, includeTermHierarchy, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a glossary term. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryTerm> CreateTerm(AtlasGlossaryTerm body, bool? includeTermHierarchy = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = CreateTerm(body, includeTermHierarchy, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryTerm)result, result);
        }

        /// <summary> Create a glossary term. </summary>
        /// <param name="body"> Body parameter. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryTerm>> CreateTermAsync(AtlasGlossaryTerm body, bool? includeTermHierarchy = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            Response result = await CreateTermAsync(body, includeTermHierarchy, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryTerm)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get a specific glossary term by its GUID. 
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetTerm(string termId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));

                using HttpMessage message = CreateGetTermRequest(termId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a specific glossary term by its GUID. 
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetTermAsync(string termId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));

                using HttpMessage message = CreateGetTermRequest(termId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a specific glossary term by its GUID. . </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryTerm> GetTerm(string termId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));

            Response result = GetTerm(termId, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryTerm)result, result);
        }

        /// <summary> Get a specific glossary term by its GUID. . </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryTerm>> GetTermAsync(string termId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));

            Response result = await GetTermAsync(termId, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryTerm)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary term by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response UpdateTerm(string termId, RequestContent content, bool? includeTermHierarchy = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.UpdateTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateTermRequest(termId, content, includeTermHierarchy, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary term by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> UpdateTermAsync(string termId, RequestContent content, bool? includeTermHierarchy = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.UpdateTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateTermRequest(termId, content, includeTermHierarchy, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update the given glossary term by its GUID. </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryTerm> UpdateTerm(string termId, AtlasGlossaryTerm body, bool? includeTermHierarchy = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = UpdateTerm(termId, body, includeTermHierarchy, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryTerm)result, result);
        }

        /// <summary> Update the given glossary term by its GUID. </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryTerm>> UpdateTermAsync(string termId, AtlasGlossaryTerm body, bool? includeTermHierarchy = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await UpdateTermAsync(termId, body, includeTermHierarchy, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryTerm)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete a glossary term.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteTerm(string termId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.DeleteTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));

                using HttpMessage message = CreateDeleteTermRequest(termId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a glossary term.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteTermAsync(string termId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.DeleteTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));

                using HttpMessage message = CreateDeleteTermRequest(termId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a glossary term. </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response DeleteTerm(string termId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));

            return DeleteTerm(termId, cancellationToken.ToRequestContext());
        }

        /// <summary> Delete a glossary term. </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> DeleteTermAsync(string termId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));

            return await DeleteTermAsync(termId, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Update the glossary term partially. So far we only supports partial updating
        /// shortDescription, longDescription, abbreviation, usage and status for term.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response PartialUpdateTerm(string termId, RequestContent content, bool? includeTermHierarchy = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdateTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreatePartialUpdateTermRequest(termId, content, includeTermHierarchy, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the glossary term partially. So far we only supports partial updating
        /// shortDescription, longDescription, abbreviation, usage and status for term.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> PartialUpdateTermAsync(string termId, RequestContent content, bool? includeTermHierarchy = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdateTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreatePartialUpdateTermRequest(termId, content, includeTermHierarchy, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update the glossary term partially. So far we only supports partial updating
        /// shortDescription, longDescription, abbreviation, usage and status for term.
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="body">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values to be updated.
        /// </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryTerm> PartialUpdateTerm(string termId, IDictionary<string, string> body, bool? includeTermHierarchy = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            Response result = PartialUpdateTerm(termId, content, includeTermHierarchy, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryTerm)result, result);
        }

        /// <summary>
        /// Update the glossary term partially. So far we only supports partial updating
        /// shortDescription, longDescription, abbreviation, usage and status for term.
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="body">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values to be updated.
        /// </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryTerm>> PartialUpdateTermAsync(string termId, IDictionary<string, string> body, bool? includeTermHierarchy = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            Response result = await PartialUpdateTermAsync(termId, content, includeTermHierarchy, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryTerm)result, result);
        }

        /// <summary>
        /// [Protocol Method] Create glossary terms in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response CreateTerms(RequestContent content, bool? includeTermHierarchy = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.CreateTerms");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateTermsRequest(content, includeTermHierarchy, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create glossary terms in bulk.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> CreateTermsAsync(RequestContent content, bool? includeTermHierarchy = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.CreateTerms");
            scope.Start();
            try
            {
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateCreateTermsRequest(content, includeTermHierarchy, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create glossary terms in bulk. </summary>
        /// <param name="body"> An array of glossary term definitions to be created in bulk. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasGlossaryTerm>> CreateTerms(IEnumerable<AtlasGlossaryTerm> body, bool? includeTermHierarchy = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            Response result = CreateTerms(content, includeTermHierarchy, cancellationToken.ToRequestContext());
            List<AtlasGlossaryTerm> value = new List<AtlasGlossaryTerm>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossaryTerm.DeserializeAtlasGlossaryTerm(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossaryTerm>)value, result);
        }

        /// <summary> Create glossary terms in bulk. </summary>
        /// <param name="body"> An array of glossary term definitions to be created in bulk. </param>
        /// <param name="includeTermHierarchy"> Whether include term hierarchy. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasGlossaryTerm>>> CreateTermsAsync(IEnumerable<AtlasGlossaryTerm> body, bool? includeTermHierarchy = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            Response result = await CreateTermsAsync(content, includeTermHierarchy, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasGlossaryTerm> value = new List<AtlasGlossaryTerm>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossaryTerm.DeserializeAtlasGlossaryTerm(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossaryTerm>)value, result);
        }

        /// <summary>
        /// [Protocol Method] List all related objects assigned with the specified term. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetEntitiesAssignedWithTerm(string termId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetEntitiesAssignedWithTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));

                using HttpMessage message = CreateGetEntitiesAssignedWithTermRequest(termId, limit, offset, sort, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all related objects assigned with the specified term. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetEntitiesAssignedWithTermAsync(string termId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetEntitiesAssignedWithTerm");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));

                using HttpMessage message = CreateGetEntitiesAssignedWithTermRequest(termId, limit, offset, sort, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List all related objects assigned with the specified term. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasRelatedObjectId>> GetEntitiesAssignedWithTerm(string termId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));

            Response result = GetEntitiesAssignedWithTerm(termId, limit, offset, sort, cancellationToken.ToRequestContext());
            List<AtlasRelatedObjectId> value = new List<AtlasRelatedObjectId>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasRelatedObjectId.DeserializeAtlasRelatedObjectId(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasRelatedObjectId>)value, result);
        }

        /// <summary>
        /// List all related objects assigned with the specified term. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasRelatedObjectId>>> GetEntitiesAssignedWithTermAsync(string termId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));

            Response result = await GetEntitiesAssignedWithTermAsync(termId, limit, offset, sort, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasRelatedObjectId> value = new List<AtlasRelatedObjectId>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasRelatedObjectId.DeserializeAtlasRelatedObjectId(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasRelatedObjectId>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Assign the given term to the provided list of related objects. Recommend using
        /// small batches with multiple API calls.
        /// [Entities Create Or Update
        /// operation](https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP)
        /// is an alternative to assign a term to multiple entities.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response AssignTermToEntities(string termId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.AssignTermToEntities");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAssignTermToEntitiesRequest(termId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Assign the given term to the provided list of related objects. Recommend using
        /// small batches with multiple API calls.
        /// [Entities Create Or Update
        /// operation](https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP)
        /// is an alternative to assign a term to multiple entities.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> AssignTermToEntitiesAsync(string termId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.AssignTermToEntities");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateAssignTermToEntitiesRequest(termId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Assign the given term to the provided list of related objects. Recommend using
        /// small batches with multiple API calls.
        /// [Entities Create Or Update
        /// operation](https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP)
        /// is an alternative to assign a term to multiple entities.
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="body"> An array of related object IDs to which the term has to be associated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response AssignTermToEntities(string termId, IEnumerable<AtlasRelatedObjectId> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return AssignTermToEntities(termId, content, cancellationToken.ToRequestContext());
        }

        /// <summary>
        /// Assign the given term to the provided list of related objects. Recommend using
        /// small batches with multiple API calls.
        /// [Entities Create Or Update
        /// operation](https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP)
        /// is an alternative to assign a term to multiple entities.
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="body"> An array of related object IDs to which the term has to be associated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> AssignTermToEntitiesAsync(string termId, IEnumerable<AtlasRelatedObjectId> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await AssignTermToEntitiesAsync(termId, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Delete the term assignment for the given list of related objects.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteTermAssignmentFromEntities(string termId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.DeleteTermAssignmentFromEntities");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateDeleteTermAssignmentFromEntitiesRequest(termId, content, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete the term assignment for the given list of related objects.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteTermAssignmentFromEntitiesAsync(string termId, RequestContent content, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.DeleteTermAssignmentFromEntities");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateDeleteTermAssignmentFromEntitiesRequest(termId, content, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete the term assignment for the given list of related objects. </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="body"> An array of related object IDs from which the term has to be dissociated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response DeleteTermAssignmentFromEntities(string termId, IEnumerable<AtlasRelatedObjectId> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return DeleteTermAssignmentFromEntities(termId, content, cancellationToken.ToRequestContext());
        }

        /// <summary> Delete the term assignment for the given list of related objects. </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="body"> An array of related object IDs from which the term has to be dissociated. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> DeleteTermAssignmentFromEntitiesAsync(string termId, IEnumerable<AtlasRelatedObjectId> body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromEnumerable(body);
            return await DeleteTermAssignmentFromEntitiesAsync(termId, content, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get all related terms for a specific term by its GUID. Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetRelatedTerms(string termId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetRelatedTerms");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));

                using HttpMessage message = CreateGetRelatedTermsRequest(termId, limit, offset, sort, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get all related terms for a specific term by its GUID. Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetRelatedTermsAsync(string termId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetRelatedTerms");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(termId, nameof(termId));

                using HttpMessage message = CreateGetRelatedTermsRequest(termId, limit, offset, sort, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get all related terms for a specific term by its GUID. Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyDictionary<string, IList<AtlasRelatedTermHeader>>> GetRelatedTerms(string termId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));

            Response result = GetRelatedTerms(termId, limit, offset, sort, cancellationToken.ToRequestContext());
            IDictionary<string, IList<AtlasRelatedTermHeader>> value = new Dictionary<string, IList<AtlasRelatedTermHeader>>();
            BinaryData data = result.Content;
            return Response.FromValue((IReadOnlyDictionary<string, IList<AtlasRelatedTermHeader>>)value, result);
        }

        /// <summary>
        /// Get all related terms for a specific term by its GUID. Limit, offset, and sort
        /// parameters are currently not being enabled and won't work even they are passed.
        /// </summary>
        /// <param name="termId"> The globally unique identifier for glossary term. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="termId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="termId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyDictionary<string, IList<AtlasRelatedTermHeader>>>> GetRelatedTermsAsync(string termId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(termId, nameof(termId));

            Response result = await GetRelatedTermsAsync(termId, limit, offset, sort, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            IDictionary<string, IList<AtlasRelatedTermHeader>> value = new Dictionary<string, IList<AtlasRelatedTermHeader>>();
            BinaryData data = result.Content;
            return Response.FromValue((IReadOnlyDictionary<string, IList<AtlasRelatedTermHeader>>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Get a specific Glossary by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetGlossary(string glossaryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetGlossary");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetGlossaryRequest(glossaryId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a specific Glossary by its GUID.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetGlossaryAsync(string glossaryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetGlossary");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetGlossaryRequest(glossaryId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a specific Glossary by its GUID. </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossary> GetGlossary(string glossaryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = GetGlossary(glossaryId, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossary)result, result);
        }

        /// <summary> Get a specific Glossary by its GUID. </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossary>> GetGlossaryAsync(string glossaryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = await GetGlossaryAsync(glossaryId, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossary)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response Update(string glossaryId, RequestContent content, bool? ignoreTermsAndCategories = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.Update");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateRequest(glossaryId, content, ignoreTermsAndCategories, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the given glossary.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> UpdateAsync(string glossaryId, RequestContent content, bool? ignoreTermsAndCategories = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.Update");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreateUpdateRequest(glossaryId, content, ignoreTermsAndCategories, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update the given glossary. </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossary> Update(string glossaryId, AtlasGlossary body, bool? ignoreTermsAndCategories = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = Update(glossaryId, body, ignoreTermsAndCategories, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossary)result, result);
        }

        /// <summary> Update the given glossary. </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="body"> Body parameter. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossary>> UpdateAsync(string glossaryId, AtlasGlossary body, bool? ignoreTermsAndCategories = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));
            Argument.AssertNotNull(body, nameof(body));

            Response result = await UpdateAsync(glossaryId, body, ignoreTermsAndCategories, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossary)result, result);
        }

        /// <summary>
        /// [Protocol Method] Delete a glossary. Will delete underlying terms/categories together. Recommend
        /// separate delete terms and categories.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response Delete(string glossaryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.Delete");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateDeleteRequest(glossaryId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a glossary. Will delete underlying terms/categories together. Recommend
        /// separate delete terms and categories.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteAsync(string glossaryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.Delete");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateDeleteRequest(glossaryId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a glossary. Will delete underlying terms/categories together. Recommend
        /// separate delete terms and categories.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response Delete(string glossaryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            return Delete(glossaryId, cancellationToken.ToRequestContext());
        }

        /// <summary>
        /// Delete a glossary. Will delete underlying terms/categories together. Recommend
        /// separate delete terms and categories.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response> DeleteAsync(string glossaryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            return await DeleteAsync(glossaryId, cancellationToken.ToRequestContext()).ConfigureAwait(false);
        }

        /// <summary>
        /// [Protocol Method] Get the categories belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCategories(string glossaryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetCategories");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetCategoriesRequest(glossaryId, limit, offset, sort, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the categories belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCategoriesAsync(string glossaryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetCategories");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetCategoriesRequest(glossaryId, limit, offset, sort, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the categories belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasGlossaryCategory>> GetCategories(string glossaryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = GetCategories(glossaryId, limit, offset, sort, cancellationToken.ToRequestContext());
            List<AtlasGlossaryCategory> value = new List<AtlasGlossaryCategory>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossaryCategory.DeserializeAtlasGlossaryCategory(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossaryCategory>)value, result);
        }

        /// <summary>
        /// Get the categories belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasGlossaryCategory>>> GetCategoriesAsync(string glossaryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = await GetCategoriesAsync(glossaryId, limit, offset, sort, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasGlossaryCategory> value = new List<AtlasGlossaryCategory>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossaryCategory.DeserializeAtlasGlossaryCategory(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossaryCategory>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Get the category headers belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetCategoriesHeaders(string glossaryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetCategoriesHeaders");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetCategoriesHeadersRequest(glossaryId, limit, offset, sort, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get the category headers belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetCategoriesHeadersAsync(string glossaryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetCategoriesHeaders");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetCategoriesHeadersRequest(glossaryId, limit, offset, sort, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the category headers belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasRelatedCategoryHeader>> GetCategoriesHeaders(string glossaryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = GetCategoriesHeaders(glossaryId, limit, offset, sort, cancellationToken.ToRequestContext());
            List<AtlasRelatedCategoryHeader> value = new List<AtlasRelatedCategoryHeader>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasRelatedCategoryHeader.DeserializeAtlasRelatedCategoryHeader(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasRelatedCategoryHeader>)value, result);
        }

        /// <summary>
        /// Get the category headers belonging to a specific glossary. Recommend using
        /// limit/offset to get pagination result.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasRelatedCategoryHeader>>> GetCategoriesHeadersAsync(string glossaryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = await GetCategoriesHeadersAsync(glossaryId, limit, offset, sort, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasRelatedCategoryHeader> value = new List<AtlasRelatedCategoryHeader>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasRelatedCategoryHeader.DeserializeAtlasRelatedCategoryHeader(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasRelatedCategoryHeader>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Get a specific glossary with detailed information. This API is not
        /// recommend.
        /// Recommend to fetch terms/categories details separately using 
        /// GET /datamap/api/atlas/v2/glossary/{glossaryId}/terms and 
        /// GET /datamap/api/atlas/v2/glossary/{glossaryId}/categories.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetDetailed(string glossaryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetDetailed");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetDetailedRequest(glossaryId, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get a specific glossary with detailed information. This API is not
        /// recommend.
        /// Recommend to fetch terms/categories details separately using 
        /// GET /datamap/api/atlas/v2/glossary/{glossaryId}/terms and 
        /// GET /datamap/api/atlas/v2/glossary/{glossaryId}/categories.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetDetailedAsync(string glossaryId, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetDetailed");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetDetailedRequest(glossaryId, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a specific glossary with detailed information. This API is not
        /// recommend.
        /// Recommend to fetch terms/categories details separately using 
        /// GET /datamap/api/atlas/v2/glossary/{glossaryId}/terms and 
        /// GET /datamap/api/atlas/v2/glossary/{glossaryId}/categories.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossaryExtInfo> GetDetailed(string glossaryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = GetDetailed(glossaryId, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossaryExtInfo)result, result);
        }

        /// <summary>
        /// Get a specific glossary with detailed information. This API is not
        /// recommend.
        /// Recommend to fetch terms/categories details separately using 
        /// GET /datamap/api/atlas/v2/glossary/{glossaryId}/terms and 
        /// GET /datamap/api/atlas/v2/glossary/{glossaryId}/categories.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossaryExtInfo>> GetDetailedAsync(string glossaryId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = await GetDetailedAsync(glossaryId, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossaryExtInfo)result, result);
        }

        /// <summary>
        /// [Protocol Method] Update the glossary partially. Some properties such as qualifiedName are not
        /// allowed to be updated.
        /// So far we only supports partial updating
        /// shortDescription, longDescription, language and usage for glossary. 
        /// Recommend
        /// using 'ignoreTermsAndCategories=true' to reduce response body size.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response PartialUpdate(string glossaryId, RequestContent content, bool? ignoreTermsAndCategories = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdate");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreatePartialUpdateRequest(glossaryId, content, ignoreTermsAndCategories, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the glossary partially. Some properties such as qualifiedName are not
        /// allowed to be updated.
        /// So far we only supports partial updating
        /// shortDescription, longDescription, language and usage for glossary. 
        /// Recommend
        /// using 'ignoreTermsAndCategories=true' to reduce response body size.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> PartialUpdateAsync(string glossaryId, RequestContent content, bool? ignoreTermsAndCategories = default, RequestContext context = null)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.PartialUpdate");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));
                Argument.AssertNotNull(content, nameof(content));

                using HttpMessage message = CreatePartialUpdateRequest(glossaryId, content, ignoreTermsAndCategories, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update the glossary partially. Some properties such as qualifiedName are not
        /// allowed to be updated.
        /// So far we only supports partial updating
        /// shortDescription, longDescription, language and usage for glossary. 
        /// Recommend
        /// using 'ignoreTermsAndCategories=true' to reduce response body size.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="body">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values.
        /// </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<AtlasGlossary> PartialUpdate(string glossaryId, IDictionary<string, string> body, bool? ignoreTermsAndCategories = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            Response result = PartialUpdate(glossaryId, content, ignoreTermsAndCategories, cancellationToken.ToRequestContext());
            return Response.FromValue((AtlasGlossary)result, result);
        }

        /// <summary>
        /// Update the glossary partially. Some properties such as qualifiedName are not
        /// allowed to be updated.
        /// So far we only supports partial updating
        /// shortDescription, longDescription, language and usage for glossary. 
        /// Recommend
        /// using 'ignoreTermsAndCategories=true' to reduce response body size.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="body">
        /// A map containing keys as attribute names and values as corresponding attribute
        /// values.
        /// </param>
        /// <param name="ignoreTermsAndCategories"> Whether ignore terms and categories. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<AtlasGlossary>> PartialUpdateAsync(string glossaryId, IDictionary<string, string> body, bool? ignoreTermsAndCategories = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));
            Argument.AssertNotNull(body, nameof(body));

            using RequestContent content = BinaryContentHelper.FromDictionary(body);
            Response result = await PartialUpdateAsync(glossaryId, content, ignoreTermsAndCategories, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            return Response.FromValue((AtlasGlossary)result, result);
        }

        /// <summary>
        /// [Protocol Method] Get terms belonging to a specific glossary. Recommend using limit/offset to get
        /// pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetTerms(string glossaryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetTerms");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetTermsRequest(glossaryId, limit, offset, sort, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get terms belonging to a specific glossary. Recommend using limit/offset to get
        /// pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetTermsAsync(string glossaryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetTerms");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetTermsRequest(glossaryId, limit, offset, sort, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get terms belonging to a specific glossary. Recommend using limit/offset to get
        /// pagination result.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasGlossaryTerm>> GetTerms(string glossaryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = GetTerms(glossaryId, limit, offset, sort, cancellationToken.ToRequestContext());
            List<AtlasGlossaryTerm> value = new List<AtlasGlossaryTerm>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossaryTerm.DeserializeAtlasGlossaryTerm(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossaryTerm>)value, result);
        }

        /// <summary>
        /// Get terms belonging to a specific glossary. Recommend using limit/offset to get
        /// pagination result.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasGlossaryTerm>>> GetTermsAsync(string glossaryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = await GetTermsAsync(glossaryId, limit, offset, sort, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasGlossaryTerm> value = new List<AtlasGlossaryTerm>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasGlossaryTerm.DeserializeAtlasGlossaryTerm(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasGlossaryTerm>)value, result);
        }

        /// <summary>
        /// [Protocol Method] Get term headers belonging to a specific glossary. Recommend using limit/offset
        /// to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response GetTermHeaders(string glossaryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetTermHeaders");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetTermHeadersRequest(glossaryId, limit, offset, sort, context);
                return Pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Get term headers belonging to a specific glossary. Recommend using limit/offset
        /// to get pagination result.
        /// <list type="bullet">
        /// <item>
        /// <description> This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="context"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> GetTermHeadersAsync(string glossaryId, int? limit, int? offset, string sort, RequestContext context)
        {
            using DiagnosticScope scope = ClientDiagnostics.CreateScope("Glossary.GetTermHeaders");
            scope.Start();
            try
            {
                Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

                using HttpMessage message = CreateGetTermHeadersRequest(glossaryId, limit, offset, sort, context);
                return await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get term headers belonging to a specific glossary. Recommend using limit/offset
        /// to get pagination result.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual Response<IReadOnlyList<AtlasRelatedTermHeader>> GetTermHeaders(string glossaryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = GetTermHeaders(glossaryId, limit, offset, sort, cancellationToken.ToRequestContext());
            List<AtlasRelatedTermHeader> value = new List<AtlasRelatedTermHeader>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasRelatedTermHeader>)value, result);
        }

        /// <summary>
        /// Get term headers belonging to a specific glossary. Recommend using limit/offset
        /// to get pagination result.
        /// </summary>
        /// <param name="glossaryId"> The globally unique identifier for glossary. </param>
        /// <param name="limit"> The page size - by default there is no paging. </param>
        /// <param name="offset"> The offset for pagination purpose. </param>
        /// <param name="sort"> The sort order, ASC (default) or DESC. </param>
        /// <param name="cancellationToken"> The cancellation token that can be used to cancel the operation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="glossaryId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="glossaryId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        public virtual async Task<Response<IReadOnlyList<AtlasRelatedTermHeader>>> GetTermHeadersAsync(string glossaryId, int? limit = default, int? offset = default, string sort = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(glossaryId, nameof(glossaryId));

            Response result = await GetTermHeadersAsync(glossaryId, limit, offset, sort, cancellationToken.ToRequestContext()).ConfigureAwait(false);
            List<AtlasRelatedTermHeader> value = new List<AtlasRelatedTermHeader>();
            BinaryData data = result.Content;
            using JsonDocument document = JsonDocument.Parse(data);
            foreach (var item in document.RootElement.EnumerateArray())
            {
                value.Add(AtlasRelatedTermHeader.DeserializeAtlasRelatedTermHeader(item, ModelSerializationExtensions.WireOptions));
            }
            return Response.FromValue((IReadOnlyList<AtlasRelatedTermHeader>)value, result);
        }
    }
}
