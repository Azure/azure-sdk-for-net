// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Analytics.Purview.Catalog.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.Purview.Catalog
{
    internal partial class PurviewEntityRestClient
    {
        private Uri endpoint;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of PurviewEntityRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> The catalog endpoint of your Purview account. Example: https://{accountName}.purview.azure.com. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public PurviewEntityRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint)
        {
            this.endpoint = endpoint ?? throw new ArgumentNullException(nameof(endpoint));
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(AtlasEntityWithExtInfo entity)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(entity);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// Create or update an entity in Atlas.
        /// Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
        /// </summary>
        /// <param name="entity"> Atlas entity with extended information. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entity"/> is null. </exception>
        public async Task<Response<EntityMutationResponse>> CreateOrUpdateAsync(AtlasEntityWithExtInfo entity, CancellationToken cancellationToken = default)
        {
            if (entity == null)
            {
                throw new ArgumentNullException(nameof(entity));
            }

            using var message = CreateCreateOrUpdateRequest(entity);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Create or update an entity in Atlas.
        /// Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
        /// </summary>
        /// <param name="entity"> Atlas entity with extended information. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entity"/> is null. </exception>
        public Response<EntityMutationResponse> CreateOrUpdate(AtlasEntityWithExtInfo entity, CancellationToken cancellationToken = default)
        {
            if (entity == null)
            {
                throw new ArgumentNullException(nameof(entity));
            }

            using var message = CreateCreateOrUpdateRequest(entity);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetByGuidsRequest(IEnumerable<string> guids, bool? minExtInfo, bool? ignoreRelationships, IEnumerable<string> excludeRelationshipTypes)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk", false);
            foreach (var param in guids)
            {
                uri.AppendQuery("guids", param, true);
            }
            if (minExtInfo != null)
            {
                uri.AppendQuery("minExtInfo", minExtInfo.Value, true);
            }
            if (ignoreRelationships != null)
            {
                uri.AppendQuery("ignoreRelationships", ignoreRelationships.Value, true);
            }
            if (excludeRelationshipTypes != null)
            {
                foreach (var param0 in excludeRelationshipTypes)
                {
                    uri.AppendQuery("excludeRelationshipTypes", param0, true);
                }
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> List entities in bulk identified by its GUIDs. </summary>
        /// <param name="guids"> An array of GUIDs of entities to create. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="excludeRelationshipTypes"> An array of the relationship types need to be excluded from the response. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guids"/> is null. </exception>
        public async Task<Response<AtlasEntitiesWithExtInfo>> GetByGuidsAsync(IEnumerable<string> guids, bool? minExtInfo = null, bool? ignoreRelationships = null, IEnumerable<string> excludeRelationshipTypes = null, CancellationToken cancellationToken = default)
        {
            if (guids == null)
            {
                throw new ArgumentNullException(nameof(guids));
            }

            using var message = CreateGetByGuidsRequest(guids, minExtInfo, ignoreRelationships, excludeRelationshipTypes);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntitiesWithExtInfo value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = AtlasEntitiesWithExtInfo.DeserializeAtlasEntitiesWithExtInfo(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> List entities in bulk identified by its GUIDs. </summary>
        /// <param name="guids"> An array of GUIDs of entities to create. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="excludeRelationshipTypes"> An array of the relationship types need to be excluded from the response. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guids"/> is null. </exception>
        public Response<AtlasEntitiesWithExtInfo> GetByGuids(IEnumerable<string> guids, bool? minExtInfo = null, bool? ignoreRelationships = null, IEnumerable<string> excludeRelationshipTypes = null, CancellationToken cancellationToken = default)
        {
            if (guids == null)
            {
                throw new ArgumentNullException(nameof(guids));
            }

            using var message = CreateGetByGuidsRequest(guids, minExtInfo, ignoreRelationships, excludeRelationshipTypes);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntitiesWithExtInfo value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = AtlasEntitiesWithExtInfo.DeserializeAtlasEntitiesWithExtInfo(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCreateOrUpdateEntitiesRequest(AtlasEntitiesWithExtInfo entities)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(entities);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// Create or update entities in Atlas in bulk.
        /// Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
        /// </summary>
        /// <param name="entities"> An array of entities to create or update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entities"/> is null. </exception>
        public async Task<Response<EntityMutationResponse>> CreateOrUpdateEntitiesAsync(AtlasEntitiesWithExtInfo entities, CancellationToken cancellationToken = default)
        {
            if (entities == null)
            {
                throw new ArgumentNullException(nameof(entities));
            }

            using var message = CreateCreateOrUpdateEntitiesRequest(entities);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Create or update entities in Atlas in bulk.
        /// Existing entity is matched using its unique guid if supplied or by its unique attributes eg: qualifiedName.
        /// Map and array of collections are not well supported. E.g., array&lt;array&lt;int&gt;&gt;, array&lt;map&lt;string, int&gt;&gt;.
        /// </summary>
        /// <param name="entities"> An array of entities to create or update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entities"/> is null. </exception>
        public Response<EntityMutationResponse> CreateOrUpdateEntities(AtlasEntitiesWithExtInfo entities, CancellationToken cancellationToken = default)
        {
            if (entities == null)
            {
                throw new ArgumentNullException(nameof(entities));
            }

            using var message = CreateCreateOrUpdateEntitiesRequest(entities);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteByGuidsRequest(IEnumerable<string> guids)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk", false);
            foreach (var param in guids)
            {
                uri.AppendQuery("guids", param, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Delete a list of entities in bulk identified by their GUIDs or unique attributes. </summary>
        /// <param name="guids"> An array of GUIDs of entities to delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guids"/> is null. </exception>
        public async Task<Response<EntityMutationResponse>> DeleteByGuidsAsync(IEnumerable<string> guids, CancellationToken cancellationToken = default)
        {
            if (guids == null)
            {
                throw new ArgumentNullException(nameof(guids));
            }

            using var message = CreateDeleteByGuidsRequest(guids);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Delete a list of entities in bulk identified by their GUIDs or unique attributes. </summary>
        /// <param name="guids"> An array of GUIDs of entities to delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guids"/> is null. </exception>
        public Response<EntityMutationResponse> DeleteByGuids(IEnumerable<string> guids, CancellationToken cancellationToken = default)
        {
            if (guids == null)
            {
                throw new ArgumentNullException(nameof(guids));
            }

            using var message = CreateDeleteByGuidsRequest(guids);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAddClassificationRequest(ClassificationAssociateRequest request)
        {
            var message = _pipeline.CreateMessage();
            var request0 = message.Request;
            request0.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk/classification", false);
            request0.Uri = uri;
            request0.Headers.Add("Accept", "application/json");
            request0.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(request);
            request0.Content = content;
            return message;
        }

        /// <summary> Associate a classification to multiple entities in bulk. </summary>
        /// <param name="request"> The request to associate a classification to multiple entities. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="request"/> is null. </exception>
        public async Task<Response> AddClassificationAsync(ClassificationAssociateRequest request, CancellationToken cancellationToken = default)
        {
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }

            using var message = CreateAddClassificationRequest(request);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Associate a classification to multiple entities in bulk. </summary>
        /// <param name="request"> The request to associate a classification to multiple entities. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="request"/> is null. </exception>
        public Response AddClassification(ClassificationAssociateRequest request, CancellationToken cancellationToken = default)
        {
            if (request == null)
            {
                throw new ArgumentNullException(nameof(request));
            }

            using var message = CreateAddClassificationRequest(request);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetByGuidRequest(string guid, bool? minExtInfo, bool? ignoreRelationships)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            if (minExtInfo != null)
            {
                uri.AppendQuery("minExtInfo", minExtInfo.Value, true);
            }
            if (ignoreRelationships != null)
            {
                uri.AppendQuery("ignoreRelationships", ignoreRelationships.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Get complete definition of an entity given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        public async Task<Response<AtlasEntityWithExtInfo>> GetByGuidAsync(string guid, bool? minExtInfo = null, bool? ignoreRelationships = null, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }

            using var message = CreateGetByGuidRequest(guid, minExtInfo, ignoreRelationships);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntityWithExtInfo value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = AtlasEntityWithExtInfo.DeserializeAtlasEntityWithExtInfo(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get complete definition of an entity given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        public Response<AtlasEntityWithExtInfo> GetByGuid(string guid, bool? minExtInfo = null, bool? ignoreRelationships = null, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }

            using var message = CreateGetByGuidRequest(guid, minExtInfo, ignoreRelationships);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntityWithExtInfo value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = AtlasEntityWithExtInfo.DeserializeAtlasEntityWithExtInfo(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePartialUpdateEntityAttributeByGuidRequest(string guid, string name, object body)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendQuery("name", name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(body);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// Update entity partially - create or update entity attribute identified by its GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not support updating complex types like arrays, and maps.
        /// Null updates are not possible.
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="body"> The value of the attribute. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/>, or <paramref name="body"/> is null. </exception>
        public async Task<Response<EntityMutationResponse>> PartialUpdateEntityAttributeByGuidAsync(string guid, string name, object body, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (name == null)
            {
                throw new ArgumentNullException(nameof(name));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreatePartialUpdateEntityAttributeByGuidRequest(guid, name, body);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Update entity partially - create or update entity attribute identified by its GUID.
        /// Supports only primitive attribute type and entity references.
        /// It does not support updating complex types like arrays, and maps.
        /// Null updates are not possible.
        /// </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="name"> The name of the attribute. </param>
        /// <param name="body"> The value of the attribute. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/>, <paramref name="name"/>, or <paramref name="body"/> is null. </exception>
        public Response<EntityMutationResponse> PartialUpdateEntityAttributeByGuid(string guid, string name, object body, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (name == null)
            {
                throw new ArgumentNullException(nameof(name));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreatePartialUpdateEntityAttributeByGuidRequest(guid, name, body);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteByGuidRequest(string guid)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Delete an entity identified by its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        public async Task<Response<EntityMutationResponse>> DeleteByGuidAsync(string guid, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }

            using var message = CreateDeleteByGuidRequest(guid);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Delete an entity identified by its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        public Response<EntityMutationResponse> DeleteByGuid(string guid, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }

            using var message = CreateDeleteByGuidRequest(guid);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetClassificationRequest(string guid, string classificationName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classification/", false);
            uri.AppendPath(classificationName, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> List classifications for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        public async Task<Response<AtlasClassification>> GetClassificationAsync(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (classificationName == null)
            {
                throw new ArgumentNullException(nameof(classificationName));
            }

            using var message = CreateGetClassificationRequest(guid, classificationName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasClassification value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = AtlasClassification.DeserializeAtlasClassification(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> List classifications for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        public Response<AtlasClassification> GetClassification(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (classificationName == null)
            {
                throw new ArgumentNullException(nameof(classificationName));
            }

            using var message = CreateGetClassificationRequest(guid, classificationName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasClassification value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = AtlasClassification.DeserializeAtlasClassification(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteClassificationRequest(string guid, string classificationName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classification/", false);
            uri.AppendPath(classificationName, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Delete a given classification from an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        public async Task<Response> DeleteClassificationAsync(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (classificationName == null)
            {
                throw new ArgumentNullException(nameof(classificationName));
            }

            using var message = CreateDeleteClassificationRequest(guid, classificationName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Delete a given classification from an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classificationName"/> is null. </exception>
        public Response DeleteClassification(string guid, string classificationName, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (classificationName == null)
            {
                throw new ArgumentNullException(nameof(classificationName));
            }

            using var message = CreateDeleteClassificationRequest(guid, classificationName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetClassificationsRequest(string guid)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classifications", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> List classifications for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        public async Task<Response<AtlasClassifications>> GetClassificationsAsync(string guid, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }

            using var message = CreateGetClassificationsRequest(guid);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasClassifications value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = AtlasClassifications.DeserializeAtlasClassifications(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> List classifications for a given entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        public Response<AtlasClassifications> GetClassifications(string guid, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }

            using var message = CreateGetClassificationsRequest(guid);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasClassifications value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = AtlasClassifications.DeserializeAtlasClassifications(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAddClassificationsRequest(string guid, IEnumerable<AtlasClassification> classifications)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classifications", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteStartArray();
            foreach (var item in classifications)
            {
                content.JsonWriter.WriteObjectValue(item);
            }
            content.JsonWriter.WriteEndArray();
            request.Content = content;
            return message;
        }

        /// <summary> Add classifications to an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classifications"> An array of classifications to be added. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classifications"/> is null. </exception>
        public async Task<Response> AddClassificationsAsync(string guid, IEnumerable<AtlasClassification> classifications, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (classifications == null)
            {
                throw new ArgumentNullException(nameof(classifications));
            }

            using var message = CreateAddClassificationsRequest(guid, classifications);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Add classifications to an existing entity represented by a GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classifications"> An array of classifications to be added. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classifications"/> is null. </exception>
        public Response AddClassifications(string guid, IEnumerable<AtlasClassification> classifications, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (classifications == null)
            {
                throw new ArgumentNullException(nameof(classifications));
            }

            using var message = CreateAddClassificationsRequest(guid, classifications);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdateClassificationsRequest(string guid, IEnumerable<AtlasClassification> classifications)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/classifications", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteStartArray();
            foreach (var item in classifications)
            {
                content.JsonWriter.WriteObjectValue(item);
            }
            content.JsonWriter.WriteEndArray();
            request.Content = content;
            return message;
        }

        /// <summary> Update classifications to an existing entity represented by a guid. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classifications"> An array of classifications to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classifications"/> is null. </exception>
        public async Task<Response> UpdateClassificationsAsync(string guid, IEnumerable<AtlasClassification> classifications, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (classifications == null)
            {
                throw new ArgumentNullException(nameof(classifications));
            }

            using var message = CreateUpdateClassificationsRequest(guid, classifications);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Update classifications to an existing entity represented by a guid. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="classifications"> An array of classifications to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> or <paramref name="classifications"/> is null. </exception>
        public Response UpdateClassifications(string guid, IEnumerable<AtlasClassification> classifications, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }
            if (classifications == null)
            {
                throw new ArgumentNullException(nameof(classifications));
            }

            using var message = CreateUpdateClassificationsRequest(guid, classifications);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetByUniqueAttributesRequest(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrQualifiedName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            if (minExtInfo != null)
            {
                uri.AppendQuery("minExtInfo", minExtInfo.Value, true);
            }
            if (ignoreRelationships != null)
            {
                uri.AppendQuery("ignoreRelationships", ignoreRelationships.Value, true);
            }
            if (attrQualifiedName != null)
            {
                uri.AppendQuery("attr:qualifiedName", attrQualifiedName, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// Get complete definition of an entity given its type and unique attribute.
        /// In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;. 
        /// NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        /// The REST request would look something like this:
        /// GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        public async Task<Response<AtlasEntityWithExtInfo>> GetByUniqueAttributesAsync(string typeName, bool? minExtInfo = null, bool? ignoreRelationships = null, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }

            using var message = CreateGetByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attrQualifiedName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntityWithExtInfo value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = AtlasEntityWithExtInfo.DeserializeAtlasEntityWithExtInfo(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Get complete definition of an entity given its type and unique attribute.
        /// In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
        /// attr:\&lt;attrName&gt;=&lt;attrValue&gt;. 
        /// NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        /// The REST request would look something like this:
        /// GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        public Response<AtlasEntityWithExtInfo> GetByUniqueAttributes(string typeName, bool? minExtInfo = null, bool? ignoreRelationships = null, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }

            using var message = CreateGetByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attrQualifiedName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntityWithExtInfo value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = AtlasEntityWithExtInfo.DeserializeAtlasEntityWithExtInfo(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePartialUpdateEntityByUniqueAttributesRequest(string typeName, AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attrQualifiedName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            if (attrQualifiedName != null)
            {
                uri.AppendQuery("attr:qualifiedName", attrQualifiedName, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(atlasEntityWithExtInfo);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// Update entity partially - Allow a subset of attributes to be updated on
        /// an entity which is identified by its type and unique attribute  eg: Referenceable.qualifiedName.
        /// Null updates are not possible.
        /// In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        /// The REST request would look something like this:
        /// PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasEntityWithExtInfo"> Atlas entity with extended information. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasEntityWithExtInfo"/> is null. </exception>
        public async Task<Response<EntityMutationResponse>> PartialUpdateEntityByUniqueAttributesAsync(string typeName, AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }
            if (atlasEntityWithExtInfo == null)
            {
                throw new ArgumentNullException(nameof(atlasEntityWithExtInfo));
            }

            using var message = CreatePartialUpdateEntityByUniqueAttributesRequest(typeName, atlasEntityWithExtInfo, attrQualifiedName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Update entity partially - Allow a subset of attributes to be updated on
        /// an entity which is identified by its type and unique attribute  eg: Referenceable.qualifiedName.
        /// Null updates are not possible.
        /// In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
        /// attr:&lt;attrName&gt;=&lt;attrValue&gt;.
        /// NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        /// The REST request would look something like this:
        /// PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasEntityWithExtInfo"> Atlas entity with extended information. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasEntityWithExtInfo"/> is null. </exception>
        public Response<EntityMutationResponse> PartialUpdateEntityByUniqueAttributes(string typeName, AtlasEntityWithExtInfo atlasEntityWithExtInfo, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }
            if (atlasEntityWithExtInfo == null)
            {
                throw new ArgumentNullException(nameof(atlasEntityWithExtInfo));
            }

            using var message = CreatePartialUpdateEntityByUniqueAttributesRequest(typeName, atlasEntityWithExtInfo, attrQualifiedName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteByUniqueAttributeRequest(string typeName, string attrQualifiedName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            if (attrQualifiedName != null)
            {
                uri.AppendQuery("attr:qualifiedName", attrQualifiedName, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// Delete an entity identified by its type and unique attributes.
        /// In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        /// The REST request would look something like this:
        /// DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        public async Task<Response<EntityMutationResponse>> DeleteByUniqueAttributeAsync(string typeName, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }

            using var message = CreateDeleteByUniqueAttributeRequest(typeName, attrQualifiedName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Delete an entity identified by its type and unique attributes.
        /// In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format:
        /// attr:\&lt;attrName&gt;=\&lt;attrValue&gt;.
        /// NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
        /// The REST request would look something like this:
        /// DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        public Response<EntityMutationResponse> DeleteByUniqueAttribute(string typeName, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }

            using var message = CreateDeleteByUniqueAttributeRequest(typeName, attrQualifiedName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EntityMutationResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = EntityMutationResponse.DeserializeEntityMutationResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteClassificationByUniqueAttributeRequest(string typeName, string classificationName, string attrQualifiedName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/classification/", false);
            uri.AppendPath(classificationName, true);
            if (attrQualifiedName != null)
            {
                uri.AppendQuery("attr:qualifiedName", attrQualifiedName, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Delete a given classification from an entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is null. </exception>
        public async Task<Response> DeleteClassificationByUniqueAttributeAsync(string typeName, string classificationName, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }
            if (classificationName == null)
            {
                throw new ArgumentNullException(nameof(classificationName));
            }

            using var message = CreateDeleteClassificationByUniqueAttributeRequest(typeName, classificationName, attrQualifiedName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Delete a given classification from an entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="classificationName"> The name of the classification. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="classificationName"/> is null. </exception>
        public Response DeleteClassificationByUniqueAttribute(string typeName, string classificationName, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }
            if (classificationName == null)
            {
                throw new ArgumentNullException(nameof(classificationName));
            }

            using var message = CreateDeleteClassificationByUniqueAttributeRequest(typeName, classificationName, attrQualifiedName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateAddClassificationsByUniqueAttributeRequest(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attrQualifiedName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/classifications", false);
            if (attrQualifiedName != null)
            {
                uri.AppendQuery("attr:qualifiedName", attrQualifiedName, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteStartArray();
            foreach (var item in atlasClassificationArray)
            {
                content.JsonWriter.WriteObjectValue(item);
            }
            content.JsonWriter.WriteEndArray();
            request.Content = content;
            return message;
        }

        /// <summary> Add classification to the entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasClassificationArray"> An array of classification to be added. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasClassificationArray"/> is null. </exception>
        public async Task<Response> AddClassificationsByUniqueAttributeAsync(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }
            if (atlasClassificationArray == null)
            {
                throw new ArgumentNullException(nameof(atlasClassificationArray));
            }

            using var message = CreateAddClassificationsByUniqueAttributeRequest(typeName, atlasClassificationArray, attrQualifiedName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Add classification to the entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasClassificationArray"> An array of classification to be added. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasClassificationArray"/> is null. </exception>
        public Response AddClassificationsByUniqueAttribute(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }
            if (atlasClassificationArray == null)
            {
                throw new ArgumentNullException(nameof(atlasClassificationArray));
            }

            using var message = CreateAddClassificationsByUniqueAttributeRequest(typeName, atlasClassificationArray, attrQualifiedName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateUpdateClassificationsByUniqueAttributeRequest(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attrQualifiedName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            uri.AppendPath("/classifications", false);
            if (attrQualifiedName != null)
            {
                uri.AppendQuery("attr:qualifiedName", attrQualifiedName, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteStartArray();
            foreach (var item in atlasClassificationArray)
            {
                content.JsonWriter.WriteObjectValue(item);
            }
            content.JsonWriter.WriteEndArray();
            request.Content = content;
            return message;
        }

        /// <summary> Update classification on an entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasClassificationArray"> An array of classification to be updated. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasClassificationArray"/> is null. </exception>
        public async Task<Response> UpdateClassificationsByUniqueAttributeAsync(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }
            if (atlasClassificationArray == null)
            {
                throw new ArgumentNullException(nameof(atlasClassificationArray));
            }

            using var message = CreateUpdateClassificationsByUniqueAttributeRequest(typeName, atlasClassificationArray, attrQualifiedName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Update classification on an entity identified by its type and unique attributes. </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="atlasClassificationArray"> An array of classification to be updated. </param>
        /// <param name="attrQualifiedName"> The qualified name of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> or <paramref name="atlasClassificationArray"/> is null. </exception>
        public Response UpdateClassificationsByUniqueAttribute(string typeName, IEnumerable<AtlasClassification> atlasClassificationArray, string attrQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }
            if (atlasClassificationArray == null)
            {
                throw new ArgumentNullException(nameof(atlasClassificationArray));
            }

            using var message = CreateUpdateClassificationsByUniqueAttributeRequest(typeName, atlasClassificationArray, attrQualifiedName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateSetClassificationsRequest(AtlasEntityHeaders entityHeaders)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk/setClassifications", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(entityHeaders);
            request.Content = content;
            return message;
        }

        /// <summary> Set classifications on entities in bulk. </summary>
        /// <param name="entityHeaders"> Atlas entity headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entityHeaders"/> is null. </exception>
        public async Task<Response<IReadOnlyList<string>>> SetClassificationsAsync(AtlasEntityHeaders entityHeaders, CancellationToken cancellationToken = default)
        {
            if (entityHeaders == null)
            {
                throw new ArgumentNullException(nameof(entityHeaders));
            }

            using var message = CreateSetClassificationsRequest(entityHeaders);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<string> value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        List<string> array = new List<string>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(item.GetString());
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Set classifications on entities in bulk. </summary>
        /// <param name="entityHeaders"> Atlas entity headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="entityHeaders"/> is null. </exception>
        public Response<IReadOnlyList<string>> SetClassifications(AtlasEntityHeaders entityHeaders, CancellationToken cancellationToken = default)
        {
            if (entityHeaders == null)
            {
                throw new ArgumentNullException(nameof(entityHeaders));
            }

            using var message = CreateSetClassificationsRequest(entityHeaders);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<string> value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        List<string> array = new List<string>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(item.GetString());
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetEntitiesByUniqueAttributesRequest(string typeName, bool? minExtInfo, bool? ignoreRelationships, string attrNQualifiedName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/bulk/uniqueAttribute/type/", false);
            uri.AppendPath(typeName, true);
            if (minExtInfo != null)
            {
                uri.AppendQuery("minExtInfo", minExtInfo.Value, true);
            }
            if (ignoreRelationships != null)
            {
                uri.AppendQuery("ignoreRelationships", ignoreRelationships.Value, true);
            }
            if (attrNQualifiedName != null)
            {
                uri.AppendQuery("attr_N:qualifiedName", attrNQualifiedName, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// Bulk API to retrieve list of entities identified by its unique attributes.
        /// 
        /// In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format
        /// 
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        /// 
        /// NOTE: The attrName should be an unique attribute for the given entity-type
        /// 
        /// The REST request would look something like this
        /// 
        /// GET /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_0:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName"> Qualified name of an entity. E.g. to find 2 entities you can set attrs_0:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        public async Task<Response<AtlasEntitiesWithExtInfo>> GetEntitiesByUniqueAttributesAsync(string typeName, bool? minExtInfo = null, bool? ignoreRelationships = null, string attrNQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }

            using var message = CreateGetEntitiesByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntitiesWithExtInfo value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = AtlasEntitiesWithExtInfo.DeserializeAtlasEntitiesWithExtInfo(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Bulk API to retrieve list of entities identified by its unique attributes.
        /// 
        /// In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the following format
        /// 
        /// typeName=\&lt;typeName&gt;&amp;attr_1:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_2:\&lt;attrName&gt;=\&lt;attrValue&gt;&amp;attr_3:\&lt;attrName&gt;=\&lt;attrValue&gt;
        /// 
        /// NOTE: The attrName should be an unique attribute for the given entity-type
        /// 
        /// The REST request would look something like this
        /// 
        /// GET /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_0:qualifiedName=db1@cl1&amp;attr_2:qualifiedName=db2@cl1
        /// </summary>
        /// <param name="typeName"> The name of the type. </param>
        /// <param name="minExtInfo"> Whether to return minimal information for referred entities. </param>
        /// <param name="ignoreRelationships"> Whether to ignore relationship attributes. </param>
        /// <param name="attrNQualifiedName"> Qualified name of an entity. E.g. to find 2 entities you can set attrs_0:qualifiedName=db1@cl1&amp;attrs_2:qualifiedName=db2@cl1. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="typeName"/> is null. </exception>
        public Response<AtlasEntitiesWithExtInfo> GetEntitiesByUniqueAttributes(string typeName, bool? minExtInfo = null, bool? ignoreRelationships = null, string attrNQualifiedName = null, CancellationToken cancellationToken = default)
        {
            if (typeName == null)
            {
                throw new ArgumentNullException(nameof(typeName));
            }

            using var message = CreateGetEntitiesByUniqueAttributesRequest(typeName, minExtInfo, ignoreRelationships, attrNQualifiedName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntitiesWithExtInfo value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = AtlasEntitiesWithExtInfo.DeserializeAtlasEntitiesWithExtInfo(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetHeaderRequest(string guid)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/entity/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendPath("/header", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary> Get entity header given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        public async Task<Response<AtlasEntityHeader>> GetHeaderAsync(string guid, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }

            using var message = CreateGetHeaderRequest(guid);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntityHeader value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = AtlasEntityHeader.DeserializeAtlasEntityHeader(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get entity header given its GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        public Response<AtlasEntityHeader> GetHeader(string guid, CancellationToken cancellationToken = default)
        {
            if (guid == null)
            {
                throw new ArgumentNullException(nameof(guid));
            }

            using var message = CreateGetHeaderRequest(guid);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        AtlasEntityHeader value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = AtlasEntityHeader.DeserializeAtlasEntityHeader(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
