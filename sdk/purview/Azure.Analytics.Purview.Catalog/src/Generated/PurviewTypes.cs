// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.Purview.Catalog
{
    /// <summary> The PurviewTypes service client. </summary>
    public partial class PurviewTypes
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://purview.azure.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of PurviewTypes for mocking. </summary>
        protected PurviewTypes()
        {
        }

        /// <summary> Initializes a new instance of PurviewTypes. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint"> The catalog endpoint of your Purview account. Example: https://{accountName}.purview.azure.com. </param>
        /// <param name="apiVersion"> Api Version. </param>
        internal PurviewTypes(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary> Get the businessMetadata definition for the given guid. </summary>
        /// <param name="guid"> businessMetadata guid. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetBusinessMetadataDefByGuidAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetBusinessMetadataDefByGuidAsync("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetBusinessMetadataDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetBusinessMetadataDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the businessMetadata definition for the given guid. </summary>
        /// <param name="guid"> businessMetadata guid. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetBusinessMetadataDefByGuid with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetBusinessMetadataDefByGuid("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetBusinessMetadataDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetBusinessMetadataDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the businessMetadata definition by it&apos;s name (unique). </summary>
        /// <param name="name"> businessMetadata name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetBusinessMetadataDefByNameAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetBusinessMetadataDefByNameAsync("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetBusinessMetadataDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetBusinessMetadataDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the businessMetadata definition by it&apos;s name (unique). </summary>
        /// <param name="name"> businessMetadata name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetBusinessMetadataDefByName with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetBusinessMetadataDefByName("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetBusinessMetadataDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetBusinessMetadataDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the classification definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetClassificationDefByGuidAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetClassificationDefByGuidAsync("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetClassificationDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetClassificationDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the classification definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetClassificationDefByGuid with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetClassificationDefByGuid("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetClassificationDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetClassificationDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the classification definition by its name (unique). </summary>
        /// <param name="name"> The name of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetClassificationDefByNameAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetClassificationDefByNameAsync("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetClassificationDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetClassificationDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the classification definition by its name (unique). </summary>
        /// <param name="name"> The name of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetClassificationDefByName with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetClassificationDefByName("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetClassificationDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetClassificationDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the Entity definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEntityDefinitionByGuidAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetEntityDefinitionByGuidAsync("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEntityDefinitionByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEntityDefinitionByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityDefinitionByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the Entity definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEntityDefinitionByGuid with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetEntityDefinitionByGuid("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEntityDefinitionByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEntityDefinitionByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityDefinitionByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the entity definition by its name (unique). </summary>
        /// <param name="name"> The name of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEntityDefinitionByNameAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetEntityDefinitionByNameAsync("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEntityDefinitionByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEntityDefinitionByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityDefinitionByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the entity definition by its name (unique). </summary>
        /// <param name="name"> The name of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEntityDefinitionByName with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetEntityDefinitionByName("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEntityDefinitionByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEntityDefinitionByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityDefinitionByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the enum definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the enum. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnumDefByGuidAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetEnumDefByGuidAsync("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEnumDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEnumDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEnumDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnumDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the enum definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the enum. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnumDefByGuid with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetEnumDefByGuid("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEnumDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEnumDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEnumDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnumDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the enum definition by its name (unique). </summary>
        /// <param name="name"> The name of the enum. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnumDefByNameAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetEnumDefByNameAsync("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEnumDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEnumDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEnumDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnumDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the enum definition by its name (unique). </summary>
        /// <param name="name"> The name of the enum. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetEnumDefByName with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetEnumDefByName("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEnumDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEnumDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEnumDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnumDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the relationship definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the relationship. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetRelationshipDefByGuidAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetRelationshipDefByGuidAsync("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetRelationshipDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetRelationshipDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelationshipDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the relationship definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the relationship. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetRelationshipDefByGuid with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetRelationshipDefByGuid("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetRelationshipDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetRelationshipDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelationshipDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the relationship definition by its name (unique). </summary>
        /// <param name="name"> The name of the relationship. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetRelationshipDefByNameAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetRelationshipDefByNameAsync("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetRelationshipDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetRelationshipDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelationshipDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the relationship definition by its name (unique). </summary>
        /// <param name="name"> The name of the relationship. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetRelationshipDefByName with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetRelationshipDefByName("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetRelationshipDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetRelationshipDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelationshipDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the struct definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the struct. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetStructDefByGuidAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetStructDefByGuidAsync("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetStructDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetStructDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStructDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the struct definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the struct. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetStructDefByGuid with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetStructDefByGuid("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetStructDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetStructDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStructDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the struct definition by its name (unique). </summary>
        /// <param name="name"> The name of the struct. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetStructDefByNameAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetStructDefByNameAsync("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetStructDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetStructDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStructDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the struct definition by its name (unique). </summary>
        /// <param name="name"> The name of the struct. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetStructDefByName with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetStructDefByName("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetStructDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetStructDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStructDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the type definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTypeDefinitionByGuidAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetTypeDefinitionByGuidAsync("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypeDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTypeDefinitionByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the type definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTypeDefinitionByGuid with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetTypeDefinitionByGuid("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypeDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTypeDefinitionByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the type definition by its name (unique). </summary>
        /// <param name="name"> The name of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTypeDefinitionByNameAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetTypeDefinitionByNameAsync("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypeDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTypeDefinitionByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the type definition by its name (unique). </summary>
        /// <param name="name"> The name of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTypeDefinitionByName with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetTypeDefinitionByName("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypeDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTypeDefinitionByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete API for type identified by its name. </summary>
        /// <param name="name"> The name of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTypeByNameAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.DeleteTypeByNameAsync("<name>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteTypeByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.DeleteTypeByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTypeByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete API for type identified by its name. </summary>
        /// <param name="name"> The name of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTypeByName with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.DeleteTypeByName("<name>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteTypeByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.DeleteTypeByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTypeByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all type definitions in Atlas in bulk. </summary>
        /// <param name="includeTermTemplate">
        /// Whether include termtemplatedef when return all typedefs.
        /// This is always true when search filter type=term_template
        /// </param>
        /// <param name="type"> Typedef name as search filter when get typedefs. Allowed values: &quot;enum&quot; | &quot;entity&quot; | &quot;classification&quot; | &quot;relationship&quot; | &quot;struct&quot; | &quot;term_template&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetAllTypeDefinitionsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetAllTypeDefinitionsAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetAllTypeDefinitionsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetAllTypeDefinitionsAsync(true, "<type>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetAllTypeDefinitionsAsync(bool? includeTermTemplate = null, string type = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetAllTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllTypeDefinitionsRequest(includeTermTemplate, type, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all type definitions in Atlas in bulk. </summary>
        /// <param name="includeTermTemplate">
        /// Whether include termtemplatedef when return all typedefs.
        /// This is always true when search filter type=term_template
        /// </param>
        /// <param name="type"> Typedef name as search filter when get typedefs. Allowed values: &quot;enum&quot; | &quot;entity&quot; | &quot;classification&quot; | &quot;relationship&quot; | &quot;struct&quot; | &quot;term_template&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetAllTypeDefinitions and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetAllTypeDefinitions();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetAllTypeDefinitions with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetAllTypeDefinitions(true, "<type>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetAllTypeDefinitions(bool? includeTermTemplate = null, string type = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetAllTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllTypeDefinitionsRequest(includeTermTemplate, type, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create all atlas type definitions in bulk, only new definitions will be created.
        /// Any changes to the existing definitions will be discarded.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateTypeDefinitionsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.CreateTypeDefinitionsAsync(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateTypeDefinitionsAsync with all request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {
        ///     businessMetadataDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     classificationDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             entityTypes = new[] {
        ///                 "<AtlasClassificationDefEntityTypesItem>"
        ///             },
        ///             subTypes = new[] {
        ///                 "<AtlasClassificationDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasClassificationDefSuperTypesItem>"
        ///             },
        ///         }
        ///     },
        ///     entityDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             subTypes = new[] {
        ///                 "<AtlasEntityDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasEntityDefSuperTypesItem>"
        ///             },
        ///             relationshipAttributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     enumDefs = new[] {
        ///         new {
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             defaultValue = "<AtlasEnumDefDefaultValue>",
        ///             elementDefs = new[] {
        ///                 new {
        ///                     description = "<AtlasEnumElementDefDescription>",
        ///                     ordinal = 1234,
        ///                     value = "<AtlasEnumElementDefValue>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     relationshipDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             endDef1 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             endDef2 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             relationshipCategory = "<ASSOCIATION>",
        ///             relationshipLabel = "<AtlasRelationshipDefRelationshipLabel>",
        ///         }
        ///     },
        ///     structDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     termTemplateDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = await client.CreateTypeDefinitionsAsync(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateTypeDefinitionsAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.CreateTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTypeDefinitionsRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create all atlas type definitions in bulk, only new definitions will be created.
        /// Any changes to the existing definitions will be discarded.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateTypeDefinitions and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.CreateTypeDefinitions(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call CreateTypeDefinitions with all request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {
        ///     businessMetadataDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     classificationDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             entityTypes = new[] {
        ///                 "<AtlasClassificationDefEntityTypesItem>"
        ///             },
        ///             subTypes = new[] {
        ///                 "<AtlasClassificationDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasClassificationDefSuperTypesItem>"
        ///             },
        ///         }
        ///     },
        ///     entityDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             subTypes = new[] {
        ///                 "<AtlasEntityDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasEntityDefSuperTypesItem>"
        ///             },
        ///             relationshipAttributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     enumDefs = new[] {
        ///         new {
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             defaultValue = "<AtlasEnumDefDefaultValue>",
        ///             elementDefs = new[] {
        ///                 new {
        ///                     description = "<AtlasEnumElementDefDescription>",
        ///                     ordinal = 1234,
        ///                     value = "<AtlasEnumElementDefValue>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     relationshipDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             endDef1 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             endDef2 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             relationshipCategory = "<ASSOCIATION>",
        ///             relationshipLabel = "<AtlasRelationshipDefRelationshipLabel>",
        ///         }
        ///     },
        ///     structDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     termTemplateDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = client.CreateTypeDefinitions(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateTypeDefinitions(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.CreateTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTypeDefinitionsRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update all types in bulk, changes detected in the type definitions would be persisted. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateAtlasTypeDefinitionsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.UpdateAtlasTypeDefinitionsAsync(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UpdateAtlasTypeDefinitionsAsync with all request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {
        ///     businessMetadataDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     classificationDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             entityTypes = new[] {
        ///                 "<AtlasClassificationDefEntityTypesItem>"
        ///             },
        ///             subTypes = new[] {
        ///                 "<AtlasClassificationDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasClassificationDefSuperTypesItem>"
        ///             },
        ///         }
        ///     },
        ///     entityDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             subTypes = new[] {
        ///                 "<AtlasEntityDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasEntityDefSuperTypesItem>"
        ///             },
        ///             relationshipAttributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     enumDefs = new[] {
        ///         new {
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             defaultValue = "<AtlasEnumDefDefaultValue>",
        ///             elementDefs = new[] {
        ///                 new {
        ///                     description = "<AtlasEnumElementDefDescription>",
        ///                     ordinal = 1234,
        ///                     value = "<AtlasEnumElementDefValue>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     relationshipDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             endDef1 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             endDef2 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             relationshipCategory = "<ASSOCIATION>",
        ///             relationshipLabel = "<AtlasRelationshipDefRelationshipLabel>",
        ///         }
        ///     },
        ///     structDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     termTemplateDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = await client.UpdateAtlasTypeDefinitionsAsync(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateAtlasTypeDefinitionsAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.UpdateAtlasTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateAtlasTypeDefinitionsRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update all types in bulk, changes detected in the type definitions would be persisted. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateAtlasTypeDefinitions and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.UpdateAtlasTypeDefinitions(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call UpdateAtlasTypeDefinitions with all request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {
        ///     businessMetadataDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     classificationDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             entityTypes = new[] {
        ///                 "<AtlasClassificationDefEntityTypesItem>"
        ///             },
        ///             subTypes = new[] {
        ///                 "<AtlasClassificationDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasClassificationDefSuperTypesItem>"
        ///             },
        ///         }
        ///     },
        ///     entityDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             subTypes = new[] {
        ///                 "<AtlasEntityDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasEntityDefSuperTypesItem>"
        ///             },
        ///             relationshipAttributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     enumDefs = new[] {
        ///         new {
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             defaultValue = "<AtlasEnumDefDefaultValue>",
        ///             elementDefs = new[] {
        ///                 new {
        ///                     description = "<AtlasEnumElementDefDescription>",
        ///                     ordinal = 1234,
        ///                     value = "<AtlasEnumElementDefValue>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     relationshipDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             endDef1 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             endDef2 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             relationshipCategory = "<ASSOCIATION>",
        ///             relationshipLabel = "<AtlasRelationshipDefRelationshipLabel>",
        ///         }
        ///     },
        ///     structDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     termTemplateDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = client.UpdateAtlasTypeDefinitions(RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
        /// Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
        /// Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateAtlasTypeDefinitions(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.UpdateAtlasTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateAtlasTypeDefinitionsRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete API for all types in bulk. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTypeDefinitionsAsync.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {};
        /// 
        /// Response response = await client.DeleteTypeDefinitionsAsync(RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call DeleteTypeDefinitionsAsync with all request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {
        ///     businessMetadataDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     classificationDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             entityTypes = new[] {
        ///                 "<AtlasClassificationDefEntityTypesItem>"
        ///             },
        ///             subTypes = new[] {
        ///                 "<AtlasClassificationDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasClassificationDefSuperTypesItem>"
        ///             },
        ///         }
        ///     },
        ///     entityDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             subTypes = new[] {
        ///                 "<AtlasEntityDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasEntityDefSuperTypesItem>"
        ///             },
        ///             relationshipAttributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     enumDefs = new[] {
        ///         new {
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             defaultValue = "<AtlasEnumDefDefaultValue>",
        ///             elementDefs = new[] {
        ///                 new {
        ///                     description = "<AtlasEnumElementDefDescription>",
        ///                     ordinal = 1234,
        ///                     value = "<AtlasEnumElementDefValue>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     relationshipDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             endDef1 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             endDef2 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             relationshipCategory = "<ASSOCIATION>",
        ///             relationshipLabel = "<AtlasRelationshipDefRelationshipLabel>",
        ///         }
        ///     },
        ///     structDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     termTemplateDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = await client.DeleteTypeDefinitionsAsync(RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteTypeDefinitionsAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.DeleteTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTypeDefinitionsRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete API for all types in bulk. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteTypeDefinitions.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {};
        /// 
        /// Response response = client.DeleteTypeDefinitions(RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call DeleteTypeDefinitions with all request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// var data = new {
        ///     businessMetadataDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     classificationDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             entityTypes = new[] {
        ///                 "<AtlasClassificationDefEntityTypesItem>"
        ///             },
        ///             subTypes = new[] {
        ///                 "<AtlasClassificationDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasClassificationDefSuperTypesItem>"
        ///             },
        ///         }
        ///     },
        ///     entityDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             subTypes = new[] {
        ///                 "<AtlasEntityDefSubTypesItem>"
        ///             },
        ///             superTypes = new[] {
        ///                 "<AtlasEntityDefSuperTypesItem>"
        ///             },
        ///             relationshipAttributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     enumDefs = new[] {
        ///         new {
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             defaultValue = "<AtlasEnumDefDefaultValue>",
        ///             elementDefs = new[] {
        ///                 new {
        ///                     description = "<AtlasEnumElementDefDescription>",
        ///                     ordinal = 1234,
        ///                     value = "<AtlasEnumElementDefValue>",
        ///                 }
        ///             },
        ///         }
        ///     },
        ///     relationshipDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///             endDef1 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             endDef2 = new {
        ///                 cardinality = "<SINGLE>",
        ///                 description = "<AtlasRelationshipEndDefDescription>",
        ///                 isContainer = true,
        ///                 isLegacyAttribute = true,
        ///                 name = "<AtlasRelationshipEndDefName>",
        ///                 type = "<AtlasRelationshipEndDefType>",
        ///             },
        ///             relationshipCategory = "<ASSOCIATION>",
        ///             relationshipLabel = "<AtlasRelationshipDefRelationshipLabel>",
        ///         }
        ///     },
        ///     structDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        ///     termTemplateDefs = new[] {
        ///         new {
        ///             attributeDefs = new[] {
        ///                 new {
        ///                     cardinality = "<SINGLE>",
        ///                     constraints = new[] {
        ///                         new {
        ///                             params = new {
        ///                                 key = new {},
        ///                             },
        ///                             type = "<AtlasConstraintDefType>",
        ///                         }
        ///                     },
        ///                     defaultValue = "<AtlasAttributeDefDefaultValue>",
        ///                     description = "<AtlasAttributeDefDescription>",
        ///                     includeInNotification = true,
        ///                     isIndexable = true,
        ///                     isOptional = true,
        ///                     isUnique = true,
        ///                     name = "<AtlasAttributeDefName>",
        ///                     options = new {
        ///                         key = "<String>",
        ///                     },
        ///                     typeName = "<AtlasAttributeDefTypeName>",
        ///                     valuesMaxCount = 1234,
        ///                     valuesMinCount = 1234,
        ///                     isLegacyAttribute = true,
        ///                     relationshipTypeName = "<AtlasRelationshipAttributeDefRelationshipTypeName>",
        ///                 }
        ///             },
        ///             category = "<PRIMITIVE>",
        ///             createTime = 1234,
        ///             createdBy = "<AtlasBaseTypeDefCreatedBy>",
        ///             dateFormatter = new {
        ///                 availableLocales = new[] {
        ///                     "<DateFormatAvailableLocalesItem>"
        ///                 },
        ///                 calendar = 1234,
        ///                 lenient = true,
        ///                 numberFormat = new {
        ///                     availableLocales = new[] {
        ///                         "<NumberFormatAvailableLocalesItem>"
        ///                     },
        ///                     currency = "<NumberFormatCurrency>",
        ///                     groupingUsed = true,
        ///                     maximumFractionDigits = 1234,
        ///                     maximumIntegerDigits = 1234,
        ///                     minimumFractionDigits = 1234,
        ///                     minimumIntegerDigits = 1234,
        ///                     parseIntegerOnly = true,
        ///                     roundingMode = "<UP>",
        ///                 },
        ///                 timeZone = new {
        ///                     dstSavings = 1234,
        ///                     id = "<TimeZoneId>",
        ///                     availableIds = new[] {
        ///                         "<TimeZoneAvailableIdsItem>"
        ///                     },
        ///                     displayName = "<TimeZoneDisplayName>",
        ///                     rawOffset = 1234,
        ///                 },
        ///             },
        ///             description = "<AtlasBaseTypeDefDescription>",
        ///             guid = "<AtlasBaseTypeDefGuid>",
        ///             name = "<AtlasBaseTypeDefName>",
        ///             options = new {
        ///                 key = "<String>",
        ///             },
        ///             serviceType = "<AtlasBaseTypeDefServiceType>",
        ///             typeVersion = "<AtlasBaseTypeDefTypeVersion>",
        ///             updateTime = 1234,
        ///             updatedBy = "<AtlasBaseTypeDefUpdatedBy>",
        ///             version = 1234,
        ///             lastModifiedTS = "<LastModifiedTS>",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = client.DeleteTypeDefinitions(RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteTypeDefinitions(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.DeleteTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTypeDefinitionsRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all type definitions returned as a list of minimal information header. </summary>
        /// <param name="includeTermTemplate">
        /// Whether include termtemplatedef when return all typedefs.
        /// This is always true when search filter type=term_template
        /// </param>
        /// <param name="type"> Typedef name as search filter when get typedefs. Allowed values: &quot;enum&quot; | &quot;entity&quot; | &quot;classification&quot; | &quot;relationship&quot; | &quot;struct&quot; | &quot;term_template&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTypeDefinitionHeadersAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetTypeDefinitionHeadersAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetTypeDefinitionHeadersAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetTypeDefinitionHeadersAsync(true, "<type>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].GetProperty("category").ToString());
        /// Console.WriteLine(result[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result[0].GetProperty("name").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfAtlasTypeDefHeader</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTypeDefinitionHeadersAsync(bool? includeTermTemplate = null, string type = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionHeaders");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionHeadersRequest(includeTermTemplate, type, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all type definitions returned as a list of minimal information header. </summary>
        /// <param name="includeTermTemplate">
        /// Whether include termtemplatedef when return all typedefs.
        /// This is always true when search filter type=term_template
        /// </param>
        /// <param name="type"> Typedef name as search filter when get typedefs. Allowed values: &quot;enum&quot; | &quot;entity&quot; | &quot;classification&quot; | &quot;relationship&quot; | &quot;struct&quot; | &quot;term_template&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTypeDefinitionHeaders and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetTypeDefinitionHeaders();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].ToString());
        /// ]]></code>
        /// This sample shows how to call GetTypeDefinitionHeaders with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetTypeDefinitionHeaders(true, "<type>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result[0].GetProperty("category").ToString());
        /// Console.WriteLine(result[0].GetProperty("guid").ToString());
        /// Console.WriteLine(result[0].GetProperty("name").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfAtlasTypeDefHeader</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTypeDefinitionHeaders(bool? includeTermTemplate = null, string type = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionHeaders");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionHeadersRequest(includeTermTemplate, type, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the term template definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the term template. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTermTemplateDefByGuidAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetTermTemplateDefByGuidAsync("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTermTemplateDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTermTemplateDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermTemplateDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the term template definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the term template. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTermTemplateDefByGuid with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetTermTemplateDefByGuid("<guid>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTermTemplateDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTermTemplateDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermTemplateDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the term template definition by its name (unique). </summary>
        /// <param name="name"> The name of the term template. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTermTemplateDefByNameAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = await client.GetTermTemplateDefByNameAsync("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTermTemplateDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTermTemplateDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermTemplateDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the term template definition by its name (unique). </summary>
        /// <param name="name"> The name of the term template. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetTermTemplateDefByName with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();
        /// 
        /// Response response = client.GetTermTemplateDefByName("<name>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
        /// Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
        /// Console.WriteLine(result.GetProperty("category").ToString());
        /// Console.WriteLine(result.GetProperty("createTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdBy").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
        /// Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("guid").ToString());
        /// Console.WriteLine(result.GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("serviceType").ToString());
        /// Console.WriteLine(result.GetProperty("typeVersion").ToString());
        /// Console.WriteLine(result.GetProperty("updateTime").ToString());
        /// Console.WriteLine(result.GetProperty("updatedBy").ToString());
        /// Console.WriteLine(result.GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTermTemplateDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTermTemplateDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermTemplateDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetBusinessMetadataDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/businessmetadatadef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBusinessMetadataDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/businessmetadatadef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/classificationdef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/classificationdef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEntityDefinitionByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/entitydef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEntityDefinitionByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/entitydef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnumDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/enumdef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnumDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/enumdef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetRelationshipDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/relationshipdef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetRelationshipDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/relationshipdef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetStructDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/structdef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetStructDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/structdef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTypeDefinitionByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTypeDefinitionByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteTypeByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllTypeDefinitionsRequest(bool? includeTermTemplate, string type, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs", false);
            if (includeTermTemplate != null)
            {
                uri.AppendQuery("includeTermTemplate", includeTermTemplate.Value, true);
            }
            if (type != null)
            {
                uri.AppendQuery("type", type, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateTypeDefinitionsRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateAtlasTypeDefinitionsRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteTypeDefinitionsRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTypeDefinitionHeadersRequest(bool? includeTermTemplate, string type, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs/headers", false);
            if (includeTermTemplate != null)
            {
                uri.AppendQuery("includeTermTemplate", includeTermTemplate.Value, true);
            }
            if (type != null)
            {
                uri.AppendQuery("type", type, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTermTemplateDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/types/termtemplatedef/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTermTemplateDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/types/termtemplatedef/name/", false);
            uri.AppendPath(name, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
